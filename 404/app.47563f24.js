! function(t) {
    var e = {};

    function i(n) {
        if (e[n]) return e[n].exports;
        var r = e[n] = {
            i: n,
            l: !1,
            exports: {}
        };
        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports
    }
    i.m = t, i.c = e, i.d = function(t, e, n) {
        i.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: n
        })
    }, i.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, i.t = function(t, e) {
        if (1 & e && (t = i(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var n = Object.create(null);
        if (i.r(n), Object.defineProperty(n, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t)
            for (var r in t) i.d(n, r, function(e) {
                return t[e]
            }.bind(null, r));
        return n
    }, i.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return i.d(e, "a", e), e
    }, i.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, i.p = "", i(i.s = 20)
}([function(t, e, i) {
    "use strict";
    (function(t, n) {
        i.d(e, "e", function() {
            return r
        }), i.d(e, "g", function() {
            return a
        }), i.d(e, "f", function() {
            return o
        }), i.d(e, "c", function() {
            return c
        }), i.d(e, "a", function() {
            return l
        }), i.d(e, "b", function() {
            return h
        }), i.d(e, "d", function() {
            return u
        });
        /*!
         * VERSION: 2.0.2
         * DATE: 2018-08-27
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         *
         * @author: Jack Doyle, jack@greensock.com
         */
        var r = "undefined" != typeof window ? window : t.exports && void 0 !== n ? n : {},
            o = function(t, e) {
                var i = {},
                    n = t.document,
                    r = t.GreenSockGlobals = t.GreenSockGlobals || t;
                if (r.TweenLite) return r.TweenLite;
                var o, a, s, c, l, h = function(t) {
                        var e, i = t.split("."),
                            n = r;
                        for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                        return n
                    },
                    u = h("com.greensock"),
                    d = function(t) {
                        var e, i = [],
                            n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]));
                        return i
                    },
                    p = function() {},
                    f = function() {
                        var t = Object.prototype.toString,
                            e = t.call([]);
                        return function(i) {
                            return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                        }
                    }(),
                    m = {},
                    g = function(t, e, n, o) {
                        this.sc = m[t] ? m[t].sc : [], m[t] = this, this.gsClass = null, this.func = n;
                        var a = [];
                        this.check = function(s) {
                            for (var c, l, u, d, p = e.length, f = p; --p > -1;)(c = m[e[p]] || new g(e[p], [])).gsClass ? (a[p] = c.gsClass, f--) : s && c.sc.push(this);
                            if (0 === f && n)
                                for (u = (l = ("com.greensock." + t).split(".")).pop(), d = h(l.join("."))[u] = this.gsClass = n.apply(n, a), o && (r[u] = i[u] = d), p = 0; p < this.sc.length; p++) this.sc[p].check()
                        }, this.check(!0)
                    },
                    v = t._gsDefine = function(t, e, i, n) {
                        return new g(t, e, i, n)
                    },
                    y = u._class = function(t, e, i) {
                        return e = e || function() {}, v(t, [], function() {
                            return e
                        }, i), e
                    };
                v.globals = r;
                var _ = [0, 0, 1, 1],
                    x = y("easing.Ease", function(t, e, i, n) {
                        this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? _.concat(e) : _
                    }, !0),
                    b = x.map = {},
                    w = x.register = function(t, e, i, n) {
                        for (var r, o, a, s, c = e.split(","), l = c.length, h = (i || "easeIn,easeOut,easeInOut").split(","); --l > -1;)
                            for (o = c[l], r = n ? y("easing." + o, null, !0) : u.easing[o] || {}, a = h.length; --a > -1;) s = h[a], b[o + "." + s] = b[s + o] = r[s] = t.getRatio ? t : t[s] || new t
                    };
                for ((s = x.prototype)._calcEnd = !1, s.getRatio = function(t) {
                        if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                        var e = this._type,
                            i = this._power,
                            n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                        return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                    }, a = (o = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --a > -1;) s = o[a] + ",Power" + a, w(new x(null, null, 1, a), s, "easeOut", !0), w(new x(null, null, 2, a), s, "easeIn" + (0 === a ? ",easeNone" : "")), w(new x(null, null, 3, a), s, "easeInOut");
                b.linear = u.easing.Linear.easeIn, b.swing = u.easing.Quad.easeInOut;
                var M = y("events.EventDispatcher", function(t) {
                    this._listeners = {}, this._eventTarget = t || this
                });
                (s = M.prototype).addEventListener = function(t, e, i, n, r) {
                    r = r || 0;
                    var o, a, s = this._listeners[t],
                        h = 0;
                    for (this !== c || l || c.wake(), null == s && (this._listeners[t] = s = []), a = s.length; --a > -1;)(o = s[a]).c === e && o.s === i ? s.splice(a, 1) : 0 === h && o.pr < r && (h = a + 1);
                    s.splice(h, 0, {
                        c: e,
                        s: i,
                        up: n,
                        pr: r
                    })
                }, s.removeEventListener = function(t, e) {
                    var i, n = this._listeners[t];
                    if (n)
                        for (i = n.length; --i > -1;)
                            if (n[i].c === e) return void n.splice(i, 1)
                }, s.dispatchEvent = function(t) {
                    var e, i, n, r = this._listeners[t];
                    if (r)
                        for ((e = r.length) > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                            type: t,
                            target: i
                        }) : n.c.call(n.s || i))
                };
                var T = t.requestAnimationFrame,
                    E = t.cancelAnimationFrame,
                    S = Date.now || function() {
                        return (new Date).getTime()
                    },
                    A = S();
                for (a = (o = ["ms", "moz", "webkit", "o"]).length; --a > -1 && !T;) T = t[o[a] + "RequestAnimationFrame"], E = t[o[a] + "CancelAnimationFrame"] || t[o[a] + "CancelRequestAnimationFrame"];
                y("Ticker", function(t, e) {
                    var i, r, o, a, s, h = this,
                        u = S(),
                        d = !(!1 === e || !T) && "auto",
                        f = 500,
                        m = 33,
                        g = function(t) {
                            var e, n, c = S() - A;
                            c > f && (u += c - m), A += c, h.time = (A - u) / 1e3, e = h.time - s, (!i || e > 0 || !0 === t) && (h.frame++, s += e + (e >= a ? .004 : a - e), n = !0), !0 !== t && (o = r(g)), n && h.dispatchEvent("tick")
                        };
                    M.call(h), h.time = h.frame = 0, h.tick = function() {
                        g(!0)
                    }, h.lagSmoothing = function(t, e) {
                        if (!arguments.length) return f < 1e10;
                        f = t || 1e10, m = Math.min(e, f, 0)
                    }, h.sleep = function() {
                        null != o && (d && E ? E(o) : clearTimeout(o), r = p, o = null, h === c && (l = !1))
                    }, h.wake = function(t) {
                        null !== o ? h.sleep() : t ? u += -A + (A = S()) : h.frame > 10 && (A = S() - f + 5), r = 0 === i ? p : d && T ? T : function(t) {
                            return setTimeout(t, 1e3 * (s - h.time) + 1 | 0)
                        }, h === c && (l = !0), g(2)
                    }, h.fps = function(t) {
                        if (!arguments.length) return i;
                        a = 1 / ((i = t) || 60), s = this.time + a, h.wake()
                    }, h.useRAF = function(t) {
                        if (!arguments.length) return d;
                        h.sleep(), d = t, h.fps(i)
                    }, h.fps(t), setTimeout(function() {
                        "auto" === d && h.frame < 5 && "hidden" !== (n || {}).visibilityState && h.useRAF(!1)
                    }, 1500)
                }), (s = u.Ticker.prototype = new u.events.EventDispatcher).constructor = u.Ticker;
                var P = y("core.Animation", function(t, e) {
                    if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, q) {
                        l || c.wake();
                        var i = this.vars.useFrames ? X : q;
                        i.add(this, i._time), this.vars.paused && this.paused(!0)
                    }
                });
                c = P.ticker = new u.Ticker, (s = P.prototype)._dirty = s._gc = s._initted = s._paused = !1, s._totalTime = s._time = 0, s._rawPrevTime = -1, s._next = s._last = s._onUpdate = s._timeline = s.timeline = null, s._paused = !1;
                var L = function() {
                    l && S() - A > 2e3 && ("hidden" !== (n || {}).visibilityState || !c.lagSmoothing()) && c.wake();
                    var t = setTimeout(L, 2e3);
                    t.unref && t.unref()
                };
                L(), s.play = function(t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, s.pause = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, s.resume = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!1)
                }, s.seek = function(t, e) {
                    return this.totalTime(Number(t), !1 !== e)
                }, s.restart = function(t, e) {
                    return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
                }, s.reverse = function(t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, s.render = function(t, e, i) {}, s.invalidate = function() {
                    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                }, s.isActive = function() {
                    var t, e = this._timeline,
                        i = this._startTime;
                    return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
                }, s._enabled = function(t, e) {
                    return l || c.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                }, s._kill = function(t, e) {
                    return this._enabled(!1, !1)
                }, s.kill = function(t, e) {
                    return this._kill(t, e), this
                }, s._uncache = function(t) {
                    for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                    return this
                }, s._swapSelfInParams = function(t) {
                    for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                    return i
                }, s._callback = function(t) {
                    var e = this.vars,
                        i = e[t],
                        n = e[t + "Params"],
                        r = e[t + "Scope"] || e.callbackScope || this;
                    switch (n ? n.length : 0) {
                        case 0:
                            i.call(r);
                            break;
                        case 1:
                            i.call(r, n[0]);
                            break;
                        case 2:
                            i.call(r, n[0], n[1]);
                            break;
                        default:
                            i.apply(r, n)
                    }
                }, s.eventCallback = function(t, e, i, n) {
                    if ("on" === (t || "").substr(0, 2)) {
                        var r = this.vars;
                        if (1 === arguments.length) return r[t];
                        null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = f(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                    }
                    return this
                }, s.delay = function(t) {
                    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                }, s.duration = function(t) {
                    return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                }, s.totalDuration = function(t) {
                    return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                }, s.time = function(t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                }, s.totalTime = function(t, e, i) {
                    if (l || c.wake(), !arguments.length) return this._totalTime;
                    if (this._timeline) {
                        if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                            this._dirty && this.totalDuration();
                            var n = this._totalDuration,
                                r = this._timeline;
                            if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                        }
                        this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (I.length && Z(), this.render(t, e, !1), I.length && Z())
                    }
                    return this
                }, s.progress = s.totalProgress = function(t, e) {
                    var i = this.duration();
                    return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
                }, s.startTime = function(t) {
                    return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                }, s.endTime = function(t) {
                    return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                }, s.timeScale = function(t) {
                    if (!arguments.length) return this._timeScale;
                    var e, i;
                    for (t = t || 1e-10, this._timeline && this._timeline.smoothChildTiming && (i = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
                    return this
                }, s.reversed = function(t) {
                    return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                }, s.paused = function(t) {
                    if (!arguments.length) return this._paused;
                    var e, i, n = this._timeline;
                    return t != this._paused && n && (l || t || c.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                };
                var C = y("core.SimpleTimeline", function(t) {
                    P.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                });
                (s = C.prototype = new P).constructor = C, s.kill()._gc = !1, s._first = s._last = s._recent = null, s._sortChildren = !1, s.add = s.insert = function(t, e, i, n) {
                    var r, o;
                    if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                        for (o = t._startTime; r && r._startTime > o;) r = r._prev;
                    return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
                }, s._remove = function(t, e) {
                    return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                }, s.render = function(t, e, i) {
                    var n, r = this._first;
                    for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
                }, s.rawTime = function() {
                    return l || c.wake(), this._totalTime
                };
                var R = y("TweenLite", function(e, i, n) {
                        if (P.call(this, i, n), this.render = R.prototype.render, null == e) throw "Cannot tween a null target.";
                        this.target = e = "string" != typeof e ? e : R.selector(e) || e;
                        var r, o, a, s = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
                            c = this.vars.overwrite;
                        if (this._overwrite = c = null == c ? W[R.defaultOverwrite] : "number" == typeof c ? c >> 0 : W[c], (s || e instanceof Array || e.push && f(e)) && "number" != typeof e[0])
                            for (this._targets = a = d(e), this._propLookup = [], this._siblings = [], r = 0; r < a.length; r++)(o = a[r]) ? "string" != typeof o ? o.length && o !== t && o[0] && (o[0] === t || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(d(o))) : (this._siblings[r] = J(o, this, !1), 1 === c && this._siblings[r].length > 1 && Q(o, this, null, 1, this._siblings[r])) : "string" == typeof(o = a[r--] = R.selector(o)) && a.splice(r + 1, 1) : a.splice(r--, 1);
                        else this._propLookup = {}, this._siblings = J(e, this, !1), 1 === c && this._siblings.length > 1 && Q(e, this, null, 1, this._siblings);
                        (this.vars.immediateRender || 0 === i && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay)))
                    }, !0),
                    O = function(e) {
                        return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType)
                    };
                (s = R.prototype = new P).constructor = R, s.kill()._gc = !1, s.ratio = 0, s._firstPT = s._targets = s._overwrittenProps = s._startAt = null, s._notifyPluginsOfEnabled = s._lazy = !1, R.version = "2.0.2", R.defaultEase = s._ease = new x(null, null, 1, 1), R.defaultOverwrite = "auto", R.ticker = c, R.autoSleep = 120, R.lagSmoothing = function(t, e) {
                    c.lagSmoothing(t, e)
                }, R.selector = t.$ || t.jQuery || function(e) {
                    var i = t.$ || t.jQuery;
                    return i ? (R.selector = i, i(e)) : (n || (n = t.document), n ? n.querySelectorAll ? n.querySelectorAll(e) : n.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e)
                };
                var I = [],
                    D = {},
                    k = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    N = /[\+-]=-?[\.\d]/,
                    B = function(t) {
                        for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : e < 1e-6 && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                    },
                    F = function(t, e, i, n) {
                        var r, o, a, s, c, l, h, u = [],
                            d = 0,
                            p = "",
                            f = 0;
                        for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(k) || [], o = e.match(k) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), c = o.length, s = 0; s < c; s++) h = o[s], p += (l = e.substr(d, e.indexOf(h, d) - d)) || !s ? l : ",", d += l.length, f ? f = (f + 1) % 5 : "rgba(" === l.substr(-5) && (f = 1), h === r[s] || r.length <= s ? p += h : (p && (u.push(p), p = ""), a = parseFloat(r[s]), u.push(a), u._firstPT = {
                            _next: u._firstPT,
                            t: u,
                            p: u.length - 1,
                            s: a,
                            c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - a) || 0,
                            f: 0,
                            m: f && f < 4 ? Math.round : 0
                        }), d += h.length;
                        return (p += e.substr(d)) && u.push(p), u.setRatio = B, N.test(e) && (u.end = null), u
                    },
                    z = function(t, e, i, n, r, o, a, s, c) {
                        "function" == typeof n && (n = n(c || 0, t));
                        var l = typeof t[e],
                            h = "function" !== l ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                            u = "get" !== i ? i : h ? a ? t[h](a) : t[h]() : t[e],
                            d = "string" == typeof n && "=" === n.charAt(1),
                            p = {
                                t: t,
                                p: e,
                                s: u,
                                f: "function" === l,
                                pg: 0,
                                n: r || e,
                                m: o ? "function" == typeof o ? o : Math.round : 0,
                                pr: 0,
                                c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - u || 0
                            };
                        if (("number" != typeof u || "number" != typeof n && !d) && (a || isNaN(u) || !d && isNaN(n) || "boolean" == typeof u || "boolean" == typeof n ? (p.fp = a, p = {
                                t: F(u, d ? parseFloat(p.s) + p.c + (p.s + "").replace(/[0-9\-\.]/g, "") : n, s || R.defaultStringFilter, p),
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 2,
                                pg: 0,
                                n: r || e,
                                pr: 0,
                                m: 0
                            }) : (p.s = parseFloat(u), d || (p.c = parseFloat(n) - p.s || 0))), p.c) return (p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p
                    },
                    U = R._internals = {
                        isArray: f,
                        isSelector: O,
                        lazyTweens: I,
                        blobDif: F
                    },
                    G = R._plugins = {},
                    H = U.tweenLookup = {},
                    V = 0,
                    j = U.reservedProps = {
                        ease: 1,
                        delay: 1,
                        overwrite: 1,
                        onComplete: 1,
                        onCompleteParams: 1,
                        onCompleteScope: 1,
                        useFrames: 1,
                        runBackwards: 1,
                        startAt: 1,
                        onUpdate: 1,
                        onUpdateParams: 1,
                        onUpdateScope: 1,
                        onStart: 1,
                        onStartParams: 1,
                        onStartScope: 1,
                        onReverseComplete: 1,
                        onReverseCompleteParams: 1,
                        onReverseCompleteScope: 1,
                        onRepeat: 1,
                        onRepeatParams: 1,
                        onRepeatScope: 1,
                        easeParams: 1,
                        yoyo: 1,
                        immediateRender: 1,
                        repeat: 1,
                        repeatDelay: 1,
                        data: 1,
                        paused: 1,
                        reversed: 1,
                        autoCSS: 1,
                        lazy: 1,
                        onOverwrite: 1,
                        callbackScope: 1,
                        stringFilter: 1,
                        id: 1,
                        yoyoEase: 1
                    },
                    W = {
                        none: 0,
                        all: 1,
                        auto: 2,
                        concurrent: 3,
                        allOnStart: 4,
                        preexisting: 5,
                        true: 1,
                        false: 0
                    },
                    X = P._rootFramesTimeline = new C,
                    q = P._rootTimeline = new C,
                    Y = 30,
                    Z = U.lazyRender = function() {
                        var t, e = I.length;
                        for (D = {}; --e > -1;)(t = I[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                        I.length = 0
                    };
                q._startTime = c.time, X._startTime = c.frame, q._active = X._active = !0, setTimeout(Z, 1), P._updateRoot = R.render = function() {
                    var t, e, i;
                    if (I.length && Z(), q.render((c.time - q._startTime) * q._timeScale, !1, !1), X.render((c.frame - X._startTime) * X._timeScale, !1, !1), I.length && Z(), c.frame >= Y) {
                        for (i in Y = c.frame + (parseInt(R.autoSleep, 10) || 120), H) {
                            for (t = (e = H[i].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
                            0 === e.length && delete H[i]
                        }
                        if ((!(i = q._first) || i._paused) && R.autoSleep && !X._first && 1 === c._listeners.tick.length) {
                            for (; i && i._paused;) i = i._next;
                            i || c.sleep()
                        }
                    }
                }, c.addEventListener("tick", P._updateRoot);
                var J = function(t, e, i) {
                        var n, r, o = t._gsTweenID;
                        if (H[o || (t._gsTweenID = o = "t" + V++)] || (H[o] = {
                                target: t,
                                tweens: []
                            }), e && ((n = H[o].tweens)[r = n.length] = e, i))
                            for (; --r > -1;) n[r] === e && n.splice(r, 1);
                        return H[o].tweens
                    },
                    K = function(t, e, i, n) {
                        var r, o, a = t.vars.onOverwrite;
                        return a && (r = a(t, e, i, n)), (a = R.onOverwrite) && (o = a(t, e, i, n)), !1 !== r && !1 !== o
                    },
                    Q = function(t, e, i, n, r) {
                        var o, a, s, c;
                        if (1 === n || n >= 4) {
                            for (c = r.length, o = 0; o < c; o++)
                                if ((s = r[o]) !== e) s._gc || s._kill(null, t, e) && (a = !0);
                                else if (5 === n) break;
                            return a
                        }
                        var l, h = e._startTime + 1e-10,
                            u = [],
                            d = 0,
                            p = 0 === e._duration;
                        for (o = r.length; --o > -1;)(s = r[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (l = l || $(e, 0, p), 0 === $(s, l, p) && (u[d++] = s)) : s._startTime <= h && s._startTime + s.totalDuration() / s._timeScale > h && ((p || !s._initted) && h - s._startTime <= 2e-10 || (u[d++] = s)));
                        for (o = d; --o > -1;)
                            if (c = (s = u[o])._firstPT, 2 === n && s._kill(i, t, e) && (a = !0), 2 !== n || !s._firstPT && s._initted && c) {
                                if (2 !== n && !K(s, e)) continue;
                                s._enabled(!1, !1) && (a = !0)
                            }
                        return a
                    },
                    $ = function(t, e, i) {
                        for (var n = t._timeline, r = n._timeScale, o = t._startTime; n._timeline;) {
                            if (o += n._startTime, r *= n._timeScale, n._paused) return -100;
                            n = n._timeline
                        }
                        return (o /= r) > e ? o - e : i && o === e || !t._initted && o - e < 2e-10 ? 1e-10 : (o += t.totalDuration() / t._timeScale / r) > e + 1e-10 ? 0 : o - e - 1e-10
                    };
                s._init = function() {
                    var t, e, i, n, r, o, a = this.vars,
                        s = this._overwrittenProps,
                        c = this._duration,
                        l = !!a.immediateRender,
                        h = a.ease;
                    if (a.startAt) {
                        for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}, a.startAt) r[n] = a.startAt[n];
                        if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = l && !1 !== a.lazy, r.startAt = r.delay = null, r.onUpdate = a.onUpdate, r.onUpdateParams = a.onUpdateParams, r.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = R.to(this.target || {}, 0, r), l)
                            if (this._time > 0) this._startAt = null;
                            else if (0 !== c) return
                    } else if (a.runBackwards && 0 !== c)
                        if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                        else {
                            for (n in 0 !== this._time && (l = !1), i = {}, a) j[n] && "autoCSS" !== n || (i[n] = a[n]);
                            if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && !1 !== a.lazy, i.immediateRender = l, this._startAt = R.to(this.target, 0, i), l) {
                                if (0 === this._time) return
                            } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                        }
                    if (this._ease = h = h ? h instanceof x ? h : "function" == typeof h ? new x(h, a.easeParams) : b[h] || R.defaultEase : R.defaultEase, a.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                        for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                    else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                    if (e && R._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                        for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                    this._onUpdate = a.onUpdate, this._initted = !0
                }, s._initProps = function(e, i, n, r, o) {
                    var a, s, c, l, h, u;
                    if (null == e) return !1;
                    for (a in D[e._gsTweenID] && Z(), this.vars.css || e.style && e !== t && e.nodeType && G.css && !1 !== this.vars.autoCSS && function(t, e) {
                            var i, n = {};
                            for (i in t) j[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!G[i] || G[i] && G[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                            t.css = n
                        }(this.vars, e), this.vars)
                        if (u = this.vars[a], j[a]) u && (u instanceof Array || u.push && f(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[a] = u = this._swapSelfInParams(u, this));
                        else if (G[a] && (l = new G[a])._onInitTween(e, this.vars[a], this, o)) {
                        for (this._firstPT = h = {
                                _next: this._firstPT,
                                t: l,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 1,
                                n: a,
                                pg: 1,
                                pr: l._priority,
                                m: 0
                            }, s = l._overwriteProps.length; --s > -1;) i[l._overwriteProps[s]] = this._firstPT;
                        (l._priority || l._onInitAllProps) && (c = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
                    } else i[a] = z.call(this, e, a, "get", u, a, 0, null, this.vars.stringFilter, o);
                    return r && this._kill(r, e) ? this._initProps(e, i, n, r, o) : this._overwrite > 1 && this._firstPT && n.length > 1 && Q(e, this, i, this._overwrite, n) ? (this._kill(i, e), this._initProps(e, i, n, r, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (D[e._gsTweenID] = !0), c)
                }, s.render = function(t, e, i) {
                    var n, r, o, a, s = this._time,
                        c = this._duration,
                        l = this._rawPrevTime;
                    if (t >= c - 1e-7 && t >= 0) this._totalTime = this._time = c, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === c && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (l < 0 || t <= 0 && t >= -1e-7 || 1e-10 === l && "isPause" !== this.data) && l !== t && (i = !0, l > 1e-10 && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || l === t ? t : 1e-10);
                    else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === c && l > 0) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === c && (this._initted || !this.vars.lazy || i) && (l >= 0 && (1e-10 !== l || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || l === t ? t : 1e-10)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
                    else if (this._totalTime = this._time = t, this._easeType) {
                        var h = t / c,
                            u = this._easeType,
                            d = this._easePower;
                        (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === d ? h *= h : 2 === d ? h *= h * h : 3 === d ? h *= h * h * h : 4 === d && (h *= h * h * h * h), this.ratio = 1 === u ? 1 - h : 2 === u ? h : t / c < .5 ? h / 2 : 1 - h / 2
                    } else this.ratio = this._ease.getRatio(t / c);
                    if (this._time !== s || i) {
                        if (!this._initted) {
                            if (this._init(), !this._initted || this._gc) return;
                            if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = l, I.push(this), void(this._lazy = [t, e]);
                            this._time && !n ? this.ratio = this._ease.getRatio(this._time / c) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                        }
                        for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), 0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== c || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                        this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== s || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === c && 1e-10 === this._rawPrevTime && 1e-10 !== a && (this._rawPrevTime = 0)))
                    }
                }, s._kill = function(t, e, i) {
                    if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                    e = "string" != typeof e ? e || this._targets || this.target : R.selector(e) || e;
                    var n, r, o, a, s, c, l, h, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline,
                        p = this._firstPT;
                    if ((f(e) || O(e)) && "number" != typeof e[0])
                        for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (c = !0);
                    else {
                        if (this._targets) {
                            for (n = this._targets.length; --n > -1;)
                                if (e === this._targets[n]) {
                                    s = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                    break
                                }
                        } else {
                            if (e !== this.target) return !1;
                            s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                        }
                        if (s) {
                            if (l = t || s, h = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill), i && (R.onOverwrite || this.vars.onOverwrite)) {
                                for (o in l) s[o] && (u || (u = []), u.push(o));
                                if ((u || !t) && !K(this, i, e, u)) return !1
                            }
                            for (o in l)(a = s[o]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, c = !0), a.pg && a.t._kill(l) && (c = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), h && (r[o] = 1);
                            !this._firstPT && this._initted && p && this._enabled(!1, !1)
                        }
                    }
                    return c
                }, s.invalidate = function() {
                    return this._notifyPluginsOfEnabled && R._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], P.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this
                }, s._enabled = function(t, e) {
                    if (l || c.wake(), t && this._gc) {
                        var i, n = this._targets;
                        if (n)
                            for (i = n.length; --i > -1;) this._siblings[i] = J(n[i], this, !0);
                        else this._siblings = J(this.target, this, !0)
                    }
                    return P.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && R._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                }, R.to = function(t, e, i) {
                    return new R(t, e, i)
                }, R.from = function(t, e, i) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new R(t, e, i)
                }, R.fromTo = function(t, e, i, n) {
                    return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new R(t, e, n)
                }, R.delayedCall = function(t, e, i, n, r) {
                    return new R(e, 0, {
                        delay: t,
                        onComplete: e,
                        onCompleteParams: i,
                        callbackScope: n,
                        onReverseComplete: e,
                        onReverseCompleteParams: i,
                        immediateRender: !1,
                        lazy: !1,
                        useFrames: r,
                        overwrite: 0
                    })
                }, R.set = function(t, e) {
                    return new R(t, 0, e)
                }, R.getTweensOf = function(t, e) {
                    if (null == t) return [];
                    var i, n, r, o;
                    if (t = "string" != typeof t ? t : R.selector(t) || t, (f(t) || O(t)) && "number" != typeof t[0]) {
                        for (i = t.length, n = []; --i > -1;) n = n.concat(R.getTweensOf(t[i], e));
                        for (i = n.length; --i > -1;)
                            for (o = n[i], r = i; --r > -1;) o === n[r] && n.splice(i, 1)
                    } else if (t._gsTweenID)
                        for (i = (n = J(t).concat()).length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                    return n || []
                }, R.killTweensOf = R.killDelayedCallsTo = function(t, e, i) {
                    "object" == typeof e && (i = e, e = !1);
                    for (var n = R.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
                };
                var tt = y("plugins.TweenPlugin", function(t, e) {
                    this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = tt.prototype
                }, !0);
                if (s = tt.prototype, tt.version = "1.19.0", tt.API = 2, s._firstPT = null, s._addTween = z, s.setRatio = B, s._kill = function(t) {
                        var e, i = this._overwriteProps,
                            n = this._firstPT;
                        if (null != t[this._propName]) this._overwriteProps = [];
                        else
                            for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                        for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                        return !1
                    }, s._mod = s._roundProps = function(t) {
                        for (var e, i = this._firstPT; i;)(e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
                    }, R._onPluginEvent = function(t, e) {
                        var i, n, r, o, a, s = e._firstPT;
                        if ("_onInitAllProps" === t) {
                            for (; s;) {
                                for (a = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                                (s._prev = n ? n._prev : o) ? s._prev._next = s: r = s, (s._next = n) ? n._prev = s : o = s, s = a
                            }
                            s = e._firstPT = r
                        }
                        for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (i = !0), s = s._next;
                        return i
                    }, tt.activate = function(t) {
                        for (var e = t.length; --e > -1;) t[e].API === tt.API && (G[(new t[e])._propName] = t[e]);
                        return !0
                    }, v.plugin = function(t) {
                        if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                        var e, i = t.propName,
                            n = t.priority || 0,
                            r = t.overwriteProps,
                            o = {
                                init: "_onInitTween",
                                set: "setRatio",
                                kill: "_kill",
                                round: "_mod",
                                mod: "_mod",
                                initAll: "_onInitAllProps"
                            },
                            a = y("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                                tt.call(this, i, n), this._overwriteProps = r || []
                            }, !0 === t.global),
                            s = a.prototype = new tt(i);
                        for (e in s.constructor = a, a.API = t.API, o) "function" == typeof t[e] && (s[o[e]] = t[e]);
                        return a.version = t.version, tt.activate([a]), a
                    }, o = t._gsQueue) {
                    for (a = 0; a < o.length; a++) o[a]();
                    for (s in m) m[s].func || t.console.log("GSAP encountered missing dependency: " + s)
                }
                return l = !1, R
            }(r),
            a = r.GreenSockGlobals,
            s = a.com.greensock,
            c = s.core.SimpleTimeline,
            l = s.core.Animation,
            h = a.Ease,
            u = (a.Linear, a.Power1, a.Power2, a.Power3, a.Power4, a.TweenPlugin);
        s.events.EventDispatcher
    }).call(this, i(10)(t), i(3))
}, function(t, e, i) {
    "use strict";
    i.r(e),
        function(t) {
            function n() {}
            i.d(e, "WebGLRenderTargetCube", function() {
                return Ke
            }), i.d(e, "WebGLRenderTarget", function() {
                return Je
            }), i.d(e, "WebGLRenderer", function() {
                return gr
            }), i.d(e, "ShaderLib", function() {
                return hi
            }), i.d(e, "UniformsLib", function() {
                return li
            }), i.d(e, "UniformsUtils", function() {
                return ai
            }), i.d(e, "ShaderChunk", function() {
                return ni
            }), i.d(e, "FogExp2", function() {
                return vr
            }), i.d(e, "Fog", function() {
                return yr
            }), i.d(e, "Scene", function() {
                return _r
            }), i.d(e, "Sprite", function() {
                return Mr
            }), i.d(e, "LOD", function() {
                return Tr
            }), i.d(e, "SkinnedMesh", function() {
                return Er
            }), i.d(e, "Skeleton", function() {
                return Sr
            }), i.d(e, "Bone", function() {
                return Ar
            }), i.d(e, "Mesh", function() {
                return ji
            }), i.d(e, "LineSegments", function() {
                return Cr
            }), i.d(e, "LineLoop", function() {
                return Rr
            }), i.d(e, "Line", function() {
                return Lr
            }), i.d(e, "Points", function() {
                return Ir
            }), i.d(e, "Group", function() {
                return sr
            }), i.d(e, "VideoTexture", function() {
                return Dr
            }), i.d(e, "DataTexture", function() {
                return Qe
            }), i.d(e, "DataTexture3D", function() {
                return qi
            }), i.d(e, "CompressedTexture", function() {
                return kr
            }), i.d(e, "CubeTexture", function() {
                return Xi
            }), i.d(e, "CanvasTexture", function() {
                return Nr
            }), i.d(e, "DepthTexture", function() {
                return Br
            }), i.d(e, "Texture", function() {
                return Ye
            }), i.d(e, "AnimationLoader", function() {
                return La
            }), i.d(e, "CompressedTextureLoader", function() {
                return Ca
            }), i.d(e, "DataTextureLoader", function() {
                return Ra
            }), i.d(e, "CubeTextureLoader", function() {
                return Ia
            }), i.d(e, "TextureLoader", function() {
                return Da
            }), i.d(e, "ObjectLoader", function() {
                return _s
            }), i.d(e, "MaterialLoader", function() {
                return ms
            }), i.d(e, "BufferGeometryLoader", function() {
                return vs
            }), i.d(e, "DefaultLoadingManager", function() {
                return Sa
            }), i.d(e, "LoadingManager", function() {
                return Ea
            }), i.d(e, "ImageLoader", function() {
                return Oa
            }), i.d(e, "ImageBitmapLoader", function() {
                return Ts
            }), i.d(e, "FontLoader", function() {
                return Ps
            }), i.d(e, "FileLoader", function() {
                return Pa
            }), i.d(e, "Loader", function() {
                return Ls
            }), i.d(e, "LoaderUtils", function() {
                return gs
            }), i.d(e, "Cache", function() {
                return Ta
            }), i.d(e, "AudioLoader", function() {
                return Rs
            }), i.d(e, "SpotLightShadow", function() {
                return ss
            }), i.d(e, "SpotLight", function() {
                return cs
            }), i.d(e, "PointLight", function() {
                return ls
            }), i.d(e, "RectAreaLight", function() {
                return fs
            }), i.d(e, "HemisphereLight", function() {
                return os
            }), i.d(e, "DirectionalLightShadow", function() {
                return us
            }), i.d(e, "DirectionalLight", function() {
                return ds
            }), i.d(e, "AmbientLight", function() {
                return ps
            }), i.d(e, "LightShadow", function() {
                return as
            }), i.d(e, "Light", function() {
                return rs
            }), i.d(e, "StereoCamera", function() {
                return Os
            }), i.d(e, "PerspectiveCamera", function() {
                return lr
            }), i.d(e, "OrthographicCamera", function() {
                return hs
            }), i.d(e, "CubeCamera", function() {
                return Is
            }), i.d(e, "ArrayCamera", function() {
                return hr
            }), i.d(e, "Camera", function() {
                return cr
            }), i.d(e, "AudioListener", function() {
                return ks
            }), i.d(e, "PositionalAudio", function() {
                return Bs
            }), i.d(e, "AudioContext", function() {
                return Cs
            }), i.d(e, "AudioAnalyser", function() {
                return Fs
            }), i.d(e, "Audio", function() {
                return Ns
            }), i.d(e, "VectorKeyframeTrack", function() {
                return ba
            }), i.d(e, "StringKeyframeTrack", function() {
                return xa
            }), i.d(e, "QuaternionKeyframeTrack", function() {
                return _a
            }), i.d(e, "NumberKeyframeTrack", function() {
                return va
            }), i.d(e, "ColorKeyframeTrack", function() {
                return ga
            }), i.d(e, "BooleanKeyframeTrack", function() {
                return ma
            }), i.d(e, "PropertyMixer", function() {
                return zs
            }), i.d(e, "PropertyBinding", function() {
                return Vs
            }), i.d(e, "KeyframeTrack", function() {
                return fa
            }), i.d(e, "AnimationUtils", function() {
                return la
            }), i.d(e, "AnimationObjectGroup", function() {
                return js
            }), i.d(e, "AnimationMixer", function() {
                return Xs
            }), i.d(e, "AnimationClip", function() {
                return wa
            }), i.d(e, "Uniform", function() {
                return qs
            }), i.d(e, "InstancedBufferGeometry", function() {
                return Ys
            }), i.d(e, "BufferGeometry", function() {
                return Ii
            }), i.d(e, "Geometry", function() {
                return _i
            }), i.d(e, "InterleavedBufferAttribute", function() {
                return br
            }), i.d(e, "InstancedInterleavedBuffer", function() {
                return Zs
            }), i.d(e, "InterleavedBuffer", function() {
                return xr
            }), i.d(e, "InstancedBufferAttribute", function() {
                return Js
            }), i.d(e, "Face3", function() {
                return pi
            }), i.d(e, "Object3D", function() {
                return vi
            }), i.d(e, "Raycaster", function() {
                return Ks
            }), i.d(e, "Layers", function() {
                return mi
            }), i.d(e, "EventDispatcher", function() {
                return n
            }), i.d(e, "Clock", function() {
                return Ds
            }), i.d(e, "QuaternionLinearInterpolant", function() {
                return ya
            }), i.d(e, "LinearInterpolant", function() {
                return da
            }), i.d(e, "DiscreteInterpolant", function() {
                return pa
            }), i.d(e, "CubicInterpolant", function() {
                return ua
            }), i.d(e, "Interpolant", function() {
                return ha
            }), i.d(e, "Triangle", function() {
                return Hi
            }), i.d(e, "Math", function() {
                return Ue
            }), i.d(e, "Spherical", function() {
                return tc
            }), i.d(e, "Cylindrical", function() {
                return ec
            }), i.d(e, "Plane", function() {
                return ei
            }), i.d(e, "Frustum", function() {
                return ii
            }), i.d(e, "Sphere", function() {
                return ti
            }), i.d(e, "Ray", function() {
                return Gi
            }), i.d(e, "Matrix4", function() {
                return He
            }), i.d(e, "Matrix3", function() {
                return We
            }), i.d(e, "Box3", function() {
                return $e
            }), i.d(e, "Box2", function() {
                return ic
            }), i.d(e, "Line3", function() {
                return nc
            }), i.d(e, "Euler", function() {
                return fi
            }), i.d(e, "Vector4", function() {
                return Ze
            }), i.d(e, "Vector3", function() {
                return je
            }), i.d(e, "Vector2", function() {
                return Ge
            }), i.d(e, "Quaternion", function() {
                return Ve
            }), i.d(e, "Color", function() {
                return ci
            }), i.d(e, "ImmediateRenderObject", function() {
                return rc
            }), i.d(e, "VertexNormalsHelper", function() {
                return oc
            }), i.d(e, "SpotLightHelper", function() {
                return ac
            }), i.d(e, "SkeletonHelper", function() {
                return sc
            }), i.d(e, "PointLightHelper", function() {
                return cc
            }), i.d(e, "RectAreaLightHelper", function() {
                return lc
            }), i.d(e, "HemisphereLightHelper", function() {
                return hc
            }), i.d(e, "GridHelper", function() {
                return uc
            }), i.d(e, "PolarGridHelper", function() {
                return dc
            }), i.d(e, "FaceNormalsHelper", function() {
                return pc
            }), i.d(e, "DirectionalLightHelper", function() {
                return fc
            }), i.d(e, "CameraHelper", function() {
                return mc
            }), i.d(e, "BoxHelper", function() {
                return gc
            }), i.d(e, "Box3Helper", function() {
                return vc
            }), i.d(e, "PlaneHelper", function() {
                return yc
            }), i.d(e, "ArrowHelper", function() {
                return _c
            }), i.d(e, "AxesHelper", function() {
                return xc
            }), i.d(e, "Shape", function() {
                return ns
            }), i.d(e, "Path", function() {
                return is
            }), i.d(e, "ShapePath", function() {
                return Es
            }), i.d(e, "Font", function() {
                return Ss
            }), i.d(e, "CurvePath", function() {
                return es
            }), i.d(e, "Curve", function() {
                return ka
            }), i.d(e, "ImageUtils", function() {
                return Xe
            }), i.d(e, "ShapeUtils", function() {
                return So
            }), i.d(e, "WebGLUtils", function() {
                return ar
            }), i.d(e, "WireframeGeometry", function() {
                return Fr
            }), i.d(e, "ParametricGeometry", function() {
                return zr
            }), i.d(e, "ParametricBufferGeometry", function() {
                return Ur
            }), i.d(e, "TetrahedronGeometry", function() {
                return Vr
            }), i.d(e, "TetrahedronBufferGeometry", function() {
                return jr
            }), i.d(e, "OctahedronGeometry", function() {
                return Wr
            }), i.d(e, "OctahedronBufferGeometry", function() {
                return Xr
            }), i.d(e, "IcosahedronGeometry", function() {
                return qr
            }), i.d(e, "IcosahedronBufferGeometry", function() {
                return Yr
            }), i.d(e, "DodecahedronGeometry", function() {
                return Zr
            }), i.d(e, "DodecahedronBufferGeometry", function() {
                return Jr
            }), i.d(e, "PolyhedronGeometry", function() {
                return Gr
            }), i.d(e, "PolyhedronBufferGeometry", function() {
                return Hr
            }), i.d(e, "TubeGeometry", function() {
                return Kr
            }), i.d(e, "TubeBufferGeometry", function() {
                return Qr
            }), i.d(e, "TorusKnotGeometry", function() {
                return $r
            }), i.d(e, "TorusKnotBufferGeometry", function() {
                return to
            }), i.d(e, "TorusGeometry", function() {
                return eo
            }), i.d(e, "TorusBufferGeometry", function() {
                return io
            }), i.d(e, "TextGeometry", function() {
                return Io
            }), i.d(e, "TextBufferGeometry", function() {
                return Do
            }), i.d(e, "SphereGeometry", function() {
                return ko
            }), i.d(e, "SphereBufferGeometry", function() {
                return No
            }), i.d(e, "RingGeometry", function() {
                return Bo
            }), i.d(e, "RingBufferGeometry", function() {
                return Fo
            }), i.d(e, "PlaneGeometry", function() {
                return Ni
            }), i.d(e, "PlaneBufferGeometry", function() {
                return Bi
            }), i.d(e, "LatheGeometry", function() {
                return zo
            }), i.d(e, "LatheBufferGeometry", function() {
                return Uo
            }), i.d(e, "ShapeGeometry", function() {
                return Go
            }), i.d(e, "ShapeBufferGeometry", function() {
                return Ho
            }), i.d(e, "ExtrudeGeometry", function() {
                return Lo
            }), i.d(e, "ExtrudeBufferGeometry", function() {
                return Co
            }), i.d(e, "EdgesGeometry", function() {
                return jo
            }), i.d(e, "ConeGeometry", function() {
                return qo
            }), i.d(e, "ConeBufferGeometry", function() {
                return Yo
            }), i.d(e, "CylinderGeometry", function() {
                return Wo
            }), i.d(e, "CylinderBufferGeometry", function() {
                return Xo
            }), i.d(e, "CircleGeometry", function() {
                return Zo
            }), i.d(e, "CircleBufferGeometry", function() {
                return Jo
            }), i.d(e, "BoxGeometry", function() {
                return Di
            }), i.d(e, "BoxBufferGeometry", function() {
                return ki
            }), i.d(e, "ShadowMaterial", function() {
                return Qo
            }), i.d(e, "SpriteMaterial", function() {
                return wr
            }), i.d(e, "RawShaderMaterial", function() {
                return $o
            }), i.d(e, "ShaderMaterial", function() {
                return Ui
            }), i.d(e, "PointsMaterial", function() {
                return Or
            }), i.d(e, "MeshPhysicalMaterial", function() {
                return ea
            }), i.d(e, "MeshStandardMaterial", function() {
                return ta
            }), i.d(e, "MeshPhongMaterial", function() {
                return ia
            }), i.d(e, "MeshToonMaterial", function() {
                return na
            }), i.d(e, "MeshNormalMaterial", function() {
                return ra
            }), i.d(e, "MeshLambertMaterial", function() {
                return oa
            }), i.d(e, "MeshDepthMaterial", function() {
                return ir
            }), i.d(e, "MeshDistanceMaterial", function() {
                return nr
            }), i.d(e, "MeshBasicMaterial", function() {
                return Vi
            }), i.d(e, "MeshMatcapMaterial", function() {
                return aa
            }), i.d(e, "LineDashedMaterial", function() {
                return sa
            }), i.d(e, "LineBasicMaterial", function() {
                return Pr
            }), i.d(e, "Material", function() {
                return zi
            }), i.d(e, "Float64BufferAttribute", function() {
                return Li
            }), i.d(e, "Float32BufferAttribute", function() {
                return Pi
            }), i.d(e, "Uint32BufferAttribute", function() {
                return Ai
            }), i.d(e, "Int32BufferAttribute", function() {
                return Si
            }), i.d(e, "Uint16BufferAttribute", function() {
                return Ei
            }), i.d(e, "Int16BufferAttribute", function() {
                return Ti
            }), i.d(e, "Uint8ClampedBufferAttribute", function() {
                return Mi
            }), i.d(e, "Uint8BufferAttribute", function() {
                return wi
            }), i.d(e, "Int8BufferAttribute", function() {
                return bi
            }), i.d(e, "BufferAttribute", function() {
                return xi
            }), i.d(e, "ArcCurve", function() {
                return Ba
            }), i.d(e, "CatmullRomCurve3", function() {
                return Va
            }), i.d(e, "CubicBezierCurve", function() {
                return qa
            }), i.d(e, "CubicBezierCurve3", function() {
                return Ya
            }), i.d(e, "EllipseCurve", function() {
                return Na
            }), i.d(e, "LineCurve", function() {
                return Za
            }), i.d(e, "LineCurve3", function() {
                return Ja
            }), i.d(e, "QuadraticBezierCurve", function() {
                return Ka
            }), i.d(e, "QuadraticBezierCurve3", function() {
                return Qa
            }), i.d(e, "SplineCurve", function() {
                return $a
            }), i.d(e, "REVISION", function() {
                return o
            }), i.d(e, "MOUSE", function() {
                return a
            }), i.d(e, "CullFaceNone", function() {
                return s
            }), i.d(e, "CullFaceBack", function() {
                return c
            }), i.d(e, "CullFaceFront", function() {
                return l
            }), i.d(e, "CullFaceFrontBack", function() {
                return h
            }), i.d(e, "FrontFaceDirectionCW", function() {
                return u
            }), i.d(e, "FrontFaceDirectionCCW", function() {
                return d
            }), i.d(e, "BasicShadowMap", function() {
                return p
            }), i.d(e, "PCFShadowMap", function() {
                return f
            }), i.d(e, "PCFSoftShadowMap", function() {
                return m
            }), i.d(e, "FrontSide", function() {
                return g
            }), i.d(e, "BackSide", function() {
                return v
            }), i.d(e, "DoubleSide", function() {
                return y
            }), i.d(e, "FlatShading", function() {
                return _
            }), i.d(e, "SmoothShading", function() {
                return x
            }), i.d(e, "NoColors", function() {
                return b
            }), i.d(e, "FaceColors", function() {
                return w
            }), i.d(e, "VertexColors", function() {
                return M
            }), i.d(e, "NoBlending", function() {
                return T
            }), i.d(e, "NormalBlending", function() {
                return E
            }), i.d(e, "AdditiveBlending", function() {
                return S
            }), i.d(e, "SubtractiveBlending", function() {
                return A
            }), i.d(e, "MultiplyBlending", function() {
                return P
            }), i.d(e, "CustomBlending", function() {
                return L
            }), i.d(e, "AddEquation", function() {
                return C
            }), i.d(e, "SubtractEquation", function() {
                return R
            }), i.d(e, "ReverseSubtractEquation", function() {
                return O
            }), i.d(e, "MinEquation", function() {
                return I
            }), i.d(e, "MaxEquation", function() {
                return D
            }), i.d(e, "ZeroFactor", function() {
                return k
            }), i.d(e, "OneFactor", function() {
                return N
            }), i.d(e, "SrcColorFactor", function() {
                return B
            }), i.d(e, "OneMinusSrcColorFactor", function() {
                return F
            }), i.d(e, "SrcAlphaFactor", function() {
                return z
            }), i.d(e, "OneMinusSrcAlphaFactor", function() {
                return U
            }), i.d(e, "DstAlphaFactor", function() {
                return G
            }), i.d(e, "OneMinusDstAlphaFactor", function() {
                return H
            }), i.d(e, "DstColorFactor", function() {
                return V
            }), i.d(e, "OneMinusDstColorFactor", function() {
                return j
            }), i.d(e, "SrcAlphaSaturateFactor", function() {
                return W
            }), i.d(e, "NeverDepth", function() {
                return X
            }), i.d(e, "AlwaysDepth", function() {
                return q
            }), i.d(e, "LessDepth", function() {
                return Y
            }), i.d(e, "LessEqualDepth", function() {
                return Z
            }), i.d(e, "EqualDepth", function() {
                return J
            }), i.d(e, "GreaterEqualDepth", function() {
                return K
            }), i.d(e, "GreaterDepth", function() {
                return Q
            }), i.d(e, "NotEqualDepth", function() {
                return $
            }), i.d(e, "MultiplyOperation", function() {
                return tt
            }), i.d(e, "MixOperation", function() {
                return et
            }), i.d(e, "AddOperation", function() {
                return it
            }), i.d(e, "NoToneMapping", function() {
                return nt
            }), i.d(e, "LinearToneMapping", function() {
                return rt
            }), i.d(e, "ReinhardToneMapping", function() {
                return ot
            }), i.d(e, "Uncharted2ToneMapping", function() {
                return at
            }), i.d(e, "CineonToneMapping", function() {
                return st
            }), i.d(e, "ACESFilmicToneMapping", function() {
                return ct
            }), i.d(e, "UVMapping", function() {
                return lt
            }), i.d(e, "CubeReflectionMapping", function() {
                return ht
            }), i.d(e, "CubeRefractionMapping", function() {
                return ut
            }), i.d(e, "EquirectangularReflectionMapping", function() {
                return dt
            }), i.d(e, "EquirectangularRefractionMapping", function() {
                return pt
            }), i.d(e, "SphericalReflectionMapping", function() {
                return ft
            }), i.d(e, "CubeUVReflectionMapping", function() {
                return mt
            }), i.d(e, "CubeUVRefractionMapping", function() {
                return gt
            }), i.d(e, "RepeatWrapping", function() {
                return vt
            }), i.d(e, "ClampToEdgeWrapping", function() {
                return yt
            }), i.d(e, "MirroredRepeatWrapping", function() {
                return _t
            }), i.d(e, "NearestFilter", function() {
                return xt
            }), i.d(e, "NearestMipMapNearestFilter", function() {
                return bt
            }), i.d(e, "NearestMipMapLinearFilter", function() {
                return wt
            }), i.d(e, "LinearFilter", function() {
                return Mt
            }), i.d(e, "LinearMipMapNearestFilter", function() {
                return Tt
            }), i.d(e, "LinearMipMapLinearFilter", function() {
                return Et
            }), i.d(e, "UnsignedByteType", function() {
                return St
            }), i.d(e, "ByteType", function() {
                return At
            }), i.d(e, "ShortType", function() {
                return Pt
            }), i.d(e, "UnsignedShortType", function() {
                return Lt
            }), i.d(e, "IntType", function() {
                return Ct
            }), i.d(e, "UnsignedIntType", function() {
                return Rt
            }), i.d(e, "FloatType", function() {
                return Ot
            }), i.d(e, "HalfFloatType", function() {
                return It
            }), i.d(e, "UnsignedShort4444Type", function() {
                return Dt
            }), i.d(e, "UnsignedShort5551Type", function() {
                return kt
            }), i.d(e, "UnsignedShort565Type", function() {
                return Nt
            }), i.d(e, "UnsignedInt248Type", function() {
                return Bt
            }), i.d(e, "AlphaFormat", function() {
                return Ft
            }), i.d(e, "RGBFormat", function() {
                return zt
            }), i.d(e, "RGBAFormat", function() {
                return Ut
            }), i.d(e, "LuminanceFormat", function() {
                return Gt
            }), i.d(e, "LuminanceAlphaFormat", function() {
                return Ht
            }), i.d(e, "RGBEFormat", function() {
                return Vt
            }), i.d(e, "DepthFormat", function() {
                return jt
            }), i.d(e, "DepthStencilFormat", function() {
                return Wt
            }), i.d(e, "RedFormat", function() {
                return Xt
            }), i.d(e, "RGB_S3TC_DXT1_Format", function() {
                return qt
            }), i.d(e, "RGBA_S3TC_DXT1_Format", function() {
                return Yt
            }), i.d(e, "RGBA_S3TC_DXT3_Format", function() {
                return Zt
            }), i.d(e, "RGBA_S3TC_DXT5_Format", function() {
                return Jt
            }), i.d(e, "RGB_PVRTC_4BPPV1_Format", function() {
                return Kt
            }), i.d(e, "RGB_PVRTC_2BPPV1_Format", function() {
                return Qt
            }), i.d(e, "RGBA_PVRTC_4BPPV1_Format", function() {
                return $t
            }), i.d(e, "RGBA_PVRTC_2BPPV1_Format", function() {
                return te
            }), i.d(e, "RGB_ETC1_Format", function() {
                return ee
            }), i.d(e, "RGBA_ASTC_4x4_Format", function() {
                return ie
            }), i.d(e, "RGBA_ASTC_5x4_Format", function() {
                return ne
            }), i.d(e, "RGBA_ASTC_5x5_Format", function() {
                return re
            }), i.d(e, "RGBA_ASTC_6x5_Format", function() {
                return oe
            }), i.d(e, "RGBA_ASTC_6x6_Format", function() {
                return ae
            }), i.d(e, "RGBA_ASTC_8x5_Format", function() {
                return se
            }), i.d(e, "RGBA_ASTC_8x6_Format", function() {
                return ce
            }), i.d(e, "RGBA_ASTC_8x8_Format", function() {
                return le
            }), i.d(e, "RGBA_ASTC_10x5_Format", function() {
                return he
            }), i.d(e, "RGBA_ASTC_10x6_Format", function() {
                return ue
            }), i.d(e, "RGBA_ASTC_10x8_Format", function() {
                return de
            }), i.d(e, "RGBA_ASTC_10x10_Format", function() {
                return pe
            }), i.d(e, "RGBA_ASTC_12x10_Format", function() {
                return fe
            }), i.d(e, "RGBA_ASTC_12x12_Format", function() {
                return me
            }), i.d(e, "LoopOnce", function() {
                return ge
            }), i.d(e, "LoopRepeat", function() {
                return ve
            }), i.d(e, "LoopPingPong", function() {
                return ye
            }), i.d(e, "InterpolateDiscrete", function() {
                return _e
            }), i.d(e, "InterpolateLinear", function() {
                return xe
            }), i.d(e, "InterpolateSmooth", function() {
                return be
            }), i.d(e, "ZeroCurvatureEnding", function() {
                return we
            }), i.d(e, "ZeroSlopeEnding", function() {
                return Me
            }), i.d(e, "WrapAroundEnding", function() {
                return Te
            }), i.d(e, "TrianglesDrawMode", function() {
                return Ee
            }), i.d(e, "TriangleStripDrawMode", function() {
                return Se
            }), i.d(e, "TriangleFanDrawMode", function() {
                return Ae
            }), i.d(e, "LinearEncoding", function() {
                return Pe
            }), i.d(e, "sRGBEncoding", function() {
                return Le
            }), i.d(e, "GammaEncoding", function() {
                return Ce
            }), i.d(e, "RGBEEncoding", function() {
                return Re
            }), i.d(e, "LogLuvEncoding", function() {
                return Oe
            }), i.d(e, "RGBM7Encoding", function() {
                return Ie
            }), i.d(e, "RGBM16Encoding", function() {
                return De
            }), i.d(e, "RGBDEncoding", function() {
                return ke
            }), i.d(e, "BasicDepthPacking", function() {
                return Ne
            }), i.d(e, "RGBADepthPacking", function() {
                return Be
            }), i.d(e, "TangentSpaceNormalMap", function() {
                return Fe
            }), i.d(e, "ObjectSpaceNormalMap", function() {
                return ze
            }), i.d(e, "CubeGeometry", function() {
                return Di
            }), i.d(e, "Face4", function() {
                return bc
            }), i.d(e, "LineStrip", function() {
                return wc
            }), i.d(e, "LinePieces", function() {
                return Mc
            }), i.d(e, "MeshFaceMaterial", function() {
                return Tc
            }), i.d(e, "MultiMaterial", function() {
                return Ec
            }), i.d(e, "PointCloud", function() {
                return Sc
            }), i.d(e, "Particle", function() {
                return Ac
            }), i.d(e, "ParticleSystem", function() {
                return Pc
            }), i.d(e, "PointCloudMaterial", function() {
                return Lc
            }), i.d(e, "ParticleBasicMaterial", function() {
                return Cc
            }), i.d(e, "ParticleSystemMaterial", function() {
                return Rc
            }), i.d(e, "Vertex", function() {
                return Oc
            }), i.d(e, "DynamicBufferAttribute", function() {
                return Ic
            }), i.d(e, "Int8Attribute", function() {
                return Dc
            }), i.d(e, "Uint8Attribute", function() {
                return kc
            }), i.d(e, "Uint8ClampedAttribute", function() {
                return Nc
            }), i.d(e, "Int16Attribute", function() {
                return Bc
            }), i.d(e, "Uint16Attribute", function() {
                return Fc
            }), i.d(e, "Int32Attribute", function() {
                return zc
            }), i.d(e, "Uint32Attribute", function() {
                return Uc
            }), i.d(e, "Float32Attribute", function() {
                return Gc
            }), i.d(e, "Float64Attribute", function() {
                return Hc
            }), i.d(e, "ClosedSplineCurve3", function() {
                return Vc
            }), i.d(e, "SplineCurve3", function() {
                return jc
            }), i.d(e, "Spline", function() {
                return Wc
            }), i.d(e, "AxisHelper", function() {
                return Xc
            }), i.d(e, "BoundingBoxHelper", function() {
                return qc
            }), i.d(e, "EdgesHelper", function() {
                return Yc
            }), i.d(e, "WireframeHelper", function() {
                return Zc
            }), i.d(e, "XHRLoader", function() {
                return Jc
            }), i.d(e, "BinaryTextureLoader", function() {
                return Kc
            }), i.d(e, "GeometryUtils", function() {
                return Qc
            }), i.d(e, "Projector", function() {
                return $c
            }), i.d(e, "CanvasRenderer", function() {
                return tl
            }), i.d(e, "JSONLoader", function() {
                return el
            }), i.d(e, "SceneUtils", function() {
                return il
            }), i.d(e, "LensFlare", function() {
                return nl
            }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
                return "number" == typeof t && isFinite(t) && Math.floor(t) === t
            }), void 0 === Math.sign && (Math.sign = function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : +t
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function(t) {
                if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), i = 1; i < arguments.length; i++) {
                    var n = arguments[i];
                    if (void 0 !== n && null !== n)
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }), Object.assign(n.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var i = this._listeners;
                    void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    return void 0 !== i[t] && -1 !== i[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 !== this._listeners) {
                        var i = this._listeners[t];
                        if (void 0 !== i) {
                            var n = i.indexOf(e); - 1 !== n && i.splice(n, 1)
                        }
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 !== this._listeners) {
                        var e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, t)
                        }
                    }
                }
            });
            var r, o = "99",
                a = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                },
                s = 0,
                c = 1,
                l = 2,
                h = 3,
                u = 0,
                d = 1,
                p = 0,
                f = 1,
                m = 2,
                g = 0,
                v = 1,
                y = 2,
                _ = 1,
                x = 2,
                b = 0,
                w = 1,
                M = 2,
                T = 0,
                E = 1,
                S = 2,
                A = 3,
                P = 4,
                L = 5,
                C = 100,
                R = 101,
                O = 102,
                I = 103,
                D = 104,
                k = 200,
                N = 201,
                B = 202,
                F = 203,
                z = 204,
                U = 205,
                G = 206,
                H = 207,
                V = 208,
                j = 209,
                W = 210,
                X = 0,
                q = 1,
                Y = 2,
                Z = 3,
                J = 4,
                K = 5,
                Q = 6,
                $ = 7,
                tt = 0,
                et = 1,
                it = 2,
                nt = 0,
                rt = 1,
                ot = 2,
                at = 3,
                st = 4,
                ct = 5,
                lt = 300,
                ht = 301,
                ut = 302,
                dt = 303,
                pt = 304,
                ft = 305,
                mt = 306,
                gt = 307,
                vt = 1e3,
                yt = 1001,
                _t = 1002,
                xt = 1003,
                bt = 1004,
                wt = 1005,
                Mt = 1006,
                Tt = 1007,
                Et = 1008,
                St = 1009,
                At = 1010,
                Pt = 1011,
                Lt = 1012,
                Ct = 1013,
                Rt = 1014,
                Ot = 1015,
                It = 1016,
                Dt = 1017,
                kt = 1018,
                Nt = 1019,
                Bt = 1020,
                Ft = 1021,
                zt = 1022,
                Ut = 1023,
                Gt = 1024,
                Ht = 1025,
                Vt = Ut,
                jt = 1026,
                Wt = 1027,
                Xt = 1028,
                qt = 33776,
                Yt = 33777,
                Zt = 33778,
                Jt = 33779,
                Kt = 35840,
                Qt = 35841,
                $t = 35842,
                te = 35843,
                ee = 36196,
                ie = 37808,
                ne = 37809,
                re = 37810,
                oe = 37811,
                ae = 37812,
                se = 37813,
                ce = 37814,
                le = 37815,
                he = 37816,
                ue = 37817,
                de = 37818,
                pe = 37819,
                fe = 37820,
                me = 37821,
                ge = 2200,
                ve = 2201,
                ye = 2202,
                _e = 2300,
                xe = 2301,
                be = 2302,
                we = 2400,
                Me = 2401,
                Te = 2402,
                Ee = 0,
                Se = 1,
                Ae = 2,
                Pe = 3e3,
                Le = 3001,
                Ce = 3007,
                Re = 3002,
                Oe = 3003,
                Ie = 3004,
                De = 3005,
                ke = 3006,
                Ne = 3200,
                Be = 3201,
                Fe = 0,
                ze = 1,
                Ue = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
                        return function() {
                            var e = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0;
                            return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & i] + t[i >> 8 & 255] + "-" + t[i >> 16 & 15 | 64] + t[i >> 24 & 255] + "-" + t[63 & n | 128] + t[n >> 8 & 255] + "-" + t[n >> 16 & 255] + t[n >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255]).toUpperCase()
                        }
                    }(),
                    clamp: function(t, e, i) {
                        return Math.max(e, Math.min(i, t))
                    },
                    euclideanModulo: function(t, e) {
                        return (t % e + e) % e
                    },
                    mapLinear: function(t, e, i, n, r) {
                        return n + (t - e) * (r - n) / (i - e)
                    },
                    lerp: function(t, e, i) {
                        return (1 - i) * t + i * e
                    },
                    smoothstep: function(t, e, i) {
                        return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, i) {
                        return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    degToRad: function(t) {
                        return t * Ue.DEG2RAD
                    },
                    radToDeg: function(t) {
                        return t * Ue.RAD2DEG
                    },
                    isPowerOfTwo: function(t) {
                        return 0 == (t & t - 1) && 0 !== t
                    },
                    ceilPowerOfTwo: function(t) {
                        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                    },
                    floorPowerOfTwo: function(t) {
                        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                    }
                };

            function Ge(t, e) {
                this.x = t || 0, this.y = e || 0
            }

            function He() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            function Ve(t, e, i, n) {
                this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
            }

            function je(t, e, i) {
                this.x = t || 0, this.y = e || 0, this.z = i || 0
            }

            function We() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.defineProperties(Ge.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }
            }), Object.assign(Ge.prototype, {
                isVector2: !0,
                set: function(t, e) {
                    return this.x = t, this.y = e, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                },
                multiply: function(t) {
                    return this.x *= t.x, this.y *= t.y, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                applyMatrix3: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = t.elements;
                    return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                },
                clampScalar: function() {
                    var t = new Ge,
                        e = new Ge;
                    return function(i, n) {
                        return t.set(i, i), e.set(n, n), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                cross: function(t) {
                    return this.x * t.y - this.y * t.x
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function() {
                    var t = Math.atan2(this.y, this.x);
                    return t < 0 && (t += 2 * Math.PI), t
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        i = this.y - t.y;
                    return e * e + i * i
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                },
                lerpVectors: function(t, e, i) {
                    return this.subVectors(e, t).multiplyScalar(i).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
                },
                fromBufferAttribute: function(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                },
                rotateAround: function(t, e) {
                    var i = Math.cos(e),
                        n = Math.sin(e),
                        r = this.x - t.x,
                        o = this.y - t.y;
                    return this.x = r * i - o * n + t.x, this.y = r * n + o * i + t.y, this
                }
            }), Object.assign(He.prototype, {
                isMatrix4: !0,
                set: function(t, e, i, n, r, o, a, s, c, l, h, u, d, p, f, m) {
                    var g = this.elements;
                    return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = a, g[13] = s, g[2] = c, g[6] = l, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new He).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
                },
                copyPosition: function(t) {
                    var e = this.elements,
                        i = t.elements;
                    return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
                },
                extractBasis: function(t, e, i) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(t, e, i) {
                    return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function() {
                    var t = new je;
                    return function(e) {
                        var i = this.elements,
                            n = e.elements,
                            r = 1 / t.setFromMatrixColumn(e, 0).length(),
                            o = 1 / t.setFromMatrixColumn(e, 1).length(),
                            a = 1 / t.setFromMatrixColumn(e, 2).length();
                        return i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * o, i[5] = n[5] * o, i[6] = n[6] * o, i[7] = 0, i[8] = n[8] * a, i[9] = n[9] * a, i[10] = n[10] * a, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
                    }
                }(),
                makeRotationFromEuler: function(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var e = this.elements,
                        i = t.x,
                        n = t.y,
                        r = t.z,
                        o = Math.cos(i),
                        a = Math.sin(i),
                        s = Math.cos(n),
                        c = Math.sin(n),
                        l = Math.cos(r),
                        h = Math.sin(r);
                    if ("XYZ" === t.order) {
                        var u = o * l,
                            d = o * h,
                            p = a * l,
                            f = a * h;
                        e[0] = s * l, e[4] = -s * h, e[8] = c, e[1] = d + p * c, e[5] = u - f * c, e[9] = -a * s, e[2] = f - u * c, e[6] = p + d * c, e[10] = o * s
                    } else if ("YXZ" === t.order) {
                        var m = s * l,
                            g = s * h,
                            v = c * l,
                            y = c * h;
                        e[0] = m + y * a, e[4] = v * a - g, e[8] = o * c, e[1] = o * h, e[5] = o * l, e[9] = -a, e[2] = g * a - v, e[6] = y + m * a, e[10] = o * s
                    } else if ("ZXY" === t.order) {
                        m = s * l, g = s * h, v = c * l, y = c * h;
                        e[0] = m - y * a, e[4] = -o * h, e[8] = v + g * a, e[1] = g + v * a, e[5] = o * l, e[9] = y - m * a, e[2] = -o * c, e[6] = a, e[10] = o * s
                    } else if ("ZYX" === t.order) {
                        u = o * l, d = o * h, p = a * l, f = a * h;
                        e[0] = s * l, e[4] = p * c - d, e[8] = u * c + f, e[1] = s * h, e[5] = f * c + u, e[9] = d * c - p, e[2] = -c, e[6] = a * s, e[10] = o * s
                    } else if ("YZX" === t.order) {
                        var _ = o * s,
                            x = o * c,
                            b = a * s,
                            w = a * c;
                        e[0] = s * l, e[4] = w - _ * h, e[8] = b * h + x, e[1] = h, e[5] = o * l, e[9] = -a * l, e[2] = -c * l, e[6] = x * h + b, e[10] = _ - w * h
                    } else if ("XZY" === t.order) {
                        _ = o * s, x = o * c, b = a * s, w = a * c;
                        e[0] = s * l, e[4] = -h, e[8] = c * l, e[1] = _ * h + w, e[5] = o * l, e[9] = x * h - b, e[2] = b * h - x, e[6] = a * l, e[10] = w * h + _
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                },
                makeRotationFromQuaternion: function() {
                    var t = new je(0, 0, 0),
                        e = new je(1, 1, 1);
                    return function(i) {
                        return this.compose(t, i, e)
                    }
                }(),
                lookAt: function() {
                    var t = new je,
                        e = new je,
                        i = new je;
                    return function(n, r, o) {
                        var a = this.elements;
                        return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), t.crossVectors(o, i), 0 === t.lengthSq() && (1 === Math.abs(o.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(o, i)), t.normalize(), e.crossVectors(i, t), a[0] = t.x, a[4] = e.x, a[8] = i.x, a[1] = t.y, a[5] = e.y, a[9] = i.y, a[2] = t.z, a[6] = e.z, a[10] = i.z, this
                    }
                }(),
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        o = i[0],
                        a = i[4],
                        s = i[8],
                        c = i[12],
                        l = i[1],
                        h = i[5],
                        u = i[9],
                        d = i[13],
                        p = i[2],
                        f = i[6],
                        m = i[10],
                        g = i[14],
                        v = i[3],
                        y = i[7],
                        _ = i[11],
                        x = i[15],
                        b = n[0],
                        w = n[4],
                        M = n[8],
                        T = n[12],
                        E = n[1],
                        S = n[5],
                        A = n[9],
                        P = n[13],
                        L = n[2],
                        C = n[6],
                        R = n[10],
                        O = n[14],
                        I = n[3],
                        D = n[7],
                        k = n[11],
                        N = n[15];
                    return r[0] = o * b + a * E + s * L + c * I, r[4] = o * w + a * S + s * C + c * D, r[8] = o * M + a * A + s * R + c * k, r[12] = o * T + a * P + s * O + c * N, r[1] = l * b + h * E + u * L + d * I, r[5] = l * w + h * S + u * C + d * D, r[9] = l * M + h * A + u * R + d * k, r[13] = l * T + h * P + u * O + d * N, r[2] = p * b + f * E + m * L + g * I, r[6] = p * w + f * S + m * C + g * D, r[10] = p * M + f * A + m * R + g * k, r[14] = p * T + f * P + m * O + g * N, r[3] = v * b + y * E + _ * L + x * I, r[7] = v * w + y * S + _ * C + x * D, r[11] = v * M + y * A + _ * R + x * k, r[15] = v * T + y * P + _ * O + x * N, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                },
                applyToBufferAttribute: function() {
                    var t = new je;
                    return function(e) {
                        for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
                        return e
                    }
                }(),
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        i = t[4],
                        n = t[8],
                        r = t[12],
                        o = t[1],
                        a = t[5],
                        s = t[9],
                        c = t[13],
                        l = t[2],
                        h = t[6],
                        u = t[10],
                        d = t[14];
                    return t[3] * (+r * s * h - n * c * h - r * a * u + i * c * u + n * a * d - i * s * d) + t[7] * (+e * s * d - e * c * u + r * o * u - n * o * d + n * c * l - r * s * l) + t[11] * (+e * c * h - e * a * d - r * o * h + i * o * d + r * a * l - i * c * l) + t[15] * (-n * a * l - e * s * h + e * a * u + n * o * h - i * o * u + i * s * l)
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                },
                setPosition: function(t) {
                    var e = this.elements;
                    return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
                },
                getInverse: function(t, e) {
                    var i = this.elements,
                        n = t.elements,
                        r = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        c = n[4],
                        l = n[5],
                        h = n[6],
                        u = n[7],
                        d = n[8],
                        p = n[9],
                        f = n[10],
                        m = n[11],
                        g = n[12],
                        v = n[13],
                        y = n[14],
                        _ = n[15],
                        x = p * y * u - v * f * u + v * h * m - l * y * m - p * h * _ + l * f * _,
                        b = g * f * u - d * y * u - g * h * m + c * y * m + d * h * _ - c * f * _,
                        w = d * v * u - g * p * u + g * l * m - c * v * m - d * l * _ + c * p * _,
                        M = g * p * h - d * v * h - g * l * f + c * v * f + d * l * y - c * p * y,
                        T = r * x + o * b + a * w + s * M;
                    if (0 === T) {
                        var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(E);
                        return console.warn(E), this.identity()
                    }
                    var S = 1 / T;
                    return i[0] = x * S, i[1] = (v * f * s - p * y * s - v * a * m + o * y * m + p * a * _ - o * f * _) * S, i[2] = (l * y * s - v * h * s + v * a * u - o * y * u - l * a * _ + o * h * _) * S, i[3] = (p * h * s - l * f * s - p * a * u + o * f * u + l * a * m - o * h * m) * S, i[4] = b * S, i[5] = (d * y * s - g * f * s + g * a * m - r * y * m - d * a * _ + r * f * _) * S, i[6] = (g * h * s - c * y * s - g * a * u + r * y * u + c * a * _ - r * h * _) * S, i[7] = (c * f * s - d * h * s + d * a * u - r * f * u - c * a * m + r * h * m) * S, i[8] = w * S, i[9] = (g * p * s - d * v * s - g * o * m + r * v * m + d * o * _ - r * p * _) * S, i[10] = (c * v * s - g * l * s + g * o * u - r * v * u - c * o * _ + r * l * _) * S, i[11] = (d * l * s - c * p * s - d * o * u + r * p * u + c * o * m - r * l * m) * S, i[12] = M * S, i[13] = (d * v * a - g * p * a + g * o * f - r * v * f - d * o * y + r * p * y) * S, i[14] = (g * l * a - c * v * a - g * o * h + r * v * h + c * o * y - r * l * y) * S, i[15] = (c * p * a - d * l * a + d * o * h - r * p * h - c * o * f + r * l * f) * S, this
                },
                scale: function(t) {
                    var e = this.elements,
                        i = t.x,
                        n = t.y,
                        r = t.z;
                    return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
                },
                getMaxScaleOnAxis: function() {
                    var t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, i, n))
                },
                makeTranslation: function(t, e, i) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
                },
                makeRotationX: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(t, e) {
                    var i = Math.cos(e),
                        n = Math.sin(e),
                        r = 1 - i,
                        o = t.x,
                        a = t.y,
                        s = t.z,
                        c = r * o,
                        l = r * a;
                    return this.set(c * o + i, c * a - n * s, c * s + n * a, 0, c * a + n * s, l * a + i, l * s - n * o, 0, c * s - n * a, l * s + n * o, r * s * s + i, 0, 0, 0, 0, 1), this
                },
                makeScale: function(t, e, i) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                },
                makeShear: function(t, e, i) {
                    return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
                },
                compose: function(t, e, i) {
                    var n = this.elements,
                        r = e._x,
                        o = e._y,
                        a = e._z,
                        s = e._w,
                        c = r + r,
                        l = o + o,
                        h = a + a,
                        u = r * c,
                        d = r * l,
                        p = r * h,
                        f = o * l,
                        m = o * h,
                        g = a * h,
                        v = s * c,
                        y = s * l,
                        _ = s * h,
                        x = i.x,
                        b = i.y,
                        w = i.z;
                    return n[0] = (1 - (f + g)) * x, n[1] = (d + _) * x, n[2] = (p - y) * x, n[3] = 0, n[4] = (d - _) * b, n[5] = (1 - (u + g)) * b, n[6] = (m + v) * b, n[7] = 0, n[8] = (p + y) * w, n[9] = (m - v) * w, n[10] = (1 - (u + f)) * w, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
                },
                decompose: function() {
                    var t = new je,
                        e = new He;
                    return function(i, n, r) {
                        var o = this.elements,
                            a = t.set(o[0], o[1], o[2]).length(),
                            s = t.set(o[4], o[5], o[6]).length(),
                            c = t.set(o[8], o[9], o[10]).length();
                        this.determinant() < 0 && (a = -a), i.x = o[12], i.y = o[13], i.z = o[14], e.copy(this);
                        var l = 1 / a,
                            h = 1 / s,
                            u = 1 / c;
                        return e.elements[0] *= l, e.elements[1] *= l, e.elements[2] *= l, e.elements[4] *= h, e.elements[5] *= h, e.elements[6] *= h, e.elements[8] *= u, e.elements[9] *= u, e.elements[10] *= u, n.setFromRotationMatrix(e), r.x = a, r.y = s, r.z = c, this
                    }
                }(),
                makePerspective: function(t, e, i, n, r, o) {
                    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var a = this.elements,
                        s = 2 * r / (e - t),
                        c = 2 * r / (i - n),
                        l = (e + t) / (e - t),
                        h = (i + n) / (i - n),
                        u = -(o + r) / (o - r),
                        d = -2 * o * r / (o - r);
                    return a[0] = s, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makeOrthographic: function(t, e, i, n, r, o) {
                    var a = this.elements,
                        s = 1 / (e - t),
                        c = 1 / (i - n),
                        l = 1 / (o - r),
                        h = (e + t) * s,
                        u = (i + n) * c,
                        d = (o + r) * l;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                equals: function(t) {
                    for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
                }
            }), Object.assign(Ve, {
                slerp: function(t, e, i, n) {
                    return i.copy(t).slerp(e, n)
                },
                slerpFlat: function(t, e, i, n, r, o, a) {
                    var s = i[n + 0],
                        c = i[n + 1],
                        l = i[n + 2],
                        h = i[n + 3],
                        u = r[o + 0],
                        d = r[o + 1],
                        p = r[o + 2],
                        f = r[o + 3];
                    if (h !== f || s !== u || c !== d || l !== p) {
                        var m = 1 - a,
                            g = s * u + c * d + l * p + h * f,
                            v = g >= 0 ? 1 : -1,
                            y = 1 - g * g;
                        if (y > Number.EPSILON) {
                            var _ = Math.sqrt(y),
                                x = Math.atan2(_, g * v);
                            m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                        }
                        var b = a * v;
                        if (s = s * m + u * b, c = c * m + d * b, l = l * m + p * b, h = h * m + f * b, m === 1 - a) {
                            var w = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
                            s *= w, c *= w, l *= w, h *= w
                        }
                    }
                    t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h
                }
            }), Object.defineProperties(Ve.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(t) {
                        this._w = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(Ve.prototype, {
                isQuaternion: !0,
                set: function(t, e, i, n) {
                    return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
                },
                setFromEuler: function(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var i = t._x,
                        n = t._y,
                        r = t._z,
                        o = t.order,
                        a = Math.cos,
                        s = Math.sin,
                        c = a(i / 2),
                        l = a(n / 2),
                        h = a(r / 2),
                        u = s(i / 2),
                        d = s(n / 2),
                        p = s(r / 2);
                    return "XYZ" === o ? (this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p) : "YXZ" === o ? (this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p) : "ZXY" === o ? (this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p) : "ZYX" === o ? (this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p) : "YZX" === o ? (this._x = u * l * h + c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h - u * d * p) : "XZY" === o && (this._x = u * l * h - c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h + u * d * p), !1 !== e && this.onChangeCallback(), this
                },
                setFromAxisAngle: function(t, e) {
                    var i = e / 2,
                        n = Math.sin(i);
                    return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t) {
                    var e, i = t.elements,
                        n = i[0],
                        r = i[4],
                        o = i[8],
                        a = i[1],
                        s = i[5],
                        c = i[9],
                        l = i[2],
                        h = i[6],
                        u = i[10],
                        d = n + s + u;
                    return d > 0 ? (e = .5 / Math.sqrt(d + 1), this._w = .25 / e, this._x = (h - c) * e, this._y = (o - l) * e, this._z = (a - r) * e) : n > s && n > u ? (e = 2 * Math.sqrt(1 + n - s - u), this._w = (h - c) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (o + l) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - n - u), this._w = (o - l) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (c + h) / e) : (e = 2 * Math.sqrt(1 + u - n - s), this._w = (a - r) / e, this._x = (o + l) / e, this._y = (c + h) / e, this._z = .25 * e), this.onChangeCallback(), this
                },
                setFromUnitVectors: function() {
                    var t, e = new je;
                    return function(i, n) {
                        return void 0 === e && (e = new je), (t = i.dot(n) + 1) < 1e-6 ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, n), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
                    }
                }(),
                angleTo: function(t) {
                    return 2 * Math.acos(Math.abs(Ue.clamp(this.dot(t), -1, 1)))
                },
                rotateTowards: function(t, e) {
                    var i = this.angleTo(t);
                    if (0 === i) return this;
                    var n = Math.min(1, e / i);
                    return this.slerp(t, n), this
                },
                inverse: function() {
                    return this.conjugate()
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyQuaternions(t, this)
                },
                multiplyQuaternions: function(t, e) {
                    var i = t._x,
                        n = t._y,
                        r = t._z,
                        o = t._w,
                        a = e._x,
                        s = e._y,
                        c = e._z,
                        l = e._w;
                    return this._x = i * l + o * a + n * c - r * s, this._y = n * l + o * s + r * a - i * c, this._z = r * l + o * c + i * s - n * a, this._w = o * l - i * a - n * s - r * c, this.onChangeCallback(), this
                },
                slerp: function(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    var i = this._x,
                        n = this._y,
                        r = this._z,
                        o = this._w,
                        a = o * t._w + i * t._x + n * t._y + r * t._z;
                    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = i, this._y = n, this._z = r, this;
                    var s = 1 - a * a;
                    if (s <= Number.EPSILON) {
                        var c = 1 - e;
                        return this._w = c * o + e * this._w, this._x = c * i + e * this._x, this._y = c * n + e * this._y, this._z = c * r + e * this._z, this.normalize()
                    }
                    var l = Math.sqrt(s),
                        h = Math.atan2(l, a),
                        u = Math.sin((1 - e) * h) / l,
                        d = Math.sin(e * h) / l;
                    return this._w = o * u + this._w * d, this._x = i * u + this._x * d, this._y = n * u + this._y * d, this._z = r * u + this._z * d, this.onChangeCallback(), this
                },
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(je.prototype, {
                isVector3: !0,
                set: function(t, e, i) {
                    return this.x = t, this.y = e, this.z = i, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                },
                multiplyVectors: function(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                },
                applyEuler: function() {
                    var t = new Ve;
                    return function(e) {
                        return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
                    }
                }(),
                applyAxisAngle: function() {
                    var t = new Ve;
                    return function(e, i) {
                        return this.applyQuaternion(t.setFromAxisAngle(e, i))
                    }
                }(),
                applyMatrix3: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements,
                        o = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                    return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * o, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * o, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * o, this
                },
                applyQuaternion: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.x,
                        o = t.y,
                        a = t.z,
                        s = t.w,
                        c = s * e + o * n - a * i,
                        l = s * i + a * e - r * n,
                        h = s * n + r * i - o * e,
                        u = -r * e - o * i - a * n;
                    return this.x = c * s + u * -r + l * -a - h * -o, this.y = l * s + u * -o + h * -r - c * -a, this.z = h * s + u * -a + c * -o - l * -r, this
                },
                project: function(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                },
                unproject: function() {
                    var t = new He;
                    return function(e) {
                        return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(e.matrixWorld)
                    }
                }(),
                transformDirection: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                },
                clampScalar: function() {
                    var t = new je,
                        e = new je;
                    return function(i, n) {
                        return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                },
                lerpVectors: function(t, e, i) {
                    return this.subVectors(e, t).multiplyScalar(i).add(t)
                },
                cross: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                },
                crossVectors: function(t, e) {
                    var i = t.x,
                        n = t.y,
                        r = t.z,
                        o = e.x,
                        a = e.y,
                        s = e.z;
                    return this.x = n * s - r * a, this.y = r * o - i * s, this.z = i * a - n * o, this
                },
                projectOnVector: function(t) {
                    var e = t.dot(this) / t.lengthSq();
                    return this.copy(t).multiplyScalar(e)
                },
                projectOnPlane: function() {
                    var t = new je;
                    return function(e) {
                        return t.copy(this).projectOnVector(e), this.sub(t)
                    }
                }(),
                reflect: function() {
                    var t = new je;
                    return function(e) {
                        return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                    }
                }(),
                angleTo: function(t) {
                    var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                    return Math.acos(Ue.clamp(e, -1, 1))
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        i = this.y - t.y,
                        n = this.z - t.z;
                    return e * e + i * i + n * n
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                },
                setFromSpherical: function(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                },
                setFromSphericalCoords: function(t, e, i) {
                    var n = Math.sin(e) * t;
                    return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
                },
                setFromCylindrical: function(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                },
                setFromCylindricalCoords: function(t, e, i) {
                    return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
                },
                setFromMatrixPosition: function(t) {
                    var e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                },
                setFromMatrixScale: function(t) {
                    var e = this.setFromMatrixColumn(t, 0).length(),
                        i = this.setFromMatrixColumn(t, 1).length(),
                        n = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = i, this.z = n, this
                },
                setFromMatrixColumn: function(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                },
                fromBufferAttribute: function(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
            }), Object.assign(We.prototype, {
                isMatrix3: !0,
                set: function(t, e, i, n, r, o, a, s, c) {
                    var l = this.elements;
                    return l[0] = t, l[1] = n, l[2] = a, l[3] = e, l[4] = r, l[5] = s, l[6] = i, l[7] = o, l[8] = c, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
                },
                setFromMatrix4: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                },
                applyToBufferAttribute: function() {
                    var t = new je;
                    return function(e) {
                        for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
                        return e
                    }
                }(),
                multiply: function(t) {
                    return this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        o = i[0],
                        a = i[3],
                        s = i[6],
                        c = i[1],
                        l = i[4],
                        h = i[7],
                        u = i[2],
                        d = i[5],
                        p = i[8],
                        f = n[0],
                        m = n[3],
                        g = n[6],
                        v = n[1],
                        y = n[4],
                        _ = n[7],
                        x = n[2],
                        b = n[5],
                        w = n[8];
                    return r[0] = o * f + a * v + s * x, r[3] = o * m + a * y + s * b, r[6] = o * g + a * _ + s * w, r[1] = c * f + l * v + h * x, r[4] = c * m + l * y + h * b, r[7] = c * g + l * _ + h * w, r[2] = u * f + d * v + p * x, r[5] = u * m + d * y + p * b, r[8] = u * g + d * _ + p * w, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                },
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        o = t[4],
                        a = t[5],
                        s = t[6],
                        c = t[7],
                        l = t[8];
                    return e * o * l - e * a * c - i * r * l + i * a * s + n * r * c - n * o * s
                },
                getInverse: function(t, e) {
                    t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var i = t.elements,
                        n = this.elements,
                        r = i[0],
                        o = i[1],
                        a = i[2],
                        s = i[3],
                        c = i[4],
                        l = i[5],
                        h = i[6],
                        u = i[7],
                        d = i[8],
                        p = d * c - l * u,
                        f = l * h - d * s,
                        m = u * s - c * h,
                        g = r * p + o * f + a * m;
                    if (0 === g) {
                        var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(v);
                        return console.warn(v), this.identity()
                    }
                    var y = 1 / g;
                    return n[0] = p * y, n[1] = (a * u - d * o) * y, n[2] = (l * o - a * c) * y, n[3] = f * y, n[4] = (d * r - a * h) * y, n[5] = (a * s - l * r) * y, n[6] = m * y, n[7] = (o * h - u * r) * y, n[8] = (c * r - o * s) * y, this
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                },
                getNormalMatrix: function(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                },
                transposeIntoArray: function(t) {
                    var e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                },
                setUvTransform: function(t, e, i, n, r, o, a) {
                    var s = Math.cos(r),
                        c = Math.sin(r);
                    this.set(i * s, i * c, -i * (s * o + c * a) + o + t, -n * c, n * s, -n * (-c * o + s * a) + a + e, 0, 0, 1)
                },
                scale: function(t, e) {
                    var i = this.elements;
                    return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t),
                        n = this.elements,
                        r = n[0],
                        o = n[3],
                        a = n[6],
                        s = n[1],
                        c = n[4],
                        l = n[7];
                    return n[0] = e * r + i * s, n[3] = e * o + i * c, n[6] = e * a + i * l, n[1] = -i * r + e * s, n[4] = -i * o + e * c, n[7] = -i * a + e * l, this
                },
                translate: function(t, e) {
                    var i = this.elements;
                    return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
                },
                equals: function(t) {
                    for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
                }
            });
            var Xe = {
                    getDataURL: function(t) {
                        var e;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === r && (r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), r.width = t.width, r.height = t.height;
                            var i = r.getContext("2d");
                            t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = r
                        }
                        return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }
                },
                qe = 0;

            function Ye(t, e, i, n, r, o, a, s, c, l) {
                Object.defineProperty(this, "id", {
                    value: qe++
                }), this.uuid = Ue.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Ye.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Ye.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : yt, this.wrapT = void 0 !== n ? n : yt, this.magFilter = void 0 !== r ? r : Mt, this.minFilter = void 0 !== o ? o : Et, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : Ut, this.type = void 0 !== s ? s : St, this.offset = new Ge(0, 0), this.repeat = new Ge(1, 1), this.center = new Ge(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new We, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : Pe, this.version = 0, this.onUpdate = null
            }

            function Ze(t, e, i, n) {
                this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
            }

            function Je(t, e, i) {
                this.width = t, this.height = e, this.scissor = new Ze(0, 0, t, e), this.scissorTest = !1, this.viewport = new Ze(0, 0, t, e), i = i || {}, this.texture = new Ye(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Mt, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
            }

            function Ke(t, e, i) {
                Je.call(this, t, e, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
            }

            function Qe(t, e, i, n, r, o, a, s, c, l, h, u) {
                Ye.call(this, null, o, a, s, c, l, n, r, h, u), this.image = {
                    data: t,
                    width: e,
                    height: i
                }, this.magFilter = void 0 !== c ? c : xt, this.minFilter = void 0 !== l ? l : xt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }

            function $e(t, e) {
                this.min = void 0 !== t ? t : new je(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new je(-1 / 0, -1 / 0, -1 / 0)
            }

            function ti(t, e) {
                this.center = void 0 !== t ? t : new je, this.radius = void 0 !== e ? e : 0
            }

            function ei(t, e) {
                this.normal = void 0 !== t ? t : new je(1, 0, 0), this.constant = void 0 !== e ? e : 0
            }

            function ii(t, e, i, n, r, o) {
                this.planes = [void 0 !== t ? t : new ei, void 0 !== e ? e : new ei, void 0 !== i ? i : new ei, void 0 !== n ? n : new ei, void 0 !== r ? r : new ei, void 0 !== o ? o : new ei]
            }
            Ye.DEFAULT_IMAGE = void 0, Ye.DEFAULT_MAPPING = lt, Ye.prototype = Object.assign(Object.create(n.prototype), {
                constructor: Ye,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    var i = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY
                    };
                    if (void 0 !== this.image) {
                        var n = this.image;
                        if (void 0 === n.uuid && (n.uuid = Ue.generateUUID()), !e && void 0 === t.images[n.uuid]) {
                            var r;
                            if (Array.isArray(n)) {
                                r = [];
                                for (var o = 0, a = n.length; o < a; o++) r.push(Xe.getDataURL(n[o]))
                            } else r = Xe.getDataURL(n);
                            t.images[n.uuid] = {
                                uuid: n.uuid,
                                url: r
                            }
                        }
                        i.image = n.uuid
                    }
                    return e || (t.textures[this.uuid] = i), i
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (this.mapping !== lt) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case vt:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case yt:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case _t:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case vt:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case yt:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case _t:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
            }), Object.defineProperty(Ye.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Ze.prototype, {
                isVector4: !0,
                set: function(t, e, i, n) {
                    return this.x = t, this.y = e, this.z = i, this.w = n, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setW: function(t) {
                    return this.w = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = this.w,
                        o = t.elements;
                    return this.x = o[0] * e + o[4] * i + o[8] * n + o[12] * r, this.y = o[1] * e + o[5] * i + o[9] * n + o[13] * r, this.z = o[2] * e + o[6] * i + o[10] * n + o[14] * r, this.w = o[3] * e + o[7] * i + o[11] * n + o[15] * r, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                setAxisAngleFromQuaternion: function(t) {
                    this.w = 2 * Math.acos(t.w);
                    var e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                },
                setAxisAngleFromRotationMatrix: function(t) {
                    var e, i, n, r, o = t.elements,
                        a = o[0],
                        s = o[4],
                        c = o[8],
                        l = o[1],
                        h = o[5],
                        u = o[9],
                        d = o[2],
                        p = o[6],
                        f = o[10];
                    if (Math.abs(s - l) < .01 && Math.abs(c - d) < .01 && Math.abs(u - p) < .01) {
                        if (Math.abs(s + l) < .1 && Math.abs(c + d) < .1 && Math.abs(u + p) < .1 && Math.abs(a + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        var m = (a + 1) / 2,
                            g = (h + 1) / 2,
                            v = (f + 1) / 2,
                            y = (s + l) / 4,
                            _ = (c + d) / 4,
                            x = (u + p) / 4;
                        return m > g && m > v ? m < .01 ? (i = 0, n = .707106781, r = .707106781) : (n = y / (i = Math.sqrt(m)), r = _ / i) : g > v ? g < .01 ? (i = .707106781, n = 0, r = .707106781) : (i = y / (n = Math.sqrt(g)), r = x / n) : v < .01 ? (i = .707106781, n = .707106781, r = 0) : (i = _ / (r = Math.sqrt(v)), n = x / r), this.set(i, n, r, e), this
                    }
                    var b = Math.sqrt((p - u) * (p - u) + (c - d) * (c - d) + (l - s) * (l - s));
                    return Math.abs(b) < .001 && (b = 1), this.x = (p - u) / b, this.y = (c - d) / b, this.z = (l - s) / b, this.w = Math.acos((a + h + f - 1) / 2), this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                },
                clampScalar: function() {
                    var t, e;
                    return function(i, n) {
                        return void 0 === t && (t = new Ze, e = new Ze), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                },
                lerpVectors: function(t, e, i) {
                    return this.subVectors(e, t).multiplyScalar(i).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                },
                fromBufferAttribute: function(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
            }), Je.prototype = Object.assign(Object.create(n.prototype), {
                constructor: Je,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Ke.prototype = Object.create(Je.prototype), Ke.prototype.constructor = Ke, Ke.prototype.isWebGLRenderTargetCube = !0, Qe.prototype = Object.create(Ye.prototype), Qe.prototype.constructor = Qe, Qe.prototype.isDataTexture = !0, Object.assign($e.prototype, {
                isBox3: !0,
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromArray: function(t) {
                    for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                        var l = t[s],
                            h = t[s + 1],
                            u = t[s + 2];
                        l < e && (e = l), h < i && (i = h), u < n && (n = u), l > r && (r = l), h > o && (o = h), u > a && (a = u)
                    }
                    return this.min.set(e, i, n), this.max.set(r, o, a), this
                },
                setFromBufferAttribute: function(t) {
                    for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) {
                        var l = t.getX(s),
                            h = t.getY(s),
                            u = t.getZ(s);
                        l < e && (e = l), h < i && (i = h), u < n && (n = u), l > r && (r = l), h > o && (o = h), u > a && (a = u)
                    }
                    return this.min.set(e, i, n), this.max.set(r, o, a), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var t = new je;
                    return function(e, i) {
                        var n = t.copy(i).multiplyScalar(.5);
                        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                    }
                }(),
                setFromObject: function(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new je), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new je), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                expandByObject: function() {
                    var t, e, i, n = new je;

                    function r(r) {
                        var o = r.geometry;
                        if (void 0 !== o)
                            if (o.isGeometry) {
                                var a = o.vertices;
                                for (e = 0, i = a.length; e < i; e++) n.copy(a[e]), n.applyMatrix4(r.matrixWorld), t.expandByPoint(n)
                            } else if (o.isBufferGeometry) {
                            var s = o.attributes.position;
                            if (void 0 !== s)
                                for (e = 0, i = s.count; e < i; e++) n.fromBufferAttribute(s, e).applyMatrix4(r.matrixWorld), t.expandByPoint(n)
                        }
                    }
                    return function(e) {
                        return t = this, e.updateMatrixWorld(!0), e.traverse(r), this
                    }
                }(),
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                },
                getParameter: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new je), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                },
                intersectsSphere: function() {
                    var t = new je;
                    return function(e) {
                        return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
                    }
                }(),
                intersectsPlane: function(t) {
                    var e, i;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
                },
                intersectsTriangle: function() {
                    var t = new je,
                        e = new je,
                        i = new je,
                        n = new je,
                        r = new je,
                        o = new je,
                        a = new je,
                        s = new je,
                        c = new je,
                        l = new je;

                    function h(n) {
                        var r, o;
                        for (r = 0, o = n.length - 3; r <= o; r += 3) {
                            a.fromArray(n, r);
                            var s = c.x * Math.abs(a.x) + c.y * Math.abs(a.y) + c.z * Math.abs(a.z),
                                l = t.dot(a),
                                h = e.dot(a),
                                u = i.dot(a);
                            if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > s) return !1
                        }
                        return !0
                    }
                    return function(a) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(s), c.subVectors(this.max, s), t.subVectors(a.a, s), e.subVectors(a.b, s), i.subVectors(a.c, s), n.subVectors(e, t), r.subVectors(i, e), o.subVectors(t, i);
                        var u = [0, -n.z, n.y, 0, -r.z, r.y, 0, -o.z, o.y, n.z, 0, -n.x, r.z, 0, -r.x, o.z, 0, -o.x, -n.y, n.x, 0, -r.y, r.x, 0, -o.y, o.x, 0];
                        return !!h(u) && (!!h(u = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (l.crossVectors(n, r), h(u = [l.x, l.y, l.z])))
                    }
                }(),
                clampPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new je), e.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var t = new je;
                    return function(e) {
                        return t.copy(e).clamp(this.min, this.max).sub(e).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var t = new je;
                    return function(e) {
                        return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new ti), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
                    }
                }(),
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                applyMatrix4: function() {
                    var t = [new je, new je, new je, new je, new je, new je, new je, new je];
                    return function(e) {
                        return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
                    }
                }(),
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }), Object.assign(ti.prototype, {
                set: function(t, e) {
                    return this.center.copy(t), this.radius = e, this
                },
                setFromPoints: function() {
                    var t = new $e;
                    return function(e, i) {
                        var n = this.center;
                        void 0 !== i ? n.copy(i) : t.setFromPoints(e).getCenter(n);
                        for (var r = 0, o = 0, a = e.length; o < a; o++) r = Math.max(r, n.distanceToSquared(e[o]));
                        return this.radius = Math.sqrt(r), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(t) {
                    return t.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(t) {
                    var e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                },
                intersectsBox: function(t) {
                    return t.intersectsSphere(this)
                },
                intersectsPlane: function(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function(t, e) {
                    var i = this.center.distanceToSquared(t);
                    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new je), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                },
                getBoundingBox: function(t) {
                    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new $e), t.set(this.center, this.center), t.expandByScalar(this.radius), t
                },
                applyMatrix4: function(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                },
                translate: function(t) {
                    return this.center.add(t), this
                },
                equals: function(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            }), Object.assign(ei.prototype, {
                set: function(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                },
                setComponents: function(t, e, i, n) {
                    return this.normal.set(t, e, i), this.constant = n, this
                },
                setFromNormalAndCoplanarPoint: function(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                },
                setFromCoplanarPoints: function() {
                    var t = new je,
                        e = new je;
                    return function(i, n, r) {
                        var o = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize();
                        return this.setFromNormalAndCoplanarPoint(o, i), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                },
                normalize: function() {
                    var t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(t) {
                    return this.normal.dot(t) + this.constant
                },
                distanceToSphere: function(t) {
                    return this.distanceToPoint(t.center) - t.radius
                },
                projectPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new je), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                },
                intersectLine: function() {
                    var t = new je;
                    return function(e, i) {
                        void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new je);
                        var n = e.delta(t),
                            r = this.normal.dot(n);
                        if (0 === r) return 0 === this.distanceToPoint(e.start) ? i.copy(e.start) : void 0;
                        var o = -(e.start.dot(this.normal) + this.constant) / r;
                        return o < 0 || o > 1 ? void 0 : i.copy(n).multiplyScalar(o).add(e.start)
                    }
                }(),
                intersectsLine: function(t) {
                    var e = this.distanceToPoint(t.start),
                        i = this.distanceToPoint(t.end);
                    return e < 0 && i > 0 || i < 0 && e > 0
                },
                intersectsBox: function(t) {
                    return t.intersectsPlane(this)
                },
                intersectsSphere: function(t) {
                    return t.intersectsPlane(this)
                },
                coplanarPoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new je), t.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var t = new je,
                        e = new We;
                    return function(i, n) {
                        var r = n || e.getNormalMatrix(i),
                            o = this.coplanarPoint(t).applyMatrix4(i),
                            a = this.normal.applyMatrix3(r).normalize();
                        return this.constant = -o.dot(a), this
                    }
                }(),
                translate: function(t) {
                    return this.constant -= t.dot(this.normal), this
                },
                equals: function(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            }), Object.assign(ii.prototype, {
                set: function(t, e, i, n, r, o) {
                    var a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                    return this
                },
                setFromMatrix: function(t) {
                    var e = this.planes,
                        i = t.elements,
                        n = i[0],
                        r = i[1],
                        o = i[2],
                        a = i[3],
                        s = i[4],
                        c = i[5],
                        l = i[6],
                        h = i[7],
                        u = i[8],
                        d = i[9],
                        p = i[10],
                        f = i[11],
                        m = i[12],
                        g = i[13],
                        v = i[14],
                        y = i[15];
                    return e[0].setComponents(a - n, h - s, f - u, y - m).normalize(), e[1].setComponents(a + n, h + s, f + u, y + m).normalize(), e[2].setComponents(a + r, h + c, f + d, y + g).normalize(), e[3].setComponents(a - r, h - c, f - d, y - g).normalize(), e[4].setComponents(a - o, h - l, f - p, y - v).normalize(), e[5].setComponents(a + o, h + l, f + p, y + v).normalize(), this
                },
                intersectsObject: function() {
                    var t = new ti;
                    return function(e) {
                        var i = e.geometry;
                        return null === i.boundingSphere && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                    }
                }(),
                intersectsSprite: function() {
                    var t = new ti;
                    return function(e) {
                        return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                    }
                }(),
                intersectsSphere: function(t) {
                    for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
                        if (e[r].distanceToPoint(i) < n) return !1
                    }
                    return !0
                },
                intersectsBox: function() {
                    var t = new je;
                    return function(e) {
                        for (var i = this.planes, n = 0; n < 6; n++) {
                            var r = i[n];
                            if (t.x = r.normal.x > 0 ? e.max.x : e.min.x, t.y = r.normal.y > 0 ? e.max.y : e.min.y, t.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(t) < 0) return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function(t) {
                    for (var e = this.planes, i = 0; i < 6; i++)
                        if (e[i].distanceToPoint(t) < 0) return !1;
                    return !0
                }
            });
            var ni = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );",
                bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
                map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif",
                normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
                uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
                background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
            };

            function ri(t) {
                var e = {};
                for (var i in t)
                    for (var n in e[i] = {}, t[i]) {
                        var r = t[i][n];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                    }
                return e
            }

            function oi(t) {
                for (var e = {}, i = 0; i < t.length; i++) {
                    var n = ri(t[i]);
                    for (var r in n) e[r] = n[r]
                }
                return e
            }
            var ai = {
                    clone: ri,
                    merge: oi
                },
                si = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                };

            function ci(t, e, i) {
                return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
            }
            Object.assign(ci.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                },
                setScalar: function(t) {
                    return this.r = t, this.g = t, this.b = t, this
                },
                setHex: function(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                },
                setRGB: function(t, e, i) {
                    return this.r = t, this.g = e, this.b = i, this
                },
                setHSL: function() {
                    function t(t, e, i) {
                        return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
                    }
                    return function(e, i, n) {
                        if (e = Ue.euclideanModulo(e, 1), i = Ue.clamp(i, 0, 1), n = Ue.clamp(n, 0, 1), 0 === i) this.r = this.g = this.b = n;
                        else {
                            var r = n <= .5 ? n * (1 + i) : n + i - n * i,
                                o = 2 * n - r;
                            this.r = t(o, r, e + 1 / 3), this.g = t(o, r, e), this.b = t(o, r, e - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    var i;
                    if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var n, r = i[1],
                            o = i[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                                if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                    var a = parseFloat(n[1]) / 360,
                                        s = parseInt(n[2], 10) / 100,
                                        c = parseInt(n[3], 10) / 100;
                                    return e(n[5]), this.setHSL(a, s, c)
                                }
                        }
                    } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var l, h = (l = i[1]).length;
                        if (3 === h) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                        if (6 === h) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
                    }
                    t && t.length > 0 && (void 0 !== (l = si[t]) ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t));
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                },
                copyGammaToLinear: function(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                },
                copyLinearToGamma: function(t, e) {
                    void 0 === e && (e = 2);
                    var i = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
                },
                convertGammaToLinear: function(t) {
                    return this.copyGammaToLinear(this, t), this
                },
                convertLinearToGamma: function(t) {
                    return this.copyLinearToGamma(this, t), this
                },
                copySRGBToLinear: function() {
                    function t(t) {
                        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                    }
                    return function(e) {
                        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                    }
                }(),
                copyLinearToSRGB: function() {
                    function t(t) {
                        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                    }
                    return function(e) {
                        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                    }
                }(),
                convertSRGBToLinear: function() {
                    return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function() {
                    return this.copyLinearToSRGB(this), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(t) {
                    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var e, i, n = this.r,
                        r = this.g,
                        o = this.b,
                        a = Math.max(n, r, o),
                        s = Math.min(n, r, o),
                        c = (s + a) / 2;
                    if (s === a) e = 0, i = 0;
                    else {
                        var l = a - s;
                        switch (i = c <= .5 ? l / (a + s) : l / (2 - a - s), a) {
                            case n:
                                e = (r - o) / l + (r < o ? 6 : 0);
                                break;
                            case r:
                                e = (o - n) / l + 2;
                                break;
                            case o:
                                e = (n - r) / l + 4
                        }
                        e /= 6
                    }
                    return t.h = e, t.s = i, t.l = c, t
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function() {
                    var t = {};
                    return function(e, i, n) {
                        return this.getHSL(t), t.h += e, t.s += i, t.l += n, this.setHSL(t.h, t.s, t.l), this
                    }
                }(),
                add: function(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                },
                addColors: function(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                },
                addScalar: function(t) {
                    return this.r += t, this.g += t, this.b += t, this
                },
                sub: function(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                },
                multiply: function(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                },
                multiplyScalar: function(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                },
                lerp: function(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                },
                lerpHSL: function() {
                    var t = {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        e = {
                            h: 0,
                            s: 0,
                            l: 0
                        };
                    return function(i, n) {
                        this.getHSL(t), i.getHSL(e);
                        var r = Ue.lerp(t.h, e.h, n),
                            o = Ue.lerp(t.s, e.s, n),
                            a = Ue.lerp(t.l, e.l, n);
                        return this.setHSL(r, o, a), this
                    }
                }(),
                equals: function(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                },
                toJSON: function() {
                    return this.getHex()
                }
            });
            var li = {
                    common: {
                        diffuse: {
                            value: new ci(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new We
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Ge(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new ci(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new ci(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new We
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new ci(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Ge(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new We
                        }
                    }
                },
                hi = {
                    basic: {
                        uniforms: oi([li.common, li.specularmap, li.envmap, li.aomap, li.lightmap, li.fog]),
                        vertexShader: ni.meshbasic_vert,
                        fragmentShader: ni.meshbasic_frag
                    },
                    lambert: {
                        uniforms: oi([li.common, li.specularmap, li.envmap, li.aomap, li.lightmap, li.emissivemap, li.fog, li.lights, {
                            emissive: {
                                value: new ci(0)
                            }
                        }]),
                        vertexShader: ni.meshlambert_vert,
                        fragmentShader: ni.meshlambert_frag
                    },
                    phong: {
                        uniforms: oi([li.common, li.specularmap, li.envmap, li.aomap, li.lightmap, li.emissivemap, li.bumpmap, li.normalmap, li.displacementmap, li.gradientmap, li.fog, li.lights, {
                            emissive: {
                                value: new ci(0)
                            },
                            specular: {
                                value: new ci(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: ni.meshphong_vert,
                        fragmentShader: ni.meshphong_frag
                    },
                    standard: {
                        uniforms: oi([li.common, li.envmap, li.aomap, li.lightmap, li.emissivemap, li.bumpmap, li.normalmap, li.displacementmap, li.roughnessmap, li.metalnessmap, li.fog, li.lights, {
                            emissive: {
                                value: new ci(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ni.meshphysical_vert,
                        fragmentShader: ni.meshphysical_frag
                    },
                    matcap: {
                        uniforms: oi([li.common, li.bumpmap, li.normalmap, li.displacementmap, li.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: ni.meshmatcap_vert,
                        fragmentShader: ni.meshmatcap_frag
                    },
                    points: {
                        uniforms: oi([li.points, li.fog]),
                        vertexShader: ni.points_vert,
                        fragmentShader: ni.points_frag
                    },
                    dashed: {
                        uniforms: oi([li.common, li.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: ni.linedashed_vert,
                        fragmentShader: ni.linedashed_frag
                    },
                    depth: {
                        uniforms: oi([li.common, li.displacementmap]),
                        vertexShader: ni.depth_vert,
                        fragmentShader: ni.depth_frag
                    },
                    normal: {
                        uniforms: oi([li.common, li.bumpmap, li.normalmap, li.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ni.normal_vert,
                        fragmentShader: ni.normal_frag
                    },
                    sprite: {
                        uniforms: oi([li.sprite, li.fog]),
                        vertexShader: ni.sprite_vert,
                        fragmentShader: ni.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new We
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: ni.background_vert,
                        fragmentShader: ni.background_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: ni.cube_vert,
                        fragmentShader: ni.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: ni.equirect_vert,
                        fragmentShader: ni.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: oi([li.common, li.displacementmap, {
                            referencePosition: {
                                value: new je
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: ni.distanceRGBA_vert,
                        fragmentShader: ni.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: oi([li.lights, li.fog, {
                            color: {
                                value: new ci(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ni.shadow_vert,
                        fragmentShader: ni.shadow_frag
                    }
                };

            function ui() {
                var t = null,
                    e = !1,
                    i = null;

                function n(r, o) {
                    !1 !== e && (i(r, o), t.requestAnimationFrame(n))
                }
                return {
                    start: function() {
                        !0 !== e && null !== i && (t.requestAnimationFrame(n), e = !0)
                    },
                    stop: function() {
                        e = !1
                    },
                    setAnimationLoop: function(t) {
                        i = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function di(t) {
                var e = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                    },
                    remove: function(i) {
                        i.isInterleavedBufferAttribute && (i = i.data);
                        var n = e.get(i);
                        n && (t.deleteBuffer(n.buffer), e.delete(i))
                    },
                    update: function(i, n) {
                        i.isInterleavedBufferAttribute && (i = i.data);
                        var r = e.get(i);
                        void 0 === r ? e.set(i, function(e, i) {
                            var n = e.array,
                                r = e.dynamic ? 35048 : 35044,
                                o = t.createBuffer();
                            t.bindBuffer(i, o), t.bufferData(i, n, r), e.onUploadCallback();
                            var a = 5126;
                            return n instanceof Float32Array ? a = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = 5123 : n instanceof Int16Array ? a = 5122 : n instanceof Uint32Array ? a = 5125 : n instanceof Int32Array ? a = 5124 : n instanceof Int8Array ? a = 5120 : n instanceof Uint8Array && (a = 5121), {
                                buffer: o,
                                type: a,
                                bytesPerElement: n.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(i, n)) : r.version < i.version && (function(e, i, n) {
                            var r = i.array,
                                o = i.updateRange;
                            t.bindBuffer(n, e), !1 === i.dynamic ? t.bufferData(n, r, 35044) : -1 === o.count ? t.bufferSubData(n, 0, r) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(r.buffer, i, n), r.version = i.version)
                    }
                }
            }

            function pi(t, e, i, n, r, o) {
                this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new je, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new ci, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
            }

            function fi(t, e, i, n) {
                this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || fi.DefaultOrder
            }

            function mi() {
                this.mask = 1
            }
            hi.physical = {
                uniforms: oi([hi.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: ni.meshphysical_vert,
                fragmentShader: ni.meshphysical_frag
            }, Object.assign(pi.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            }), fi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], fi.DefaultOrder = "XYZ", Object.defineProperties(fi.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(t) {
                        this._order = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(fi.prototype, {
                isEuler: !0,
                set: function(t, e, i, n) {
                    return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t, e, i) {
                    var n = Ue.clamp,
                        r = t.elements,
                        o = r[0],
                        a = r[4],
                        s = r[8],
                        c = r[1],
                        l = r[5],
                        h = r[9],
                        u = r[2],
                        d = r[6],
                        p = r[10];
                    return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(h, -1, 1)), Math.abs(h) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === e ? (this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === e ? (this._z = Math.asin(n(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === e ? (this._z = Math.asin(-n(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-h, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
                },
                setFromQuaternion: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n)
                    }
                }(),
                setFromVector3: function(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                },
                reorder: function() {
                    var t = new Ve;
                    return function(e) {
                        return t.setFromEuler(this), this.setFromQuaternion(t, e)
                    }
                }(),
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                },
                fromArray: function(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                },
                toVector3: function(t) {
                    return t ? t.set(this._x, this._y, this._z) : new je(this._x, this._y, this._z)
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(mi.prototype, {
                set: function(t) {
                    this.mask = 1 << t | 0
                },
                enable: function(t) {
                    this.mask |= 1 << t | 0
                },
                toggle: function(t) {
                    this.mask ^= 1 << t | 0
                },
                disable: function(t) {
                    this.mask &= ~(1 << t | 0)
                },
                test: function(t) {
                    return 0 != (this.mask & t.mask)
                }
            });
            var gi = 0;

            function vi() {
                Object.defineProperty(this, "id", {
                    value: gi++
                }), this.uuid = Ue.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = vi.DefaultUp.clone();
                var t = new je,
                    e = new fi,
                    i = new Ve,
                    n = new je(1, 1, 1);
                e.onChange(function() {
                    i.setFromEuler(e, !1)
                }), i.onChange(function() {
                    e.setFromQuaternion(i, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    modelViewMatrix: {
                        value: new He
                    },
                    normalMatrix: {
                        value: new We
                    }
                }), this.matrix = new He, this.matrixWorld = new He, this.matrixAutoUpdate = vi.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new mi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }
            vi.DefaultUp = new je(0, 1, 0), vi.DefaultMatrixAutoUpdate = !0, vi.prototype = Object.assign(Object.create(n.prototype), {
                constructor: vi,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(t) {
                    this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function() {
                    var t = new Ve;
                    return function(e, i) {
                        return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this
                    }
                }(),
                rotateOnWorldAxis: function() {
                    var t = new Ve;
                    return function(e, i) {
                        return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this
                    }
                }(),
                rotateX: function() {
                    var t = new je(1, 0, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateY: function() {
                    var t = new je(0, 1, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateZ: function() {
                    var t = new je(0, 0, 1);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                translateOnAxis: function() {
                    var t = new je;
                    return function(e, i) {
                        return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this
                    }
                }(),
                translateX: function() {
                    var t = new je(1, 0, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateY: function() {
                    var t = new je(0, 1, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateZ: function() {
                    var t = new je(0, 0, 1);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var t = new He;
                    return function(e) {
                        return e.applyMatrix4(t.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var t = new Ve,
                        e = new He,
                        i = new je,
                        n = new je;
                    return function(r, o, a) {
                        r.isVector3 ? i.copy(r) : i.set(r, o, a);
                        var s = this.parent;
                        this.updateWorldMatrix(!0, !1), n.setFromMatrixPosition(this.matrixWorld), this.isCamera ? e.lookAt(n, i, this.up) : e.lookAt(i, n, this.up), this.quaternion.setFromRotationMatrix(e), s && (e.extractRotation(s.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()))
                    }
                }(),
                add: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                        type: "added"
                    }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    var i = this.children.indexOf(t);
                    return -1 !== i && (t.parent = null, t.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(i, 1)), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (var i = 0, n = this.children.length; i < n; i++) {
                        var r = this.children[i].getObjectByProperty(t, e);
                        if (void 0 !== r) return r
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new je), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var t = new je,
                        e = new je;
                    return function(i) {
                        return void 0 === i && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), i = new Ve), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i
                    }
                }(),
                getWorldScale: function() {
                    var t = new je,
                        e = new Ve;
                    return function(i) {
                        return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new je), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i
                    }
                }(),
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new je), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 !== this.visible) {
                        t(this);
                        for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                    }
                },
                traverseAncestors: function(t) {
                    var e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    var i = this.parent;
                    if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                        for (var n = this.children, r = 0, o = n.length; r < o; r++) n[r].updateWorldMatrix(!1, !0)
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t,
                        i = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, i.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var n = {};

                    function r(e, i) {
                        return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
                        n.geometry = r(t.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var a = o.shapes;
                            if (Array.isArray(a))
                                for (var s = 0, c = a.length; s < c; s++) {
                                    var l = a[s];
                                    r(t.shapes, l)
                                } else r(t.shapes, a)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            var h = [];
                            for (s = 0, c = this.material.length; s < c; s++) h.push(r(t.materials, this.material[s]));
                            n.material = h
                        } else n.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        n.children = [];
                        for (s = 0; s < this.children.length; s++) n.children.push(this.children[s].toJSON(t).object)
                    }
                    if (e) {
                        var u = m(t.geometries),
                            d = m(t.materials),
                            p = m(t.textures),
                            f = m(t.images);
                        a = m(t.shapes);
                        u.length > 0 && (i.geometries = u), d.length > 0 && (i.materials = d), p.length > 0 && (i.textures = p), f.length > 0 && (i.images = f), a.length > 0 && (i.shapes = a)
                    }
                    return i.object = n, i;

                    function m(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (var i = 0; i < t.children.length; i++) {
                            var n = t.children[i];
                            this.add(n.clone())
                        }
                    return this
                }
            });
            var yi = 0;

            function _i() {
                Object.defineProperty(this, "id", {
                    value: yi += 2
                }), this.uuid = Ue.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function xi(t, e, i) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function bi(t, e, i) {
                xi.call(this, new Int8Array(t), e, i)
            }

            function wi(t, e, i) {
                xi.call(this, new Uint8Array(t), e, i)
            }

            function Mi(t, e, i) {
                xi.call(this, new Uint8ClampedArray(t), e, i)
            }

            function Ti(t, e, i) {
                xi.call(this, new Int16Array(t), e, i)
            }

            function Ei(t, e, i) {
                xi.call(this, new Uint16Array(t), e, i)
            }

            function Si(t, e, i) {
                xi.call(this, new Int32Array(t), e, i)
            }

            function Ai(t, e, i) {
                xi.call(this, new Uint32Array(t), e, i)
            }

            function Pi(t, e, i) {
                xi.call(this, new Float32Array(t), e, i)
            }

            function Li(t, e, i) {
                xi.call(this, new Float64Array(t), e, i)
            }

            function Ci() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Ri(t) {
                if (0 === t.length) return -1 / 0;
                for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
                return e
            }
            _i.prototype = Object.assign(Object.create(n.prototype), {
                constructor: _i,
                isGeometry: !0,
                applyMatrix: function(t) {
                    for (var e = (new We).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) {
                        this.vertices[i].applyMatrix4(t)
                    }
                    for (i = 0, n = this.faces.length; i < n; i++) {
                        var r = this.faces[i];
                        r.normal.applyMatrix3(e).normalize();
                        for (var o = 0, a = r.vertexNormals.length; o < a; o++) r.vertexNormals[o].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeScale(e, i, n), this.applyMatrix(t), this
                    }
                }(),
                lookAt: function() {
                    var t = new vi;
                    return function(e) {
                        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                    }
                }(),
                fromBufferGeometry: function(t) {
                    var e = this,
                        i = null !== t.index ? t.index.array : void 0,
                        n = t.attributes,
                        r = n.position.array,
                        o = void 0 !== n.normal ? n.normal.array : void 0,
                        a = void 0 !== n.color ? n.color.array : void 0,
                        s = void 0 !== n.uv ? n.uv.array : void 0,
                        c = void 0 !== n.uv2 ? n.uv2.array : void 0;
                    void 0 !== c && (this.faceVertexUvs[1] = []);
                    for (var l = 0, h = 0; l < r.length; l += 3, h += 2) e.vertices.push((new je).fromArray(r, l)), void 0 !== a && e.colors.push((new ci).fromArray(a, l));

                    function u(t, i, n, r) {
                        var l = void 0 === a ? [] : [e.colors[t].clone(), e.colors[i].clone(), e.colors[n].clone()],
                            h = new pi(t, i, n, void 0 === o ? [] : [(new je).fromArray(o, 3 * t), (new je).fromArray(o, 3 * i), (new je).fromArray(o, 3 * n)], l, r);
                        e.faces.push(h), void 0 !== s && e.faceVertexUvs[0].push([(new Ge).fromArray(s, 2 * t), (new Ge).fromArray(s, 2 * i), (new Ge).fromArray(s, 2 * n)]), void 0 !== c && e.faceVertexUvs[1].push([(new Ge).fromArray(c, 2 * t), (new Ge).fromArray(c, 2 * i), (new Ge).fromArray(c, 2 * n)])
                    }
                    var d = t.groups;
                    if (d.length > 0)
                        for (l = 0; l < d.length; l++)
                            for (var p = d[l], f = p.start, m = (h = f, f + p.count); h < m; h += 3) void 0 !== i ? u(i[h], i[h + 1], i[h + 2], p.materialIndex) : u(h, h + 1, h + 2, p.materialIndex);
                    else if (void 0 !== i)
                        for (l = 0; l < i.length; l += 3) u(i[l], i[l + 1], i[l + 2]);
                    else
                        for (l = 0; l < r.length / 3; l += 3) u(l, l + 1, l + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: function() {
                    var t = new je;
                    return function() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                    }
                }(),
                normalize: function() {
                    this.computeBoundingSphere();
                    var t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        i = 0 === e ? 1 : 1 / e,
                        n = new He;
                    return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(n), this
                },
                computeFaceNormals: function() {
                    for (var t = new je, e = new je, i = 0, n = this.faces.length; i < n; i++) {
                        var r = this.faces[i],
                            o = this.vertices[r.a],
                            a = this.vertices[r.b],
                            s = this.vertices[r.c];
                        t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), r.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    var e, i, n, r, o, a;
                    for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) a[e] = new je;
                    if (t) {
                        var s, c, l, h = new je,
                            u = new je;
                        for (n = 0, r = this.faces.length; n < r; n++) o = this.faces[n], s = this.vertices[o.a], c = this.vertices[o.b], l = this.vertices[o.c], h.subVectors(l, c), u.subVectors(s, c), h.cross(u), a[o.a].add(h), a[o.b].add(h), a[o.c].add(h)
                    } else
                        for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) a[(o = this.faces[n]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                    for (e = 0, i = this.vertices.length; e < i; e++) a[e].normalize();
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        var d = (o = this.faces[n]).vertexNormals;
                        3 === d.length ? (d[0].copy(a[o.a]), d[1].copy(a[o.b]), d[2].copy(a[o.c])) : (d[0] = a[o.a].clone(), d[1] = a[o.b].clone(), d[2] = a[o.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var t, e, i;
                    for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                        var n = (i = this.faces[t]).vertexNormals;
                        3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var t, e, i, n, r;
                    for (i = 0, n = this.faces.length; i < n; i++)
                        for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                    var o = new _i;
                    for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                        if (!this.morphNormals[t]) {
                            this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                            var a = this.morphNormals[t].faceNormals,
                                s = this.morphNormals[t].vertexNormals;
                            for (i = 0, n = this.faces.length; i < n; i++) c = new je, l = {
                                a: new je,
                                b: new je,
                                c: new je
                            }, a.push(c), s.push(l)
                        }
                        var c, l, h = this.morphNormals[t];
                        for (o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], c = h.faceNormals[i], l = h.vertexNormals[i], c.copy(r.normal), l.a.copy(r.vertexNormals[0]), l.b.copy(r.vertexNormals[1]), l.c.copy(r.vertexNormals[2])
                    }
                    for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new $e), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new ti), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, i) {
                    if (t && t.isGeometry) {
                        var n, r = this.vertices.length,
                            o = this.vertices,
                            a = t.vertices,
                            s = this.faces,
                            c = t.faces,
                            l = this.faceVertexUvs[0],
                            h = t.faceVertexUvs[0],
                            u = this.colors,
                            d = t.colors;
                        void 0 === i && (i = 0), void 0 !== e && (n = (new We).getNormalMatrix(e));
                        for (var p = 0, f = a.length; p < f; p++) {
                            var m = a[p].clone();
                            void 0 !== e && m.applyMatrix4(e), o.push(m)
                        }
                        for (p = 0, f = d.length; p < f; p++) u.push(d[p].clone());
                        for (p = 0, f = c.length; p < f; p++) {
                            var g, v, y, _ = c[p],
                                x = _.vertexNormals,
                                b = _.vertexColors;
                            (g = new pi(_.a + r, _.b + r, _.c + r)).normal.copy(_.normal), void 0 !== n && g.normal.applyMatrix3(n).normalize();
                            for (var w = 0, M = x.length; w < M; w++) v = x[w].clone(), void 0 !== n && v.applyMatrix3(n).normalize(), g.vertexNormals.push(v);
                            g.color.copy(_.color);
                            for (w = 0, M = b.length; w < M; w++) y = b[w], g.vertexColors.push(y.clone());
                            g.materialIndex = _.materialIndex + i, s.push(g)
                        }
                        for (p = 0, f = h.length; p < f; p++) {
                            var T = h[p],
                                E = [];
                            if (void 0 !== T) {
                                for (w = 0, M = T.length; w < M; w++) E.push(T[w].clone());
                                l.push(E)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
                },
                mergeMesh: function(t) {
                    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                },
                mergeVertices: function() {
                    var t, e, i, n, r, o, a, s, c = {},
                        l = [],
                        h = [],
                        u = Math.pow(10, 4);
                    for (i = 0, n = this.vertices.length; i < n; i++) t = this.vertices[i], void 0 === c[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (c[e] = i, l.push(this.vertices[i]), h[i] = l.length - 1) : h[i] = h[c[e]];
                    var d = [];
                    for (i = 0, n = this.faces.length; i < n; i++) {
                        (r = this.faces[i]).a = h[r.a], r.b = h[r.b], r.c = h[r.c], o = [r.a, r.b, r.c];
                        for (var p = 0; p < 3; p++)
                            if (o[p] === o[(p + 1) % 3]) {
                                d.push(i);
                                break
                            }
                    }
                    for (i = d.length - 1; i >= 0; i--) {
                        var f = d[i];
                        for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
                    }
                    var m = this.vertices.length - l.length;
                    return this.vertices = l, m
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (var e = 0, i = t.length; e < i; e++) {
                        var n = t[e];
                        this.vertices.push(new je(n.x, n.y, n.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
                    t.sort(function(t, e) {
                        return t.materialIndex - e.materialIndex
                    });
                    var n, r, o = this.faceVertexUvs[0],
                        a = this.faceVertexUvs[1];
                    o && o.length === e && (n = []), a && a.length === e && (r = []);
                    for (i = 0; i < e; i++) {
                        var s = t[i]._id;
                        n && n.push(o[s]), r && r.push(a[s])
                    }
                    n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t
                    }
                    for (var n = [], r = 0; r < this.vertices.length; r++) {
                        var o = this.vertices[r];
                        n.push(o.x, o.y, o.z)
                    }
                    var a = [],
                        s = [],
                        c = {},
                        l = [],
                        h = {},
                        u = [],
                        d = {};
                    for (r = 0; r < this.faces.length; r++) {
                        var p = this.faces[r],
                            f = void 0 !== this.faceVertexUvs[0][r],
                            m = p.normal.length() > 0,
                            g = p.vertexNormals.length > 0,
                            v = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                            y = p.vertexColors.length > 0,
                            _ = 0;
                        if (_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, g), 6, v), 7, y), a.push(_), a.push(p.a, p.b, p.c), a.push(p.materialIndex), f) {
                            var x = this.faceVertexUvs[0][r];
                            a.push(S(x[0]), S(x[1]), S(x[2]))
                        }
                        if (m && a.push(T(p.normal)), g) {
                            var b = p.vertexNormals;
                            a.push(T(b[0]), T(b[1]), T(b[2]))
                        }
                        if (v && a.push(E(p.color)), y) {
                            var w = p.vertexColors;
                            a.push(E(w[0]), E(w[1]), E(w[2]))
                        }
                    }

                    function M(t, e, i) {
                        return i ? t | 1 << e : t & ~(1 << e)
                    }

                    function T(t) {
                        var e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z), c[e])
                    }

                    function E(t) {
                        var e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== h[e] ? h[e] : (h[e] = l.length, l.push(t.getHex()), h[e])
                    }

                    function S(t) {
                        var e = t.x.toString() + t.y.toString();
                        return void 0 !== d[e] ? d[e] : (d[e] = u.length / 2, u.push(t.x, t.y), d[e])
                    }
                    return t.data = {}, t.data.vertices = n, t.data.normals = s, l.length > 0 && (t.data.colors = l), u.length > 0 && (t.data.uvs = [u]), t.data.faces = a, t
                },
                clone: function() {
                    return (new _i).copy(this)
                },
                copy: function(t) {
                    var e, i, n, r, o, a;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var s = t.vertices;
                    for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
                    var c = t.colors;
                    for (e = 0, i = c.length; e < i; e++) this.colors.push(c[e].clone());
                    var l = t.faces;
                    for (e = 0, i = l.length; e < i; e++) this.faces.push(l[e].clone());
                    for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
                        var h = t.faceVertexUvs[e];
                        for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0, r = h.length; n < r; n++) {
                            var u = h[n],
                                d = [];
                            for (o = 0, a = u.length; o < a; o++) {
                                var p = u[o];
                                d.push(p.clone())
                            }
                            this.faceVertexUvs[e].push(d)
                        }
                    }
                    var f = t.morphTargets;
                    for (e = 0, i = f.length; e < i; e++) {
                        var m = {};
                        if (m.name = f[e].name, void 0 !== f[e].vertices)
                            for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m.vertices.push(f[e].vertices[n].clone());
                        if (void 0 !== f[e].normals)
                            for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m.normals.push(f[e].normals[n].clone());
                        this.morphTargets.push(m)
                    }
                    var g = t.morphNormals;
                    for (e = 0, i = g.length; e < i; e++) {
                        var v = {};
                        if (void 0 !== g[e].vertexNormals)
                            for (v.vertexNormals = [], n = 0, r = g[e].vertexNormals.length; n < r; n++) {
                                var y = g[e].vertexNormals[n],
                                    _ = {};
                                _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), v.vertexNormals.push(_)
                            }
                        if (void 0 !== g[e].faceNormals)
                            for (v.faceNormals = [], n = 0, r = g[e].faceNormals.length; n < r; n++) v.faceNormals.push(g[e].faceNormals[n].clone());
                        this.morphNormals.push(v)
                    }
                    var x = t.skinWeights;
                    for (e = 0, i = x.length; e < i; e++) this.skinWeights.push(x[e].clone());
                    var b = t.skinIndices;
                    for (e = 0, i = b.length; e < i; e++) this.skinIndices.push(b[e].clone());
                    var w = t.lineDistances;
                    for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
                    var M = t.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var T = t.boundingSphere;
                    return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(xi.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(xi.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, i) {
                    t *= this.itemSize, i *= e.itemSize;
                    for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new ci), e[i++] = o.r, e[i++] = o.g, e[i++] = o.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), o = new Ge), e[i++] = o.x, e[i++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), o = new je), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new Ze), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z, e[i++] = o.w
                    }
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
                },
                setXYZ: function(t, e, i, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
                },
                setXYZW: function(t, e, i, n, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            }), bi.prototype = Object.create(xi.prototype), bi.prototype.constructor = bi, wi.prototype = Object.create(xi.prototype), wi.prototype.constructor = wi, Mi.prototype = Object.create(xi.prototype), Mi.prototype.constructor = Mi, Ti.prototype = Object.create(xi.prototype), Ti.prototype.constructor = Ti, Ei.prototype = Object.create(xi.prototype), Ei.prototype.constructor = Ei, Si.prototype = Object.create(xi.prototype), Si.prototype.constructor = Si, Ai.prototype = Object.create(xi.prototype), Ai.prototype.constructor = Ai, Pi.prototype = Object.create(xi.prototype), Pi.prototype.constructor = Pi, Li.prototype = Object.create(xi.prototype), Li.prototype.constructor = Li, Object.assign(Ci.prototype, {
                computeGroups: function(t) {
                    for (var e, i = [], n = void 0, r = t.faces, o = 0; o < r.length; o++) {
                        var a = r[o];
                        a.materialIndex !== n && (n = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), e = {
                            start: 3 * o,
                            materialIndex: n
                        })
                    }
                    void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), this.groups = i
                },
                fromGeometry: function(t) {
                    var e, i = t.faces,
                        n = t.vertices,
                        r = t.faceVertexUvs,
                        o = r[0] && r[0].length > 0,
                        a = r[1] && r[1].length > 0,
                        s = t.morphTargets,
                        c = s.length;
                    if (c > 0) {
                        e = [];
                        for (var l = 0; l < c; l++) e[l] = {
                            name: s[l].name,
                            data: []
                        };
                        this.morphTargets.position = e
                    }
                    var h, u = t.morphNormals,
                        d = u.length;
                    if (d > 0) {
                        h = [];
                        for (l = 0; l < d; l++) h[l] = {
                            name: u[l].name,
                            data: []
                        };
                        this.morphTargets.normal = h
                    }
                    var p = t.skinIndices,
                        f = t.skinWeights,
                        m = p.length === n.length,
                        g = f.length === n.length;
                    n.length > 0 && 0 === i.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (l = 0; l < i.length; l++) {
                        var v = i[l];
                        this.vertices.push(n[v.a], n[v.b], n[v.c]);
                        var y = v.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var _ = v.normal;
                            this.normals.push(_, _, _)
                        }
                        var x, b = v.vertexColors;
                        if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                        else {
                            var w = v.color;
                            this.colors.push(w, w, w)
                        }
                        if (!0 === o) void 0 !== (x = r[0][l]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new Ge, new Ge, new Ge));
                        if (!0 === a) void 0 !== (x = r[1][l]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new Ge, new Ge, new Ge));
                        for (var M = 0; M < c; M++) {
                            var T = s[M].vertices;
                            e[M].data.push(T[v.a], T[v.b], T[v.c])
                        }
                        for (M = 0; M < d; M++) {
                            var E = u[M].vertexNormals[l];
                            h[M].data.push(E.a, E.b, E.c)
                        }
                        m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                }
            });
            var Oi = 1;

            function Ii() {
                Object.defineProperty(this, "id", {
                    value: Oi += 2
                }), this.uuid = Ue.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            function Di(t, e, i, n, r, o) {
                _i.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: i,
                    widthSegments: n,
                    heightSegments: r,
                    depthSegments: o
                }, this.fromBufferGeometry(new ki(t, e, i, n, r, o)), this.mergeVertices()
            }

            function ki(t, e, i, n, r, o) {
                Ii.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: i,
                    widthSegments: n,
                    heightSegments: r,
                    depthSegments: o
                };
                var a = this;
                t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1;
                var s = [],
                    c = [],
                    l = [],
                    h = [],
                    u = 0,
                    d = 0;

                function p(t, e, i, n, r, o, p, f, m, g, v) {
                    var y, _, x = o / m,
                        b = p / g,
                        w = o / 2,
                        M = p / 2,
                        T = f / 2,
                        E = m + 1,
                        S = g + 1,
                        A = 0,
                        P = 0,
                        L = new je;
                    for (_ = 0; _ < S; _++) {
                        var C = _ * b - M;
                        for (y = 0; y < E; y++) {
                            var R = y * x - w;
                            L[t] = R * n, L[e] = C * r, L[i] = T, c.push(L.x, L.y, L.z), L[t] = 0, L[e] = 0, L[i] = f > 0 ? 1 : -1, l.push(L.x, L.y, L.z), h.push(y / m), h.push(1 - _ / g), A += 1
                        }
                    }
                    for (_ = 0; _ < g; _++)
                        for (y = 0; y < m; y++) {
                            var O = u + y + E * _,
                                I = u + y + E * (_ + 1),
                                D = u + (y + 1) + E * (_ + 1),
                                k = u + (y + 1) + E * _;
                            s.push(O, I, k), s.push(I, D, k), P += 6
                        }
                    a.addGroup(d, P, v), d += P, u += A
                }
                p("z", "y", "x", -1, -1, i, e, t, o = Math.floor(o) || 1, r, 0), p("z", "y", "x", 1, -1, i, e, -t, o, r, 1), p("x", "z", "y", 1, 1, t, i, e, n, o, 2), p("x", "z", "y", 1, -1, t, i, -e, n, o, 3), p("x", "y", "z", 1, -1, t, e, i, n, r, 4), p("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(s), this.addAttribute("position", new Pi(c, 3)), this.addAttribute("normal", new Pi(l, 3)), this.addAttribute("uv", new Pi(h, 2))
            }

            function Ni(t, e, i, n) {
                _i.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: i,
                    heightSegments: n
                }, this.fromBufferGeometry(new Bi(t, e, i, n)), this.mergeVertices()
            }

            function Bi(t, e, i, n) {
                Ii.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: i,
                    heightSegments: n
                };
                var r, o, a = (t = t || 1) / 2,
                    s = (e = e || 1) / 2,
                    c = Math.floor(i) || 1,
                    l = Math.floor(n) || 1,
                    h = c + 1,
                    u = l + 1,
                    d = t / c,
                    p = e / l,
                    f = [],
                    m = [],
                    g = [],
                    v = [];
                for (o = 0; o < u; o++) {
                    var y = o * p - s;
                    for (r = 0; r < h; r++) {
                        var _ = r * d - a;
                        m.push(_, -y, 0), g.push(0, 0, 1), v.push(r / c), v.push(1 - o / l)
                    }
                }
                for (o = 0; o < l; o++)
                    for (r = 0; r < c; r++) {
                        var x = r + h * o,
                            b = r + h * (o + 1),
                            w = r + 1 + h * (o + 1),
                            M = r + 1 + h * o;
                        f.push(x, b, M), f.push(b, w, M)
                    }
                this.setIndex(f), this.addAttribute("position", new Pi(m, 3)), this.addAttribute("normal", new Pi(g, 3)), this.addAttribute("uv", new Pi(v, 2))
            }
            Ii.prototype = Object.assign(Object.create(n.prototype), {
                constructor: Ii,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    Array.isArray(t) ? this.index = new(Ri(t) > 65535 ? Ai : Ei)(t, 1) : this.index = t
                },
                addAttribute: function(t, e) {
                    return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new xi(arguments[1], arguments[2])))
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                removeAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, i) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== i ? i : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix: function(t) {
                    var e = this.attributes.position;
                    void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                    var i = this.attributes.normal;
                    void 0 !== i && ((new We).getNormalMatrix(t).applyToBufferAttribute(i), i.needsUpdate = !0);
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeScale(e, i, n), this.applyMatrix(t), this
                    }
                }(),
                lookAt: function() {
                    var t = new vi;
                    return function(e) {
                        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                    }
                }(),
                center: function() {
                    var t = new je;
                    return function() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                    }
                }(),
                setFromObject: function(t) {
                    var e = t.geometry;
                    if (t.isPoints || t.isLine) {
                        var i = new Pi(3 * e.vertices.length, 3),
                            n = new Pi(3 * e.colors.length, 3);
                        if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this.addAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            var r = new Pi(e.lineDistances.length, 1);
                            this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                setFromPoints: function(t) {
                    for (var e = [], i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        e.push(r.x, r.y, r.z || 0)
                    }
                    return this.addAttribute("position", new Pi(e, 3)), this
                },
                updateFromObject: function(t) {
                    var e, i = t.geometry;
                    if (t.isMesh) {
                        var n = i.__directGeometry;
                        if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(i);
                        n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i = n
                    }
                    return !0 === i.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(i.vertices), e.needsUpdate = !0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(i.normals), e.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(i.colors), e.needsUpdate = !0), i.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(i.uvs), e.needsUpdate = !0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(i.lineDistances), e.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i.computeGroups(t.geometry), this.groups = i.groups, i.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new Ci).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    var e = new Float32Array(3 * t.vertices.length);
                    if (this.addAttribute("position", new xi(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                        var i = new Float32Array(3 * t.normals.length);
                        this.addAttribute("normal", new xi(i, 3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        var n = new Float32Array(3 * t.colors.length);
                        this.addAttribute("color", new xi(n, 3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        var r = new Float32Array(2 * t.uvs.length);
                        this.addAttribute("uv", new xi(r, 2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        var o = new Float32Array(2 * t.uvs2.length);
                        this.addAttribute("uv2", new xi(o, 2).copyVector2sArray(t.uvs2))
                    }
                    for (var a in this.groups = t.groups, t.morphTargets) {
                        for (var s = [], c = t.morphTargets[a], l = 0, h = c.length; l < h; l++) {
                            var u = c[l],
                                d = new Pi(3 * u.data.length, 3);
                            d.name = u.name, s.push(d.copyVector3sArray(u.data))
                        }
                        this.morphAttributes[a] = s
                    }
                    if (t.skinIndices.length > 0) {
                        var p = new Pi(4 * t.skinIndices.length, 4);
                        this.addAttribute("skinIndex", p.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        var f = new Pi(4 * t.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new $e);
                    var t = this.attributes.position;
                    void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    var t = new $e,
                        e = new je;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new ti);
                        var i = this.attributes.position;
                        if (i) {
                            var n = this.boundingSphere.center;
                            t.setFromBufferAttribute(i), t.getCenter(n);
                            for (var r = 0, o = 0, a = i.count; o < a; o++) e.x = i.getX(o), e.y = i.getY(o), e.z = i.getZ(o), r = Math.max(r, n.distanceToSquared(e));
                            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var t = this.index,
                        e = this.attributes;
                    if (e.position) {
                        var i = e.position.array;
                        if (void 0 === e.normal) this.addAttribute("normal", new xi(new Float32Array(i.length), 3));
                        else
                            for (var n = e.normal.array, r = 0, o = n.length; r < o; r++) n[r] = 0;
                        var a, s, c, l = e.normal.array,
                            h = new je,
                            u = new je,
                            d = new je,
                            p = new je,
                            f = new je;
                        if (t) {
                            var m = t.array;
                            for (r = 0, o = t.count; r < o; r += 3) a = 3 * m[r + 0], s = 3 * m[r + 1], c = 3 * m[r + 2], h.fromArray(i, a), u.fromArray(i, s), d.fromArray(i, c), p.subVectors(d, u), f.subVectors(h, u), p.cross(f), l[a] += p.x, l[a + 1] += p.y, l[a + 2] += p.z, l[s] += p.x, l[s + 1] += p.y, l[s + 2] += p.z, l[c] += p.x, l[c + 1] += p.y, l[c + 2] += p.z
                        } else
                            for (r = 0, o = i.length; r < o; r += 9) h.fromArray(i, r), u.fromArray(i, r + 3), d.fromArray(i, r + 6), p.subVectors(d, u), f.subVectors(h, u), p.cross(f), l[r] = p.x, l[r + 1] = p.y, l[r + 2] = p.z, l[r + 3] = p.x, l[r + 4] = p.y, l[r + 5] = p.z, l[r + 6] = p.x, l[r + 7] = p.y, l[r + 8] = p.z;
                        this.normalizeNormals(), e.normal.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (t && t.isBufferGeometry) {
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        var i = this.attributes;
                        for (var n in i)
                            if (void 0 !== t.attributes[n])
                                for (var r = i[n].array, o = t.attributes[n], a = o.array, s = 0, c = o.itemSize * e; s < a.length; s++, c++) r[c] = a[s];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
                },
                normalizeNormals: function() {
                    var t = new je;
                    return function() {
                        for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z)
                    }
                }(),
                toNonIndexed: function() {
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var t = new Ii,
                        e = this.index.array,
                        i = this.attributes;
                    for (var n in i) {
                        for (var r = i[n], o = r.array, a = r.itemSize, s = new o.constructor(e.length * a), c = 0, l = 0, h = 0, u = e.length; h < u; h++) {
                            c = e[h] * a;
                            for (var d = 0; d < a; d++) s[l++] = o[c++]
                        }
                        t.addAttribute(n, new xi(s, a))
                    }
                    var p = this.groups;
                    for (h = 0, u = p.length; h < u; h++) {
                        var f = p[h];
                        t.addGroup(f.start, f.count, f.materialIndex)
                    }
                    return t
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    var n = this.index;
                    if (null !== n) {
                        var r = Array.prototype.slice.call(n.array);
                        t.data.index = {
                            type: n.array.constructor.name,
                            array: r
                        }
                    }
                    var o = this.attributes;
                    for (var i in o) {
                        var a = o[i];
                        r = Array.prototype.slice.call(a.array);
                        t.data.attributes[i] = {
                            itemSize: a.itemSize,
                            type: a.array.constructor.name,
                            array: r,
                            normalized: a.normalized
                        }
                    }
                    var s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    var c = this.boundingSphere;
                    return null !== c && (t.data.boundingSphere = {
                        center: c.center.toArray(),
                        radius: c.radius
                    }), t
                },
                clone: function() {
                    return (new Ii).copy(this)
                },
                copy: function(t) {
                    var e, i, n;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var r = t.index;
                    null !== r && this.setIndex(r.clone());
                    var o = t.attributes;
                    for (e in o) {
                        var a = o[e];
                        this.addAttribute(e, a.clone())
                    }
                    var s = t.morphAttributes;
                    for (e in s) {
                        var c = [],
                            l = s[e];
                        for (i = 0, n = l.length; i < n; i++) c.push(l[i].clone());
                        this.morphAttributes[e] = c
                    }
                    var h = t.groups;
                    for (i = 0, n = h.length; i < n; i++) {
                        var u = h[i];
                        this.addGroup(u.start, u.count, u.materialIndex)
                    }
                    var d = t.boundingBox;
                    null !== d && (this.boundingBox = d.clone());
                    var p = t.boundingSphere;
                    return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Di.prototype = Object.create(_i.prototype), Di.prototype.constructor = Di, ki.prototype = Object.create(Ii.prototype), ki.prototype.constructor = ki, Ni.prototype = Object.create(_i.prototype), Ni.prototype.constructor = Ni, Bi.prototype = Object.create(Ii.prototype), Bi.prototype.constructor = Bi;
            var Fi = 0;

            function zi() {
                Object.defineProperty(this, "id", {
                    value: Fi++
                }), this.uuid = Ue.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = E, this.side = g, this.flatShading = !1, this.vertexColors = b, this.opacity = 1, this.transparent = !1, this.blendSrc = z, this.blendDst = U, this.blendEquation = C, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Z, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
            }

            function Ui(t) {
                zi.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            function Gi(t, e) {
                this.origin = void 0 !== t ? t : new je, this.direction = void 0 !== e ? e : new je
            }

            function Hi(t, e, i) {
                this.a = void 0 !== t ? t : new je, this.b = void 0 !== e ? e : new je, this.c = void 0 !== i ? i : new je
            }

            function Vi(t) {
                zi.call(this), this.type = "MeshBasicMaterial", this.color = new ci(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function ji(t, e) {
                vi.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Ii, this.material = void 0 !== e ? e : new Vi({
                    color: 16777215 * Math.random()
                }), this.drawMode = Ee, this.updateMorphTargets()
            }

            function Wi(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function Xi(t, e, i, n, r, o, a, s, c, l) {
                t = void 0 !== t ? t : [], e = void 0 !== e ? e : ht, Ye.call(this, t, e, i, n, r, o, a, s, c, l), this.flipY = !1
            }

            function qi(t, e, i, n) {
                Ye.call(this, null), this.image = {
                    data: t,
                    width: e,
                    height: i,
                    depth: n
                }, this.magFilter = xt, this.minFilter = xt, this.generateMipmaps = !1, this.flipY = !1
            }
            zi.prototype = Object.assign(Object.create(n.prototype), {
                constructor: zi,
                isMaterial: !0,
                onBeforeCompile: function() {},
                setValues: function(t) {
                    if (void 0 !== t)
                        for (var e in t) {
                            var i = t[e];
                            if (void 0 !== i)
                                if ("shading" !== e) {
                                    var n = this[e];
                                    void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === _;
                            else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                        }
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    var i = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function n(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== E && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), this.side !== g && (i.side = this.side), this.vertexColors !== b && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
                        var r = n(t.textures),
                            o = n(t.images);
                        r.length > 0 && (i.textures = r), o.length > 0 && (i.images = o)
                    }
                    return i
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                    var e = t.clippingPlanes,
                        i = null;
                    if (null !== e) {
                        var n = e.length;
                        i = new Array(n);
                        for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
                    }
                    return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Ui.prototype = Object.create(zi.prototype), Ui.prototype.constructor = Ui, Ui.prototype.isShaderMaterial = !0, Ui.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ri(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
            }, Ui.prototype.toJSON = function(t) {
                var e = zi.prototype.toJSON.call(this, t);
                for (var i in e.uniforms = {}, this.uniforms) {
                    var n = this.uniforms[i].value;
                    n.isTexture ? e.uniforms[i] = {
                        type: "t",
                        value: n.toJSON(t).uuid
                    } : n.isColor ? e.uniforms[i] = {
                        type: "c",
                        value: n.getHex()
                    } : n.isVector2 ? e.uniforms[i] = {
                        type: "v2",
                        value: n.toArray()
                    } : n.isVector3 ? e.uniforms[i] = {
                        type: "v3",
                        value: n.toArray()
                    } : n.isVector4 ? e.uniforms[i] = {
                        type: "v4",
                        value: n.toArray()
                    } : n.isMatrix4 ? e.uniforms[i] = {
                        type: "m4",
                        value: n.toArray()
                    } : e.uniforms[i] = {
                        value: n
                    }
                }
                return Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
            }, Object.assign(Gi.prototype, {
                set: function(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                },
                at: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new je), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                },
                recast: function() {
                    var t = new je;
                    return function(e) {
                        return this.origin.copy(this.at(e, t)), this
                    }
                }(),
                closestPointToPoint: function(t, e) {
                    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new je), e.subVectors(t, this.origin);
                    var i = e.dot(this.direction);
                    return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
                },
                distanceToPoint: function(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                },
                distanceSqToPoint: function() {
                    var t = new je;
                    return function(e) {
                        var i = t.subVectors(e, this.origin).dot(this.direction);
                        return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
                    }
                }(),
                distanceSqToSegment: function() {
                    var t = new je,
                        e = new je,
                        i = new je;
                    return function(n, r, o, a) {
                        t.copy(n).add(r).multiplyScalar(.5), e.copy(r).sub(n).normalize(), i.copy(this.origin).sub(t);
                        var s, c, l, h, u = .5 * n.distanceTo(r),
                            d = -this.direction.dot(e),
                            p = i.dot(this.direction),
                            f = -i.dot(e),
                            m = i.lengthSq(),
                            g = Math.abs(1 - d * d);
                        if (g > 0)
                            if (c = d * p - f, h = u * g, (s = d * f - p) >= 0)
                                if (c >= -h)
                                    if (c <= h) {
                                        var v = 1 / g;
                                        l = (s *= v) * (s + d * (c *= v) + 2 * p) + c * (d * s + c + 2 * f) + m
                                    } else c = u, l = -(s = Math.max(0, -(d * c + p))) * s + c * (c + 2 * f) + m;
                        else c = -u, l = -(s = Math.max(0, -(d * c + p))) * s + c * (c + 2 * f) + m;
                        else c <= -h ? l = -(s = Math.max(0, -(-d * u + p))) * s + (c = s > 0 ? -u : Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m : c <= h ? (s = 0, l = (c = Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m) : l = -(s = Math.max(0, -(d * u + p))) * s + (c = s > 0 ? u : Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m;
                        else c = d > 0 ? -u : u, l = -(s = Math.max(0, -(d * c + p))) * s + c * (c + 2 * f) + m;
                        return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(e).multiplyScalar(c).add(t), l
                    }
                }(),
                intersectSphere: function() {
                    var t = new je;
                    return function(e, i) {
                        t.subVectors(e.center, this.origin);
                        var n = t.dot(this.direction),
                            r = t.dot(t) - n * n,
                            o = e.radius * e.radius;
                        if (r > o) return null;
                        var a = Math.sqrt(o - r),
                            s = n - a,
                            c = n + a;
                        return s < 0 && c < 0 ? null : s < 0 ? this.at(c, i) : this.at(s, i)
                    }
                }(),
                intersectsSphere: function(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                },
                distanceToPlane: function(t) {
                    var e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    var i = -(this.origin.dot(t.normal) + t.constant) / e;
                    return i >= 0 ? i : null
                },
                intersectPlane: function(t, e) {
                    var i = this.distanceToPlane(t);
                    return null === i ? null : this.at(i, e)
                },
                intersectsPlane: function(t) {
                    var e = t.distanceToPoint(this.origin);
                    return 0 === e || t.normal.dot(this.direction) * e < 0
                },
                intersectBox: function(t, e) {
                    var i, n, r, o, a, s, c = 1 / this.direction.x,
                        l = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin;
                    return c >= 0 ? (i = (t.min.x - u.x) * c, n = (t.max.x - u.x) * c) : (i = (t.max.x - u.x) * c, n = (t.min.x - u.x) * c), l >= 0 ? (r = (t.min.y - u.y) * l, o = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l, o = (t.min.y - u.y) * l), i > o || r > n ? null : ((r > i || i != i) && (i = r), (o < n || n != n) && (n = o), h >= 0 ? (a = (t.min.z - u.z) * h, s = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, s = (t.min.z - u.z) * h), i > s || a > n ? null : ((a > i || i != i) && (i = a), (s < n || n != n) && (n = s), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
                },
                intersectsBox: function() {
                    var t = new je;
                    return function(e) {
                        return null !== this.intersectBox(e, t)
                    }
                }(),
                intersectTriangle: function() {
                    var t = new je,
                        e = new je,
                        i = new je,
                        n = new je;
                    return function(r, o, a, s, c) {
                        e.subVectors(o, r), i.subVectors(a, r), n.crossVectors(e, i);
                        var l, h = this.direction.dot(n);
                        if (h > 0) {
                            if (s) return null;
                            l = 1
                        } else {
                            if (!(h < 0)) return null;
                            l = -1, h = -h
                        }
                        t.subVectors(this.origin, r);
                        var u = l * this.direction.dot(i.crossVectors(t, i));
                        if (u < 0) return null;
                        var d = l * this.direction.dot(e.cross(t));
                        if (d < 0) return null;
                        if (u + d > h) return null;
                        var p = -l * t.dot(n);
                        return p < 0 ? null : this.at(p / h, c)
                    }
                }(),
                applyMatrix4: function(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                },
                equals: function(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            }), Object.assign(Hi, {
                getNormal: function() {
                    var t = new je;
                    return function(e, i, n, r) {
                        void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new je), r.subVectors(n, i), t.subVectors(e, i), r.cross(t);
                        var o = r.lengthSq();
                        return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0)
                    }
                }(),
                getBarycoord: function() {
                    var t = new je,
                        e = new je,
                        i = new je;
                    return function(n, r, o, a, s) {
                        t.subVectors(a, r), e.subVectors(o, r), i.subVectors(n, r);
                        var c = t.dot(t),
                            l = t.dot(e),
                            h = t.dot(i),
                            u = e.dot(e),
                            d = e.dot(i),
                            p = c * u - l * l;
                        if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s = new je), 0 === p) return s.set(-2, -1, -1);
                        var f = 1 / p,
                            m = (u * h - l * d) * f,
                            g = (c * d - l * h) * f;
                        return s.set(1 - m - g, g, m)
                    }
                }(),
                containsPoint: function() {
                    var t = new je;
                    return function(e, i, n, r) {
                        return Hi.getBarycoord(e, i, n, r, t), t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
                    }
                }(),
                getUV: function() {
                    var t = new je;
                    return function(e, i, n, r, o, a, s, c) {
                        return this.getBarycoord(e, i, n, r, t), c.set(0, 0), c.addScaledVector(o, t.x), c.addScaledVector(a, t.y), c.addScaledVector(s, t.z), c
                    }
                }()
            }), Object.assign(Hi.prototype, {
                set: function(t, e, i) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
                },
                setFromPointsAndIndices: function(t, e, i, n) {
                    return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                },
                getArea: function() {
                    var t = new je,
                        e = new je;
                    return function() {
                        return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                    }
                }(),
                getMidpoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new je), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function(t) {
                    return Hi.getNormal(this.a, this.b, this.c, t)
                },
                getPlane: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new je), t.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function(t, e) {
                    return Hi.getBarycoord(t, this.a, this.b, this.c, e)
                },
                containsPoint: function(t) {
                    return Hi.containsPoint(t, this.a, this.b, this.c)
                },
                getUV: function(t, e, i, n, r) {
                    return Hi.getUV(t, this.a, this.b, this.c, e, i, n, r)
                },
                intersectsBox: function(t) {
                    return t.intersectsTriangle(this)
                },
                closestPointToPoint: function() {
                    var t = new je,
                        e = new je,
                        i = new je,
                        n = new je,
                        r = new je,
                        o = new je;
                    return function(a, s) {
                        void 0 === s && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), s = new je);
                        var c, l, h = this.a,
                            u = this.b,
                            d = this.c;
                        t.subVectors(u, h), e.subVectors(d, h), n.subVectors(a, h);
                        var p = t.dot(n),
                            f = e.dot(n);
                        if (p <= 0 && f <= 0) return s.copy(h);
                        r.subVectors(a, u);
                        var m = t.dot(r),
                            g = e.dot(r);
                        if (m >= 0 && g <= m) return s.copy(u);
                        var v = p * g - m * f;
                        if (v <= 0 && p >= 0 && m <= 0) return c = p / (p - m), s.copy(h).addScaledVector(t, c);
                        o.subVectors(a, d);
                        var y = t.dot(o),
                            _ = e.dot(o);
                        if (_ >= 0 && y <= _) return s.copy(d);
                        var x = y * f - p * _;
                        if (x <= 0 && f >= 0 && _ <= 0) return l = f / (f - _), s.copy(h).addScaledVector(e, l);
                        var b = m * _ - y * g;
                        if (b <= 0 && g - m >= 0 && y - _ >= 0) return i.subVectors(d, u), l = (g - m) / (g - m + (y - _)), s.copy(u).addScaledVector(i, l);
                        var w = 1 / (b + x + v);
                        return c = x * w, l = v * w, s.copy(h).addScaledVector(t, c).addScaledVector(e, l)
                    }
                }(),
                equals: function(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }), Vi.prototype = Object.create(zi.prototype), Vi.prototype.constructor = Vi, Vi.prototype.isMeshBasicMaterial = !0, Vi.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            }, ji.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: ji,
                isMesh: !0,
                setDrawMode: function(t) {
                    this.drawMode = t
                },
                copy: function(t) {
                    return vi.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
                },
                updateMorphTargets: function() {
                    var t, e, i, n = this.geometry;
                    if (n.isBufferGeometry) {
                        var r = n.morphAttributes,
                            o = Object.keys(r);
                        if (o.length > 0) {
                            var a = r[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) i = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                        }
                    } else {
                        var s = n.morphTargets;
                        if (void 0 !== s && s.length > 0)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) i = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                    }
                },
                raycast: function() {
                    var t = new He,
                        e = new Gi,
                        i = new ti,
                        n = new je,
                        r = new je,
                        o = new je,
                        a = new je,
                        s = new je,
                        c = new je,
                        l = new Ge,
                        h = new Ge,
                        u = new Ge,
                        d = new je,
                        p = new je;

                    function f(t, e, i, n, r, o, a, s) {
                        if (null === (e.side === v ? n.intersectTriangle(a, o, r, !0, s) : n.intersectTriangle(r, o, a, e.side !== y, s))) return null;
                        p.copy(s), p.applyMatrix4(t.matrixWorld);
                        var c = i.ray.origin.distanceTo(p);
                        return c < i.near || c > i.far ? null : {
                            distance: c,
                            point: p.clone(),
                            object: t
                        }
                    }

                    function m(t, e, i, a, s, c, p, m, g) {
                        n.fromBufferAttribute(s, p), r.fromBufferAttribute(s, m), o.fromBufferAttribute(s, g);
                        var v = f(t, e, i, a, n, r, o, d);
                        if (v) {
                            c && (l.fromBufferAttribute(c, p), h.fromBufferAttribute(c, m), u.fromBufferAttribute(c, g), v.uv = Hi.getUV(d, n, r, o, l, h, u, new Ge));
                            var y = new pi(p, m, g);
                            Hi.getNormal(n, r, o, y.normal), v.face = y
                        }
                        return v
                    }
                    return function(p, g) {
                        var v, y = this.geometry,
                            _ = this.material,
                            x = this.matrixWorld;
                        if (void 0 !== _ && (null === y.boundingSphere && y.computeBoundingSphere(), i.copy(y.boundingSphere), i.applyMatrix4(x), !1 !== p.ray.intersectsSphere(i) && (t.getInverse(x), e.copy(p.ray).applyMatrix4(t), null === y.boundingBox || !1 !== e.intersectsBox(y.boundingBox))))
                            if (y.isBufferGeometry) {
                                var b, w, M, T, E, S, A, P, L, C = y.index,
                                    R = y.attributes.position,
                                    O = y.attributes.uv,
                                    I = y.groups,
                                    D = y.drawRange;
                                if (null !== C)
                                    if (Array.isArray(_))
                                        for (T = 0, S = I.length; T < S; T++)
                                            for (L = _[(P = I[T]).materialIndex], E = Math.max(P.start, D.start), A = Math.min(P.start + P.count, D.start + D.count); E < A; E += 3) b = C.getX(E), w = C.getX(E + 1), M = C.getX(E + 2), (v = m(this, L, p, e, R, O, b, w, M)) && (v.faceIndex = Math.floor(E / 3), g.push(v));
                                    else
                                        for (T = Math.max(0, D.start), S = Math.min(C.count, D.start + D.count); T < S; T += 3) b = C.getX(T), w = C.getX(T + 1), M = C.getX(T + 2), (v = m(this, _, p, e, R, O, b, w, M)) && (v.faceIndex = Math.floor(T / 3), g.push(v));
                                else if (void 0 !== R)
                                    if (Array.isArray(_))
                                        for (T = 0, S = I.length; T < S; T++)
                                            for (L = _[(P = I[T]).materialIndex], E = Math.max(P.start, D.start), A = Math.min(P.start + P.count, D.start + D.count); E < A; E += 3)(v = m(this, L, p, e, R, O, b = E, w = E + 1, M = E + 2)) && (v.faceIndex = Math.floor(E / 3), g.push(v));
                                    else
                                        for (T = Math.max(0, D.start), S = Math.min(R.count, D.start + D.count); T < S; T += 3)(v = m(this, _, p, e, R, O, b = T, w = T + 1, M = T + 2)) && (v.faceIndex = Math.floor(T / 3), g.push(v))
                            } else if (y.isGeometry) {
                            var k, N, B, F, z = Array.isArray(_),
                                U = y.vertices,
                                G = y.faces,
                                H = y.faceVertexUvs[0];
                            H.length > 0 && (F = H);
                            for (var V = 0, j = G.length; V < j; V++) {
                                var W = G[V],
                                    X = z ? _[W.materialIndex] : _;
                                if (void 0 !== X) {
                                    if (k = U[W.a], N = U[W.b], B = U[W.c], !0 === X.morphTargets) {
                                        var q = y.morphTargets,
                                            Y = this.morphTargetInfluences;
                                        n.set(0, 0, 0), r.set(0, 0, 0), o.set(0, 0, 0);
                                        for (var Z = 0, J = q.length; Z < J; Z++) {
                                            var K = Y[Z];
                                            if (0 !== K) {
                                                var Q = q[Z].vertices;
                                                n.addScaledVector(a.subVectors(Q[W.a], k), K), r.addScaledVector(s.subVectors(Q[W.b], N), K), o.addScaledVector(c.subVectors(Q[W.c], B), K)
                                            }
                                        }
                                        n.add(k), r.add(N), o.add(B), k = n, N = r, B = o
                                    }
                                    if (v = f(this, X, p, e, k, N, B, d)) {
                                        if (F && F[V]) {
                                            var $ = F[V];
                                            l.copy($[0]), h.copy($[1]), u.copy($[2]), v.uv = Hi.getUV(d, k, N, B, l, h, u, new Ge)
                                        }
                                        v.face = W, v.faceIndex = V, g.push(v)
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Xi.prototype = Object.create(Ye.prototype), Xi.prototype.constructor = Xi, Xi.prototype.isCubeTexture = !0, Object.defineProperty(Xi.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            }), qi.prototype = Object.create(Ye.prototype), qi.prototype.constructor = qi, qi.prototype.isDataTexture3D = !0;
            var Yi = new Ye,
                Zi = new qi,
                Ji = new Xi;

            function Ki() {
                this.seq = [], this.map = {}
            }
            var Qi = [],
                $i = [],
                tn = new Float32Array(16),
                en = new Float32Array(9),
                nn = new Float32Array(4);

            function rn(t, e, i) {
                var n = t[0];
                if (n <= 0 || n > 0) return t;
                var r = e * i,
                    o = Qi[r];
                if (void 0 === o && (o = new Float32Array(r), Qi[r] = o), 0 !== e) {
                    n.toArray(o, 0);
                    for (var a = 1, s = 0; a !== e; ++a) s += i, t[a].toArray(o, s)
                }
                return o
            }

            function on(t, e) {
                if (t.length !== e.length) return !1;
                for (var i = 0, n = t.length; i < n; i++)
                    if (t[i] !== e[i]) return !1;
                return !0
            }

            function an(t, e) {
                for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
            }

            function sn(t, e) {
                var i = $i[e];
                void 0 === i && (i = new Int32Array(e), $i[e] = i);
                for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
                return i
            }

            function cn(t, e) {
                var i = this.cache;
                i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
            }

            function ln(t, e) {
                var i = this.cache;
                i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
            }

            function hn(t, e) {
                var i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
                else {
                    if (on(i, e)) return;
                    t.uniform2fv(this.addr, e), an(i, e)
                }
            }

            function un(t, e) {
                var i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
                else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
                else {
                    if (on(i, e)) return;
                    t.uniform3fv(this.addr, e), an(i, e)
                }
            }

            function dn(t, e) {
                var i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
                else {
                    if (on(i, e)) return;
                    t.uniform4fv(this.addr, e), an(i, e)
                }
            }

            function pn(t, e) {
                var i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (on(i, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), an(i, e)
                } else {
                    if (on(i, n)) return;
                    nn.set(n), t.uniformMatrix2fv(this.addr, !1, nn), an(i, n)
                }
            }

            function fn(t, e) {
                var i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (on(i, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), an(i, e)
                } else {
                    if (on(i, n)) return;
                    en.set(n), t.uniformMatrix3fv(this.addr, !1, en), an(i, n)
                }
            }

            function mn(t, e) {
                var i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (on(i, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), an(i, e)
                } else {
                    if (on(i, n)) return;
                    tn.set(n), t.uniformMatrix4fv(this.addr, !1, tn), an(i, n)
                }
            }

            function gn(t, e, i) {
                var n = this.cache,
                    r = i.allocTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(e || Yi, r)
            }

            function vn(t, e, i) {
                var n = this.cache,
                    r = i.allocTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || Zi, r)
            }

            function yn(t, e, i) {
                var n = this.cache,
                    r = i.allocTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(e || Ji, r)
            }

            function _n(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform2iv(this.addr, e), an(i, e))
            }

            function xn(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform3iv(this.addr, e), an(i, e))
            }

            function bn(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform4iv(this.addr, e), an(i, e))
            }

            function wn(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform1fv(this.addr, e), an(i, e))
            }

            function Mn(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform1iv(this.addr, e), an(i, e))
            }

            function Tn(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 2);
                on(i, n) || (t.uniform2fv(this.addr, n), this.updateCache(n))
            }

            function En(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 3);
                on(i, n) || (t.uniform3fv(this.addr, n), this.updateCache(n))
            }

            function Sn(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 4);
                on(i, n) || (t.uniform4fv(this.addr, n), this.updateCache(n))
            }

            function An(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 4);
                on(i, n) || (t.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n))
            }

            function Pn(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 9);
                on(i, n) || (t.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n))
            }

            function Ln(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 16);
                on(i, n) || (t.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n))
            }

            function Cn(t, e, i) {
                var n = this.cache,
                    r = e.length,
                    o = sn(i, r);
                !1 === on(n, o) && (t.uniform1iv(this.addr, o), an(n, o));
                for (var a = 0; a !== r; ++a) i.setTexture2D(e[a] || Yi, o[a])
            }

            function Rn(t, e, i) {
                var n = this.cache,
                    r = e.length,
                    o = sn(i, r);
                !1 === on(n, o) && (t.uniform1iv(this.addr, o), an(n, o));
                for (var a = 0; a !== r; ++a) i.setTextureCube(e[a] || Ji, o[a])
            }

            function On(t, e, i) {
                this.id = t, this.addr = i, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return cn;
                        case 35664:
                            return hn;
                        case 35665:
                            return un;
                        case 35666:
                            return dn;
                        case 35674:
                            return pn;
                        case 35675:
                            return fn;
                        case 35676:
                            return mn;
                        case 35678:
                        case 36198:
                            return gn;
                        case 35679:
                            return vn;
                        case 35680:
                            return yn;
                        case 5124:
                        case 35670:
                            return ln;
                        case 35667:
                        case 35671:
                            return _n;
                        case 35668:
                        case 35672:
                            return xn;
                        case 35669:
                        case 35673:
                            return bn
                    }
                }(e.type)
            }

            function In(t, e, i) {
                this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return wn;
                        case 35664:
                            return Tn;
                        case 35665:
                            return En;
                        case 35666:
                            return Sn;
                        case 35674:
                            return An;
                        case 35675:
                            return Pn;
                        case 35676:
                            return Ln;
                        case 35678:
                            return Cn;
                        case 35680:
                            return Rn;
                        case 5124:
                        case 35670:
                            return Mn;
                        case 35667:
                        case 35671:
                            return _n;
                        case 35668:
                        case 35672:
                            return xn;
                        case 35669:
                        case 35673:
                            return bn
                    }
                }(e.type)
            }

            function Dn(t) {
                this.id = t, Ki.call(this)
            }
            In.prototype.updateCache = function(t) {
                var e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), an(e, t)
            }, Dn.prototype.setValue = function(t, e, i) {
                for (var n = this.seq, r = 0, o = n.length; r !== o; ++r) {
                    var a = n[r];
                    a.setValue(t, e[a.id], i)
                }
            };
            var kn = /([\w\d_]+)(\])?(\[|\.)?/g;

            function Nn(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function Bn(t, e, i) {
                var n = t.name,
                    r = n.length;
                for (kn.lastIndex = 0;;) {
                    var o = kn.exec(n),
                        a = kn.lastIndex,
                        s = o[1],
                        c = "]" === o[2],
                        l = o[3];
                    if (c && (s |= 0), void 0 === l || "[" === l && a + 2 === r) {
                        Nn(i, void 0 === l ? new On(s, t, e) : new In(s, t, e));
                        break
                    }
                    var h = i.map[s];
                    void 0 === h && Nn(i, h = new Dn(s)), i = h
                }
            }

            function Fn(t, e, i) {
                Ki.call(this), this.renderer = i;
                for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
                    var o = t.getActiveUniform(e, r);
                    Bn(o, t.getUniformLocation(e, o.name), this)
                }
            }

            function zn(t, e, i) {
                var n = t.createShader(e);
                return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" : "fragment", t.getShaderInfoLog(n), function(t) {
                    for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
                    return e.join("\n")
                }(i)), n
            }
            Fn.prototype.setValue = function(t, e, i) {
                var n = this.map[e];
                void 0 !== n && n.setValue(t, i, this.renderer)
            }, Fn.prototype.setOptional = function(t, e, i) {
                var n = e[i];
                void 0 !== n && this.setValue(t, i, n)
            }, Fn.upload = function(t, e, i, n) {
                for (var r = 0, o = e.length; r !== o; ++r) {
                    var a = e[r],
                        s = i[a.id];
                    !1 !== s.needsUpdate && a.setValue(t, s.value, n)
                }
            }, Fn.seqWithValue = function(t, e) {
                for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                    var o = t[n];
                    o.id in e && i.push(o)
                }
                return i
            };
            var Un = 0;

            function Gn(t) {
                switch (t) {
                    case Pe:
                        return ["Linear", "( value )"];
                    case Le:
                        return ["sRGB", "( value )"];
                    case Re:
                        return ["RGBE", "( value )"];
                    case Ie:
                        return ["RGBM", "( value, 7.0 )"];
                    case De:
                        return ["RGBM", "( value, 16.0 )"];
                    case ke:
                        return ["RGBD", "( value, 256.0 )"];
                    case Ce:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + t)
                }
            }

            function Hn(t, e) {
                var i = Gn(e);
                return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
            }

            function Vn(t) {
                return "" !== t
            }

            function jn(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            }

            function Wn(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }

            function Xn(t) {
                return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(t, e) {
                    var i = ni[e];
                    if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
                    return Xn(i)
                })
            }

            function qn(t) {
                return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, i, n) {
                    for (var r = "", o = parseInt(e); o < parseInt(i); o++) r += n.replace(/\[ i \]/g, "[ " + o + " ]");
                    return r
                })
            }

            function Yn(t, e, i, n, r, o, a) {
                var s = t.context,
                    c = n.defines,
                    l = r.vertexShader,
                    h = r.fragmentShader,
                    u = "SHADOWMAP_TYPE_BASIC";
                o.shadowMapType === f ? u = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === m && (u = "SHADOWMAP_TYPE_PCF_SOFT");
                var d = "ENVMAP_TYPE_CUBE",
                    p = "ENVMAP_MODE_REFLECTION",
                    g = "ENVMAP_BLENDING_MULTIPLY";
                if (o.envMap) {
                    switch (n.envMap.mapping) {
                        case ht:
                        case ut:
                            d = "ENVMAP_TYPE_CUBE";
                            break;
                        case mt:
                        case gt:
                            d = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case dt:
                        case pt:
                            d = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case ft:
                            d = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (n.envMap.mapping) {
                        case ut:
                        case pt:
                            p = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (n.combine) {
                        case tt:
                            g = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case et:
                            g = "ENVMAP_BLENDING_MIX";
                            break;
                        case it:
                            g = "ENVMAP_BLENDING_ADD"
                    }
                }
                var v, y, _ = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    x = a.isWebGL2 ? "" : function(t, e, i) {
                        return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Vn).join("\n")
                    }(n.extensions, o, e),
                    b = function(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            !1 !== n && e.push("#define " + i + " " + n)
                        }
                        return e.join("\n")
                    }(c),
                    w = s.createProgram();
                if (n.isRawShaderMaterial ? ((v = [b].filter(Vn).join("\n")).length > 0 && (v += "\n"), (y = [x, b].filter(Vn).join("\n")).length > 0 && (y += "\n")) : (v = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Vn).join("\n"), y = [x, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + _, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + d : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + g : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (a.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== nt ? "#define TONE_MAPPING" : "", o.toneMapping !== nt ? ni.tonemapping_pars_fragment : "", o.toneMapping !== nt ? function(t, e) {
                        var i;
                        switch (e) {
                            case rt:
                                i = "Linear";
                                break;
                            case ot:
                                i = "Reinhard";
                                break;
                            case at:
                                i = "Uncharted2";
                                break;
                            case st:
                                i = "OptimizedCineon";
                                break;
                            case ct:
                                i = "ACESFilmic";
                                break;
                            default:
                                throw new Error("unsupported toneMapping: " + e)
                        }
                        return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
                    }("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? ni.encodings_pars_fragment : "", o.mapEncoding ? Hn("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? Hn("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? Hn("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Hn("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? function(t, e) {
                        var i = Gn(e);
                        return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
                    }("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Vn).join("\n")), l = Wn(l = jn(l = Xn(l), o), o), h = Wn(h = jn(h = Xn(h), o), o), l = qn(l), h = qn(h), a.isWebGL2 && !n.isRawShaderMaterial) {
                    var M = !1,
                        T = /^\s*#version\s+300\s+es\s*\n/;
                    n.isShaderMaterial && null !== l.match(T) && null !== h.match(T) && (M = !0, l = l.replace(T, ""), h = h.replace(T, "")), v = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v, y = ["#version 300 es\n", "#define varying in", M ? "" : "out highp vec4 pc_fragColor;", M ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y
                }
                var E = y + h,
                    S = zn(s, 35633, v + l),
                    A = zn(s, 35632, E);
                s.attachShader(w, S), s.attachShader(w, A), void 0 !== n.index0AttributeName ? s.bindAttribLocation(w, 0, n.index0AttributeName) : !0 === o.morphTargets && s.bindAttribLocation(w, 0, "position"), s.linkProgram(w);
                var P, L, C = s.getProgramInfoLog(w).trim(),
                    R = s.getShaderInfoLog(S).trim(),
                    O = s.getShaderInfoLog(A).trim(),
                    I = !0,
                    D = !0;
                return !1 === s.getProgramParameter(w, 35714) ? (I = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(w, 35715), "gl.getProgramInfoLog", C, R, O)) : "" !== C ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C) : "" !== R && "" !== O || (D = !1), D && (this.diagnostics = {
                    runnable: I,
                    material: n,
                    programLog: C,
                    vertexShader: {
                        log: R,
                        prefix: v
                    },
                    fragmentShader: {
                        log: O,
                        prefix: y
                    }
                }), s.deleteShader(S), s.deleteShader(A), this.getUniforms = function() {
                    return void 0 === P && (P = new Fn(s, w, t)), P
                }, this.getAttributes = function() {
                    return void 0 === L && (L = function(t, e) {
                        for (var i = {}, n = t.getProgramParameter(e, 35721), r = 0; r < n; r++) {
                            var o = t.getActiveAttrib(e, r).name;
                            i[o] = t.getAttribLocation(e, o)
                        }
                        return i
                    }(s, w)), L
                }, this.destroy = function() {
                    s.deleteProgram(w), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.name = r.name, this.id = Un++, this.code = i, this.usedTimes = 1, this.program = w, this.vertexShader = S, this.fragmentShader = A, this
            }

            function Zn(t, e, i) {
                var n = [],
                    r = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

                function a(t, e) {
                    var i;
                    return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = Pe, i === Pe && e && (i = Ce), i
                }
                this.getParameters = function(e, n, o, s, c, l, h) {
                    var u = r[e.type],
                        d = h.isSkinnedMesh ? function(t) {
                            var e = t.skeleton.bones;
                            if (i.floatVertexTextures) return 1024;
                            var n = i.maxVertexUniforms,
                                r = Math.floor((n - 20) / 4),
                                o = Math.min(r, e.length);
                            return o < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + o + "."), 0) : o
                        }(h) : 0,
                        p = i.precision;
                    null !== e.precision && (p = i.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", p, "instead.");
                    var f = t.getRenderTarget();
                    return {
                        shaderID: u,
                        precision: p,
                        supportsVertexTextures: i.vertexTextures,
                        outputEncoding: a(f ? f.texture : null, t.gammaOutput),
                        map: !!e.map,
                        mapEncoding: a(e.map, t.gammaInput),
                        matcap: !!e.matcap,
                        matcapEncoding: a(e.matcap, t.gammaInput),
                        envMap: !!e.envMap,
                        envMapMode: e.envMap && e.envMap.mapping,
                        envMapEncoding: a(e.envMap, t.gammaInput),
                        envMapCubeUV: !!e.envMap && (e.envMap.mapping === mt || e.envMap.mapping === gt),
                        lightMap: !!e.lightMap,
                        aoMap: !!e.aoMap,
                        emissiveMap: !!e.emissiveMap,
                        emissiveMapEncoding: a(e.emissiveMap, t.gammaInput),
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        objectSpaceNormalMap: e.normalMapType === ze,
                        displacementMap: !!e.displacementMap,
                        roughnessMap: !!e.roughnessMap,
                        metalnessMap: !!e.metalnessMap,
                        specularMap: !!e.specularMap,
                        alphaMap: !!e.alphaMap,
                        gradientMap: !!e.gradientMap,
                        combine: e.combine,
                        vertexColors: e.vertexColors,
                        fog: !!s,
                        useFog: e.fog,
                        fogExp: s && s.isFogExp2,
                        flatShading: e.flatShading,
                        sizeAttenuation: e.sizeAttenuation,
                        logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                        skinning: e.skinning && d > 0,
                        maxBones: d,
                        useVertexTexture: i.floatVertexTextures,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: t.maxMorphTargets,
                        maxMorphNormals: t.maxMorphNormals,
                        numDirLights: n.directional.length,
                        numPointLights: n.point.length,
                        numSpotLights: n.spot.length,
                        numRectAreaLights: n.rectArea.length,
                        numHemiLights: n.hemi.length,
                        numClippingPlanes: c,
                        numClipIntersection: l,
                        dithering: e.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && h.receiveShadow && o.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: t.toneMapping,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: e.premultipliedAlpha,
                        alphaTest: e.alphaTest,
                        doubleSided: e.side === y,
                        flipSided: e.side === v,
                        depthPacking: void 0 !== e.depthPacking && e.depthPacking
                    }
                }, this.getProgramCode = function(e, i) {
                    var n = [];
                    if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                        for (var r in e.defines) n.push(r), n.push(e.defines[r]);
                    for (var a = 0; a < o.length; a++) n.push(i[o[a]]);
                    return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.push(t.gammaFactor), n.join()
                }, this.acquireProgram = function(r, o, a, s) {
                    for (var c, l = 0, h = n.length; l < h; l++) {
                        var u = n[l];
                        if (u.code === s) {
                            ++(c = u).usedTimes;
                            break
                        }
                    }
                    return void 0 === c && (c = new Yn(t, e, s, r, o, a, i), n.push(c)), c
                }, this.releaseProgram = function(t) {
                    if (0 == --t.usedTimes) {
                        var e = n.indexOf(t);
                        n[e] = n[n.length - 1], n.pop(), t.destroy()
                    }
                }, this.programs = n
            }

            function Jn(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function Kn(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function Qn() {
                var t = [],
                    e = 0,
                    i = [],
                    n = [];

                function r(i, n, r, o, a) {
                    var s = t[e];
                    return void 0 === s ? (s = {
                        id: i.id,
                        object: i,
                        geometry: n,
                        material: r,
                        program: r.program,
                        renderOrder: i.renderOrder,
                        z: o,
                        group: a
                    }, t[e] = s) : (s.id = i.id, s.object = i, s.geometry = n, s.material = r, s.program = r.program, s.renderOrder = i.renderOrder, s.z = o, s.group = a), e++, s
                }
                return {
                    opaque: i,
                    transparent: n,
                    init: function() {
                        e = 0, i.length = 0, n.length = 0
                    },
                    push: function(t, e, o, a, s) {
                        var c = r(t, e, o, a, s);
                        (!0 === o.transparent ? n : i).push(c)
                    },
                    unshift: function(t, e, o, a, s) {
                        var c = r(t, e, o, a, s);
                        (!0 === o.transparent ? n : i).unshift(c)
                    },
                    sort: function() {
                        i.length > 1 && i.sort(Jn), n.length > 1 && n.sort(Kn)
                    }
                }
            }
            var $n = 0;

            function tr() {
                var t = new function() {
                        var t = {};
                        return {
                            get: function(e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                var i;
                                switch (e.type) {
                                    case "DirectionalLight":
                                        i = {
                                            direction: new je,
                                            color: new ci,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ge
                                        };
                                        break;
                                    case "SpotLight":
                                        i = {
                                            position: new je,
                                            direction: new je,
                                            color: new ci,
                                            distance: 0,
                                            coneCos: 0,
                                            penumbraCos: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ge
                                        };
                                        break;
                                    case "PointLight":
                                        i = {
                                            position: new je,
                                            color: new ci,
                                            distance: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ge,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        };
                                        break;
                                    case "HemisphereLight":
                                        i = {
                                            direction: new je,
                                            skyColor: new ci,
                                            groundColor: new ci
                                        };
                                        break;
                                    case "RectAreaLight":
                                        i = {
                                            color: new ci,
                                            position: new je,
                                            halfWidth: new je,
                                            halfHeight: new je
                                        }
                                }
                                return t[e.id] = i, i
                            }
                        }
                    },
                    e = {
                        id: $n++,
                        hash: {
                            stateID: -1,
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            shadowsLength: -1
                        },
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    },
                    i = new je,
                    n = new He,
                    r = new He;
                return {
                    setup: function(o, a, s) {
                        for (var c = 0, l = 0, h = 0, u = 0, d = 0, p = 0, f = 0, m = 0, g = s.matrixWorldInverse, v = 0, y = o.length; v < y; v++) {
                            var _ = o[v],
                                x = _.color,
                                b = _.intensity,
                                w = _.distance,
                                M = _.shadow && _.shadow.map ? _.shadow.map.texture : null;
                            if (_.isAmbientLight) c += x.r * b, l += x.g * b, h += x.b * b;
                            else if (_.isDirectionalLight) {
                                if ((E = t.get(_)).color.copy(_.color).multiplyScalar(_.intensity), E.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), E.direction.sub(i), E.direction.transformDirection(g), E.shadow = _.castShadow, _.castShadow) {
                                    var T = _.shadow;
                                    E.shadowBias = T.bias, E.shadowRadius = T.radius, E.shadowMapSize = T.mapSize
                                }
                                e.directionalShadowMap[u] = M, e.directionalShadowMatrix[u] = _.shadow.matrix, e.directional[u] = E, u++
                            } else if (_.isSpotLight)(E = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(g), E.color.copy(x).multiplyScalar(b), E.distance = w, E.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), E.direction.sub(i), E.direction.transformDirection(g), E.coneCos = Math.cos(_.angle), E.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)), E.decay = _.decay, E.shadow = _.castShadow, _.castShadow && (T = _.shadow, E.shadowBias = T.bias, E.shadowRadius = T.radius, E.shadowMapSize = T.mapSize), e.spotShadowMap[p] = M, e.spotShadowMatrix[p] = _.shadow.matrix, e.spot[p] = E, p++;
                            else if (_.isRectAreaLight)(E = t.get(_)).color.copy(x).multiplyScalar(b), E.position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(g), r.identity(), n.copy(_.matrixWorld), n.premultiply(g), r.extractRotation(n), E.halfWidth.set(.5 * _.width, 0, 0), E.halfHeight.set(0, .5 * _.height, 0), E.halfWidth.applyMatrix4(r), E.halfHeight.applyMatrix4(r), e.rectArea[f] = E, f++;
                            else if (_.isPointLight)(E = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(g), E.color.copy(_.color).multiplyScalar(_.intensity), E.distance = _.distance, E.decay = _.decay, E.shadow = _.castShadow, _.castShadow && (T = _.shadow, E.shadowBias = T.bias, E.shadowRadius = T.radius, E.shadowMapSize = T.mapSize, E.shadowCameraNear = T.camera.near, E.shadowCameraFar = T.camera.far), e.pointShadowMap[d] = M, e.pointShadowMatrix[d] = _.shadow.matrix, e.point[d] = E, d++;
                            else if (_.isHemisphereLight) {
                                var E;
                                (E = t.get(_)).direction.setFromMatrixPosition(_.matrixWorld), E.direction.transformDirection(g), E.direction.normalize(), E.skyColor.copy(_.color).multiplyScalar(b), E.groundColor.copy(_.groundColor).multiplyScalar(b), e.hemi[m] = E, m++
                            }
                        }
                        e.ambient[0] = c, e.ambient[1] = l, e.ambient[2] = h, e.directional.length = u, e.spot.length = p, e.rectArea.length = f, e.point.length = d, e.hemi.length = m, e.hash.stateID = e.id, e.hash.directionalLength = u, e.hash.pointLength = d, e.hash.spotLength = p, e.hash.rectAreaLength = f, e.hash.hemiLength = m, e.hash.shadowsLength = a.length
                    },
                    state: e
                }
            }

            function er() {
                var t = new tr,
                    e = [],
                    i = [];
                return {
                    init: function() {
                        e.length = 0, i.length = 0
                    },
                    state: {
                        lightsArray: e,
                        shadowsArray: i,
                        lights: t
                    },
                    setupLights: function(n) {
                        t.setup(e, i, n)
                    },
                    pushLight: function(t) {
                        e.push(t)
                    },
                    pushShadow: function(t) {
                        i.push(t)
                    }
                }
            }

            function ir(t) {
                zi.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Ne, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function nr(t) {
                zi.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new je, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function rr(t, e, i) {
                for (var n = new ii, r = new He, o = new Ge, a = new Ge(i, i), s = new je, c = new je, l = 1, h = 2, u = 1 + (l | h), d = new Array(u), p = new Array(u), m = {}, _ = {
                        0: v,
                        1: g,
                        2: y
                    }, x = [new je(1, 0, 0), new je(-1, 0, 0), new je(0, 0, 1), new je(0, 0, -1), new je(0, 1, 0), new je(0, -1, 0)], b = [new je(0, 1, 0), new je(0, 1, 0), new je(0, 1, 0), new je(0, 1, 0), new je(0, 0, 1), new je(0, 0, -1)], w = [new Ze, new Ze, new Ze, new Ze, new Ze, new Ze], M = 0; M !== u; ++M) {
                    var T = 0 != (M & l),
                        E = 0 != (M & h),
                        S = new ir({
                            depthPacking: Be,
                            morphTargets: T,
                            skinning: E
                        });
                    d[M] = S;
                    var A = new nr({
                        morphTargets: T,
                        skinning: E
                    });
                    p[M] = A
                }
                var P = this;

                function L(e, i, n, r, o, a) {
                    var s = e.geometry,
                        c = null,
                        u = d,
                        f = e.customDepthMaterial;
                    if (n && (u = p, f = e.customDistanceMaterial), f) c = f;
                    else {
                        var g = !1;
                        i.morphTargets && (s && s.isBufferGeometry ? g = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (g = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                        var v = e.isSkinnedMesh && i.skinning,
                            y = 0;
                        g && (y |= l), v && (y |= h), c = u[y]
                    }
                    if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                        var x = c.uuid,
                            b = i.uuid,
                            w = m[x];
                        void 0 === w && (w = {}, m[x] = w);
                        var M = w[b];
                        void 0 === M && (M = c.clone(), w[b] = M), c = M
                    }
                    return c.visible = i.visible, c.wireframe = i.wireframe, c.side = null != i.shadowSide ? i.shadowSide : _[i.side], c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, n && c.isMeshDistanceMaterial && (c.referencePosition.copy(r), c.nearDistance = o, c.farDistance = a), c
                }

                function C(i, r, o, a) {
                    if (!1 !== i.visible) {
                        if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || n.intersectsObject(i))) {
                            i.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, i.matrixWorld);
                            var s = e.update(i),
                                l = i.material;
                            if (Array.isArray(l))
                                for (var h = s.groups, u = 0, d = h.length; u < d; u++) {
                                    var p = h[u],
                                        f = l[p.materialIndex];
                                    if (f && f.visible) {
                                        var m = L(i, f, a, c, o.near, o.far);
                                        t.renderBufferDirect(o, null, s, m, i, p)
                                    }
                                } else if (l.visible) {
                                    m = L(i, l, a, c, o.near, o.far);
                                    t.renderBufferDirect(o, null, s, m, i, null)
                                }
                        }
                        for (var g = i.children, v = 0, y = g.length; v < y; v++) C(g[v], r, o, a)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = f, this.render = function(e, i, l) {
                    if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== e.length) {
                        t.context;
                        var h, u = t.state;
                        u.disable(3042), u.buffers.color.setClear(1, 1, 1, 1), u.buffers.depth.setTest(!0), u.setScissorTest(!1);
                        for (var d = 0, p = e.length; d < p; d++) {
                            var f = e[d],
                                m = f.shadow,
                                g = f && f.isPointLight;
                            if (void 0 !== m) {
                                var v = m.camera;
                                if (o.copy(m.mapSize), o.min(a), g) {
                                    var y = o.x,
                                        _ = o.y;
                                    w[0].set(2 * y, _, y, _), w[1].set(0, _, y, _), w[2].set(3 * y, _, y, _), w[3].set(y, _, y, _), w[4].set(3 * y, 0, y, _), w[5].set(y, 0, y, _), o.x *= 4, o.y *= 2
                                }
                                if (null === m.map) {
                                    var M = {
                                        minFilter: xt,
                                        magFilter: xt,
                                        format: Ut
                                    };
                                    m.map = new Je(o.x, o.y, M), m.map.texture.name = f.name + ".shadowMap", v.updateProjectionMatrix()
                                }
                                m.isSpotLightShadow && m.update(f);
                                var T = m.map,
                                    E = m.matrix;
                                c.setFromMatrixPosition(f.matrixWorld), v.position.copy(c), g ? (h = 6, E.makeTranslation(-c.x, -c.y, -c.z)) : (h = 1, s.setFromMatrixPosition(f.target.matrixWorld), v.lookAt(s), v.updateMatrixWorld(), E.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), E.multiply(v.projectionMatrix), E.multiply(v.matrixWorldInverse)), t.setRenderTarget(T), t.clear();
                                for (var S = 0; S < h; S++) {
                                    if (g) {
                                        s.copy(v.position), s.add(x[S]), v.up.copy(b[S]), v.lookAt(s), v.updateMatrixWorld();
                                        var A = w[S];
                                        u.viewport(A)
                                    }
                                    r.multiplyMatrices(v.projectionMatrix, v.matrixWorldInverse), n.setFromMatrix(r), C(i, l, v, g)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", f, "has no shadow.")
                        }
                        P.needsUpdate = !1
                    }
                }
            }

            function or(t, e, i, n, r, o, a) {
                var s, c = {};

                function l(t, e) {
                    if (t.width > e || t.height > e) {
                        if ("data" in t) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + t.width + "x" + t.height + ").");
                        var i = e / Math.max(t.width, t.height),
                            n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return n.width = Math.floor(t.width * i), n.height = Math.floor(t.height * i), n.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + n.width + "x" + n.height), n
                    }
                    return t
                }

                function h(t) {
                    return Ue.isPowerOfTwo(t.width) && Ue.isPowerOfTwo(t.height)
                }

                function u(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== xt && t.minFilter !== Mt
                }

                function d(e, i, r, o) {
                    t.generateMipmap(e), n.get(i).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
                }

                function p(t, e) {
                    if (!r.isWebGL2) return t;
                    if (6403 === t) {
                        if (5126 === e) return 33326;
                        if (5131 === e) return 33325;
                        if (5121 === e) return 33321
                    }
                    if (6407 === t) {
                        if (5126 === e) return 34837;
                        if (5131 === e) return 34843;
                        if (5121 === e) return 32849
                    }
                    if (6408 === t) {
                        if (5126 === e) return 34836;
                        if (5131 === e) return 34842;
                        if (5121 === e) return 32856
                    }
                    return t
                }

                function f(t) {
                    return t === xt || t === bt || t === wt ? 9728 : 9729
                }

                function m(e) {
                    var i = e.target;
                    i.removeEventListener("dispose", m),
                        function(e) {
                            var i = n.get(e);
                            if (e.image && i.__image__webglTextureCube) t.deleteTexture(i.__image__webglTextureCube);
                            else {
                                if (void 0 === i.__webglInit) return;
                                t.deleteTexture(i.__webglTexture)
                            }
                            n.remove(e)
                        }(i), i.isVideoTexture && delete c[i.id], a.memory.textures--
                }

                function g(e) {
                    var i = e.target;
                    i.removeEventListener("dispose", g),
                        function(e) {
                            var i = n.get(e),
                                r = n.get(e.texture);
                            if (!e) return;
                            void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLRenderTargetCube)
                                for (var o = 0; o < 6; o++) t.deleteFramebuffer(i.__webglFramebuffer[o]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[o]);
                            else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                            n.remove(e.texture), n.remove(e)
                        }(i), a.memory.textures--
                }

                function v(t, e) {
                    var r = n.get(t);
                    if (t.isVideoTexture && function(t) {
                            var e = t.id,
                                i = a.render.frame;
                            c[e] !== i && (c[e] = i, t.update())
                        }(t), t.version > 0 && r.__version !== t.version) {
                        var o = t.image;
                        if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== o.complete) return void _(r, t, e);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture)
                }

                function y(i, a, s) {
                    var c;
                    if (s ? (t.texParameteri(i, 10242, o.convert(a.wrapS)), t.texParameteri(i, 10243, o.convert(a.wrapT)), t.texParameteri(i, 10240, o.convert(a.magFilter)), t.texParameteri(i, 10241, o.convert(a.minFilter))) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), a.wrapS === yt && a.wrapT === yt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, f(a.magFilter)), t.texParameteri(i, 10241, f(a.minFilter)), a.minFilter !== xt && a.minFilter !== Mt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c = e.get("EXT_texture_filter_anisotropic")) {
                        if (a.type === Ot && null === e.get("OES_texture_float_linear")) return;
                        if (a.type === It && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear"))) return;
                        (a.anisotropy > 1 || n.get(a).__currentAnisotropy) && (t.texParameterf(i, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function _(e, n, c) {
                    var f;
                    f = n.isDataTexture3D ? 32879 : 3553, void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", m), e.__webglTexture = t.createTexture(), a.memory.textures++), i.activeTexture(33984 + c), i.bindTexture(f, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment);
                    var g = l(n.image, r.maxTextureSize);
                    (function(t) {
                        return !r.isWebGL2 && (t.wrapS !== yt || t.wrapT !== yt || t.minFilter !== xt && t.minFilter !== Mt)
                    })(n) && !1 === h(g) && (g = function(t) {
                        return t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap ? (void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), s.width = Ue.floorPowerOfTwo(t.width), s.height = Ue.floorPowerOfTwo(t.height), s.getContext("2d").drawImage(t, 0, 0, s.width, s.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + s.width + "x" + s.height), s) : t
                    }(g));
                    var v = h(g),
                        _ = o.convert(n.format),
                        x = o.convert(n.type),
                        b = p(_, x);
                    y(f, n, v);
                    var w, M = n.mipmaps;
                    if (n.isDepthTexture) {
                        if (b = 6402, n.type === Ot) {
                            if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            b = 36012
                        } else r.isWebGL2 && (b = 33189);
                        n.format === jt && 6402 === b && n.type !== Lt && n.type !== Rt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = Lt, x = o.convert(n.type)), n.format === Wt && (b = 34041, n.type !== Bt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = Bt, x = o.convert(n.type))), i.texImage2D(3553, 0, b, g.width, g.height, 0, _, x, null)
                    } else if (n.isDataTexture)
                        if (M.length > 0 && v) {
                            for (var T = 0, E = M.length; T < E; T++) w = M[T], i.texImage2D(3553, T, b, w.width, w.height, 0, _, x, w.data);
                            n.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                        } else i.texImage2D(3553, 0, b, g.width, g.height, 0, _, x, g.data), e.__maxMipLevel = 0;
                    else if (n.isCompressedTexture) {
                        for (T = 0, E = M.length; T < E; T++) w = M[T], n.format !== Ut && n.format !== zt ? i.getCompressedTextureFormats().indexOf(_) > -1 ? i.compressedTexImage2D(3553, T, b, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, T, b, w.width, w.height, 0, _, x, w.data);
                        e.__maxMipLevel = M.length - 1
                    } else if (n.isDataTexture3D) i.texImage3D(32879, 0, b, g.width, g.height, g.depth, 0, _, x, g.data), e.__maxMipLevel = 0;
                    else if (M.length > 0 && v) {
                        for (T = 0, E = M.length; T < E; T++) w = M[T], i.texImage2D(3553, T, b, _, x, w);
                        n.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                    } else i.texImage2D(3553, 0, b, _, x, g), e.__maxMipLevel = 0;
                    u(n, v) && d(3553, n, g.width, g.height), e.__version = n.version, n.onUpdate && n.onUpdate(n)
                }

                function x(e, r, a, s) {
                    var c = o.convert(r.texture.format),
                        l = o.convert(r.texture.type),
                        h = p(c, l);
                    i.texImage2D(s, 0, h, r.width, r.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, s, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
                }

                function b(e, i) {
                    t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer ? (t.renderbufferStorage(36161, 33189, i.width, i.height), t.framebufferRenderbuffer(36160, 36096, 36161, e)) : i.depthBuffer && i.stencilBuffer ? (t.renderbufferStorage(36161, 34041, i.width, i.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)) : t.renderbufferStorage(36161, 32854, i.width, i.height), t.bindRenderbuffer(36161, null)
                }

                function w(e) {
                    var i = n.get(e),
                        r = !0 === e.isWebGLRenderTargetCube;
                    if (e.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, i) {
                            if (i && i.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), v(i.depthTexture, 0);
                            var r = n.get(i.depthTexture).__webglTexture;
                            if (i.depthTexture.format === jt) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                            else {
                                if (i.depthTexture.format !== Wt) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                            }
                        }(i.__webglFramebuffer, e)
                    } else if (r) {
                        i.__webglDepthbuffer = [];
                        for (var o = 0; o < 6; o++) t.bindFramebuffer(36160, i.__webglFramebuffer[o]), i.__webglDepthbuffer[o] = t.createRenderbuffer(), b(i.__webglDepthbuffer[o], e)
                    } else t.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), b(i.__webglDepthbuffer, e);
                    t.bindFramebuffer(36160, null)
                }
                this.setTexture2D = v, this.setTexture3D = function(t, e) {
                    var r = n.get(t);
                    t.version > 0 && r.__version !== t.version ? _(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = function(e, s) {
                    var c = n.get(e);
                    if (6 === e.image.length)
                        if (e.version > 0 && c.__version !== e.version) {
                            c.__image__webglTextureCube || (e.addEventListener("dispose", m), c.__image__webglTextureCube = t.createTexture(), a.memory.textures++), i.activeTexture(33984 + s), i.bindTexture(34067, c.__image__webglTextureCube), t.pixelStorei(37440, e.flipY);
                            for (var f = e && e.isCompressedTexture, g = e.image[0] && e.image[0].isDataTexture, v = [], _ = 0; _ < 6; _++) v[_] = f || g ? g ? e.image[_].image : e.image[_] : l(e.image[_], r.maxCubemapSize);
                            var x = v[0],
                                b = h(x),
                                w = o.convert(e.format),
                                M = o.convert(e.type),
                                T = p(w, M);
                            for (y(34067, e, b), _ = 0; _ < 6; _++)
                                if (f)
                                    for (var E, S = v[_].mipmaps, A = 0, P = S.length; A < P; A++) E = S[A], e.format !== Ut && e.format !== zt ? i.getCompressedTextureFormats().indexOf(w) > -1 ? i.compressedTexImage2D(34069 + _, A, T, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + _, A, T, E.width, E.height, 0, w, M, E.data);
                                else g ? i.texImage2D(34069 + _, 0, T, v[_].width, v[_].height, 0, w, M, v[_].data) : i.texImage2D(34069 + _, 0, T, w, M, v[_]);
                            c.__maxMipLevel = f ? S.length - 1 : 0, u(e, b) && d(34067, e, x.width, x.height), c.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else i.activeTexture(33984 + s), i.bindTexture(34067, c.__image__webglTextureCube)
                }, this.setTextureCubeDynamic = function(t, e) {
                    i.activeTexture(33984 + e), i.bindTexture(34067, n.get(t).__webglTexture)
                }, this.setupRenderTarget = function(e) {
                    var r = n.get(e),
                        o = n.get(e.texture);
                    e.addEventListener("dispose", g), o.__webglTexture = t.createTexture(), a.memory.textures++;
                    var s = !0 === e.isWebGLRenderTargetCube,
                        c = h(e);
                    if (s) {
                        r.__webglFramebuffer = [];
                        for (var l = 0; l < 6; l++) r.__webglFramebuffer[l] = t.createFramebuffer()
                    } else r.__webglFramebuffer = t.createFramebuffer();
                    if (s) {
                        for (i.bindTexture(34067, o.__webglTexture), y(34067, e.texture, c), l = 0; l < 6; l++) x(r.__webglFramebuffer[l], e, 36064, 34069 + l);
                        u(e.texture, c) && d(34067, e.texture, e.width, e.height), i.bindTexture(34067, null)
                    } else i.bindTexture(3553, o.__webglTexture), y(3553, e.texture, c), x(r.__webglFramebuffer, e, 36064, 3553), u(e.texture, c) && d(3553, e.texture, e.width, e.height), i.bindTexture(3553, null);
                    e.depthBuffer && w(e)
                }, this.updateRenderTargetMipmap = function(t) {
                    var e = t.texture;
                    if (u(e, h(t))) {
                        var r = t.isWebGLRenderTargetCube ? 34067 : 3553,
                            o = n.get(e).__webglTexture;
                        i.bindTexture(r, o), d(r, e, t.width, t.height), i.bindTexture(r, null)
                    }
                }
            }

            function ar(t, e, i) {
                return {
                    convert: function(t) {
                        var n;
                        if (t === vt) return 10497;
                        if (t === yt) return 33071;
                        if (t === _t) return 33648;
                        if (t === xt) return 9728;
                        if (t === bt) return 9984;
                        if (t === wt) return 9986;
                        if (t === Mt) return 9729;
                        if (t === Tt) return 9985;
                        if (t === Et) return 9987;
                        if (t === St) return 5121;
                        if (t === Dt) return 32819;
                        if (t === kt) return 32820;
                        if (t === Nt) return 33635;
                        if (t === At) return 5120;
                        if (t === Pt) return 5122;
                        if (t === Lt) return 5123;
                        if (t === Ct) return 5124;
                        if (t === Rt) return 5125;
                        if (t === Ot) return 5126;
                        if (t === It) {
                            if (i.isWebGL2) return 5131;
                            if (null !== (n = e.get("OES_texture_half_float"))) return n.HALF_FLOAT_OES
                        }
                        if (t === Ft) return 6406;
                        if (t === zt) return 6407;
                        if (t === Ut) return 6408;
                        if (t === Gt) return 6409;
                        if (t === Ht) return 6410;
                        if (t === jt) return 6402;
                        if (t === Wt) return 34041;
                        if (t === Xt) return 6403;
                        if (t === C) return 32774;
                        if (t === R) return 32778;
                        if (t === O) return 32779;
                        if (t === k) return 0;
                        if (t === N) return 1;
                        if (t === B) return 768;
                        if (t === F) return 769;
                        if (t === z) return 770;
                        if (t === U) return 771;
                        if (t === G) return 772;
                        if (t === H) return 773;
                        if (t === V) return 774;
                        if (t === j) return 775;
                        if (t === W) return 776;
                        if ((t === qt || t === Yt || t === Zt || t === Jt) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) {
                            if (t === qt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === Yt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === Zt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === Jt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if ((t === Kt || t === Qt || t === $t || t === te) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) {
                            if (t === Kt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (t === Qt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (t === $t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (t === te) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (t === ee && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                        if ((t === ie || t === ne || t === re || t === oe || t === ae || t === se || t === ce || t === le || t === he || t === ue || t === de || t === pe || t === fe || t === me) && null !== (n = e.get("WEBGL_compressed_texture_astc"))) return t;
                        if (t === I || t === D) {
                            if (i.isWebGL2) {
                                if (t === I) return 32775;
                                if (t === D) return 32776
                            }
                            if (null !== (n = e.get("EXT_blend_minmax"))) {
                                if (t === I) return n.MIN_EXT;
                                if (t === D) return n.MAX_EXT
                            }
                        }
                        if (t === Bt) {
                            if (i.isWebGL2) return 34042;
                            if (null !== (n = e.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
                        }
                        return 0
                    }
                }
            }

            function sr() {
                vi.call(this), this.type = "Group"
            }

            function cr() {
                vi.call(this), this.type = "Camera", this.matrixWorldInverse = new He, this.projectionMatrix = new He, this.projectionMatrixInverse = new He
            }

            function lr(t, e, i, n) {
                cr.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            function hr(t) {
                lr.call(this), this.cameras = t || []
            }
            ir.prototype = Object.create(zi.prototype), ir.prototype.constructor = ir, ir.prototype.isMeshDepthMaterial = !0, ir.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, nr.prototype = Object.create(zi.prototype), nr.prototype.constructor = nr, nr.prototype.isMeshDistanceMaterial = !0, nr.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }, sr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: sr,
                isGroup: !0
            }), cr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: cr,
                isCamera: !0,
                copy: function(t, e) {
                    return vi.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new je), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    vi.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), lr.prototype = Object.assign(Object.create(cr.prototype), {
                constructor: lr,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return cr.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    var e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * Ue.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var t = Math.tan(.5 * Ue.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * Ue.RAD2DEG * Math.atan(Math.tan(.5 * Ue.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, i, n, r, o) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = this.near,
                        e = t * Math.tan(.5 * Ue.DEG2RAD * this.fov) / this.zoom,
                        i = 2 * e,
                        n = this.aspect * i,
                        r = -.5 * n,
                        o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var a = o.fullWidth,
                            s = o.fullHeight;
                        r += o.offsetX * n / a, e -= o.offsetY * i / s, n *= o.width / a, i *= o.height / s
                    }
                    var c = this.filmOffset;
                    0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            }), hr.prototype = Object.assign(Object.create(lr.prototype), {
                constructor: hr,
                isArrayCamera: !0
            });
            var ur, dr = new je,
                pr = new je;

            function fr(t, e, i) {
                dr.setFromMatrixPosition(e.matrixWorld), pr.setFromMatrixPosition(i.matrixWorld);
                var n = dr.distanceTo(pr),
                    r = e.projectionMatrix.elements,
                    o = i.projectionMatrix.elements,
                    a = r[14] / (r[10] - 1),
                    s = r[14] / (r[10] + 1),
                    c = (r[9] + 1) / r[5],
                    l = (r[9] - 1) / r[5],
                    h = (r[8] - 1) / r[0],
                    u = (o[8] + 1) / o[0],
                    d = a * h,
                    p = a * u,
                    f = n / (-h + u),
                    m = f * -h;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                var g = a + f,
                    v = s + f,
                    y = d - m,
                    _ = p + (n - m),
                    x = c * s / v * g,
                    b = l * s / v * g;
                t.projectionMatrix.makePerspective(y, _, x, b, g, v)
            }

            function mr(t) {
                var e = this,
                    i = null,
                    n = null,
                    r = null,
                    o = [],
                    a = new He,
                    s = new He,
                    c = 1,
                    l = "stage";
                "undefined" != typeof window && "VRFrameData" in window && (n = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", _, !1));
                var h = new He,
                    u = new Ve,
                    d = new je,
                    p = new lr;
                p.bounds = new Ze(0, 0, .5, 1), p.layers.enable(1);
                var f = new lr;
                f.bounds = new Ze(.5, 0, .5, 1), f.layers.enable(2);
                var m, g, v = new hr([p, f]);

                function y() {
                    return null !== i && !0 === i.isPresenting
                }

                function _() {
                    if (y()) {
                        var n = i.getEyeParameters("left"),
                            r = n.renderWidth * c,
                            o = n.renderHeight * c;
                        g = t.getPixelRatio(), m = t.getSize(), t.setDrawingBufferSize(2 * r, o, 1), w.start()
                    } else e.enabled && t.setDrawingBufferSize(m.width, m.height, g), w.stop()
                }
                v.layers.enable(1), v.layers.enable(2);
                var x = [];

                function b(t) {
                    for (var e = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        if (o && ("Daydream Controller" === o.id || "Gear VR Controller" === o.id || "Oculus Go Controller" === o.id || "OpenVR Gamepad" === o.id || o.id.startsWith("Oculus Touch") || o.id.startsWith("Spatial Controller"))) {
                            if (n === t) return o;
                            n++
                        }
                    }
                }
                this.enabled = !1, this.getController = function(t) {
                    var e = o[t];
                    return void 0 === e && ((e = new sr).matrixAutoUpdate = !1, e.visible = !1, o[t] = e), e
                }, this.getDevice = function() {
                    return i
                }, this.setDevice = function(t) {
                    void 0 !== t && (i = t), w.setContext(t)
                }, this.setFramebufferScaleFactor = function(t) {
                    c = t
                }, this.setFrameOfReferenceType = function(t) {
                    l = t
                }, this.setPoseTarget = function(t) {
                    void 0 !== t && (r = t)
                }, this.getCamera = function(t) {
                    var e = "stage" === l ? 1.6 : 0;
                    if (null === i) return t.position.set(0, e, 0), t;
                    if (i.depthNear = t.near, i.depthFar = t.far, i.getFrameData(n), "stage" === l) {
                        var c = i.stageParameters;
                        c ? a.fromArray(c.sittingToStandingTransform) : a.makeTranslation(0, e, 0)
                    }
                    var m = n.pose,
                        g = null !== r ? r : t;
                    if (g.matrix.copy(a), g.matrix.decompose(g.position, g.quaternion, g.scale), null !== m.orientation && (u.fromArray(m.orientation), g.quaternion.multiply(u)), null !== m.position && (u.setFromRotationMatrix(a), d.fromArray(m.position), d.applyQuaternion(u), g.position.add(d)), g.updateMatrixWorld(), !1 === i.isPresenting) return t;
                    p.near = t.near, f.near = t.near, p.far = t.far, f.far = t.far, p.matrixWorldInverse.fromArray(n.leftViewMatrix), f.matrixWorldInverse.fromArray(n.rightViewMatrix), s.getInverse(a), "stage" === l && (p.matrixWorldInverse.multiply(s), f.matrixWorldInverse.multiply(s));
                    var y = g.parent;
                    null !== y && (h.getInverse(y.matrixWorld), p.matrixWorldInverse.multiply(h), f.matrixWorldInverse.multiply(h)), p.matrixWorld.getInverse(p.matrixWorldInverse), f.matrixWorld.getInverse(f.matrixWorldInverse), p.projectionMatrix.fromArray(n.leftProjectionMatrix), f.projectionMatrix.fromArray(n.rightProjectionMatrix), fr(v, p, f);
                    var _ = i.getLayers();
                    if (_.length) {
                        var w = _[0];
                        null !== w.leftBounds && 4 === w.leftBounds.length && p.bounds.fromArray(w.leftBounds), null !== w.rightBounds && 4 === w.rightBounds.length && f.bounds.fromArray(w.rightBounds)
                    }
                    return function() {
                        for (var t = 0; t < o.length; t++) {
                            var e = o[t],
                                i = b(t);
                            if (void 0 !== i && void 0 !== i.pose) {
                                if (null === i.pose) return;
                                var n = i.pose;
                                !1 === n.hasPosition && e.position.set(.2, -.6, -.05), null !== n.position && e.position.fromArray(n.position), null !== n.orientation && e.quaternion.fromArray(n.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(a), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
                                var r = "Daydream Controller" === i.id ? 0 : 1;
                                x[t] !== i.buttons[r].pressed && (x[t] = i.buttons[r].pressed, !0 === x[t] ? e.dispatchEvent({
                                    type: "selectstart"
                                }) : (e.dispatchEvent({
                                    type: "selectend"
                                }), e.dispatchEvent({
                                    type: "select"
                                })))
                            } else e.visible = !1
                        }
                    }(), v
                }, this.getStandingMatrix = function() {
                    return a
                }, this.isPresenting = y;
                var w = new ui;
                this.setAnimationLoop = function(t) {
                    w.setAnimationLoop(t)
                }, this.submitFrame = function() {
                    y() && i.submitFrame()
                }, this.dispose = function() {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", _)
                }
            }

            function gr(e) {
                console.log("THREE.WebGLRenderer", o);
                var i = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    n = void 0 !== e.context ? e.context : null,
                    r = void 0 !== e.alpha && e.alpha,
                    a = void 0 === e.depth || e.depth,
                    h = void 0 === e.stencil || e.stencil,
                    u = void 0 !== e.antialias && e.antialias,
                    d = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    p = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    f = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    m = null,
                    _ = null;
                this.domElement = i, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = rt, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var x, b, w, M, R, O, I, D, k, N, B, F, z, U, G, H, V, j, W = this,
                    tt = !1,
                    et = null,
                    it = null,
                    nt = null,
                    ot = -1,
                    at = {
                        geometry: null,
                        program: null,
                        wireframe: !1
                    },
                    st = null,
                    ct = null,
                    lt = new Ze,
                    ht = new Ze,
                    ut = null,
                    dt = 0,
                    pt = i.width,
                    ft = i.height,
                    mt = 1,
                    gt = new Ze(0, 0, pt, ft),
                    vt = new Ze(0, 0, pt, ft),
                    yt = !1,
                    _t = new ii,
                    xt = new function() {
                        var t = this,
                            e = null,
                            i = 0,
                            n = !1,
                            r = !1,
                            o = new ei,
                            a = new We,
                            s = {
                                value: null,
                                needsUpdate: !1
                            };

                        function c() {
                            s.value !== e && (s.value = e, s.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
                        }

                        function l(e, i, n, r) {
                            var c = null !== e ? e.length : 0,
                                l = null;
                            if (0 !== c) {
                                if (l = s.value, !0 !== r || null === l) {
                                    var h = n + 4 * c,
                                        u = i.matrixWorldInverse;
                                    a.getNormalMatrix(u), (null === l || l.length < h) && (l = new Float32Array(h));
                                    for (var d = 0, p = n; d !== c; ++d, p += 4) o.copy(e[d]).applyMatrix4(u, a), o.normal.toArray(l, p), l[p + 3] = o.constant
                                }
                                s.value = l, s.needsUpdate = !0
                            }
                            return t.numPlanes = c, l
                        }
                        this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, r, o) {
                            var a = 0 !== t.length || r || 0 !== i || n;
                            return n = r, e = l(t, o, 0), i = t.length, a
                        }, this.beginShadows = function() {
                            r = !0, l(null)
                        }, this.endShadows = function() {
                            r = !1, c()
                        }, this.setState = function(t, o, a, h, u, d) {
                            if (!n || null === t || 0 === t.length || r && !a) r ? l(null) : c();
                            else {
                                var p = r ? 0 : i,
                                    f = 4 * p,
                                    m = u.clippingState || null;
                                s.value = m, m = l(t, h, f, d);
                                for (var g = 0; g !== f; ++g) m[g] = e[g];
                                u.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += p
                            }
                        }
                    },
                    bt = !1,
                    wt = !1,
                    Mt = new He,
                    Tt = new je;

                function Et() {
                    return null === it ? mt : 1
                }
                try {
                    var At = {
                        alpha: r,
                        depth: a,
                        stencil: h,
                        antialias: u,
                        premultipliedAlpha: d,
                        preserveDrawingBuffer: p,
                        powerPreference: f
                    };
                    if (i.addEventListener("webglcontextlost", Rt, !1), i.addEventListener("webglcontextrestored", Dt, !1), null === (x = n || i.getContext("webgl", At) || i.getContext("experimental-webgl", At))) throw null !== i.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === x.getShaderPrecisionFormat && (x.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    console.error("THREE.WebGLRenderer: " + t.message)
                }

                function Pt() {
                    b = new function(t) {
                        var e = {};
                        return {
                            get: function(i) {
                                if (void 0 !== e[i]) return e[i];
                                var n;
                                switch (i) {
                                    case "WEBGL_depth_texture":
                                        n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                        break;
                                    case "EXT_texture_filter_anisotropic":
                                        n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                        break;
                                    case "WEBGL_compressed_texture_s3tc":
                                        n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                        break;
                                    case "WEBGL_compressed_texture_pvrtc":
                                        n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                        break;
                                    default:
                                        n = t.getExtension(i)
                                }
                                return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n, n
                            }
                        }
                    }(x), (w = new function(t, e, i) {
                        var n;

                        function r(e) {
                            if ("highp" === e) {
                                if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                                e = "mediump"
                            }
                            return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                        }
                        var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                            a = void 0 !== i.precision ? i.precision : "highp",
                            s = r(a);
                        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
                        var c = !0 === i.logarithmicDepthBuffer,
                            l = t.getParameter(34930),
                            h = t.getParameter(35660),
                            u = t.getParameter(3379),
                            d = t.getParameter(34076),
                            p = t.getParameter(34921),
                            f = t.getParameter(36347),
                            m = t.getParameter(36348),
                            g = t.getParameter(36349),
                            v = h > 0,
                            y = o || !!e.get("OES_texture_float");
                        return {
                            isWebGL2: o,
                            getMaxAnisotropy: function() {
                                if (void 0 !== n) return n;
                                var i = e.get("EXT_texture_filter_anisotropic");
                                return n = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                            },
                            getMaxPrecision: r,
                            precision: a,
                            logarithmicDepthBuffer: c,
                            maxTextures: l,
                            maxVertexTextures: h,
                            maxTextureSize: u,
                            maxCubemapSize: d,
                            maxAttributes: p,
                            maxVertexUniforms: f,
                            maxVaryings: m,
                            maxFragmentUniforms: g,
                            vertexTextures: v,
                            floatFragmentTextures: y,
                            floatVertexTextures: v && y
                        }
                    }(x, b, e)).isWebGL2 || (b.get("WEBGL_depth_texture"), b.get("OES_texture_float"), b.get("OES_texture_half_float"), b.get("OES_texture_half_float_linear"), b.get("OES_standard_derivatives"), b.get("OES_element_index_uint"), b.get("ANGLE_instanced_arrays")), b.get("OES_texture_float_linear"), j = new ar(x, b, w), (M = new function(t, e, i, n) {
                        var r = new function() {
                                var e = !1,
                                    i = new Ze,
                                    n = null,
                                    r = new Ze(0, 0, 0, 0);
                                return {
                                    setMask: function(i) {
                                        n === i || e || (t.colorMask(i, i, i, i), n = i)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e, n, o, a, s) {
                                        !0 === s && (e *= a, n *= a, o *= a), i.set(e, n, o, a), !1 === r.equals(i) && (t.clearColor(e, n, o, a), r.copy(i))
                                    },
                                    reset: function() {
                                        e = !1, n = null, r.set(-1, 0, 0, 0)
                                    }
                                }
                            },
                            o = new function() {
                                var e = !1,
                                    i = null,
                                    n = null,
                                    r = null;
                                return {
                                    setTest: function(t) {
                                        t ? ot(2929) : at(2929)
                                    },
                                    setMask: function(n) {
                                        i === n || e || (t.depthMask(n), i = n)
                                    },
                                    setFunc: function(e) {
                                        if (n !== e) {
                                            if (e) switch (e) {
                                                case X:
                                                    t.depthFunc(512);
                                                    break;
                                                case q:
                                                    t.depthFunc(519);
                                                    break;
                                                case Y:
                                                    t.depthFunc(513);
                                                    break;
                                                case Z:
                                                    t.depthFunc(515);
                                                    break;
                                                case J:
                                                    t.depthFunc(514);
                                                    break;
                                                case K:
                                                    t.depthFunc(518);
                                                    break;
                                                case Q:
                                                    t.depthFunc(516);
                                                    break;
                                                case $:
                                                    t.depthFunc(517);
                                                    break;
                                                default:
                                                    t.depthFunc(515)
                                            } else t.depthFunc(515);
                                            n = e
                                        }
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        r !== e && (t.clearDepth(e), r = e)
                                    },
                                    reset: function() {
                                        e = !1, i = null, n = null, r = null
                                    }
                                }
                            },
                            a = new function() {
                                var e = !1,
                                    i = null,
                                    n = null,
                                    r = null,
                                    o = null,
                                    a = null,
                                    s = null,
                                    c = null,
                                    l = null;
                                return {
                                    setTest: function(t) {
                                        t ? ot(2960) : at(2960)
                                    },
                                    setMask: function(n) {
                                        i === n || e || (t.stencilMask(n), i = n)
                                    },
                                    setFunc: function(e, i, a) {
                                        n === e && r === i && o === a || (t.stencilFunc(e, i, a), n = e, r = i, o = a)
                                    },
                                    setOp: function(e, i, n) {
                                        a === e && s === i && c === n || (t.stencilOp(e, i, n), a = e, s = i, c = n)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        l !== e && (t.clearStencil(e), l = e)
                                    },
                                    reset: function() {
                                        e = !1, i = null, n = null, r = null, o = null, a = null, s = null, c = null, l = null
                                    }
                                }
                            },
                            h = t.getParameter(34921),
                            u = new Uint8Array(h),
                            d = new Uint8Array(h),
                            p = new Uint8Array(h),
                            f = {},
                            m = null,
                            g = null,
                            _ = null,
                            x = null,
                            b = null,
                            w = null,
                            M = null,
                            R = null,
                            O = null,
                            I = null,
                            D = !1,
                            k = null,
                            N = null,
                            B = null,
                            F = null,
                            z = null,
                            U = t.getParameter(35661),
                            G = !1,
                            H = 0,
                            V = t.getParameter(7938); - 1 !== V.indexOf("WebGL") ? (H = parseFloat(/^WebGL\ ([0-9])/.exec(V)[1]), G = H >= 1) : -1 !== V.indexOf("OpenGL ES") && (H = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(V)[1]), G = H >= 2);
                        var j = null,
                            W = {},
                            tt = new Ze,
                            et = new Ze;

                        function it(e, i, n) {
                            var r = new Uint8Array(4),
                                o = t.createTexture();
                            t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                            for (var a = 0; a < n; a++) t.texImage2D(i + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
                            return o
                        }
                        var nt = {};

                        function rt(i, r) {
                            u[i] = 1, 0 === d[i] && (t.enableVertexAttribArray(i), d[i] = 1), p[i] !== r && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), p[i] = r)
                        }

                        function ot(e) {
                            !0 !== f[e] && (t.enable(e), f[e] = !0)
                        }

                        function at(e) {
                            !1 !== f[e] && (t.disable(e), f[e] = !1)
                        }

                        function st(e, n, r, o, a, s, c, l) {
                            if (e !== T) {
                                if (_ || (ot(3042), _ = !0), e === L) a = a || n, s = s || r, c = c || o, n === b && a === R || (t.blendEquationSeparate(i.convert(n), i.convert(a)), b = n, R = a), r === w && o === M && s === O && c === I || (t.blendFuncSeparate(i.convert(r), i.convert(o), i.convert(s), i.convert(c)), w = r, M = o, O = s, I = c), x = e, D = null;
                                else if (e !== x || l !== D) {
                                    if (b === C && R === C || (t.blendEquation(32774), b = C, R = C), l) switch (e) {
                                        case E:
                                            t.blendFuncSeparate(1, 771, 1, 771);
                                            break;
                                        case S:
                                            t.blendFunc(1, 1);
                                            break;
                                        case A:
                                            t.blendFuncSeparate(0, 0, 769, 771);
                                            break;
                                        case P:
                                            t.blendFuncSeparate(0, 768, 0, 770);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    } else switch (e) {
                                        case E:
                                            t.blendFuncSeparate(770, 771, 1, 771);
                                            break;
                                        case S:
                                            t.blendFunc(770, 1);
                                            break;
                                        case A:
                                            t.blendFunc(0, 769);
                                            break;
                                        case P:
                                            t.blendFunc(0, 768);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    }
                                    w = null, M = null, O = null, I = null, x = e, D = l
                                }
                            } else _ && (at(3042), _ = !1)
                        }

                        function ct(e) {
                            k !== e && (e ? t.frontFace(2304) : t.frontFace(2305), k = e)
                        }

                        function lt(e) {
                            e !== s ? (ot(2884), e !== N && (e === c ? t.cullFace(1029) : e === l ? t.cullFace(1028) : t.cullFace(1032))) : at(2884), N = e
                        }

                        function ht(e, i, n) {
                            e ? (ot(32823), F === i && z === n || (t.polygonOffset(i, n), F = i, z = n)) : at(32823)
                        }

                        function ut(e) {
                            void 0 === e && (e = 33984 + U - 1), j !== e && (t.activeTexture(e), j = e)
                        }
                        return nt[3553] = it(3553, 3553, 1), nt[34067] = it(34067, 34069, 6), r.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), ot(2929), o.setFunc(Z), ct(!1), lt(c), ot(2884), st(T), {
                            buffers: {
                                color: r,
                                depth: o,
                                stencil: a
                            },
                            initAttributes: function() {
                                for (var t = 0, e = u.length; t < e; t++) u[t] = 0
                            },
                            enableAttribute: function(t) {
                                rt(t, 0)
                            },
                            enableAttributeAndDivisor: rt,
                            disableUnusedAttributes: function() {
                                for (var e = 0, i = d.length; e !== i; ++e) d[e] !== u[e] && (t.disableVertexAttribArray(e), d[e] = 0)
                            },
                            enable: ot,
                            disable: at,
                            getCompressedTextureFormats: function() {
                                if (null === m && (m = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                                    for (var i = t.getParameter(34467), n = 0; n < i.length; n++) m.push(i[n]);
                                return m
                            },
                            useProgram: function(e) {
                                return g !== e && (t.useProgram(e), g = e, !0)
                            },
                            setBlending: st,
                            setMaterial: function(t, e) {
                                t.side === y ? at(2884) : ot(2884);
                                var i = t.side === v;
                                e && (i = !i), ct(i), t.blending === E && !1 === t.transparent ? st(T) : st(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), r.setMask(t.colorWrite), ht(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                            },
                            setFlipSided: ct,
                            setCullFace: lt,
                            setLineWidth: function(e) {
                                e !== B && (G && t.lineWidth(e), B = e)
                            },
                            setPolygonOffset: ht,
                            setScissorTest: function(t) {
                                t ? ot(3089) : at(3089)
                            },
                            activeTexture: ut,
                            bindTexture: function(e, i) {
                                null === j && ut();
                                var n = W[j];
                                void 0 === n && (n = {
                                    type: void 0,
                                    texture: void 0
                                }, W[j] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || nt[e]), n.type = e, n.texture = i)
                            },
                            compressedTexImage2D: function() {
                                try {
                                    t.compressedTexImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage2D: function() {
                                try {
                                    t.texImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage3D: function() {
                                try {
                                    t.texImage3D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            scissor: function(e) {
                                !1 === tt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), tt.copy(e))
                            },
                            viewport: function(e) {
                                !1 === et.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), et.copy(e))
                            },
                            reset: function() {
                                for (var e = 0; e < d.length; e++) 1 === d[e] && (t.disableVertexAttribArray(e), d[e] = 0);
                                f = {}, m = null, j = null, W = {}, g = null, x = null, k = null, N = null, r.reset(), o.reset(), a.reset()
                            }
                        }
                    }(x, b, j, w)).scissor(ht.copy(vt).multiplyScalar(mt)), M.viewport(lt.copy(gt).multiplyScalar(mt)), R = new function(t) {
                        var e = {
                            frame: 0,
                            calls: 0,
                            triangles: 0,
                            points: 0,
                            lines: 0
                        };
                        return {
                            memory: {
                                geometries: 0,
                                textures: 0
                            },
                            render: e,
                            programs: null,
                            autoReset: !0,
                            reset: function() {
                                e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                            },
                            update: function(t, i, n) {
                                switch (n = n || 1, e.calls++, i) {
                                    case 4:
                                        e.triangles += n * (t / 3);
                                        break;
                                    case 5:
                                    case 6:
                                        e.triangles += n * (t - 2);
                                        break;
                                    case 1:
                                        e.lines += n * (t / 2);
                                        break;
                                    case 3:
                                        e.lines += n * (t - 1);
                                        break;
                                    case 2:
                                        e.lines += n * t;
                                        break;
                                    case 0:
                                        e.points += n * t;
                                        break;
                                    default:
                                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                                }
                            }
                        }
                    }(x), O = new function() {
                        var t = new WeakMap;
                        return {
                            get: function(e) {
                                var i = t.get(e);
                                return void 0 === i && (i = {}, t.set(e, i)), i
                            },
                            remove: function(e) {
                                t.delete(e)
                            },
                            update: function(e, i, n) {
                                t.get(e)[i] = n
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }, I = new or(x, b, M, O, w, j, R), D = new di(x), k = new function(t, e, i) {
                        var n = {},
                            r = {};

                        function o(t) {
                            var a = t.target,
                                s = n[a.id];
                            for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[c]);
                            a.removeEventListener("dispose", o), delete n[a.id];
                            var l = r[s.id];
                            l && (e.remove(l), delete r[s.id]), i.memory.geometries--
                        }
                        return {
                            get: function(t, e) {
                                var r = n[e.id];
                                return r || (e.addEventListener("dispose", o), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Ii).setFromObject(t)), r = e._bufferGeometry), n[e.id] = r, i.memory.geometries++, r)
                            },
                            update: function(t) {
                                var i = t.index,
                                    n = t.attributes;
                                for (var r in null !== i && e.update(i, 34963), n) e.update(n[r], 34962);
                                var o = t.morphAttributes;
                                for (var r in o)
                                    for (var a = o[r], s = 0, c = a.length; s < c; s++) e.update(a[s], 34962)
                            },
                            getWireframeAttribute: function(t) {
                                var i = r[t.id];
                                if (i) return i;
                                var n, o = [],
                                    a = t.index,
                                    s = t.attributes;
                                if (null !== a)
                                    for (var c = 0, l = (n = a.array).length; c < l; c += 3) {
                                        var h = n[c + 0],
                                            u = n[c + 1],
                                            d = n[c + 2];
                                        o.push(h, u, u, d, d, h)
                                    } else
                                        for (c = 0, l = (n = s.position.array).length / 3 - 1; c < l; c += 3) h = c + 0, u = c + 1, d = c + 2, o.push(h, u, u, d, d, h);
                                return i = new(Ri(o) > 65535 ? Ai : Ei)(o, 1), e.update(i, 34963), r[t.id] = i, i
                            }
                        }
                    }(x, D, R), N = new function(t, e) {
                        var i = {};
                        return {
                            update: function(n) {
                                var r = e.render.frame,
                                    o = n.geometry,
                                    a = t.get(n, o);
                                return i[a.id] !== r && (o.isGeometry && a.updateFromObject(n), t.update(a), i[a.id] = r), a
                            },
                            dispose: function() {
                                i = {}
                            }
                        }
                    }(k, R), G = new function(t) {
                        var e = {},
                            i = new Float32Array(8);
                        return {
                            update: function(n, r, o, a) {
                                var s = n.morphTargetInfluences,
                                    c = s.length,
                                    l = e[r.id];
                                if (void 0 === l) {
                                    l = [];
                                    for (var h = 0; h < c; h++) l[h] = [h, 0];
                                    e[r.id] = l
                                }
                                var u = o.morphTargets && r.morphAttributes.position,
                                    d = o.morphNormals && r.morphAttributes.normal;
                                for (h = 0; h < c; h++) 0 !== (p = l[h])[1] && (u && r.removeAttribute("morphTarget" + h), d && r.removeAttribute("morphNormal" + h));
                                for (h = 0; h < c; h++)(p = l[h])[0] = h, p[1] = s[h];
                                for (l.sort(Wi), h = 0; h < 8; h++) {
                                    var p;
                                    if (p = l[h]) {
                                        var f = p[0],
                                            m = p[1];
                                        if (m) {
                                            u && r.addAttribute("morphTarget" + h, u[f]), d && r.addAttribute("morphNormal" + h, d[f]), i[h] = m;
                                            continue
                                        }
                                    }
                                    i[h] = 0
                                }
                                a.getUniforms().setValue(t, "morphTargetInfluences", i)
                            }
                        }
                    }(x), B = new Zn(W, b, w), F = new function() {
                        var t = {};
                        return {
                            get: function(e, i) {
                                var n, r = t[e.id];
                                return void 0 === r ? (n = new Qn, t[e.id] = {}, t[e.id][i.id] = n) : void 0 === (n = r[i.id]) && (n = new Qn, r[i.id] = n), n
                            },
                            dispose: function() {
                                t = {}
                            }
                        }
                    }, z = new function() {
                        var t = {};
                        return {
                            get: function(e, i) {
                                var n;
                                return void 0 === t[e.id] ? (n = new er, t[e.id] = {}, t[e.id][i.id] = n) : void 0 === t[e.id][i.id] ? (n = new er, t[e.id][i.id] = n) : n = t[e.id][i.id], n
                            },
                            dispose: function() {
                                t = {}
                            }
                        }
                    }, U = new function(t, e, i, n) {
                        var r, o, a = new ci(0),
                            s = 0,
                            c = null,
                            l = 0;

                        function h(t, i) {
                            e.buffers.color.setClear(t.r, t.g, t.b, i, n)
                        }
                        return {
                            getClearColor: function() {
                                return a
                            },
                            setClearColor: function(t, e) {
                                a.set(t), h(a, s = void 0 !== e ? e : 1)
                            },
                            getClearAlpha: function() {
                                return s
                            },
                            setClearAlpha: function(t) {
                                h(a, s = t)
                            },
                            render: function(e, n, u, d) {
                                var p = n.background;
                                if (null === p ? (h(a, s), c = null, l = 0) : p && p.isColor && (h(p, 1), d = !0, c = null, l = 0), (t.autoClear || d) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), p && (p.isCubeTexture || p.isWebGLRenderTargetCube)) {
                                    void 0 === o && ((o = new ji(new ki(1, 1, 1), new Ui({
                                        type: "BackgroundCubeMaterial",
                                        uniforms: ri(hi.cube.uniforms),
                                        vertexShader: hi.cube.vertexShader,
                                        fragmentShader: hi.cube.fragmentShader,
                                        side: v,
                                        depthTest: !0,
                                        depthWrite: !1,
                                        fog: !1
                                    }))).geometry.removeAttribute("normal"), o.geometry.removeAttribute("uv"), o.onBeforeRender = function(t, e, i) {
                                        this.matrixWorld.copyPosition(i.matrixWorld)
                                    }, Object.defineProperty(o.material, "map", {
                                        get: function() {
                                            return this.uniforms.tCube.value
                                        }
                                    }), i.update(o));
                                    var f = p.isWebGLRenderTargetCube ? p.texture : p;
                                    o.material.uniforms.tCube.value = f, o.material.uniforms.tFlip.value = p.isWebGLRenderTargetCube ? 1 : -1, c === p && l === f.version || (o.material.needsUpdate = !0, c = p, l = f.version), e.unshift(o, o.geometry, o.material, 0, null)
                                } else p && p.isTexture && (void 0 === r && ((r = new ji(new Bi(2, 2), new Ui({
                                    type: "BackgroundMaterial",
                                    uniforms: ri(hi.background.uniforms),
                                    vertexShader: hi.background.vertexShader,
                                    fragmentShader: hi.background.fragmentShader,
                                    side: g,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                }))).geometry.removeAttribute("normal"), Object.defineProperty(r.material, "map", {
                                    get: function() {
                                        return this.uniforms.t2D.value
                                    }
                                }), i.update(r)), r.material.uniforms.t2D.value = p, !0 === p.matrixAutoUpdate && p.updateMatrix(), r.material.uniforms.uvTransform.value.copy(p.matrix), c === p && l === p.version || (r.material.needsUpdate = !0, c = p, l = p.version), e.unshift(r, r.geometry, r.material, 0, null))
                            }
                        }
                    }(W, M, N, d), H = new function(t, e, i, n) {
                        var r;
                        this.setMode = function(t) {
                            r = t
                        }, this.render = function(e, n) {
                            t.drawArrays(r, e, n), i.update(n, r)
                        }, this.renderInstances = function(o, a, s) {
                            var c;
                            if (n.isWebGL2) c = t;
                            else if (null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            c[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, a, s, o.maxInstancedCount), i.update(s, r, o.maxInstancedCount)
                        }
                    }(x, b, R, w), V = new function(t, e, i, n) {
                        var r, o, a;
                        this.setMode = function(t) {
                            r = t
                        }, this.setIndex = function(t) {
                            o = t.type, a = t.bytesPerElement
                        }, this.render = function(e, n) {
                            t.drawElements(r, n, o, e * a), i.update(n, r)
                        }, this.renderInstances = function(s, c, l) {
                            var h;
                            if (n.isWebGL2) h = t;
                            else if (null === (h = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            h[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, l, o, c * a, s.maxInstancedCount), i.update(l, r, s.maxInstancedCount)
                        }
                    }(x, b, R, w), R.programs = B.programs, W.context = x, W.capabilities = w, W.extensions = b, W.properties = O, W.renderLists = F, W.state = M, W.info = R
                }
                Pt();
                var Lt = null;
                "undefined" != typeof navigator && (Lt = "xr" in navigator ? new function(e) {
                    var i = e.context,
                        n = null,
                        r = null,
                        o = 1,
                        a = null,
                        s = "stage",
                        c = null,
                        l = [],
                        h = [];

                    function u() {
                        return null !== r && null !== a
                    }
                    var d = new lr;
                    d.layers.enable(1), d.viewport = new Ze;
                    var p = new lr;
                    p.layers.enable(2), p.viewport = new Ze;
                    var f = new hr([d, p]);

                    function m(t) {
                        var e = l[h.indexOf(t.inputSource)];
                        e && e.dispatchEvent({
                            type: t.type
                        })
                    }

                    function g() {
                        e.setFramebuffer(null), _.stop()
                    }

                    function v(t, e) {
                        null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
                    }
                    f.layers.enable(1), f.layers.enable(2), this.enabled = !1, this.getController = function(t) {
                        var e = l[t];
                        return void 0 === e && ((e = new sr).matrixAutoUpdate = !1, e.visible = !1, l[t] = e), e
                    }, this.getDevice = function() {
                        return n
                    }, this.setDevice = function(t) {
                        void 0 !== t && (n = t), t instanceof XRDevice && i.setCompatibleXRDevice(t)
                    }, this.setFramebufferScaleFactor = function(t) {
                        o = t
                    }, this.setFrameOfReferenceType = function(t) {
                        s = t
                    }, this.setSession = function(t) {
                        null !== (r = t) && (r.addEventListener("select", m), r.addEventListener("selectstart", m), r.addEventListener("selectend", m), r.addEventListener("end", g), r.baseLayer = new XRWebGLLayer(r, i, {
                            framebufferScaleFactor: o
                        }), r.requestFrameOfReference(s).then(function(t) {
                            a = t, e.setFramebuffer(r.baseLayer.framebuffer), _.setContext(r), _.start()
                        }), h = r.getInputSources(), r.addEventListener("inputsourceschange", function() {
                            h = r.getInputSources(), console.log(h);
                            for (var t = 0; t < l.length; t++) l[t].userData.inputSource = h[t]
                        }))
                    }, this.getCamera = function(t) {
                        if (u()) {
                            var e = t.parent,
                                i = f.cameras;
                            v(f, e);
                            for (var n = 0; n < i.length; n++) v(i[n], e);
                            t.matrixWorld.copy(f.matrixWorld);
                            for (var r = t.children, o = (n = 0, r.length); n < o; n++) r[n].updateMatrixWorld(!0);
                            return fr(f, d, p), f
                        }
                        return t
                    }, this.isPresenting = u;
                    var y = null,
                        _ = new ui;
                    _.setAnimationLoop(function(t, e) {
                        if (null !== (c = e.getDevicePose(a)))
                            for (var i = r.baseLayer, n = e.views, o = 0; o < n.length; o++) {
                                var s = n[o],
                                    u = i.getViewport(s),
                                    d = c.getViewMatrix(s),
                                    p = f.cameras[o];
                                p.matrix.fromArray(d).getInverse(p.matrix), p.projectionMatrix.fromArray(s.projectionMatrix), p.viewport.set(u.x, u.y, u.width, u.height), 0 === o && f.matrix.copy(p.matrix)
                            }
                        for (o = 0; o < l.length; o++) {
                            var m = l[o],
                                g = h[o];
                            if (g) {
                                var v = e.getInputPose(g, a);
                                if (null !== v) {
                                    "targetRay" in v ? m.matrix.elements = v.targetRay.transformMatrix : "pointerMatrix" in v && (m.matrix.elements = v.pointerMatrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.visible = !0;
                                    continue
                                }
                            }
                            m.visible = !1
                        }
                        y && y(t)
                    }), this.setAnimationLoop = function(t) {
                        y = t
                    }, this.dispose = function() {}, this.getStandingMatrix = function() {
                        return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new t.Matrix4
                    }, this.submitFrame = function() {}
                }(W) : new mr(W)), this.vr = Lt;
                var Ct = new rr(W, N, w.maxTextureSize);

                function Rt(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), tt = !0
                }

                function Dt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), tt = !1, Pt()
                }

                function kt(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", kt),
                        function(t) {
                            Nt(t), O.remove(t)
                        }(e)
                }

                function Nt(t) {
                    var e = O.get(t).program;
                    t.program = void 0, void 0 !== e && B.releaseProgram(e)
                }
                this.shadowMap = Ct, this.getContext = function() {
                    return x
                }, this.getContextAttributes = function() {
                    return x.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var t = b.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    var t = b.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return mt
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (mt = t, this.setSize(pt, ft, !1))
                }, this.getSize = function() {
                    return {
                        width: pt,
                        height: ft
                    }
                }, this.setSize = function(t, e, n) {
                    Lt.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (pt = t, ft = e, i.width = t * mt, i.height = e * mt, !1 !== n && (i.style.width = t + "px", i.style.height = e + "px"), this.setViewport(0, 0, t, e))
                }, this.getDrawingBufferSize = function() {
                    return {
                        width: pt * mt,
                        height: ft * mt
                    }
                }, this.setDrawingBufferSize = function(t, e, n) {
                    pt = t, ft = e, mt = n, i.width = t * n, i.height = e * n, this.setViewport(0, 0, t, e)
                }, this.getCurrentViewport = function() {
                    return lt
                }, this.setViewport = function(t, e, i, n) {
                    gt.set(t, ft - e - n, i, n), M.viewport(lt.copy(gt).multiplyScalar(mt))
                }, this.setScissor = function(t, e, i, n) {
                    vt.set(t, ft - e - n, i, n), M.scissor(ht.copy(vt).multiplyScalar(mt))
                }, this.setScissorTest = function(t) {
                    M.setScissorTest(yt = t)
                }, this.getClearColor = function() {
                    return U.getClearColor()
                }, this.setClearColor = function() {
                    U.setClearColor.apply(U, arguments)
                }, this.getClearAlpha = function() {
                    return U.getClearAlpha()
                }, this.setClearAlpha = function() {
                    U.setClearAlpha.apply(U, arguments)
                }, this.clear = function(t, e, i) {
                    var n = 0;
                    (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), x.clear(n)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    i.removeEventListener("webglcontextlost", Rt, !1), i.removeEventListener("webglcontextrestored", Dt, !1), F.dispose(), z.dispose(), O.dispose(), N.dispose(), Lt.dispose(), Ft.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    M.initAttributes();
                    var i = O.get(t);
                    t.hasPositions && !i.position && (i.position = x.createBuffer()), t.hasNormals && !i.normal && (i.normal = x.createBuffer()), t.hasUvs && !i.uv && (i.uv = x.createBuffer()), t.hasColors && !i.color && (i.color = x.createBuffer());
                    var n = e.getAttributes();
                    t.hasPositions && (x.bindBuffer(34962, i.position), x.bufferData(34962, t.positionArray, 35048), M.enableAttribute(n.position), x.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (x.bindBuffer(34962, i.normal), x.bufferData(34962, t.normalArray, 35048), M.enableAttribute(n.normal), x.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (x.bindBuffer(34962, i.uv), x.bufferData(34962, t.uvArray, 35048), M.enableAttribute(n.uv), x.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (x.bindBuffer(34962, i.color), x.bufferData(34962, t.colorArray, 35048), M.enableAttribute(n.color), x.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), M.disableUnusedAttributes(), x.drawArrays(4, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, i, n, r, o) {
                    var a = r.isMesh && r.normalMatrix.determinant() < 0;
                    M.setMaterial(n, a);
                    var s = Vt(t, e, n, r),
                        c = !1;
                    at.geometry === i.id && at.program === s.id && at.wireframe === (!0 === n.wireframe) || (at.geometry = i.id, at.program = s.id, at.wireframe = !0 === n.wireframe, c = !0), r.morphTargetInfluences && (G.update(r, i, n, s), c = !0);
                    var l, h = i.index,
                        u = i.attributes.position,
                        d = 1;
                    !0 === n.wireframe && (h = k.getWireframeAttribute(i), d = 2);
                    var p = H;
                    null !== h && (l = D.get(h), (p = V).setIndex(l)), c && (! function(t, e, i) {
                        if (i && i.isInstancedBufferGeometry & !w.isWebGL2 && null === b.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        M.initAttributes();
                        var n = i.attributes,
                            r = e.getAttributes(),
                            o = t.defaultAttributeValues;
                        for (var a in r) {
                            var s = r[a];
                            if (s >= 0) {
                                var c = n[a];
                                if (void 0 !== c) {
                                    var l = c.normalized,
                                        h = c.itemSize,
                                        u = D.get(c);
                                    if (void 0 === u) continue;
                                    var d = u.buffer,
                                        p = u.type,
                                        f = u.bytesPerElement;
                                    if (c.isInterleavedBufferAttribute) {
                                        var m = c.data,
                                            g = m.stride,
                                            v = c.offset;
                                        m && m.isInstancedInterleavedBuffer ? (M.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = m.meshPerAttribute * m.count)) : M.enableAttribute(s), x.bindBuffer(34962, d), x.vertexAttribPointer(s, h, p, l, g * f, v * f)
                                    } else c.isInstancedBufferAttribute ? (M.enableAttributeAndDivisor(s, c.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = c.meshPerAttribute * c.count)) : M.enableAttribute(s), x.bindBuffer(34962, d), x.vertexAttribPointer(s, h, p, l, 0, 0)
                                } else if (void 0 !== o) {
                                    var y = o[a];
                                    if (void 0 !== y) switch (y.length) {
                                        case 2:
                                            x.vertexAttrib2fv(s, y);
                                            break;
                                        case 3:
                                            x.vertexAttrib3fv(s, y);
                                            break;
                                        case 4:
                                            x.vertexAttrib4fv(s, y);
                                            break;
                                        default:
                                            x.vertexAttrib1fv(s, y)
                                    }
                                }
                            }
                        }
                        M.disableUnusedAttributes()
                    }(n, s, i), null !== h && x.bindBuffer(34963, l.buffer));
                    var f = 1 / 0;
                    null !== h ? f = h.count : void 0 !== u && (f = u.count);
                    var m = i.drawRange.start * d,
                        g = i.drawRange.count * d,
                        v = null !== o ? o.start * d : 0,
                        y = null !== o ? o.count * d : 1 / 0,
                        _ = Math.max(m, v),
                        T = Math.min(f, m + g, v + y) - 1,
                        E = Math.max(0, T - _ + 1);
                    if (0 !== E) {
                        if (r.isMesh)
                            if (!0 === n.wireframe) M.setLineWidth(n.wireframeLinewidth * Et()), p.setMode(1);
                            else switch (r.drawMode) {
                                case Ee:
                                    p.setMode(4);
                                    break;
                                case Se:
                                    p.setMode(5);
                                    break;
                                case Ae:
                                    p.setMode(6)
                            } else if (r.isLine) {
                                var S = n.linewidth;
                                void 0 === S && (S = 1), M.setLineWidth(S * Et()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                            } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                        i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && p.renderInstances(i, _, E) : p.render(_, E)
                    }
                }, this.compile = function(t, e) {
                    (_ = z.get(t, e)).init(), t.traverse(function(t) {
                        t.isLight && (_.pushLight(t), t.castShadow && _.pushShadow(t))
                    }), _.setupLights(e), t.traverse(function(e) {
                        if (e.material)
                            if (Array.isArray(e.material))
                                for (var i = 0; i < e.material.length; i++) Ht(e.material[i], t.fog, e);
                            else Ht(e.material, t.fog, e)
                    })
                };
                var Bt = null;
                var Ft = new ui;

                function zt(t, e, i, n) {
                    for (var r = 0, o = t.length; r < o; r++) {
                        var a = t[r],
                            s = a.object,
                            c = a.geometry,
                            l = void 0 === n ? a.material : n,
                            h = a.group;
                        if (i.isArrayCamera) {
                            ct = i;
                            for (var u = i.cameras, d = 0, p = u.length; d < p; d++) {
                                var f = u[d];
                                if (s.layers.test(f.layers)) {
                                    if ("viewport" in f) M.viewport(lt.copy(f.viewport));
                                    else {
                                        var m = f.bounds,
                                            g = m.x * pt,
                                            v = m.y * ft,
                                            y = m.z * pt,
                                            x = m.w * ft;
                                        M.viewport(lt.set(g, v, y, x).multiplyScalar(mt))
                                    }
                                    _.setupLights(f), Gt(s, e, f, c, l, h)
                                }
                            }
                        } else ct = null, Gt(s, e, i, c, l, h)
                    }
                }

                function Gt(t, e, i, n, r, o) {
                    if (t.onBeforeRender(W, e, i, n, r, o), _ = z.get(e, ct || i), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        M.setMaterial(r);
                        var a = Vt(i, e.fog, r, t);
                        at.geometry = null, at.program = null, at.wireframe = !1,
                            function(t, e) {
                                t.render(function(t) {
                                    W.renderBufferImmediate(t, e)
                                })
                            }(t, a)
                    } else W.renderBufferDirect(i, e.fog, n, r, t, o);
                    t.onAfterRender(W, e, i, n, r, o), _ = z.get(e, ct || i)
                }

                function Ht(t, e, i) {
                    var n = O.get(t),
                        r = _.state.lights,
                        o = _.state.shadowsArray,
                        a = n.lightsHash,
                        s = r.state.hash,
                        c = B.getParameters(t, r.state, o, e, xt.numPlanes, xt.numIntersection, i),
                        l = B.getProgramCode(t, c),
                        h = n.program,
                        u = !0;
                    if (void 0 === h) t.addEventListener("dispose", kt);
                    else if (h.code !== l) Nt(t);
                    else if (a.stateID !== s.stateID || a.directionalLength !== s.directionalLength || a.pointLength !== s.pointLength || a.spotLength !== s.spotLength || a.rectAreaLength !== s.rectAreaLength || a.hemiLength !== s.hemiLength || a.shadowsLength !== s.shadowsLength) a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, u = !1;
                    else {
                        if (void 0 !== c.shaderID) return;
                        u = !1
                    }
                    if (u) {
                        if (c.shaderID) {
                            var d = hi[c.shaderID];
                            n.shader = {
                                name: t.type,
                                uniforms: ri(d.uniforms),
                                vertexShader: d.vertexShader,
                                fragmentShader: d.fragmentShader
                            }
                        } else n.shader = {
                            name: t.type,
                            uniforms: t.uniforms,
                            vertexShader: t.vertexShader,
                            fragmentShader: t.fragmentShader
                        };
                        t.onBeforeCompile(n.shader, W), l = B.getProgramCode(t, c), h = B.acquireProgram(t, n.shader, c, l), n.program = h, t.program = h
                    }
                    var p = h.getAttributes();
                    if (t.morphTargets) {
                        t.numSupportedMorphTargets = 0;
                        for (var f = 0; f < W.maxMorphTargets; f++) p["morphTarget" + f] >= 0 && t.numSupportedMorphTargets++
                    }
                    if (t.morphNormals) {
                        t.numSupportedMorphNormals = 0;
                        for (f = 0; f < W.maxMorphNormals; f++) p["morphNormal" + f] >= 0 && t.numSupportedMorphNormals++
                    }
                    var m = n.shader.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = xt.numPlanes, n.numIntersection = xt.numIntersection, m.clippingPlanes = xt.uniform), n.fog = e, void 0 === a && (n.lightsHash = a = {}), a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, t.lights && (m.ambientLightColor.value = r.state.ambient, m.directionalLights.value = r.state.directional, m.spotLights.value = r.state.spot, m.rectAreaLights.value = r.state.rectArea, m.pointLights.value = r.state.point, m.hemisphereLights.value = r.state.hemi, m.directionalShadowMap.value = r.state.directionalShadowMap, m.directionalShadowMatrix.value = r.state.directionalShadowMatrix, m.spotShadowMap.value = r.state.spotShadowMap, m.spotShadowMatrix.value = r.state.spotShadowMatrix, m.pointShadowMap.value = r.state.pointShadowMap, m.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    var g = n.program.getUniforms(),
                        v = Fn.seqWithValue(g.seq, m);
                    n.uniformsList = v
                }

                function Vt(t, e, i, n) {
                    dt = 0;
                    var r = O.get(i),
                        o = _.state.lights,
                        a = r.lightsHash,
                        s = o.state.hash;
                    if (bt && (wt || t !== st)) {
                        var c = t === st && i.id === ot;
                        xt.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, c)
                    }!1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : (!i.lights || a.stateID === s.stateID && a.directionalLength === s.directionalLength && a.pointLength === s.pointLength && a.spotLength === s.spotLength && a.rectAreaLength === s.rectAreaLength && a.hemiLength === s.hemiLength && a.shadowsLength === s.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === xt.numPlanes && r.numIntersection === xt.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (Ht(i, e, n), i.needsUpdate = !1);
                    var l = !1,
                        h = !1,
                        u = !1,
                        d = r.program,
                        p = d.getUniforms(),
                        f = r.shader.uniforms;
                    if (M.useProgram(d.program) && (l = !0, h = !0, u = !0), i.id !== ot && (ot = i.id, h = !0), l || st !== t) {
                        if (p.setValue(x, "projectionMatrix", t.projectionMatrix), w.logarithmicDepthBuffer && p.setValue(x, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), st !== t && (st = t, h = !0, u = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                            var m = p.map.cameraPosition;
                            void 0 !== m && m.setValue(x, Tt.setFromMatrixPosition(t.matrixWorld))
                        }(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && p.setValue(x, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (i.skinning) {
                        p.setOptional(x, n, "bindMatrix"), p.setOptional(x, n, "bindMatrixInverse");
                        var g = n.skeleton;
                        if (g) {
                            var y = g.bones;
                            if (w.floatVertexTextures) {
                                if (void 0 === g.boneTexture) {
                                    var b = Math.sqrt(4 * y.length);
                                    b = Ue.ceilPowerOfTwo(b), b = Math.max(b, 4);
                                    var T = new Float32Array(b * b * 4);
                                    T.set(g.boneMatrices);
                                    var E = new Qe(T, b, b, Ut, Ot);
                                    E.needsUpdate = !0, g.boneMatrices = T, g.boneTexture = E, g.boneTextureSize = b
                                }
                                p.setValue(x, "boneTexture", g.boneTexture), p.setValue(x, "boneTextureSize", g.boneTextureSize)
                            } else p.setOptional(x, g, "boneMatrices")
                        }
                    }
                    return h && (p.setValue(x, "toneMappingExposure", W.toneMappingExposure), p.setValue(x, "toneMappingWhitePoint", W.toneMappingWhitePoint), i.lights && function(t, e) {
                        t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
                    }(f, u), e && i.fog && function(t, e) {
                        t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    }(f, e), i.isMeshBasicMaterial ? jt(f, i) : i.isMeshLambertMaterial ? (jt(f, i), function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(f, i)) : i.isMeshPhongMaterial ? (jt(f, i), i.isMeshToonMaterial ? function(t, e) {
                        Wt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(f, i) : Wt(f, i)) : i.isMeshStandardMaterial ? (jt(f, i), i.isMeshPhysicalMaterial ? function(t, e) {
                        Xt(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness
                    }(f, i) : Xt(f, i)) : i.isMeshMatcapMaterial ? (jt(f, i), function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === v && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === v && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(f, i)) : i.isMeshDepthMaterial ? (jt(f, i), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(f, i)) : i.isMeshDistanceMaterial ? (jt(f, i), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(f, i)) : i.isMeshNormalMaterial ? (jt(f, i), function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === v && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === v && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(f, i)) : i.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity
                    }(f, i), i.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(f, i)) : i.isPointsMaterial ? function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * mt, t.scale.value = .5 * ft, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(f, i) : i.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity, t.rotation.value = e.rotation, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(f, i) : i.isShadowMaterial && (f.color.value = i.color, f.opacity.value = i.opacity), void 0 !== f.ltc_1 && (f.ltc_1.value = li.LTC_1), void 0 !== f.ltc_2 && (f.ltc_2.value = li.LTC_2), Fn.upload(x, r.uniformsList, f, W)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Fn.upload(x, r.uniformsList, f, W), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && p.setValue(x, "center", n.center), p.setValue(x, "modelViewMatrix", n.modelViewMatrix), p.setValue(x, "normalMatrix", n.normalMatrix), p.setValue(x, "modelMatrix", n.matrixWorld), d
                }

                function jt(t, e) {
                    var i;
                    t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = O.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                }

                function Wt(t, e) {
                    t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === v && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === v && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function Xt(t, e) {
                    t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === v && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === v && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                }
                Ft.setAnimationLoop(function(t) {
                    Lt.isPresenting() || Bt && Bt(t)
                }), "undefined" != typeof window && Ft.setContext(window), this.setAnimationLoop = function(t) {
                    Bt = t, Lt.setAnimationLoop(t), Ft.start()
                }, this.render = function(t, e, i, n) {
                    if (e && e.isCamera) {
                        if (!tt) {
                            at.geometry = null, at.program = null, at.wireframe = !1, ot = -1, st = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), Lt.enabled && (e = Lt.getCamera(e)), (_ = z.get(t, e)).init(), t.onBeforeRender(W, t, e, i), Mt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), _t.setFromMatrix(Mt), wt = this.localClippingEnabled, bt = xt.init(this.clippingPlanes, wt, e), (m = F.get(t, e)).init(),
                                function t(e, i, n) {
                                    if (!1 === e.visible) return;
                                    var r = e.layers.test(i.layers);
                                    if (r)
                                        if (e.isLight) _.pushLight(e), e.castShadow && _.pushShadow(e);
                                        else if (e.isSprite) {
                                        if (!e.frustumCulled || _t.intersectsSprite(e)) {
                                            n && Tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Mt);
                                            var o = N.update(e),
                                                a = e.material;
                                            m.push(e, o, a, Tt.z, null)
                                        }
                                    } else if (e.isImmediateRenderObject) n && Tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Mt), m.push(e, null, e.material, Tt.z, null);
                                    else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || _t.intersectsObject(e))) {
                                        n && Tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Mt);
                                        var o = N.update(e),
                                            a = e.material;
                                        if (Array.isArray(a))
                                            for (var s = o.groups, c = 0, l = s.length; c < l; c++) {
                                                var h = s[c],
                                                    u = a[h.materialIndex];
                                                u && u.visible && m.push(e, o, u, Tt.z, h)
                                            } else a.visible && m.push(e, o, a, Tt.z, null)
                                    }
                                    var d = e.children;
                                    for (var c = 0, l = d.length; c < l; c++) t(d[c], i, n)
                                }(t, e, W.sortObjects), !0 === W.sortObjects && m.sort(), bt && xt.beginShadows();
                            var r = _.state.shadowsArray;
                            Ct.render(r, t, e), _.setupLights(e), bt && xt.endShadows(), this.info.autoReset && this.info.reset(), void 0 === i && (i = null), this.setRenderTarget(i), U.render(m, t, e, n);
                            var o = m.opaque,
                                a = m.transparent;
                            if (t.overrideMaterial) {
                                var s = t.overrideMaterial;
                                o.length && zt(o, t, e, s), a.length && zt(a, t, e, s)
                            } else o.length && zt(o, t, e), a.length && zt(a, t, e);
                            i && I.updateRenderTargetMipmap(i), M.buffers.depth.setTest(!0), M.buffers.depth.setMask(!0), M.buffers.color.setMask(!0), M.setPolygonOffset(!1), t.onAfterRender(W, t, e), Lt.enabled && Lt.submitFrame(), m = null, _ = null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.allocTextureUnit = function() {
                    var t = dt;
                    return t >= w.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + w.maxTextures), dt += 1, t
                }, this.setTexture2D = function() {
                    var t = !1;
                    return function(e, i) {
                        e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), I.setTexture2D(e, i)
                    }
                }(), this.setTexture3D = function(t, e) {
                    I.setTexture3D(t, e)
                }, this.setTexture = function() {
                    var t = !1;
                    return function(e, i) {
                        t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), I.setTexture2D(e, i)
                    }
                }(), this.setTextureCube = function() {
                    var t = !1;
                    return function(e, i) {
                        e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? I.setTextureCube(e, i) : I.setTextureCubeDynamic(e, i)
                    }
                }(), this.setFramebuffer = function(t) {
                    et = t
                }, this.getRenderTarget = function() {
                    return it
                }, this.setRenderTarget = function(t) {
                    it = t, t && void 0 === O.get(t).__webglFramebuffer && I.setupRenderTarget(t);
                    var e = et,
                        i = !1;
                    if (t) {
                        var n = O.get(t).__webglFramebuffer;
                        t.isWebGLRenderTargetCube ? (e = n[t.activeCubeFace], i = !0) : e = n, lt.copy(t.viewport), ht.copy(t.scissor), ut = t.scissorTest
                    } else lt.copy(gt).multiplyScalar(mt), ht.copy(vt).multiplyScalar(mt), ut = yt;
                    if (nt !== e && (x.bindFramebuffer(36160, e), nt = e), M.viewport(lt), M.scissor(ht), M.setScissorTest(ut), i) {
                        var r = O.get(t.texture);
                        x.framebufferTexture2D(36160, 36064, 34069 + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
                    }
                }, this.readRenderTargetPixels = function(t, e, i, n, r, o) {
                    if (t && t.isWebGLRenderTarget) {
                        var a = O.get(t).__webglFramebuffer;
                        if (a) {
                            var s = !1;
                            a !== nt && (x.bindFramebuffer(36160, a), s = !0);
                            try {
                                var c = t.texture,
                                    l = c.format,
                                    h = c.type;
                                if (l !== Ut && j.convert(l) !== x.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(h === St || j.convert(h) === x.getParameter(35738) || h === Ot && (w.isWebGL2 || b.get("OES_texture_float") || b.get("WEBGL_color_buffer_float")) || h === It && (w.isWebGL2 ? b.get("EXT_color_buffer_float") : b.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === x.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && x.readPixels(e, i, n, r, j.convert(l), j.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                s && x.bindFramebuffer(36160, nt)
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }, this.copyFramebufferToTexture = function(t, e, i) {
                    var n = e.image.width,
                        r = e.image.height,
                        o = j.convert(e.format);
                    this.setTexture2D(e, 0), x.copyTexImage2D(3553, i || 0, o, t.x, t.y, n, r, 0)
                }, this.copyTextureToTexture = function(t, e, i, n) {
                    var r = e.image.width,
                        o = e.image.height,
                        a = j.convert(i.format),
                        s = j.convert(i.type);
                    this.setTexture2D(i, 0), e.isDataTexture ? x.texSubImage2D(3553, n || 0, t.x, t.y, r, o, a, s, e.image.data) : x.texSubImage2D(3553, n || 0, t.x, t.y, a, s, e.image)
                }
            }

            function vr(t, e) {
                this.name = "", this.color = new ci(t), this.density = void 0 !== e ? e : 25e-5
            }

            function yr(t, e, i) {
                this.name = "", this.color = new ci(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
            }

            function _r() {
                vi.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }

            function xr(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function br(t, e, i, n) {
                this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
            }

            function wr(t) {
                zi.call(this), this.type = "SpriteMaterial", this.color = new ci(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t)
            }

            function Mr(t) {
                if (vi.call(this), this.type = "Sprite", void 0 === ur) {
                    ur = new Ii;
                    var e = new xr(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    ur.setIndex([0, 1, 2, 0, 2, 3]), ur.addAttribute("position", new br(e, 3, 0, !1)), ur.addAttribute("uv", new br(e, 2, 3, !1))
                }
                this.geometry = ur, this.material = void 0 !== t ? t : new wr, this.center = new Ge(.5, .5)
            }

            function Tr() {
                vi.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }

            function Er(t, e) {
                t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), ji.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new He, this.bindMatrixInverse = new He
            }

            function Sr(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new He)
                }
            }

            function Ar() {
                vi.call(this), this.type = "Bone"
            }

            function Pr(t) {
                zi.call(this), this.type = "LineBasicMaterial", this.color = new ci(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
            }

            function Lr(t, e, i) {
                1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), vi.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Ii, this.material = void 0 !== e ? e : new Pr({
                    color: 16777215 * Math.random()
                })
            }

            function Cr(t, e) {
                Lr.call(this, t, e), this.type = "LineSegments"
            }

            function Rr(t, e) {
                Lr.call(this, t, e), this.type = "LineLoop"
            }

            function Or(t) {
                zi.call(this), this.type = "PointsMaterial", this.color = new ci(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function Ir(t, e) {
                vi.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Ii, this.material = void 0 !== e ? e : new Or({
                    color: 16777215 * Math.random()
                })
            }

            function Dr(t, e, i, n, r, o, a, s, c) {
                Ye.call(this, t, e, i, n, r, o, a, s, c), this.format = void 0 !== a ? a : zt, this.minFilter = void 0 !== o ? o : Mt, this.magFilter = void 0 !== r ? r : Mt, this.generateMipmaps = !1
            }

            function kr(t, e, i, n, r, o, a, s, c, l, h, u) {
                Ye.call(this, null, o, a, s, c, l, n, r, h, u), this.image = {
                    width: e,
                    height: i
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }

            function Nr(t, e, i, n, r, o, a, s, c) {
                Ye.call(this, t, e, i, n, r, o, a, s, c), this.needsUpdate = !0
            }

            function Br(t, e, i, n, r, o, a, s, c, l) {
                if ((l = void 0 !== l ? l : jt) !== jt && l !== Wt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === i && l === jt && (i = Lt), void 0 === i && l === Wt && (i = Bt), Ye.call(this, null, n, r, o, a, s, l, i, c), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== a ? a : xt, this.minFilter = void 0 !== s ? s : xt, this.flipY = !1, this.generateMipmaps = !1
            }

            function Fr(t) {
                Ii.call(this), this.type = "WireframeGeometry";
                var e, i, n, r, o, a, s, c, l, h, u = [],
                    d = [0, 0],
                    p = {},
                    f = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    var m = t.faces;
                    for (e = 0, n = m.length; e < n; e++) {
                        var g = m[e];
                        for (i = 0; i < 3; i++) s = g[f[i]], c = g[f[(i + 1) % 3]], d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[l = d[0] + "," + d[1]] && (p[l] = {
                            index1: d[0],
                            index2: d[1]
                        })
                    }
                    for (l in p) a = p[l], h = t.vertices[a.index1], u.push(h.x, h.y, h.z), h = t.vertices[a.index2], u.push(h.x, h.y, h.z)
                } else if (t && t.isBufferGeometry) {
                    var v, y, _, x, b, w, M;
                    if (h = new je, null !== t.index) {
                        for (v = t.attributes.position, y = t.index, 0 === (_ = t.groups).length && (_ = [{
                                start: 0,
                                count: y.count,
                                materialIndex: 0
                            }]), r = 0, o = _.length; r < o; ++r)
                            for (e = b = (x = _[r]).start, n = b + x.count; e < n; e += 3)
                                for (i = 0; i < 3; i++) s = y.getX(e + i), c = y.getX(e + (i + 1) % 3), d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[l = d[0] + "," + d[1]] && (p[l] = {
                                    index1: d[0],
                                    index2: d[1]
                                });
                        for (l in p) a = p[l], h.fromBufferAttribute(v, a.index1), u.push(h.x, h.y, h.z), h.fromBufferAttribute(v, a.index2), u.push(h.x, h.y, h.z)
                    } else
                        for (e = 0, n = (v = t.attributes.position).count / 3; e < n; e++)
                            for (i = 0; i < 3; i++) w = 3 * e + i, h.fromBufferAttribute(v, w), u.push(h.x, h.y, h.z), M = 3 * e + (i + 1) % 3, h.fromBufferAttribute(v, M), u.push(h.x, h.y, h.z)
                }
                this.addAttribute("position", new Pi(u, 3))
            }

            function zr(t, e, i) {
                _i.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: i
                }, this.fromBufferGeometry(new Ur(t, e, i)), this.mergeVertices()
            }

            function Ur(t, e, i) {
                Ii.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: i
                };
                var n, r, o = [],
                    a = [],
                    s = [],
                    c = [],
                    l = new je,
                    h = new je,
                    u = new je,
                    d = new je,
                    p = new je;
                t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var f = e + 1;
                for (n = 0; n <= i; n++) {
                    var m = n / i;
                    for (r = 0; r <= e; r++) {
                        var g = r / e;
                        t(g, m, h), a.push(h.x, h.y, h.z), g - 1e-5 >= 0 ? (t(g - 1e-5, m, u), d.subVectors(h, u)) : (t(g + 1e-5, m, u), d.subVectors(u, h)), m - 1e-5 >= 0 ? (t(g, m - 1e-5, u), p.subVectors(h, u)) : (t(g, m + 1e-5, u), p.subVectors(u, h)), l.crossVectors(d, p).normalize(), s.push(l.x, l.y, l.z), c.push(g, m)
                    }
                }
                for (n = 0; n < i; n++)
                    for (r = 0; r < e; r++) {
                        var v = n * f + r,
                            y = n * f + r + 1,
                            _ = (n + 1) * f + r + 1,
                            x = (n + 1) * f + r;
                        o.push(v, y, x), o.push(y, _, x)
                    }
                this.setIndex(o), this.addAttribute("position", new Pi(a, 3)), this.addAttribute("normal", new Pi(s, 3)), this.addAttribute("uv", new Pi(c, 2))
            }

            function Gr(t, e, i, n) {
                _i.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: i,
                    detail: n
                }, this.fromBufferGeometry(new Hr(t, e, i, n)), this.mergeVertices()
            }

            function Hr(t, e, i, n) {
                Ii.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: i,
                    detail: n
                }, i = i || 1;
                var r = [],
                    o = [];

                function a(t, e, i, n) {
                    var r, o, a = Math.pow(2, n),
                        c = [];
                    for (r = 0; r <= a; r++) {
                        c[r] = [];
                        var l = t.clone().lerp(i, r / a),
                            h = e.clone().lerp(i, r / a),
                            u = a - r;
                        for (o = 0; o <= u; o++) c[r][o] = 0 === o && r === a ? l : l.clone().lerp(h, o / u)
                    }
                    for (r = 0; r < a; r++)
                        for (o = 0; o < 2 * (a - r) - 1; o++) {
                            var d = Math.floor(o / 2);
                            o % 2 == 0 ? (s(c[r][d + 1]), s(c[r + 1][d]), s(c[r][d])) : (s(c[r][d + 1]), s(c[r + 1][d + 1]), s(c[r + 1][d]))
                        }
                }

                function s(t) {
                    r.push(t.x, t.y, t.z)
                }

                function c(e, i) {
                    var n = 3 * e;
                    i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
                }

                function l(t, e, i, n) {
                    n < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === i.x && 0 === i.z && (o[e] = n / 2 / Math.PI + .5)
                }

                function h(t) {
                    return Math.atan2(t.z, -t.x)
                }

                function u(t) {
                    return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                }! function(t) {
                    for (var i = new je, n = new je, r = new je, o = 0; o < e.length; o += 3) c(e[o + 0], i), c(e[o + 1], n), c(e[o + 2], r), a(i, n, r, t)
                }(n = n || 0),
                function(t) {
                    for (var e = new je, i = 0; i < r.length; i += 3) e.x = r[i + 0], e.y = r[i + 1], e.z = r[i + 2], e.normalize().multiplyScalar(t), r[i + 0] = e.x, r[i + 1] = e.y, r[i + 2] = e.z
                }(i),
                function() {
                    for (var t = new je, e = 0; e < r.length; e += 3) {
                        t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                        var i = h(t) / 2 / Math.PI + .5,
                            n = u(t) / Math.PI + .5;
                        o.push(i, 1 - n)
                    }(function() {
                        for (var t = new je, e = new je, i = new je, n = new je, a = new Ge, s = new Ge, c = new Ge, u = 0, d = 0; u < r.length; u += 9, d += 6) {
                            t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), i.set(r[u + 6], r[u + 7], r[u + 8]), a.set(o[d + 0], o[d + 1]), s.set(o[d + 2], o[d + 3]), c.set(o[d + 4], o[d + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                            var p = h(n);
                            l(a, d + 0, t, p), l(s, d + 2, e, p), l(c, d + 4, i, p)
                        }
                    })(),
                    function() {
                        for (var t = 0; t < o.length; t += 6) {
                            var e = o[t + 0],
                                i = o[t + 2],
                                n = o[t + 4],
                                r = Math.max(e, i, n),
                                a = Math.min(e, i, n);
                            r > .9 && a < .1 && (e < .2 && (o[t + 0] += 1), i < .2 && (o[t + 2] += 1), n < .2 && (o[t + 4] += 1))
                        }
                    }()
                }(), this.addAttribute("position", new Pi(r, 3)), this.addAttribute("normal", new Pi(r.slice(), 3)), this.addAttribute("uv", new Pi(o, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function Vr(t, e) {
                _i.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new jr(t, e)), this.mergeVertices()
            }

            function jr(t, e) {
                Hr.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Wr(t, e) {
                _i.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Xr(t, e)), this.mergeVertices()
            }

            function Xr(t, e) {
                Hr.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function qr(t, e) {
                _i.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Yr(t, e)), this.mergeVertices()
            }

            function Yr(t, e) {
                var i = (1 + Math.sqrt(5)) / 2,
                    n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];
                Hr.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Zr(t, e) {
                _i.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Jr(t, e)), this.mergeVertices()
            }

            function Jr(t, e) {
                var i = (1 + Math.sqrt(5)) / 2,
                    n = 1 / i,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n];
                Hr.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Kr(t, e, i, n, r, o) {
                _i.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: i,
                    radialSegments: n,
                    closed: r
                }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
                var a = new Qr(t, e, i, n, r);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
            }

            function Qr(t, e, i, n, r) {
                Ii.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: i,
                    radialSegments: n,
                    closed: r
                }, e = e || 64, i = i || 1, n = n || 8, r = r || !1;
                var o = t.computeFrenetFrames(e, r);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
                var a, s, c = new je,
                    l = new je,
                    h = new Ge,
                    u = new je,
                    d = [],
                    p = [],
                    f = [],
                    m = [];

                function g(r) {
                    u = t.getPointAt(r / e, u);
                    var a = o.normals[r],
                        h = o.binormals[r];
                    for (s = 0; s <= n; s++) {
                        var f = s / n * Math.PI * 2,
                            m = Math.sin(f),
                            g = -Math.cos(f);
                        l.x = g * a.x + m * h.x, l.y = g * a.y + m * h.y, l.z = g * a.z + m * h.z, l.normalize(), p.push(l.x, l.y, l.z), c.x = u.x + i * l.x, c.y = u.y + i * l.y, c.z = u.z + i * l.z, d.push(c.x, c.y, c.z)
                    }
                }! function() {
                    for (a = 0; a < e; a++) g(a);
                    g(!1 === r ? e : 0),
                        function() {
                            for (a = 0; a <= e; a++)
                                for (s = 0; s <= n; s++) h.x = a / e, h.y = s / n, f.push(h.x, h.y)
                        }(),
                        function() {
                            for (s = 1; s <= e; s++)
                                for (a = 1; a <= n; a++) {
                                    var t = (n + 1) * (s - 1) + (a - 1),
                                        i = (n + 1) * s + (a - 1),
                                        r = (n + 1) * s + a,
                                        o = (n + 1) * (s - 1) + a;
                                    m.push(t, i, o), m.push(i, r, o)
                                }
                        }()
                }(), this.setIndex(m), this.addAttribute("position", new Pi(d, 3)), this.addAttribute("normal", new Pi(p, 3)), this.addAttribute("uv", new Pi(f, 2))
            }

            function $r(t, e, i, n, r, o, a) {
                _i.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: i,
                    radialSegments: n,
                    p: r,
                    q: o
                }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new to(t, e, i, n, r, o)), this.mergeVertices()
            }

            function to(t, e, i, n, r, o) {
                Ii.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: i,
                    radialSegments: n,
                    p: r,
                    q: o
                }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, o = o || 3;
                var a, s, c = [],
                    l = [],
                    h = [],
                    u = [],
                    d = new je,
                    p = new je,
                    f = new je,
                    m = new je,
                    g = new je,
                    v = new je,
                    y = new je;
                for (a = 0; a <= i; ++a) {
                    var _ = a / i * r * Math.PI * 2;
                    for (A(_, r, o, t, f), A(_ + .01, r, o, t, m), v.subVectors(m, f), y.addVectors(m, f), g.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), s = 0; s <= n; ++s) {
                        var x = s / n * Math.PI * 2,
                            b = -e * Math.cos(x),
                            w = e * Math.sin(x);
                        d.x = f.x + (b * y.x + w * g.x), d.y = f.y + (b * y.y + w * g.y), d.z = f.z + (b * y.z + w * g.z), l.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), h.push(p.x, p.y, p.z), u.push(a / i), u.push(s / n)
                    }
                }
                for (s = 1; s <= i; s++)
                    for (a = 1; a <= n; a++) {
                        var M = (n + 1) * (s - 1) + (a - 1),
                            T = (n + 1) * s + (a - 1),
                            E = (n + 1) * s + a,
                            S = (n + 1) * (s - 1) + a;
                        c.push(M, T, S), c.push(T, E, S)
                    }

                function A(t, e, i, n, r) {
                    var o = Math.cos(t),
                        a = Math.sin(t),
                        s = i / e * t,
                        c = Math.cos(s);
                    r.x = n * (2 + c) * .5 * o, r.y = n * (2 + c) * a * .5, r.z = n * Math.sin(s) * .5
                }
                this.setIndex(c), this.addAttribute("position", new Pi(l, 3)), this.addAttribute("normal", new Pi(h, 3)), this.addAttribute("uv", new Pi(u, 2))
            }

            function eo(t, e, i, n, r) {
                _i.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: r
                }, this.fromBufferGeometry(new io(t, e, i, n, r)), this.mergeVertices()
            }

            function io(t, e, i, n, r) {
                Ii.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: r
                }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
                var o, a, s = [],
                    c = [],
                    l = [],
                    h = [],
                    u = new je,
                    d = new je,
                    p = new je;
                for (o = 0; o <= i; o++)
                    for (a = 0; a <= n; a++) {
                        var f = a / n * r,
                            m = o / i * Math.PI * 2;
                        d.x = (t + e * Math.cos(m)) * Math.cos(f), d.y = (t + e * Math.cos(m)) * Math.sin(f), d.z = e * Math.sin(m), c.push(d.x, d.y, d.z), u.x = t * Math.cos(f), u.y = t * Math.sin(f), p.subVectors(d, u).normalize(), l.push(p.x, p.y, p.z), h.push(a / n), h.push(o / i)
                    }
                for (o = 1; o <= i; o++)
                    for (a = 1; a <= n; a++) {
                        var g = (n + 1) * o + a - 1,
                            v = (n + 1) * (o - 1) + a - 1,
                            y = (n + 1) * (o - 1) + a,
                            _ = (n + 1) * o + a;
                        s.push(g, v, _), s.push(v, y, _)
                    }
                this.setIndex(s), this.addAttribute("position", new Pi(c, 3)), this.addAttribute("normal", new Pi(l, 3)), this.addAttribute("uv", new Pi(h, 2))
            }
            vr.prototype.isFogExp2 = !0, vr.prototype.clone = function() {
                return new vr(this.color, this.density)
            }, vr.prototype.toJSON = function() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }, yr.prototype.isFog = !0, yr.prototype.clone = function() {
                return new yr(this.color, this.near, this.far)
            }, yr.prototype.toJSON = function() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }, _r.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: _r,
                copy: function(t, e) {
                    return vi.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                },
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                }
            }), Object.defineProperty(xr.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(xr.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, i) {
                    t *= this.stride, i *= e.stride;
                    for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                }
            }), Object.defineProperties(br.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            }), Object.assign(br.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
                },
                setXYZ: function(t, e, i, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
                },
                setXYZW: function(t, e, i, n, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
                }
            }), wr.prototype = Object.create(zi.prototype), wr.prototype.constructor = wr, wr.prototype.isSpriteMaterial = !0, wr.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            }, Mr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Mr,
                isSprite: !0,
                raycast: function() {
                    var t = new je,
                        e = new je,
                        i = new je,
                        n = new Ge,
                        r = new Ge,
                        o = new He,
                        a = new je,
                        s = new je,
                        c = new je,
                        l = new Ge,
                        h = new Ge,
                        u = new Ge;

                    function d(t, e, i, a, s, c) {
                        n.subVectors(t, i).addScalar(.5).multiply(a), void 0 !== s ? (r.x = c * n.x - s * n.y, r.y = s * n.x + c * n.y) : r.copy(n), t.copy(e), t.x += r.x, t.y += r.y, t.applyMatrix4(o)
                    }
                    return function(n, r) {
                        e.setFromMatrixScale(this.matrixWorld), o.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), i.setFromMatrixPosition(this.modelViewMatrix);
                        var p, f, m = this.material.rotation;
                        0 !== m && (f = Math.cos(m), p = Math.sin(m));
                        var g = this.center;
                        d(a.set(-.5, -.5, 0), i, g, e, p, f), d(s.set(.5, -.5, 0), i, g, e, p, f), d(c.set(.5, .5, 0), i, g, e, p, f), l.set(0, 0), h.set(1, 0), u.set(1, 1);
                        var v = n.ray.intersectTriangle(a, s, c, !1, t);
                        if (null !== v || (d(s.set(-.5, .5, 0), i, g, e, p, f), h.set(0, 1), null !== (v = n.ray.intersectTriangle(a, c, s, !1, t)))) {
                            var y = n.ray.origin.distanceTo(t);
                            y < n.near || y > n.far || r.push({
                                distance: y,
                                point: t.clone(),
                                uv: Hi.getUV(t, a, s, c, l, h, u, new Ge),
                                face: null,
                                object: this
                            })
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function(t) {
                    return vi.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
                }
            }), Tr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Tr,
                copy: function(t) {
                    vi.prototype.copy.call(this, t, !1);
                    for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
                        var r = e[i];
                        this.addLevel(r.object.clone(), r.distance)
                    }
                    return this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
                    i.splice(n, 0, {
                        distance: e,
                        object: t
                    }), this.add(t)
                },
                getObjectForDistance: function(t) {
                    for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
                    return e[i - 1].object
                },
                raycast: function() {
                    var t = new je;
                    return function(e, i) {
                        t.setFromMatrixPosition(this.matrixWorld);
                        var n = e.ray.origin.distanceTo(t);
                        this.getObjectForDistance(n).raycast(e, i)
                    }
                }(),
                update: function() {
                    var t = new je,
                        e = new je;
                    return function(i) {
                        var n = this.levels;
                        if (n.length > 1) {
                            t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                            var r = t.distanceTo(e);
                            n[0].object.visible = !0;
                            for (var o = 1, a = n.length; o < a && r >= n[o].distance; o++) n[o - 1].object.visible = !1, n[o].object.visible = !0;
                            for (; o < a; o++) n[o].object.visible = !1
                        }
                    }
                }(),
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    e.object.levels = [];
                    for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                        var o = i[n];
                        e.object.levels.push({
                            object: o.object.uuid,
                            distance: o.distance
                        })
                    }
                    return e
                }
            }), Er.prototype = Object.assign(Object.create(ji.prototype), {
                constructor: Er,
                isSkinnedMesh: !0,
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    for (var t = new Ze, e = this.geometry.attributes.skinWeight, i = 0, n = e.count; i < n; i++) {
                        t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
                        var r = 1 / t.manhattanLength();
                        r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                    }
                },
                updateMatrixWorld: function(t) {
                    ji.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Object.assign(Sr.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var i = new He;
                        this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                    }
                },
                pose: function() {
                    var t, e, i;
                    for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                    for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                },
                update: function() {
                    var t = new He,
                        e = new He;
                    return function() {
                        for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = i.length; a < s; a++) {
                            var c = i[a] ? i[a].matrixWorld : e;
                            t.multiplyMatrices(c, n[a]), t.toArray(r, 16 * a)
                        }
                        void 0 !== o && (o.needsUpdate = !0)
                    }
                }(),
                clone: function() {
                    return new Sr(this.bones, this.boneInverses)
                },
                getBoneByName: function(t) {
                    for (var e = 0, i = this.bones.length; e < i; e++) {
                        var n = this.bones[e];
                        if (n.name === t) return n
                    }
                }
            }), Ar.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Ar,
                isBone: !0
            }), Pr.prototype = Object.create(zi.prototype), Pr.prototype.constructor = Pr, Pr.prototype.isLineBasicMaterial = !0, Pr.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
            }, Lr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Lr,
                isLine: !0,
                computeLineDistances: function() {
                    var t = new je,
                        e = new je;
                    return function() {
                        var i = this.geometry;
                        if (i.isBufferGeometry)
                            if (null === i.index) {
                                for (var n = i.attributes.position, r = [0], o = 1, a = n.count; o < a; o++) t.fromBufferAttribute(n, o - 1), e.fromBufferAttribute(n, o), r[o] = r[o - 1], r[o] += t.distanceTo(e);
                                i.addAttribute("lineDistance", new Pi(r, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (i.isGeometry) {
                            var s = i.vertices;
                            (r = i.lineDistances)[0] = 0;
                            for (o = 1, a = s.length; o < a; o++) r[o] = r[o - 1], r[o] += s[o - 1].distanceTo(s[o])
                        }
                        return this
                    }
                }(),
                raycast: function() {
                    var t = new He,
                        e = new Gi,
                        i = new ti;
                    return function(n, r) {
                        var o = n.linePrecision,
                            a = this.geometry,
                            s = this.matrixWorld;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(s), i.radius += o, !1 !== n.ray.intersectsSphere(i)) {
                            t.getInverse(s), e.copy(n.ray).applyMatrix4(t);
                            var c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                l = c * c,
                                h = new je,
                                u = new je,
                                d = new je,
                                p = new je,
                                f = this && this.isLineSegments ? 2 : 1;
                            if (a.isBufferGeometry) {
                                var m = a.index,
                                    g = a.attributes.position.array;
                                if (null !== m)
                                    for (var v = m.array, y = 0, _ = v.length - 1; y < _; y += f) {
                                        var x = v[y],
                                            b = v[y + 1];
                                        if (h.fromArray(g, 3 * x), u.fromArray(g, 3 * b), !(e.distanceSqToSegment(h, u, p, d) > l)) p.applyMatrix4(this.matrixWorld), (T = n.ray.origin.distanceTo(p)) < n.near || T > n.far || r.push({
                                            distance: T,
                                            point: d.clone().applyMatrix4(this.matrixWorld),
                                            index: y,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    } else
                                        for (y = 0, _ = g.length / 3 - 1; y < _; y += f) {
                                            if (h.fromArray(g, 3 * y), u.fromArray(g, 3 * y + 3), !(e.distanceSqToSegment(h, u, p, d) > l)) p.applyMatrix4(this.matrixWorld), (T = n.ray.origin.distanceTo(p)) < n.near || T > n.far || r.push({
                                                distance: T,
                                                point: d.clone().applyMatrix4(this.matrixWorld),
                                                index: y,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                            } else if (a.isGeometry) {
                                var w = a.vertices,
                                    M = w.length;
                                for (y = 0; y < M - 1; y += f) {
                                    var T;
                                    if (!(e.distanceSqToSegment(w[y], w[y + 1], p, d) > l)) p.applyMatrix4(this.matrixWorld), (T = n.ray.origin.distanceTo(p)) < n.near || T > n.far || r.push({
                                        distance: T,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                        }
                    }
                }(),
                copy: function(t) {
                    return vi.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), Cr.prototype = Object.assign(Object.create(Lr.prototype), {
                constructor: Cr,
                isLineSegments: !0,
                computeLineDistances: function() {
                    var t = new je,
                        e = new je;
                    return function() {
                        var i = this.geometry;
                        if (i.isBufferGeometry)
                            if (null === i.index) {
                                for (var n = i.attributes.position, r = [], o = 0, a = n.count; o < a; o += 2) t.fromBufferAttribute(n, o), e.fromBufferAttribute(n, o + 1), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e);
                                i.addAttribute("lineDistance", new Pi(r, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (i.isGeometry) {
                            var s = i.vertices;
                            for (r = i.lineDistances, o = 0, a = s.length; o < a; o += 2) t.copy(s[o]), e.copy(s[o + 1]), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e)
                        }
                        return this
                    }
                }()
            }), Rr.prototype = Object.assign(Object.create(Lr.prototype), {
                constructor: Rr,
                isLineLoop: !0
            }), Or.prototype = Object.create(zi.prototype), Or.prototype.constructor = Or, Or.prototype.isPointsMaterial = !0, Or.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
            }, Ir.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Ir,
                isPoints: !0,
                raycast: function() {
                    var t = new He,
                        e = new Gi,
                        i = new ti;
                    return function(n, r) {
                        var o = this,
                            a = this.geometry,
                            s = this.matrixWorld,
                            c = n.params.Points.threshold;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(s), i.radius += c, !1 !== n.ray.intersectsSphere(i)) {
                            t.getInverse(s), e.copy(n.ray).applyMatrix4(t);
                            var l = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                h = l * l,
                                u = new je,
                                d = new je;
                            if (a.isBufferGeometry) {
                                var p = a.index,
                                    f = a.attributes.position.array;
                                if (null !== p)
                                    for (var m = p.array, g = 0, v = m.length; g < v; g++) {
                                        var y = m[g];
                                        u.fromArray(f, 3 * y), b(u, y)
                                    } else {
                                        g = 0;
                                        for (var _ = f.length / 3; g < _; g++) u.fromArray(f, 3 * g), b(u, g)
                                    }
                            } else {
                                var x = a.vertices;
                                for (g = 0, _ = x.length; g < _; g++) b(x[g], g)
                            }
                        }

                        function b(t, i) {
                            var a = e.distanceSqToPoint(t);
                            if (a < h) {
                                e.closestPointToPoint(t, d), d.applyMatrix4(s);
                                var c = n.ray.origin.distanceTo(d);
                                if (c < n.near || c > n.far) return;
                                r.push({
                                    distance: c,
                                    distanceToRay: Math.sqrt(a),
                                    point: d.clone(),
                                    index: i,
                                    face: null,
                                    object: o
                                })
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Dr.prototype = Object.assign(Object.create(Ye.prototype), {
                constructor: Dr,
                isVideoTexture: !0,
                update: function() {
                    var t = this.image;
                    t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), kr.prototype = Object.create(Ye.prototype), kr.prototype.constructor = kr, kr.prototype.isCompressedTexture = !0, Nr.prototype = Object.create(Ye.prototype), Nr.prototype.constructor = Nr, Nr.prototype.isCanvasTexture = !0, Br.prototype = Object.create(Ye.prototype), Br.prototype.constructor = Br, Br.prototype.isDepthTexture = !0, Fr.prototype = Object.create(Ii.prototype), Fr.prototype.constructor = Fr, zr.prototype = Object.create(_i.prototype), zr.prototype.constructor = zr, Ur.prototype = Object.create(Ii.prototype), Ur.prototype.constructor = Ur, Gr.prototype = Object.create(_i.prototype), Gr.prototype.constructor = Gr, Hr.prototype = Object.create(Ii.prototype), Hr.prototype.constructor = Hr, Vr.prototype = Object.create(_i.prototype), Vr.prototype.constructor = Vr, jr.prototype = Object.create(Hr.prototype), jr.prototype.constructor = jr, Wr.prototype = Object.create(_i.prototype), Wr.prototype.constructor = Wr, Xr.prototype = Object.create(Hr.prototype), Xr.prototype.constructor = Xr, qr.prototype = Object.create(_i.prototype), qr.prototype.constructor = qr, Yr.prototype = Object.create(Hr.prototype), Yr.prototype.constructor = Yr, Zr.prototype = Object.create(_i.prototype), Zr.prototype.constructor = Zr, Jr.prototype = Object.create(Hr.prototype), Jr.prototype.constructor = Jr, Kr.prototype = Object.create(_i.prototype), Kr.prototype.constructor = Kr, Qr.prototype = Object.create(Ii.prototype), Qr.prototype.constructor = Qr, $r.prototype = Object.create(_i.prototype), $r.prototype.constructor = $r, to.prototype = Object.create(Ii.prototype), to.prototype.constructor = to, eo.prototype = Object.create(_i.prototype), eo.prototype.constructor = eo, io.prototype = Object.create(Ii.prototype), io.prototype.constructor = io;
            var no = function(t, e, i) {
                i = i || 2;
                var n, r, o, a, s, c, l, h = e && e.length,
                    u = h ? e[0] * i : t.length,
                    d = ro(t, 0, u, i, !0),
                    p = [];
                if (!d) return p;
                if (h && (d = function(t, e, i, n) {
                        var r, o, a, s, c, l = [];
                        for (r = 0, o = e.length; r < o; r++) a = e[r] * n, s = r < o - 1 ? e[r + 1] * n : t.length, (c = ro(t, a, s, n, !1)) === c.next && (c.steiner = !0), l.push(mo(c));
                        for (l.sort(uo), r = 0; r < l.length; r++) po(l[r], i), i = oo(i, i.next);
                        return i
                    }(t, e, d, i)), t.length > 80 * i) {
                    n = o = t[0], r = a = t[1];
                    for (var f = i; f < u; f += i) s = t[f], c = t[f + 1], s < n && (n = s), c < r && (r = c), s > o && (o = s), c > a && (a = c);
                    l = 0 !== (l = Math.max(o - n, a - r)) ? 1 / l : 0
                }
                return ao(d, p, i, n, r, l), p
            };

            function ro(t, e, i, n, r) {
                var o, a;
                if (r === function(t, e, i, n) {
                        for (var r = 0, o = e, a = i - n; o < i; o += n) r += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                        return r
                    }(t, e, i, n) > 0)
                    for (o = e; o < i; o += n) a = Mo(o, t[o], t[o + 1], a);
                else
                    for (o = i - n; o >= e; o -= n) a = Mo(o, t[o], t[o + 1], a);
                return a && _o(a, a.next) && (To(a), a = a.next), a
            }

            function oo(t, e) {
                if (!t) return t;
                e || (e = t);
                var i, n = t;
                do {
                    if (i = !1, n.steiner || !_o(n, n.next) && 0 !== yo(n.prev, n, n.next)) n = n.next;
                    else {
                        if (To(n), (n = e = n.prev) === n.next) break;
                        i = !0
                    }
                } while (i || n !== e);
                return e
            }

            function ao(t, e, i, n, r, o, a) {
                if (t) {
                    !a && o && function(t, e, i, n) {
                        var r = t;
                        do {
                            null === r.z && (r.z = fo(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                var e, i, n, r, o, a, s, c, l = 1;
                                do {
                                    for (i = t, t = null, o = null, a = 0; i;) {
                                        for (a++, n = i, s = 0, e = 0; e < l && (s++, n = n.nextZ); e++);
                                        for (c = l; s > 0 || c > 0 && n;) 0 !== s && (0 === c || !n || i.z <= n.z) ? (r = i, i = i.nextZ, s--) : (r = n, n = n.nextZ, c--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                                        i = n
                                    }
                                    o.nextZ = null, l *= 2
                                } while (a > 1)
                            }(r)
                    }(t, n, r, o);
                    for (var s, c, l = t; t.prev !== t.next;)
                        if (s = t.prev, c = t.next, o ? co(t, n, r, o) : so(t)) e.push(s.i / i), e.push(t.i / i), e.push(c.i / i), To(t), t = c.next, l = c.next;
                        else if ((t = c) === l) {
                        a ? 1 === a ? ao(t = lo(t, e, i), e, i, n, r, o, 2) : 2 === a && ho(t, e, i, n, r, o) : ao(oo(t), e, i, n, r, o, 1);
                        break
                    }
                }
            }

            function so(t) {
                var e = t.prev,
                    i = t,
                    n = t.next;
                if (yo(e, i, n) >= 0) return !1;
                for (var r = t.next.next; r !== t.prev;) {
                    if (go(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && yo(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function co(t, e, i, n) {
                var r = t.prev,
                    o = t,
                    a = t.next;
                if (yo(r, o, a) >= 0) return !1;
                for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, c = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, l = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, h = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, u = fo(s, c, e, i, n), d = fo(l, h, e, i, n), p = t.nextZ; p && p.z <= d;) {
                    if (p !== t.prev && p !== t.next && go(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && yo(p.prev, p, p.next) >= 0) return !1;
                    p = p.nextZ
                }
                for (p = t.prevZ; p && p.z >= u;) {
                    if (p !== t.prev && p !== t.next && go(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && yo(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                return !0
            }

            function lo(t, e, i) {
                var n = t;
                do {
                    var r = n.prev,
                        o = n.next.next;
                    !_o(r, o) && xo(r, n, n.next, o) && bo(r, o) && bo(o, r) && (e.push(r.i / i), e.push(n.i / i), e.push(o.i / i), To(n), To(n.next), n = t = o), n = n.next
                } while (n !== t);
                return n
            }

            function ho(t, e, i, n, r, o) {
                var a = t;
                do {
                    for (var s = a.next.next; s !== a.prev;) {
                        if (a.i !== s.i && vo(a, s)) {
                            var c = wo(a, s);
                            return a = oo(a, a.next), c = oo(c, c.next), ao(a, e, i, n, r, o), void ao(c, e, i, n, r, o)
                        }
                        s = s.next
                    }
                    a = a.next
                } while (a !== t)
            }

            function uo(t, e) {
                return t.x - e.x
            }

            function po(t, e) {
                if (e = function(t, e) {
                        var i, n = e,
                            r = t.x,
                            o = t.y,
                            a = -1 / 0;
                        do {
                            if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
                                var s = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (s <= r && s > a) {
                                    if (a = s, s === r) {
                                        if (o === n.y) return n;
                                        if (o === n.next.y) return n.next
                                    }
                                    i = n.x < n.next.x ? n : n.next
                                }
                            }
                            n = n.next
                        } while (n !== e);
                        if (!i) return null;
                        if (r === a) return i.prev;
                        var c, l = i,
                            h = i.x,
                            u = i.y,
                            d = 1 / 0;
                        n = i.next;
                        for (; n !== l;) r >= n.x && n.x >= h && r !== n.x && go(o < u ? r : a, o, h, u, o < u ? a : r, o, n.x, n.y) && ((c = Math.abs(o - n.y) / (r - n.x)) < d || c === d && n.x > i.x) && bo(n, t) && (i = n, d = c), n = n.next;
                        return i
                    }(t, e)) {
                    var i = wo(e, t);
                    oo(i, i.next)
                }
            }

            function fo(t, e, i, n, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function mo(t) {
                var e = t,
                    i = t;
                do {
                    e.x < i.x && (i = e), e = e.next
                } while (e !== t);
                return i
            }

            function go(t, e, i, n, r, o, a, s) {
                return (r - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (n - s) - (i - a) * (e - s) >= 0 && (i - a) * (o - s) - (r - a) * (n - s) >= 0
            }

            function vo(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                    var i = t;
                    do {
                        if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && xo(i, i.next, t, e)) return !0;
                        i = i.next
                    } while (i !== t);
                    return !1
                }(t, e) && bo(t, e) && bo(e, t) && function(t, e) {
                    var i = t,
                        n = !1,
                        r = (t.x + e.x) / 2,
                        o = (t.y + e.y) / 2;
                    do {
                        i.y > o != i.next.y > o && i.next.y !== i.y && r < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
                    } while (i !== t);
                    return n
                }(t, e)
            }

            function yo(t, e, i) {
                return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
            }

            function _o(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function xo(t, e, i, n) {
                return !!(_o(t, e) && _o(i, n) || _o(t, n) && _o(i, e)) || yo(t, e, i) > 0 != yo(t, e, n) > 0 && yo(i, n, t) > 0 != yo(i, n, e) > 0
            }

            function bo(t, e) {
                return yo(t.prev, t, t.next) < 0 ? yo(t, e, t.next) >= 0 && yo(t, t.prev, e) >= 0 : yo(t, e, t.prev) < 0 || yo(t, t.next, e) < 0
            }

            function wo(t, e) {
                var i = new Eo(t.i, t.x, t.y),
                    n = new Eo(e.i, e.x, e.y),
                    r = t.next,
                    o = e.prev;
                return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
            }

            function Mo(t, e, i, n) {
                var r = new Eo(t, e, i);
                return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
            }

            function To(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function Eo(t, e, i) {
                this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var So = {
                area: function(t) {
                    for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                    return .5 * i
                },
                isClockWise: function(t) {
                    return So.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    var i = [],
                        n = [],
                        r = [];
                    Ao(t), Po(i, t);
                    var o = t.length;
                    e.forEach(Ao);
                    for (var a = 0; a < e.length; a++) n.push(o), o += e[a].length, Po(i, e[a]);
                    var s = no(i, n);
                    for (a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3));
                    return r
                }
            };

            function Ao(t) {
                var e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function Po(t, e) {
                for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
            }

            function Lo(t, e) {
                _i.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, this.fromBufferGeometry(new Co(t, e)), this.mergeVertices()
            }

            function Co(t, e) {
                Ii.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: t,
                    options: e
                };
                for (var i = this, n = [], r = [], o = 0, a = (t = Array.isArray(t) ? t : [t]).length; o < a; o++) {
                    s(t[o])
                }

                function s(t) {
                    var o = [],
                        a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        s = void 0 !== e.steps ? e.steps : 1,
                        c = void 0 !== e.depth ? e.depth : 100,
                        l = void 0 === e.bevelEnabled || e.bevelEnabled,
                        h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                        u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                        d = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                        p = e.extrudePath,
                        f = void 0 !== e.UVGenerator ? e.UVGenerator : Ro;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
                    var m, g, v, y, _, x, b, w, M = !1;
                    p && (m = p.getSpacedPoints(s), M = !0, l = !1, g = p.computeFrenetFrames(s, !1), v = new je, y = new je, _ = new je), l || (d = 0, h = 0, u = 0);
                    var T = t.extractPoints(a),
                        E = T.shape,
                        S = T.holes;
                    if (!So.isClockWise(E))
                        for (E = E.reverse(), b = 0, w = S.length; b < w; b++) x = S[b], So.isClockWise(x) && (S[b] = x.reverse());
                    var A = So.triangulateShape(E, S),
                        P = E;
                    for (b = 0, w = S.length; b < w; b++) x = S[b], E = E.concat(x);

                    function L(t, e, i) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
                    }
                    var C, R, O, I, D, k, N = E.length,
                        B = A.length;

                    function F(t, e, i) {
                        var n, r, o, a = t.x - e.x,
                            s = t.y - e.y,
                            c = i.x - t.x,
                            l = i.y - t.y,
                            h = a * a + s * s,
                            u = a * l - s * c;
                        if (Math.abs(u) > Number.EPSILON) {
                            var d = Math.sqrt(h),
                                p = Math.sqrt(c * c + l * l),
                                f = e.x - s / d,
                                m = e.y + a / d,
                                g = ((i.x - l / p - f) * l - (i.y + c / p - m) * c) / (a * l - s * c),
                                v = (n = f + a * g - t.x) * n + (r = m + s * g - t.y) * r;
                            if (v <= 2) return new Ge(n, r);
                            o = Math.sqrt(v / 2)
                        } else {
                            var y = !1;
                            a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(l) && (y = !0), y ? (n = -s, r = a, o = Math.sqrt(h)) : (n = a, r = s, o = Math.sqrt(h / 2))
                        }
                        return new Ge(n / o, r / o)
                    }
                    for (var z = [], U = 0, G = P.length, H = G - 1, V = U + 1; U < G; U++, H++, V++) H === G && (H = 0), V === G && (V = 0), z[U] = F(P[U], P[H], P[V]);
                    var j, W, X = [],
                        q = z.concat();
                    for (b = 0, w = S.length; b < w; b++) {
                        for (x = S[b], j = [], U = 0, H = (G = x.length) - 1, V = U + 1; U < G; U++, H++, V++) H === G && (H = 0), V === G && (V = 0), j[U] = F(x[U], x[H], x[V]);
                        X.push(j), q = q.concat(j)
                    }
                    for (C = 0; C < d; C++) {
                        for (O = C / d, I = h * Math.cos(O * Math.PI / 2), R = u * Math.sin(O * Math.PI / 2), U = 0, G = P.length; U < G; U++) Z((D = L(P[U], z[U], R)).x, D.y, -I);
                        for (b = 0, w = S.length; b < w; b++)
                            for (x = S[b], j = X[b], U = 0, G = x.length; U < G; U++) Z((D = L(x[U], j[U], R)).x, D.y, -I)
                    }
                    for (R = u, U = 0; U < N; U++) D = l ? L(E[U], q[U], R) : E[U], M ? (y.copy(g.normals[0]).multiplyScalar(D.x), v.copy(g.binormals[0]).multiplyScalar(D.y), _.copy(m[0]).add(y).add(v), Z(_.x, _.y, _.z)) : Z(D.x, D.y, 0);
                    for (W = 1; W <= s; W++)
                        for (U = 0; U < N; U++) D = l ? L(E[U], q[U], R) : E[U], M ? (y.copy(g.normals[W]).multiplyScalar(D.x), v.copy(g.binormals[W]).multiplyScalar(D.y), _.copy(m[W]).add(y).add(v), Z(_.x, _.y, _.z)) : Z(D.x, D.y, c / s * W);
                    for (C = d - 1; C >= 0; C--) {
                        for (O = C / d, I = h * Math.cos(O * Math.PI / 2), R = u * Math.sin(O * Math.PI / 2), U = 0, G = P.length; U < G; U++) Z((D = L(P[U], z[U], R)).x, D.y, c + I);
                        for (b = 0, w = S.length; b < w; b++)
                            for (x = S[b], j = X[b], U = 0, G = x.length; U < G; U++) D = L(x[U], j[U], R), M ? Z(D.x, D.y + m[s - 1].y, m[s - 1].x + I) : Z(D.x, D.y, c + I)
                    }

                    function Y(t, e) {
                        var i, n;
                        for (U = t.length; --U >= 0;) {
                            i = U, (n = U - 1) < 0 && (n = t.length - 1);
                            var r = 0,
                                o = s + 2 * d;
                            for (r = 0; r < o; r++) {
                                var a = N * r,
                                    c = N * (r + 1);
                                K(e + i + a, e + n + a, e + n + c, e + i + c)
                            }
                        }
                    }

                    function Z(t, e, i) {
                        o.push(t), o.push(e), o.push(i)
                    }

                    function J(t, e, r) {
                        Q(t), Q(e), Q(r);
                        var o = n.length / 3,
                            a = f.generateTopUV(i, n, o - 3, o - 2, o - 1);
                        $(a[0]), $(a[1]), $(a[2])
                    }

                    function K(t, e, r, o) {
                        Q(t), Q(e), Q(o), Q(e), Q(r), Q(o);
                        var a = n.length / 3,
                            s = f.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                        $(s[0]), $(s[1]), $(s[3]), $(s[1]), $(s[2]), $(s[3])
                    }

                    function Q(t) {
                        n.push(o[3 * t + 0]), n.push(o[3 * t + 1]), n.push(o[3 * t + 2])
                    }

                    function $(t) {
                        r.push(t.x), r.push(t.y)
                    }! function() {
                        var t = n.length / 3;
                        if (l) {
                            var e = 0,
                                r = N * e;
                            for (U = 0; U < B; U++) J((k = A[U])[2] + r, k[1] + r, k[0] + r);
                            for (r = N * (e = s + 2 * d), U = 0; U < B; U++) J((k = A[U])[0] + r, k[1] + r, k[2] + r)
                        } else {
                            for (U = 0; U < B; U++) J((k = A[U])[2], k[1], k[0]);
                            for (U = 0; U < B; U++) J((k = A[U])[0] + N * s, k[1] + N * s, k[2] + N * s)
                        }
                        i.addGroup(t, n.length / 3 - t, 0)
                    }(),
                    function() {
                        var t = n.length / 3,
                            e = 0;
                        for (Y(P, e), e += P.length, b = 0, w = S.length; b < w; b++) Y(x = S[b], e), e += x.length;
                        i.addGroup(t, n.length / 3 - t, 1)
                    }()
                }
                this.addAttribute("position", new Pi(n, 3)), this.addAttribute("uv", new Pi(r, 2)), this.computeVertexNormals()
            }
            Lo.prototype = Object.create(_i.prototype), Lo.prototype.constructor = Lo, Lo.prototype.toJSON = function() {
                var t = _i.prototype.toJSON.call(this);
                return Oo(this.parameters.shapes, this.parameters.options, t)
            }, Co.prototype = Object.create(Ii.prototype), Co.prototype.constructor = Co, Co.prototype.toJSON = function() {
                var t = Ii.prototype.toJSON.call(this);
                return Oo(this.parameters.shapes, this.parameters.options, t)
            };
            var Ro = {
                generateTopUV: function(t, e, i, n, r) {
                    var o = e[3 * i],
                        a = e[3 * i + 1],
                        s = e[3 * n],
                        c = e[3 * n + 1],
                        l = e[3 * r],
                        h = e[3 * r + 1];
                    return [new Ge(o, a), new Ge(s, c), new Ge(l, h)]
                },
                generateSideWallUV: function(t, e, i, n, r, o) {
                    var a = e[3 * i],
                        s = e[3 * i + 1],
                        c = e[3 * i + 2],
                        l = e[3 * n],
                        h = e[3 * n + 1],
                        u = e[3 * n + 2],
                        d = e[3 * r],
                        p = e[3 * r + 1],
                        f = e[3 * r + 2],
                        m = e[3 * o],
                        g = e[3 * o + 1],
                        v = e[3 * o + 2];
                    return Math.abs(s - h) < .01 ? [new Ge(a, 1 - c), new Ge(l, 1 - u), new Ge(d, 1 - f), new Ge(m, 1 - v)] : [new Ge(s, 1 - c), new Ge(h, 1 - u), new Ge(p, 1 - f), new Ge(g, 1 - v)]
                }
            };

            function Oo(t, e, i) {
                if (i.shapes = [], Array.isArray(t))
                    for (var n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        i.shapes.push(o.uuid)
                    } else i.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
            }

            function Io(t, e) {
                _i.call(this), this.type = "TextGeometry", this.parameters = {
                    text: t,
                    parameters: e
                }, this.fromBufferGeometry(new Do(t, e)), this.mergeVertices()
            }

            function Do(t, e) {
                var i = (e = e || {}).font;
                if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new _i;
                var n = i.generateShapes(t, e.size);
                e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Co.call(this, n, e), this.type = "TextBufferGeometry"
            }

            function ko(t, e, i, n, r, o, a) {
                _i.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: a
                }, this.fromBufferGeometry(new No(t, e, i, n, r, o, a)), this.mergeVertices()
            }

            function No(t, e, i, n, r, o, a) {
                Ii.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: a
                }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var s, c, l = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI),
                    h = 0,
                    u = [],
                    d = new je,
                    p = new je,
                    f = [],
                    m = [],
                    g = [],
                    v = [];
                for (c = 0; c <= i; c++) {
                    var y = [],
                        _ = c / i;
                    for (s = 0; s <= e; s++) {
                        var x = s / e;
                        d.x = -t * Math.cos(n + x * r) * Math.sin(o + _ * a), d.y = t * Math.cos(o + _ * a), d.z = t * Math.sin(n + x * r) * Math.sin(o + _ * a), m.push(d.x, d.y, d.z), p.set(d.x, d.y, d.z).normalize(), g.push(p.x, p.y, p.z), v.push(x, 1 - _), y.push(h++)
                    }
                    u.push(y)
                }
                for (c = 0; c < i; c++)
                    for (s = 0; s < e; s++) {
                        var b = u[c][s + 1],
                            w = u[c][s],
                            M = u[c + 1][s],
                            T = u[c + 1][s + 1];
                        (0 !== c || o > 0) && f.push(b, w, T), (c !== i - 1 || l < Math.PI) && f.push(w, M, T)
                    }
                this.setIndex(f), this.addAttribute("position", new Pi(m, 3)), this.addAttribute("normal", new Pi(g, 3)), this.addAttribute("uv", new Pi(v, 2))
            }

            function Bo(t, e, i, n, r, o) {
                _i.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: r,
                    thetaLength: o
                }, this.fromBufferGeometry(new Fo(t, e, i, n, r, o)), this.mergeVertices()
            }

            function Fo(t, e, i, n, r, o) {
                Ii.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: r,
                    thetaLength: o
                }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
                var a, s, c, l = [],
                    h = [],
                    u = [],
                    d = [],
                    p = t,
                    f = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1),
                    m = new je,
                    g = new Ge;
                for (s = 0; s <= n; s++) {
                    for (c = 0; c <= i; c++) a = r + c / i * o, m.x = p * Math.cos(a), m.y = p * Math.sin(a), h.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / e + 1) / 2, g.y = (m.y / e + 1) / 2, d.push(g.x, g.y);
                    p += f
                }
                for (s = 0; s < n; s++) {
                    var v = s * (i + 1);
                    for (c = 0; c < i; c++) {
                        var y = a = c + v,
                            _ = a + i + 1,
                            x = a + i + 2,
                            b = a + 1;
                        l.push(y, _, b), l.push(_, x, b)
                    }
                }
                this.setIndex(l), this.addAttribute("position", new Pi(h, 3)), this.addAttribute("normal", new Pi(u, 3)), this.addAttribute("uv", new Pi(d, 2))
            }

            function zo(t, e, i, n) {
                _i.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: i,
                    phiLength: n
                }, this.fromBufferGeometry(new Uo(t, e, i, n)), this.mergeVertices()
            }

            function Uo(t, e, i, n) {
                Ii.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: i,
                    phiLength: n
                }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = Ue.clamp(n, 0, 2 * Math.PI);
                var r, o, a, s = [],
                    c = [],
                    l = [],
                    h = 1 / e,
                    u = new je,
                    d = new Ge;
                for (o = 0; o <= e; o++) {
                    var p = i + o * h * n,
                        f = Math.sin(p),
                        m = Math.cos(p);
                    for (a = 0; a <= t.length - 1; a++) u.x = t[a].x * f, u.y = t[a].y, u.z = t[a].x * m, c.push(u.x, u.y, u.z), d.x = o / e, d.y = a / (t.length - 1), l.push(d.x, d.y)
                }
                for (o = 0; o < e; o++)
                    for (a = 0; a < t.length - 1; a++) {
                        var g = r = a + o * t.length,
                            v = r + t.length,
                            y = r + t.length + 1,
                            _ = r + 1;
                        s.push(g, v, _), s.push(v, y, _)
                    }
                if (this.setIndex(s), this.addAttribute("position", new Pi(c, 3)), this.addAttribute("uv", new Pi(l, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
                    var x = this.attributes.normal.array,
                        b = new je,
                        w = new je,
                        M = new je;
                    for (r = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3) b.x = x[a + 0], b.y = x[a + 1], b.z = x[a + 2], w.x = x[r + a + 0], w.y = x[r + a + 1], w.z = x[r + a + 2], M.addVectors(b, w).normalize(), x[a + 0] = x[r + a + 0] = M.x, x[a + 1] = x[r + a + 1] = M.y, x[a + 2] = x[r + a + 2] = M.z
                }
            }

            function Go(t, e) {
                _i.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, this.fromBufferGeometry(new Ho(t, e)), this.mergeVertices()
            }

            function Ho(t, e) {
                Ii.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, e = e || 12;
                var i = [],
                    n = [],
                    r = [],
                    o = [],
                    a = 0,
                    s = 0;
                if (!1 === Array.isArray(t)) l(t);
                else
                    for (var c = 0; c < t.length; c++) l(t[c]), this.addGroup(a, s, c), a += s, s = 0;

                function l(t) {
                    var a, c, l, h = n.length / 3,
                        u = t.extractPoints(e),
                        d = u.shape,
                        p = u.holes;
                    if (!1 === So.isClockWise(d))
                        for (d = d.reverse(), a = 0, c = p.length; a < c; a++) l = p[a], !0 === So.isClockWise(l) && (p[a] = l.reverse());
                    var f = So.triangulateShape(d, p);
                    for (a = 0, c = p.length; a < c; a++) l = p[a], d = d.concat(l);
                    for (a = 0, c = d.length; a < c; a++) {
                        var m = d[a];
                        n.push(m.x, m.y, 0), r.push(0, 0, 1), o.push(m.x, m.y)
                    }
                    for (a = 0, c = f.length; a < c; a++) {
                        var g = f[a],
                            v = g[0] + h,
                            y = g[1] + h,
                            _ = g[2] + h;
                        i.push(v, y, _), s += 3
                    }
                }
                this.setIndex(i), this.addAttribute("position", new Pi(n, 3)), this.addAttribute("normal", new Pi(r, 3)), this.addAttribute("uv", new Pi(o, 2))
            }

            function Vo(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (var i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        e.shapes.push(r.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }

            function jo(t, e) {
                Ii.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: e
                }, e = void 0 !== e ? e : 1;
                var i, n, r, o, a = [],
                    s = Math.cos(Ue.DEG2RAD * e),
                    c = [0, 0],
                    l = {},
                    h = ["a", "b", "c"];
                t.isBufferGeometry ? (o = new _i).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var u = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
                    for (var m = d[p], g = 0; g < 3; g++) i = m[h[g]], n = m[h[(g + 1) % 3]], c[0] = Math.min(i, n), c[1] = Math.max(i, n), void 0 === l[r = c[0] + "," + c[1]] ? l[r] = {
                        index1: c[0],
                        index2: c[1],
                        face1: p,
                        face2: void 0
                    } : l[r].face2 = p;
                for (r in l) {
                    var v = l[r];
                    if (void 0 === v.face2 || d[v.face1].normal.dot(d[v.face2].normal) <= s) {
                        var y = u[v.index1];
                        a.push(y.x, y.y, y.z), y = u[v.index2], a.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new Pi(a, 3))
            }

            function Wo(t, e, i, n, r, o, a, s) {
                _i.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: i,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                }, this.fromBufferGeometry(new Xo(t, e, i, n, r, o, a, s)), this.mergeVertices()
            }

            function Xo(t, e, i, n, r, o, a, s) {
                Ii.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: i,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                };
                var c = this;
                t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, i = i || 1, n = Math.floor(n) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
                var l = [],
                    h = [],
                    u = [],
                    d = [],
                    p = 0,
                    f = [],
                    m = i / 2,
                    g = 0;

                function v(i) {
                    var r, o, f, v = new Ge,
                        y = new je,
                        _ = 0,
                        x = !0 === i ? t : e,
                        b = !0 === i ? 1 : -1;
                    for (o = p, r = 1; r <= n; r++) h.push(0, m * b, 0), u.push(0, b, 0), d.push(.5, .5), p++;
                    for (f = p, r = 0; r <= n; r++) {
                        var w = r / n * s + a,
                            M = Math.cos(w),
                            T = Math.sin(w);
                        y.x = x * T, y.y = m * b, y.z = x * M, h.push(y.x, y.y, y.z), u.push(0, b, 0), v.x = .5 * M + .5, v.y = .5 * T * b + .5, d.push(v.x, v.y), p++
                    }
                    for (r = 0; r < n; r++) {
                        var E = o + r,
                            S = f + r;
                        !0 === i ? l.push(S, S + 1, E) : l.push(S + 1, S, E), _ += 3
                    }
                    c.addGroup(g, _, !0 === i ? 1 : 2), g += _
                }! function() {
                    var o, v, y = new je,
                        _ = new je,
                        x = 0,
                        b = (e - t) / i;
                    for (v = 0; v <= r; v++) {
                        var w = [],
                            M = v / r,
                            T = M * (e - t) + t;
                        for (o = 0; o <= n; o++) {
                            var E = o / n,
                                S = E * s + a,
                                A = Math.sin(S),
                                P = Math.cos(S);
                            _.x = T * A, _.y = -M * i + m, _.z = T * P, h.push(_.x, _.y, _.z), y.set(A, b, P).normalize(), u.push(y.x, y.y, y.z), d.push(E, 1 - M), w.push(p++)
                        }
                        f.push(w)
                    }
                    for (o = 0; o < n; o++)
                        for (v = 0; v < r; v++) {
                            var L = f[v][o],
                                C = f[v + 1][o],
                                R = f[v + 1][o + 1],
                                O = f[v][o + 1];
                            l.push(L, C, O), l.push(C, R, O), x += 6
                        }
                    c.addGroup(g, x, 0), g += x
                }(), !1 === o && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(l), this.addAttribute("position", new Pi(h, 3)), this.addAttribute("normal", new Pi(u, 3)), this.addAttribute("uv", new Pi(d, 2))
            }

            function qo(t, e, i, n, r, o, a) {
                Wo.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: i,
                    heightSegments: n,
                    openEnded: r,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function Yo(t, e, i, n, r, o, a) {
                Xo.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: i,
                    heightSegments: n,
                    openEnded: r,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function Zo(t, e, i, n) {
                _i.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: i,
                    thetaLength: n
                }, this.fromBufferGeometry(new Jo(t, e, i, n)), this.mergeVertices()
            }

            function Jo(t, e, i, n) {
                Ii.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: i,
                    thetaLength: n
                }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
                var r, o, a = [],
                    s = [],
                    c = [],
                    l = [],
                    h = new je,
                    u = new Ge;
                for (s.push(0, 0, 0), c.push(0, 0, 1), l.push(.5, .5), o = 0, r = 3; o <= e; o++, r += 3) {
                    var d = i + o / e * n;
                    h.x = t * Math.cos(d), h.y = t * Math.sin(d), s.push(h.x, h.y, h.z), c.push(0, 0, 1), u.x = (s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, l.push(u.x, u.y)
                }
                for (r = 1; r <= e; r++) a.push(r, r + 1, 0);
                this.setIndex(a), this.addAttribute("position", new Pi(s, 3)), this.addAttribute("normal", new Pi(c, 3)), this.addAttribute("uv", new Pi(l, 2))
            }
            Io.prototype = Object.create(_i.prototype), Io.prototype.constructor = Io, Do.prototype = Object.create(Co.prototype), Do.prototype.constructor = Do, ko.prototype = Object.create(_i.prototype), ko.prototype.constructor = ko, No.prototype = Object.create(Ii.prototype), No.prototype.constructor = No, Bo.prototype = Object.create(_i.prototype), Bo.prototype.constructor = Bo, Fo.prototype = Object.create(Ii.prototype), Fo.prototype.constructor = Fo, zo.prototype = Object.create(_i.prototype), zo.prototype.constructor = zo, Uo.prototype = Object.create(Ii.prototype), Uo.prototype.constructor = Uo, Go.prototype = Object.create(_i.prototype), Go.prototype.constructor = Go, Go.prototype.toJSON = function() {
                var t = _i.prototype.toJSON.call(this);
                return Vo(this.parameters.shapes, t)
            }, Ho.prototype = Object.create(Ii.prototype), Ho.prototype.constructor = Ho, Ho.prototype.toJSON = function() {
                var t = Ii.prototype.toJSON.call(this);
                return Vo(this.parameters.shapes, t)
            }, jo.prototype = Object.create(Ii.prototype), jo.prototype.constructor = jo, Wo.prototype = Object.create(_i.prototype), Wo.prototype.constructor = Wo, Xo.prototype = Object.create(Ii.prototype), Xo.prototype.constructor = Xo, qo.prototype = Object.create(Wo.prototype), qo.prototype.constructor = qo, Yo.prototype = Object.create(Xo.prototype), Yo.prototype.constructor = Yo, Zo.prototype = Object.create(_i.prototype), Zo.prototype.constructor = Zo, Jo.prototype = Object.create(Ii.prototype), Jo.prototype.constructor = Jo;
            var Ko = Object.freeze({
                WireframeGeometry: Fr,
                ParametricGeometry: zr,
                ParametricBufferGeometry: Ur,
                TetrahedronGeometry: Vr,
                TetrahedronBufferGeometry: jr,
                OctahedronGeometry: Wr,
                OctahedronBufferGeometry: Xr,
                IcosahedronGeometry: qr,
                IcosahedronBufferGeometry: Yr,
                DodecahedronGeometry: Zr,
                DodecahedronBufferGeometry: Jr,
                PolyhedronGeometry: Gr,
                PolyhedronBufferGeometry: Hr,
                TubeGeometry: Kr,
                TubeBufferGeometry: Qr,
                TorusKnotGeometry: $r,
                TorusKnotBufferGeometry: to,
                TorusGeometry: eo,
                TorusBufferGeometry: io,
                TextGeometry: Io,
                TextBufferGeometry: Do,
                SphereGeometry: ko,
                SphereBufferGeometry: No,
                RingGeometry: Bo,
                RingBufferGeometry: Fo,
                PlaneGeometry: Ni,
                PlaneBufferGeometry: Bi,
                LatheGeometry: zo,
                LatheBufferGeometry: Uo,
                ShapeGeometry: Go,
                ShapeBufferGeometry: Ho,
                ExtrudeGeometry: Lo,
                ExtrudeBufferGeometry: Co,
                EdgesGeometry: jo,
                ConeGeometry: qo,
                ConeBufferGeometry: Yo,
                CylinderGeometry: Wo,
                CylinderBufferGeometry: Xo,
                CircleGeometry: Zo,
                CircleBufferGeometry: Jo,
                BoxGeometry: Di,
                BoxBufferGeometry: ki
            });

            function Qo(t) {
                zi.call(this), this.type = "ShadowMaterial", this.color = new ci(0), this.transparent = !0, this.setValues(t)
            }

            function $o(t) {
                Ui.call(this, t), this.type = "RawShaderMaterial"
            }

            function ta(t) {
                zi.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new ci(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ci(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function ea(t) {
                ta.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
            }

            function ia(t) {
                zi.call(this), this.type = "MeshPhongMaterial", this.color = new ci(16777215), this.specular = new ci(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ci(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function na(t) {
                ia.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
            }

            function ra(t) {
                zi.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function oa(t) {
                zi.call(this), this.type = "MeshLambertMaterial", this.color = new ci(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ci(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function aa(t) {
                zi.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new ci(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t)
            }

            function sa(t) {
                Pr.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            Qo.prototype = Object.create(zi.prototype), Qo.prototype.constructor = Qo, Qo.prototype.isShadowMaterial = !0, Qo.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this
            }, $o.prototype = Object.create(Ui.prototype), $o.prototype.constructor = $o, $o.prototype.isRawShaderMaterial = !0, ta.prototype = Object.create(zi.prototype), ta.prototype.constructor = ta, ta.prototype.isMeshStandardMaterial = !0, ta.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, ea.prototype = Object.create(ta.prototype), ea.prototype.constructor = ea, ea.prototype.isMeshPhysicalMaterial = !0, ea.prototype.copy = function(t) {
                return ta.prototype.copy.call(this, t), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
            }, ia.prototype = Object.create(zi.prototype), ia.prototype.constructor = ia, ia.prototype.isMeshPhongMaterial = !0, ia.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, na.prototype = Object.create(ia.prototype), na.prototype.constructor = na, na.prototype.isMeshToonMaterial = !0, na.prototype.copy = function(t) {
                return ia.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
            }, ra.prototype = Object.create(zi.prototype), ra.prototype.constructor = ra, ra.prototype.isMeshNormalMaterial = !0, ra.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, oa.prototype = Object.create(zi.prototype), oa.prototype.constructor = oa, oa.prototype.isMeshLambertMaterial = !0, oa.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, aa.prototype = Object.create(zi.prototype), aa.prototype.constructor = aa, aa.prototype.isMeshMatcapMaterial = !0, aa.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, sa.prototype = Object.create(Pr.prototype), sa.prototype.constructor = sa, sa.prototype.isLineDashedMaterial = !0, sa.prototype.copy = function(t) {
                return Pr.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var ca = Object.freeze({
                    ShadowMaterial: Qo,
                    SpriteMaterial: wr,
                    RawShaderMaterial: $o,
                    ShaderMaterial: Ui,
                    PointsMaterial: Or,
                    MeshPhysicalMaterial: ea,
                    MeshStandardMaterial: ta,
                    MeshPhongMaterial: ia,
                    MeshToonMaterial: na,
                    MeshNormalMaterial: ra,
                    MeshLambertMaterial: oa,
                    MeshDepthMaterial: ir,
                    MeshDistanceMaterial: nr,
                    MeshBasicMaterial: Vi,
                    MeshMatcapMaterial: aa,
                    LineDashedMaterial: sa,
                    LineBasicMaterial: Pr,
                    Material: zi
                }),
                la = {
                    arraySlice: function(t, e, i) {
                        return la.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
                    },
                    convertArray: function(t, e, i) {
                        return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    },
                    isTypedArray: function(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    },
                    getKeyframeOrder: function(t) {
                        for (var e = t.length, i = new Array(e), n = 0; n !== e; ++n) i[n] = n;
                        return i.sort(function(e, i) {
                            return t[e] - t[i]
                        }), i
                    },
                    sortedArray: function(t, e, i) {
                        for (var n = t.length, r = new t.constructor(n), o = 0, a = 0; a !== n; ++o)
                            for (var s = i[o] * e, c = 0; c !== e; ++c) r[a++] = t[s + c];
                        return r
                    },
                    flattenJSON: function(t, e, i, n) {
                        for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[n];) o = t[r++];
                        if (void 0 !== o) {
                            var a = o[n];
                            if (void 0 !== a)
                                if (Array.isArray(a))
                                    do {
                                        void 0 !== (a = o[n]) && (e.push(o.time), i.push.apply(i, a)), o = t[r++]
                                    } while (void 0 !== o);
                                else if (void 0 !== a.toArray)
                                do {
                                    void 0 !== (a = o[n]) && (e.push(o.time), a.toArray(i, i.length)), o = t[r++]
                                } while (void 0 !== o);
                            else
                                do {
                                    void 0 !== (a = o[n]) && (e.push(o.time), i.push(a)), o = t[r++]
                                } while (void 0 !== o)
                        }
                    }
                };

            function ha(t, e, i, n) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
            }

            function ua(t, e, i, n) {
                ha.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function da(t, e, i, n) {
                ha.call(this, t, e, i, n)
            }

            function pa(t, e, i, n) {
                ha.call(this, t, e, i, n)
            }

            function fa(t, e, i, n) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = la.convertArray(e, this.TimeBufferType), this.values = la.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
            }

            function ma(t, e, i) {
                fa.call(this, t, e, i)
            }

            function ga(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function va(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function ya(t, e, i, n) {
                ha.call(this, t, e, i, n)
            }

            function _a(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function xa(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function ba(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function wa(t, e, i) {
                this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = Ue.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function Ma(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var e = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return va;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return ba;
                        case "color":
                            return ga;
                        case "quaternion":
                            return _a;
                        case "bool":
                        case "boolean":
                            return ma;
                        case "string":
                            return xa
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    var i = [],
                        n = [];
                    la.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            Object.assign(ha.prototype, {
                    evaluate: function(t) {
                        var e = this.parameterPositions,
                            i = this._cachedIndex,
                            n = e[i],
                            r = e[i - 1];
                        t: {
                            e: {
                                var o;i: {
                                    n: if (!(t < n)) {
                                        for (var a = i + 2;;) {
                                            if (void 0 === n) {
                                                if (t < r) break n;
                                                return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r)
                                            }
                                            if (i === a) break;
                                            if (r = n, t < (n = e[++i])) break e
                                        }
                                        o = e.length;
                                        break i
                                    }if (t >= r) break t;
                                    var s = e[1];t < s && (i = 2, r = s);
                                    for (a = i - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                        if (i === a) break;
                                        if (n = r, t >= (r = e[--i - 1])) break e
                                    }
                                    o = i,
                                    i = 0
                                }
                                for (; i < o;) {
                                    var c = i + o >>> 1;
                                    t < e[c] ? o = c : i = c + 1
                                }
                                if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                if (void 0 === n) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, t)
                            }
                            this._cachedIndex = i,
                            this.intervalChanged_(i, r, n)
                        }
                        return this.interpolate_(i, r, t, n)
                    },
                    settings: null,
                    DefaultSettings_: {},
                    getSettings_: function() {
                        return this.settings || this.DefaultSettings_
                    },
                    copySampleValue_: function(t) {
                        for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, o = 0; o !== n; ++o) e[o] = i[r + o];
                        return e
                    },
                    interpolate_: function() {
                        throw new Error("call to abstract method")
                    },
                    intervalChanged_: function() {}
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign(ha.prototype, {
                    beforeStart_: ha.prototype.copySampleValue_,
                    afterEnd_: ha.prototype.copySampleValue_
                }), ua.prototype = Object.assign(Object.create(ha.prototype), {
                    constructor: ua,
                    DefaultSettings_: {
                        endingStart: we,
                        endingEnd: we
                    },
                    intervalChanged_: function(t, e, i) {
                        var n = this.parameterPositions,
                            r = t - 2,
                            o = t + 1,
                            a = n[r],
                            s = n[o];
                        if (void 0 === a) switch (this.getSettings_().endingStart) {
                            case Me:
                                r = t, a = 2 * e - i;
                                break;
                            case Te:
                                a = e + n[r = n.length - 2] - n[r + 1];
                                break;
                            default:
                                r = t, a = i
                        }
                        if (void 0 === s) switch (this.getSettings_().endingEnd) {
                            case Me:
                                o = t, s = 2 * i - e;
                                break;
                            case Te:
                                o = 1, s = i + n[1] - n[0];
                                break;
                            default:
                                o = t - 1, s = e
                        }
                        var c = .5 * (i - e),
                            l = this.valueSize;
                        this._weightPrev = c / (e - a), this._weightNext = c / (s - i), this._offsetPrev = r * l, this._offsetNext = o * l
                    },
                    interpolate_: function(t, e, i, n) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (i - e) / (n - e), f = p * p, m = f * p, g = -u * m + 2 * u * f - u * p, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, _ = d * m - d * f, x = 0; x !== a; ++x) r[x] = g * o[l + x] + v * o[c + x] + y * o[s + x] + _ * o[h + x];
                        return r
                    }
                }), da.prototype = Object.assign(Object.create(ha.prototype), {
                    constructor: da,
                    interpolate_: function(t, e, i, n) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = (i - e) / (n - e), h = 1 - l, u = 0; u !== a; ++u) r[u] = o[c + u] * h + o[s + u] * l;
                        return r
                    }
                }), pa.prototype = Object.assign(Object.create(ha.prototype), {
                    constructor: pa,
                    interpolate_: function(t) {
                        return this.copySampleValue_(t - 1)
                    }
                }), Object.assign(fa, {
                    toJSON: function(t) {
                        var e, i = t.constructor;
                        if (void 0 !== i.toJSON) e = i.toJSON(t);
                        else {
                            e = {
                                name: t.name,
                                times: la.convertArray(t.times, Array),
                                values: la.convertArray(t.values, Array)
                            };
                            var n = t.getInterpolation();
                            n !== t.DefaultInterpolation && (e.interpolation = n)
                        }
                        return e.type = t.ValueTypeName, e
                    }
                }), Object.assign(fa.prototype, {
                    constructor: fa,
                    TimeBufferType: Float32Array,
                    ValueBufferType: Float32Array,
                    DefaultInterpolation: xe,
                    InterpolantFactoryMethodDiscrete: function(t) {
                        return new pa(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodLinear: function(t) {
                        return new da(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: function(t) {
                        return new ua(this.times, this.values, this.getValueSize(), t)
                    },
                    setInterpolation: function(t) {
                        var e;
                        switch (t) {
                            case _e:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case xe:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case be:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(i);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", i), this
                        }
                        return this.createInterpolant = e, this
                    },
                    getInterpolation: function() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return _e;
                            case this.InterpolantFactoryMethodLinear:
                                return xe;
                            case this.InterpolantFactoryMethodSmooth:
                                return be
                        }
                    },
                    getValueSize: function() {
                        return this.values.length / this.times.length
                    },
                    shift: function(t) {
                        if (0 !== t)
                            for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
                        return this
                    },
                    scale: function(t) {
                        if (1 !== t)
                            for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                        return this
                    },
                    trim: function(t, e) {
                        for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < t;) ++r;
                        for (; - 1 !== o && i[o] > e;) --o;
                        if (++o, 0 !== r || o !== n) {
                            r >= o && (r = (o = Math.max(o, 1)) - 1);
                            var a = this.getValueSize();
                            this.times = la.arraySlice(i, r, o), this.values = la.arraySlice(this.values, r * a, o * a)
                        }
                        return this
                    },
                    validate: function() {
                        var t = !0,
                            e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        var i = this.times,
                            n = this.values,
                            r = i.length;
                        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        for (var o = null, a = 0; a !== r; a++) {
                            var s = i[a];
                            if ("number" == typeof s && isNaN(s)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1;
                                break
                            }
                            if (null !== o && o > s) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1;
                                break
                            }
                            o = s
                        }
                        if (void 0 !== n && la.isTypedArray(n)) {
                            a = 0;
                            for (var c = n.length; a !== c; ++a) {
                                var l = n[a];
                                if (isNaN(l)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), t = !1;
                                    break
                                }
                            }
                        }
                        return t
                    },
                    optimize: function() {
                        for (var t = this.times, e = this.values, i = this.getValueSize(), n = this.getInterpolation() === be, r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                            var s = !1,
                                c = t[a];
                            if (c !== t[a + 1] && (1 !== a || c !== c[0]))
                                if (n) s = !0;
                                else
                                    for (var l = a * i, h = l - i, u = l + i, d = 0; d !== i; ++d) {
                                        var p = e[l + d];
                                        if (p !== e[h + d] || p !== e[u + d]) {
                                            s = !0;
                                            break
                                        }
                                    }
                            if (s) {
                                if (a !== r) {
                                    t[r] = t[a];
                                    var f = a * i,
                                        m = r * i;
                                    for (d = 0; d !== i; ++d) e[m + d] = e[f + d]
                                }++r
                            }
                        }
                        if (o > 0) {
                            t[r] = t[o];
                            for (f = o * i, m = r * i, d = 0; d !== i; ++d) e[m + d] = e[f + d];
                            ++r
                        }
                        return r !== t.length && (this.times = la.arraySlice(t, 0, r), this.values = la.arraySlice(e, 0, r * i)), this
                    }
                }), ma.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: ma,
                    ValueTypeName: "bool",
                    ValueBufferType: Array,
                    DefaultInterpolation: _e,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), ga.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: ga,
                    ValueTypeName: "color"
                }), va.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: va,
                    ValueTypeName: "number"
                }), ya.prototype = Object.assign(Object.create(ha.prototype), {
                    constructor: ya,
                    interpolate_: function(t, e, i, n) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = (i - e) / (n - e), l = s + a; s !== l; s += 4) Ve.slerpFlat(r, 0, o, s - a, o, s, c);
                        return r
                    }
                }), _a.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: _a,
                    ValueTypeName: "quaternion",
                    DefaultInterpolation: xe,
                    InterpolantFactoryMethodLinear: function(t) {
                        return new ya(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: void 0
                }), xa.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: xa,
                    ValueTypeName: "string",
                    ValueBufferType: Array,
                    DefaultInterpolation: _e,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), ba.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: ba,
                    ValueTypeName: "vector"
                }), Object.assign(wa, {
                    parse: function(t) {
                        for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, o = i.length; r !== o; ++r) e.push(Ma(i[r]).scale(n));
                        return new wa(t.name, t.duration, e)
                    },
                    toJSON: function(t) {
                        for (var e = [], i = t.tracks, n = {
                                name: t.name,
                                duration: t.duration,
                                tracks: e,
                                uuid: t.uuid
                            }, r = 0, o = i.length; r !== o; ++r) e.push(fa.toJSON(i[r]));
                        return n
                    },
                    CreateFromMorphTargetSequence: function(t, e, i, n) {
                        for (var r = e.length, o = [], a = 0; a < r; a++) {
                            var s = [],
                                c = [];
                            s.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
                            var l = la.getKeyframeOrder(s);
                            s = la.sortedArray(s, 1, l), c = la.sortedArray(c, 1, l), n || 0 !== s[0] || (s.push(r), c.push(c[0])), o.push(new va(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(1 / i))
                        }
                        return new wa(t, -1, o)
                    },
                    findByName: function(t, e) {
                        var i = t;
                        if (!Array.isArray(t)) {
                            var n = t;
                            i = n.geometry && n.geometry.animations || n.animations
                        }
                        for (var r = 0; r < i.length; r++)
                            if (i[r].name === e) return i[r];
                        return null
                    },
                    CreateClipsFromMorphTargetSequences: function(t, e, i) {
                        for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                            var s = t[o],
                                c = s.name.match(r);
                            if (c && c.length > 1) {
                                var l = n[u = c[1]];
                                l || (n[u] = l = []), l.push(s)
                            }
                        }
                        var h = [];
                        for (var u in n) h.push(wa.CreateFromMorphTargetSequence(u, n[u], e, i));
                        return h
                    },
                    parseAnimation: function(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        for (var i = function(t, e, i, n, r) {
                                if (0 !== i.length) {
                                    var o = [],
                                        a = [];
                                    la.flattenJSON(i, o, a, n), 0 !== o.length && r.push(new t(e, o, a))
                                }
                            }, n = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                            var l = s[c].keys;
                            if (l && 0 !== l.length)
                                if (l[0].morphTargets) {
                                    for (var h = {}, u = 0; u < l.length; u++)
                                        if (l[u].morphTargets)
                                            for (var d = 0; d < l[u].morphTargets.length; d++) h[l[u].morphTargets[d]] = -1;
                                    for (var p in h) {
                                        var f = [],
                                            m = [];
                                        for (d = 0; d !== l[u].morphTargets.length; ++d) {
                                            var g = l[u];
                                            f.push(g.time), m.push(g.morphTarget === p ? 1 : 0)
                                        }
                                        n.push(new va(".morphTargetInfluence[" + p + "]", f, m))
                                    }
                                    o = h.length * (a || 1)
                                } else {
                                    var v = ".bones[" + e[c].name + "]";
                                    i(ba, v + ".position", l, "pos", n), i(_a, v + ".quaternion", l, "rot", n), i(ba, v + ".scale", l, "scl", n)
                                }
                        }
                        return 0 === n.length ? null : new wa(r, o, n)
                    }
                }), Object.assign(wa.prototype, {
                    resetDuration: function() {
                        for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
                            var n = this.tracks[e];
                            t = Math.max(t, n.times[n.times.length - 1])
                        }
                        return this.duration = t, this
                    },
                    trim: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                        return this
                    },
                    validate: function() {
                        for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                        return t
                    },
                    optimize: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                        return this
                    }
                });
            var Ta = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function Ea(t, e, i) {
                var n = this,
                    r = !1,
                    o = 0,
                    a = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                    a++, !1 === r && void 0 !== n.onStart && n.onStart(t, o, a), r = !0
                }, this.itemEnd = function(t) {
                    o++, void 0 !== n.onProgress && n.onProgress(t, o, a), o === a && (r = !1, void 0 !== n.onLoad && n.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== n.onError && n.onError(t)
                }, this.resolveURL = function(t) {
                    return s ? s(t) : t
                }, this.setURLModifier = function(t) {
                    return s = t, this
                }
            }
            var Sa = new Ea,
                Aa = {};

            function Pa(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function La(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Ca(t) {
                this.manager = void 0 !== t ? t : Sa, this._parser = null
            }

            function Ra(t) {
                this.manager = void 0 !== t ? t : Sa, this._parser = null
            }

            function Oa(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Ia(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Da(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function ka() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function Na(t, e, i, n, r, o, a, s) {
                ka.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
            }

            function Ba(t, e, i, n, r, o) {
                Na.call(this, t, e, i, i, n, r, o), this.type = "ArcCurve"
            }

            function Fa() {
                var t = 0,
                    e = 0,
                    i = 0,
                    n = 0;

                function r(r, o, a, s) {
                    t = r, e = a, i = -3 * r + 3 * o - 2 * a - s, n = 2 * r - 2 * o + a + s
                }
                return {
                    initCatmullRom: function(t, e, i, n, o) {
                        r(e, i, o * (i - t), o * (n - e))
                    },
                    initNonuniformCatmullRom: function(t, e, i, n, o, a, s) {
                        var c = (e - t) / o - (i - t) / (o + a) + (i - e) / a,
                            l = (i - e) / a - (n - e) / (a + s) + (n - i) / s;
                        r(e, i, c *= a, l *= a)
                    },
                    calc: function(r) {
                        var o = r * r;
                        return t + e * r + i * o + n * (o * r)
                    }
                }
            }
            Object.assign(Pa.prototype, {
                load: function(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Ta.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    if (void 0 === Aa[t]) {
                        var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (a) {
                            var s = a[1],
                                c = !!a[2],
                                l = a[3];
                            l = decodeURIComponent(l), c && (l = atob(l));
                            try {
                                var h, u = (this.responseType || "").toLowerCase();
                                switch (u) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var d = new Uint8Array(l.length), p = 0; p < l.length; p++) d[p] = l.charCodeAt(p);
                                        h = "blob" === u ? new Blob([d.buffer], {
                                            type: s
                                        }) : d.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        h = f.parseFromString(l, s);
                                        break;
                                    case "json":
                                        h = JSON.parse(l);
                                        break;
                                    default:
                                        h = l
                                }
                                setTimeout(function() {
                                    e && e(h), r.manager.itemEnd(t)
                                }, 0)
                            } catch (e) {
                                setTimeout(function() {
                                    n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                                }, 0)
                            }
                        } else {
                            Aa[t] = [], Aa[t].push({
                                onLoad: e,
                                onProgress: i,
                                onError: n
                            });
                            var m = new XMLHttpRequest;
                            for (var g in m.open("GET", t, !0), m.addEventListener("load", function(e) {
                                    var i = this.response;
                                    Ta.add(t, i);
                                    var n = Aa[t];
                                    if (delete Aa[t], 200 === this.status || 0 === this.status) {
                                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                        for (var o = 0, a = n.length; o < a; o++) {
                                            (s = n[o]).onLoad && s.onLoad(i)
                                        }
                                        r.manager.itemEnd(t)
                                    } else {
                                        for (o = 0, a = n.length; o < a; o++) {
                                            var s;
                                            (s = n[o]).onError && s.onError(e)
                                        }
                                        r.manager.itemError(t), r.manager.itemEnd(t)
                                    }
                                }, !1), m.addEventListener("progress", function(e) {
                                    for (var i = Aa[t], n = 0, r = i.length; n < r; n++) {
                                        var o = i[n];
                                        o.onProgress && o.onProgress(e)
                                    }
                                }, !1), m.addEventListener("error", function(e) {
                                    var i = Aa[t];
                                    delete Aa[t];
                                    for (var n = 0, o = i.length; n < o; n++) {
                                        var a = i[n];
                                        a.onError && a.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }, !1), m.addEventListener("abort", function(e) {
                                    var i = Aa[t];
                                    delete Aa[t];
                                    for (var n = 0, o = i.length; n < o; n++) {
                                        var a = i[n];
                                        a.onError && a.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
                            m.send(null)
                        }
                        return r.manager.itemStart(t), m
                    }
                    Aa[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: n
                    })
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            }), Object.assign(La.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Pa(r.manager);
                    o.setPath(r.path), o.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, i, n)
                },
                parse: function(t, e) {
                    for (var i = [], n = 0; n < t.length; n++) {
                        var r = wa.parse(t[n]);
                        i.push(r)
                    }
                    e(i)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Ca.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = [],
                        a = new kr;
                    a.image = o;
                    var s = new Pa(this.manager);

                    function c(c) {
                        s.load(t[c], function(t) {
                            var i = r._parser(t, !0);
                            o[c] = {
                                width: i.width,
                                height: i.height,
                                format: i.format,
                                mipmaps: i.mipmaps
                            }, 6 === (l += 1) && (1 === i.mipmapCount && (a.minFilter = Mt), a.format = i.format, a.needsUpdate = !0, e && e(a))
                        }, i, n)
                    }
                    if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                        for (var l = 0, h = 0, u = t.length; h < u; ++h) c(h);
                    else s.load(t, function(t) {
                        var i = r._parser(t, !0);
                        if (i.isCubemap)
                            for (var n = i.mipmaps.length / i.mipmapCount, s = 0; s < n; s++) {
                                o[s] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < i.mipmapCount; c++) o[s].mipmaps.push(i.mipmaps[s * i.mipmapCount + c]), o[s].format = i.format, o[s].width = i.width, o[s].height = i.height
                            } else a.image.width = i.width, a.image.height = i.height, a.mipmaps = i.mipmaps;
                        1 === i.mipmapCount && (a.minFilter = Mt), a.format = i.format, a.needsUpdate = !0, e && e(a)
                    }, i, n);
                    return a
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Ra.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Qe,
                        a = new Pa(this.manager);
                    return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(t, function(t) {
                        var i = r._parser(t);
                        i && (void 0 !== i.image ? o.image = i.image : void 0 !== i.data && (o.image.width = i.width, o.image.height = i.height, o.image.data = i.data), o.wrapS = void 0 !== i.wrapS ? i.wrapS : yt, o.wrapT = void 0 !== i.wrapT ? i.wrapT : yt, o.magFilter = void 0 !== i.magFilter ? i.magFilter : Mt, o.minFilter = void 0 !== i.minFilter ? i.minFilter : Et, o.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (o.format = i.format), void 0 !== i.type && (o.type = i.type), void 0 !== i.mipmaps && (o.mipmaps = i.mipmaps), 1 === i.mipmapCount && (o.minFilter = Mt), o.needsUpdate = !0, e && e(o, i))
                    }, i, n), o
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Oa.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Ta.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), Ta.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }

                    function c(e) {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }
                    return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Ia.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, i, n) {
                    var r = new Xi,
                        o = new Oa(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    var a = 0;

                    function s(i) {
                        o.load(t[i], function(t) {
                            r.images[i] = t, 6 === ++a && (r.needsUpdate = !0, e && e(r))
                        }, void 0, n)
                    }
                    for (var c = 0; c < t.length; ++c) s(c);
                    return r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Da.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, i, n) {
                    var r = new Ye,
                        o = new Oa(this.manager);
                    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(i) {
                        r.image = i;
                        var n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        r.format = n ? zt : Ut, r.needsUpdate = !0, void 0 !== e && e(r)
                    }, i, n), r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(ka.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    var i = this.getUtoTmapping(t);
                    return this.getPoint(i, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                    return e
                },
                getLength: function() {
                    var t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var e, i, n = [],
                        r = this.getPoint(0),
                        o = 0;
                    for (n.push(0), i = 1; i <= t; i++) o += (e = this.getPoint(i / t)).distanceTo(r), n.push(o), r = e;
                    return this.cacheArcLengths = n, n
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    var i, n = this.getLengths(),
                        r = 0,
                        o = n.length;
                    i = e || t * n[o - 1];
                    for (var a, s = 0, c = o - 1; s <= c;)
                        if ((a = n[r = Math.floor(s + (c - s) / 2)] - i) < 0) s = r + 1;
                        else {
                            if (!(a > 0)) {
                                c = r;
                                break
                            }
                            c = r - 1
                        }
                    if (n[r = c] === i) return r / (o - 1);
                    var l = n[r];
                    return (r + (i - l) / (n[r + 1] - l)) / (o - 1)
                },
                getTangent: function(t) {
                    var e = t - 1e-4,
                        i = t + 1e-4;
                    e < 0 && (e = 0), i > 1 && (i = 1);
                    var n = this.getPoint(e);
                    return this.getPoint(i).clone().sub(n).normalize()
                },
                getTangentAt: function(t) {
                    var e = this.getUtoTmapping(t);
                    return this.getTangent(e)
                },
                computeFrenetFrames: function(t, e) {
                    var i, n, r, o = new je,
                        a = [],
                        s = [],
                        c = [],
                        l = new je,
                        h = new He;
                    for (i = 0; i <= t; i++) n = i / t, a[i] = this.getTangentAt(n), a[i].normalize();
                    s[0] = new je, c[0] = new je;
                    var u = Number.MAX_VALUE,
                        d = Math.abs(a[0].x),
                        p = Math.abs(a[0].y),
                        f = Math.abs(a[0].z);
                    for (d <= u && (u = d, o.set(1, 0, 0)), p <= u && (u = p, o.set(0, 1, 0)), f <= u && o.set(0, 0, 1), l.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], l), c[0].crossVectors(a[0], s[0]), i = 1; i <= t; i++) s[i] = s[i - 1].clone(), c[i] = c[i - 1].clone(), l.crossVectors(a[i - 1], a[i]), l.length() > Number.EPSILON && (l.normalize(), r = Math.acos(Ue.clamp(a[i - 1].dot(a[i]), -1, 1)), s[i].applyMatrix4(h.makeRotationAxis(l, r))), c[i].crossVectors(a[i], s[i]);
                    if (!0 === e)
                        for (r = Math.acos(Ue.clamp(s[0].dot(s[t]), -1, 1)), r /= t, a[0].dot(l.crossVectors(s[0], s[t])) > 0 && (r = -r), i = 1; i <= t; i++) s[i].applyMatrix4(h.makeRotationAxis(a[i], r * i)), c[i].crossVectors(a[i], s[i]);
                    return {
                        tangents: a,
                        normals: s,
                        binormals: c
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), Na.prototype = Object.create(ka.prototype), Na.prototype.constructor = Na, Na.prototype.isEllipseCurve = !0, Na.prototype.getPoint = function(t, e) {
                for (var i = e || new Ge, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; r < 0;) r += n;
                for (; r > n;) r -= n;
                r < Number.EPSILON && (r = o ? 0 : n), !0 !== this.aClockwise || o || (r === n ? r = -n : r -= n);
                var a = this.aStartAngle + t * r,
                    s = this.aX + this.xRadius * Math.cos(a),
                    c = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    var l = Math.cos(this.aRotation),
                        h = Math.sin(this.aRotation),
                        u = s - this.aX,
                        d = c - this.aY;
                    s = u * l - d * h + this.aX, c = u * h + d * l + this.aY
                }
                return i.set(s, c)
            }, Na.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Na.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, Na.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Ba.prototype = Object.create(Na.prototype), Ba.prototype.constructor = Ba, Ba.prototype.isArcCurve = !0;
            var za = new je,
                Ua = new Fa,
                Ga = new Fa,
                Ha = new Fa;

            function Va(t, e, i, n) {
                ka.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || .5
            }

            function ja(t, e, i, n, r) {
                var o = .5 * (n - e),
                    a = .5 * (r - i),
                    s = t * t;
                return (2 * i - 2 * n + o + a) * (t * s) + (-3 * i + 3 * n - 2 * o - a) * s + o * t + i
            }

            function Wa(t, e, i, n) {
                return function(t, e) {
                    var i = 1 - t;
                    return i * i * e
                }(t, e) + function(t, e) {
                    return 2 * (1 - t) * t * e
                }(t, i) + function(t, e) {
                    return t * t * e
                }(t, n)
            }

            function Xa(t, e, i, n, r) {
                return function(t, e) {
                    var i = 1 - t;
                    return i * i * i * e
                }(t, e) + function(t, e) {
                    var i = 1 - t;
                    return 3 * i * i * t * e
                }(t, i) + function(t, e) {
                    return 3 * (1 - t) * t * t * e
                }(t, n) + function(t, e) {
                    return t * t * t * e
                }(t, r)
            }

            function qa(t, e, i, n) {
                ka.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Ge, this.v1 = e || new Ge, this.v2 = i || new Ge, this.v3 = n || new Ge
            }

            function Ya(t, e, i, n) {
                ka.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new je, this.v1 = e || new je, this.v2 = i || new je, this.v3 = n || new je
            }

            function Za(t, e) {
                ka.call(this), this.type = "LineCurve", this.v1 = t || new Ge, this.v2 = e || new Ge
            }

            function Ja(t, e) {
                ka.call(this), this.type = "LineCurve3", this.v1 = t || new je, this.v2 = e || new je
            }

            function Ka(t, e, i) {
                ka.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Ge, this.v1 = e || new Ge, this.v2 = i || new Ge
            }

            function Qa(t, e, i) {
                ka.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new je, this.v1 = e || new je, this.v2 = i || new je
            }

            function $a(t) {
                ka.call(this), this.type = "SplineCurve", this.points = t || []
            }
            Va.prototype = Object.create(ka.prototype), Va.prototype.constructor = Va, Va.prototype.isCatmullRomCurve3 = !0, Va.prototype.getPoint = function(t, e) {
                var i, n, r, o, a = e || new je,
                    s = this.points,
                    c = s.length,
                    l = (c - (this.closed ? 0 : 1)) * t,
                    h = Math.floor(l),
                    u = l - h;
                if (this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / c) + 1) * c : 0 === u && h === c - 1 && (h = c - 2, u = 1), this.closed || h > 0 ? i = s[(h - 1) % c] : (za.subVectors(s[0], s[1]).add(s[0]), i = za), n = s[h % c], r = s[(h + 1) % c], this.closed || h + 2 < c ? o = s[(h + 2) % c] : (za.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), o = za), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var d = "chordal" === this.curveType ? .5 : .25,
                        p = Math.pow(i.distanceToSquared(n), d),
                        f = Math.pow(n.distanceToSquared(r), d),
                        m = Math.pow(r.distanceToSquared(o), d);
                    f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), Ua.initNonuniformCatmullRom(i.x, n.x, r.x, o.x, p, f, m), Ga.initNonuniformCatmullRom(i.y, n.y, r.y, o.y, p, f, m), Ha.initNonuniformCatmullRom(i.z, n.z, r.z, o.z, p, f, m)
                } else "catmullrom" === this.curveType && (Ua.initCatmullRom(i.x, n.x, r.x, o.x, this.tension), Ga.initCatmullRom(i.y, n.y, r.y, o.y, this.tension), Ha.initCatmullRom(i.z, n.z, r.z, o.z, this.tension));
                return a.set(Ua.calc(u), Ga.calc(u), Ha.calc(u)), a
            }, Va.prototype.copy = function(t) {
                ka.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, Va.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, i = this.points.length; e < i; e++) {
                    var n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, Va.prototype.fromJSON = function(t) {
                ka.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push((new je).fromArray(n))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, qa.prototype = Object.create(ka.prototype), qa.prototype.constructor = qa, qa.prototype.isCubicBezierCurve = !0, qa.prototype.getPoint = function(t, e) {
                var i = e || new Ge,
                    n = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return i.set(Xa(t, n.x, r.x, o.x, a.x), Xa(t, n.y, r.y, o.y, a.y)), i
            }, qa.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, qa.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, qa.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, Ya.prototype = Object.create(ka.prototype), Ya.prototype.constructor = Ya, Ya.prototype.isCubicBezierCurve3 = !0, Ya.prototype.getPoint = function(t, e) {
                var i = e || new je,
                    n = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return i.set(Xa(t, n.x, r.x, o.x, a.x), Xa(t, n.y, r.y, o.y, a.y), Xa(t, n.z, r.z, o.z, a.z)), i
            }, Ya.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, Ya.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, Ya.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, Za.prototype = Object.create(ka.prototype), Za.prototype.constructor = Za, Za.prototype.isLineCurve = !0, Za.prototype.getPoint = function(t, e) {
                var i = e || new Ge;
                return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
            }, Za.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, Za.prototype.getTangent = function() {
                return this.v2.clone().sub(this.v1).normalize()
            }, Za.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Za.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Za.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Ja.prototype = Object.create(ka.prototype), Ja.prototype.constructor = Ja, Ja.prototype.isLineCurve3 = !0, Ja.prototype.getPoint = function(t, e) {
                var i = e || new je;
                return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
            }, Ja.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, Ja.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Ja.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Ja.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Ka.prototype = Object.create(ka.prototype), Ka.prototype.constructor = Ka, Ka.prototype.isQuadraticBezierCurve = !0, Ka.prototype.getPoint = function(t, e) {
                var i = e || new Ge,
                    n = this.v0,
                    r = this.v1,
                    o = this.v2;
                return i.set(Wa(t, n.x, r.x, o.x), Wa(t, n.y, r.y, o.y)), i
            }, Ka.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Ka.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Ka.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Qa.prototype = Object.create(ka.prototype), Qa.prototype.constructor = Qa, Qa.prototype.isQuadraticBezierCurve3 = !0, Qa.prototype.getPoint = function(t, e) {
                var i = e || new je,
                    n = this.v0,
                    r = this.v1,
                    o = this.v2;
                return i.set(Wa(t, n.x, r.x, o.x), Wa(t, n.y, r.y, o.y), Wa(t, n.z, r.z, o.z)), i
            }, Qa.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Qa.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Qa.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, $a.prototype = Object.create(ka.prototype), $a.prototype.constructor = $a, $a.prototype.isSplineCurve = !0, $a.prototype.getPoint = function(t, e) {
                var i = e || new Ge,
                    n = this.points,
                    r = (n.length - 1) * t,
                    o = Math.floor(r),
                    a = r - o,
                    s = n[0 === o ? o : o - 1],
                    c = n[o],
                    l = n[o > n.length - 2 ? n.length - 1 : o + 1],
                    h = n[o > n.length - 3 ? n.length - 1 : o + 2];
                return i.set(ja(a, s.x, c.x, l.x, h.x), ja(a, s.y, c.y, l.y, h.y)), i
            }, $a.prototype.copy = function(t) {
                ka.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }, $a.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, i = this.points.length; e < i; e++) {
                    var n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }, $a.prototype.fromJSON = function(t) {
                ka.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push((new Ge).fromArray(n))
                }
                return this
            };
            var ts = Object.freeze({
                ArcCurve: Ba,
                CatmullRomCurve3: Va,
                CubicBezierCurve: qa,
                CubicBezierCurve3: Ya,
                EllipseCurve: Na,
                LineCurve: Za,
                LineCurve3: Ja,
                QuadraticBezierCurve: Ka,
                QuadraticBezierCurve3: Qa,
                SplineCurve: $a
            });

            function es() {
                ka.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function is(t) {
                es.call(this), this.type = "Path", this.currentPoint = new Ge, t && this.setFromPoints(t)
            }

            function ns(t) {
                is.call(this, t), this.uuid = Ue.generateUUID(), this.type = "Shape", this.holes = []
            }

            function rs(t, e) {
                vi.call(this), this.type = "Light", this.color = new ci(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
            }

            function os(t, e, i) {
                rs.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(vi.DefaultUp), this.updateMatrix(), this.groundColor = new ci(e)
            }

            function as(t) {
                this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new Ge(512, 512), this.map = null, this.matrix = new He
            }

            function ss() {
                as.call(this, new lr(50, 1, .5, 500))
            }

            function cs(t, e, i, n, r, o) {
                rs.call(this, t, e), this.type = "SpotLight", this.position.copy(vi.DefaultUp), this.updateMatrix(), this.target = new vi, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new ss
            }

            function ls(t, e, i, n) {
                rs.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new as(new lr(90, 1, .5, 500))
            }

            function hs(t, e, i, n, r, o) {
                cr.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
            }

            function us() {
                as.call(this, new hs(-5, 5, 5, -5, .5, 500))
            }

            function ds(t, e) {
                rs.call(this, t, e), this.type = "DirectionalLight", this.position.copy(vi.DefaultUp), this.updateMatrix(), this.target = new vi, this.shadow = new us
            }

            function ps(t, e) {
                rs.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
            }

            function fs(t, e, i, n) {
                rs.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
            }

            function ms(t) {
                this.manager = void 0 !== t ? t : Sa, this.textures = {}
            }
            es.prototype = Object.assign(Object.create(ka.prototype), {
                constructor: es,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    var t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new Za(e, t))
                },
                getPoint: function(t) {
                    for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) {
                        if (i[n] >= e) {
                            var r = i[n] - e,
                                o = this.curves[n],
                                a = o.getLength(),
                                s = 0 === a ? 0 : 1 - r / a;
                            return o.getPointAt(s)
                        }
                        n++
                    }
                    return null
                },
                getLength: function() {
                    var t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                        for (var o = r[n], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), c = 0; c < s.length; c++) {
                            var l = s[c];
                            e && e.equals(l) || (i.push(l), e = l)
                        }
                    return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
                },
                copy: function(t) {
                    ka.prototype.copy.call(this, t), this.curves = [];
                    for (var e = 0, i = t.curves.length; e < i; e++) {
                        var n = t.curves[e];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    var t = ka.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (var e = 0, i = this.curves.length; e < i; e++) {
                        var n = this.curves[e];
                        t.curves.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    ka.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (var e = 0, i = t.curves.length; e < i; e++) {
                        var n = t.curves[e];
                        this.curves.push((new ts[n.type]).fromJSON(n))
                    }
                    return this
                }
            }), is.prototype = Object.assign(Object.create(es.prototype), {
                constructor: is,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
                },
                moveTo: function(t, e) {
                    this.currentPoint.set(t, e)
                },
                lineTo: function(t, e) {
                    var i = new Za(this.currentPoint.clone(), new Ge(t, e));
                    this.curves.push(i), this.currentPoint.set(t, e)
                },
                quadraticCurveTo: function(t, e, i, n) {
                    var r = new Ka(this.currentPoint.clone(), new Ge(t, e), new Ge(i, n));
                    this.curves.push(r), this.currentPoint.set(i, n)
                },
                bezierCurveTo: function(t, e, i, n, r, o) {
                    var a = new qa(this.currentPoint.clone(), new Ge(t, e), new Ge(i, n), new Ge(r, o));
                    this.curves.push(a), this.currentPoint.set(r, o)
                },
                splineThru: function(t) {
                    var e = new $a([this.currentPoint.clone()].concat(t));
                    this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
                },
                arc: function(t, e, i, n, r, o) {
                    var a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(t + a, e + s, i, n, r, o)
                },
                absarc: function(t, e, i, n, r, o) {
                    this.absellipse(t, e, i, i, n, r, o)
                },
                ellipse: function(t, e, i, n, r, o, a, s) {
                    var c = this.currentPoint.x,
                        l = this.currentPoint.y;
                    this.absellipse(t + c, e + l, i, n, r, o, a, s)
                },
                absellipse: function(t, e, i, n, r, o, a, s) {
                    var c = new Na(t, e, i, n, r, o, a, s);
                    if (this.curves.length > 0) {
                        var l = c.getPoint(0);
                        l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
                    }
                    this.curves.push(c);
                    var h = c.getPoint(1);
                    this.currentPoint.copy(h)
                },
                copy: function(t) {
                    return es.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    var t = es.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return es.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), ns.prototype = Object.assign(Object.create(is.prototype), {
                constructor: ns,
                getPointsHoles: function(t) {
                    for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    is.prototype.copy.call(this, t), this.holes = [];
                    for (var e = 0, i = t.holes.length; e < i; e++) {
                        var n = t.holes[e];
                        this.holes.push(n.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var t = is.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (var e = 0, i = this.holes.length; e < i; e++) {
                        var n = this.holes[e];
                        t.holes.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    is.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (var e = 0, i = t.holes.length; e < i; e++) {
                        var n = t.holes[e];
                        this.holes.push((new is).fromJSON(n))
                    }
                    return this
                }
            }), rs.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: rs,
                isLight: !0,
                copy: function(t) {
                    return vi.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), os.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: os,
                isHemisphereLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(as.prototype, {
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), ss.prototype = Object.assign(Object.create(as.prototype), {
                constructor: ss,
                isSpotLightShadow: !0,
                update: function(t) {
                    var e = this.camera,
                        i = 2 * Ue.RAD2DEG * t.angle,
                        n = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix())
                }
            }), cs.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: cs,
                isSpotLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), ls.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: ls,
                isPointLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), hs.prototype = Object.assign(Object.create(cr.prototype), {
                constructor: hs,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return cr.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, i, n, r, o) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        i = (this.right + this.left) / 2,
                        n = (this.top + this.bottom) / 2,
                        r = i - t,
                        o = i + t,
                        a = n + e,
                        s = n - e;
                    if (null !== this.view && this.view.enabled) {
                        var c = this.zoom / (this.view.width / this.view.fullWidth),
                            l = this.zoom / (this.view.height / this.view.fullHeight),
                            h = (this.right - this.left) / this.view.width,
                            u = (this.top - this.bottom) / this.view.height;
                        o = (r += h * (this.view.offsetX / c)) + h * (this.view.width / c), s = (a -= u * (this.view.offsetY / l)) - u * (this.view.height / l)
                    }
                    this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), us.prototype = Object.assign(Object.create(as.prototype), {
                constructor: us
            }), ds.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: ds,
                isDirectionalLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), ps.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: ps,
                isAmbientLight: !0
            }), fs.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: fs,
                isRectAreaLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    var e = rs.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            }), Object.assign(ms.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Pa(r.manager);
                    o.setPath(r.path), o.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, i, n)
                },
                parse: function(t) {
                    var e = this.textures;

                    function i(t) {
                        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                    }
                    var n = new ca[t.type];
                    if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular), void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t.clearCoat && (n.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (n.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !== t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t.flatShading), void 0 !== t.blending && (n.blending = t.blending), void 0 !== t.combine && (n.combine = t.combine), void 0 !== t.side && (n.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (n.rotation = t.rotation), 1 !== t.linewidth && (n.linewidth = t.linewidth), void 0 !== t.dashSize && (n.dashSize = t.dashSize), void 0 !== t.gapSize && (n.gapSize = t.gapSize), void 0 !== t.scale && (n.scale = t.scale), void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (n.skinning = t.skinning), void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets), void 0 !== t.dithering && (n.dithering = t.dithering), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.uniforms)
                        for (var r in t.uniforms) {
                            var o = t.uniforms[r];
                            switch (n.uniforms[r] = {}, o.type) {
                                case "t":
                                    n.uniforms[r].value = i(o.value);
                                    break;
                                case "c":
                                    n.uniforms[r].value = (new ci).setHex(o.value);
                                    break;
                                case "v2":
                                    n.uniforms[r].value = (new Ge).fromArray(o.value);
                                    break;
                                case "v3":
                                    n.uniforms[r].value = (new je).fromArray(o.value);
                                    break;
                                case "v4":
                                    n.uniforms[r].value = (new Ze).fromArray(o.value);
                                    break;
                                case "m4":
                                    n.uniforms[r].value = (new He).fromArray(o.value);
                                    break;
                                default:
                                    n.uniforms[r].value = o.value
                            }
                        }
                    if (void 0 !== t.defines && (n.defines = t.defines), void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = i(t.map)), void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap), n.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)), void 0 !== t.normalMapType && (n.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                        var a = t.normalScale;
                        !1 === Array.isArray(a) && (a = [a, a]), n.normalScale = (new Ge).fromArray(a)
                    }
                    return void 0 !== t.displacementMap && (n.displacementMap = i(t.displacementMap)), void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)), void 0 !== t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)), void 0 !== t.emissiveMap && (n.emissiveMap = i(t.emissiveMap)), void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)), void 0 !== t.envMap && (n.envMap = i(t.envMap)), void 0 !== t.envMapIntensity && (n.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n.gradientMap = i(t.gradientMap)), n
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setTextures: function(t) {
                    return this.textures = t, this
                }
            });
            var gs = {
                decodeText: function(t) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                    for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
                    return decodeURIComponent(escape(e))
                },
                extractUrlBase: function(t) {
                    var e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1)
                }
            };

            function vs(t) {
                this.manager = void 0 !== t ? t : Sa
            }
            Object.assign(vs.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Pa(r.manager);
                    o.setPath(r.path), o.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, i, n)
                },
                parse: function(t) {
                    var e = new Ii,
                        i = t.data.index;
                    if (void 0 !== i) {
                        var n = new ys[i.type](i.array);
                        e.setIndex(new xi(n, 1))
                    }
                    var r = t.data.attributes;
                    for (var o in r) {
                        var a = r[o];
                        n = new ys[a.type](a.array);
                        e.addAttribute(o, new xi(n, a.itemSize, a.normalized))
                    }
                    var s = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== s)
                        for (var c = 0, l = s.length; c !== l; ++c) {
                            var h = s[c];
                            e.addGroup(h.start, h.count, h.materialIndex)
                        }
                    var u = t.data.boundingSphere;
                    if (void 0 !== u) {
                        var d = new je;
                        void 0 !== u.center && d.fromArray(u.center), e.boundingSphere = new ti(d, u.radius)
                    }
                    return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            });
            var ys = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function _s(t) {
                this.manager = void 0 !== t ? t : Sa, this.resourcePath = ""
            }
            Object.assign(_s.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, i, n) {
                    var r = this,
                        o = void 0 === this.path ? gs.extractUrlBase(t) : this.path;
                    this.resourcePath = this.resourcePath || o;
                    var a = new Pa(r.manager);
                    a.setPath(this.path), a.load(t, function(i) {
                        var o = null;
                        try {
                            o = JSON.parse(i)
                        } catch (e) {
                            return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                        }
                        var a = o.metadata;
                        void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                    }, i, n)
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                parse: function(t, e) {
                    var i = this.parseShape(t.shapes),
                        n = this.parseGeometries(t.geometries, i),
                        r = this.parseImages(t.images, function() {
                            void 0 !== e && e(s)
                        }),
                        o = this.parseTextures(t.textures, r),
                        a = this.parseMaterials(t.materials, o),
                        s = this.parseObject(t.object, n, a);
                    return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
                },
                parseShape: function(t) {
                    var e = {};
                    if (void 0 !== t)
                        for (var i = 0, n = t.length; i < n; i++) {
                            var r = (new ns).fromJSON(t[i]);
                            e[r.uuid] = r
                        }
                    return e
                },
                parseGeometries: function(e, i) {
                    var n = {};
                    if (void 0 !== e)
                        for (var r = new vs, o = 0, a = e.length; o < a; o++) {
                            var s, c = e[o];
                            switch (c.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new Ko[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new Ko[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new Ko[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new Ko[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new Ko[c.type](c.points, c.segments, c.phiStart, c.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new Ko[c.type](c.vertices, c.indices, c.radius, c.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var l = [], h = 0, u = c.shapes.length; h < u; h++) {
                                        var d = i[c.shapes[h]];
                                        l.push(d)
                                    }
                                    s = new Ko[c.type](l, c.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (l = [], h = 0, u = c.shapes.length; h < u; h++) {
                                        d = i[c.shapes[h]];
                                        l.push(d)
                                    }
                                    var p = c.options.extrudePath;
                                    void 0 !== p && (c.options.extrudePath = (new ts[p.type]).fromJSON(p)), s = new Ko[c.type](l, c.options);
                                    break;
                                case "BufferGeometry":
                                    s = r.parse(c);
                                    break;
                                case "Geometry":
                                    if ("THREE" in window && "LegacyJSONLoader" in t) s = (new t.LegacyJSONLoader).parse(c, this.resourcePath).geometry;
                                    else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
                                    continue
                            }
                            s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), !0 === s.isBufferGeometry && void 0 !== c.userData && (s.userData = c.userData), n[c.uuid] = s
                        }
                    return n
                },
                parseMaterials: function(t, e) {
                    var i = {},
                        n = {};
                    if (void 0 !== t) {
                        var r = new ms;
                        r.setTextures(e);
                        for (var o = 0, a = t.length; o < a; o++) {
                            var s = t[o];
                            if ("MultiMaterial" === s.type) {
                                for (var c = [], l = 0; l < s.materials.length; l++) {
                                    var h = s.materials[l];
                                    void 0 === i[h.uuid] && (i[h.uuid] = r.parse(h)), c.push(i[h.uuid])
                                }
                                n[s.uuid] = c
                            } else n[s.uuid] = r.parse(s), i[s.uuid] = n[s.uuid]
                        }
                    }
                    return n
                },
                parseAnimations: function(t) {
                    for (var e = [], i = 0; i < t.length; i++) {
                        var n = t[i],
                            r = wa.parse(n);
                        void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
                    }
                    return e
                },
                parseImages: function(t, e) {
                    var i = this,
                        n = {};

                    function r(t) {
                        return i.manager.itemStart(t), o.load(t, function() {
                            i.manager.itemEnd(t)
                        }, void 0, function() {
                            i.manager.itemError(t), i.manager.itemEnd(t)
                        })
                    }
                    if (void 0 !== t && t.length > 0) {
                        var o = new Oa(new Ea(e));
                        o.setCrossOrigin(this.crossOrigin);
                        for (var a = 0, s = t.length; a < s; a++) {
                            var c = t[a],
                                l = c.url;
                            if (Array.isArray(l)) {
                                n[c.uuid] = [];
                                for (var h = 0, u = l.length; h < u; h++) {
                                    var d = l[h],
                                        p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : i.resourcePath + d;
                                    n[c.uuid].push(r(p))
                                }
                            } else {
                                p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i.resourcePath + c.url;
                                n[c.uuid] = r(p)
                            }
                        }
                    }
                    return n
                },
                parseTextures: function(t, e) {
                    function i(t, e) {
                        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                    }
                    var n = {};
                    if (void 0 !== t)
                        for (var r = 0, o = t.length; r < o; r++) {
                            var a, s = t[r];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(e[s.image]) ? new Xi(e[s.image]) : new Ye(e[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = i(s.mapping, bs)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = i(s.wrap[0], ws), a.wrapT = i(s.wrap[1], ws)), void 0 !== s.format && (a.format = s.format), void 0 !== s.minFilter && (a.minFilter = i(s.minFilter, Ms)), void 0 !== s.magFilter && (a.magFilter = i(s.magFilter, Ms)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), n[s.uuid] = a
                        }
                    return n
                },
                parseObject: function(t, e, i) {
                    var n;

                    function r(t) {
                        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                    }

                    function o(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], n = 0, r = t.length; n < r; n++) {
                                    var o = t[n];
                                    void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(i[o])
                                }
                                return e
                            }
                            return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t), i[t]
                        }
                    }
                    switch (t.type) {
                        case "Scene":
                            n = new _r, void 0 !== t.background && Number.isInteger(t.background) && (n.background = new ci(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? n.fog = new yr(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (n.fog = new vr(t.fog.color, t.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            n = new lr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (n.focus = t.focus), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.filmGauge && (n.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (n.filmOffset = t.filmOffset), void 0 !== t.view && (n.view = Object.assign({}, t.view));
                            break;
                        case "OrthographicCamera":
                            n = new hs(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.view && (n.view = Object.assign({}, t.view));
                            break;
                        case "AmbientLight":
                            n = new ps(t.color, t.intensity);
                            break;
                        case "DirectionalLight":
                            n = new ds(t.color, t.intensity);
                            break;
                        case "PointLight":
                            n = new ls(t.color, t.intensity, t.distance, t.decay);
                            break;
                        case "RectAreaLight":
                            n = new fs(t.color, t.intensity, t.width, t.height);
                            break;
                        case "SpotLight":
                            n = new cs(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                            break;
                        case "HemisphereLight":
                            n = new os(t.color, t.groundColor, t.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var a = r(t.geometry),
                                s = o(t.material);
                            n = a.bones && a.bones.length > 0 ? new Er(a, s) : new ji(a, s);
                            break;
                        case "LOD":
                            n = new Tr;
                            break;
                        case "Line":
                            n = new Lr(r(t.geometry), o(t.material), t.mode);
                            break;
                        case "LineLoop":
                            n = new Rr(r(t.geometry), o(t.material));
                            break;
                        case "LineSegments":
                            n = new Cr(r(t.geometry), o(t.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            n = new Ir(r(t.geometry), o(t.material));
                            break;
                        case "Sprite":
                            n = new Mr(o(t.material));
                            break;
                        case "Group":
                            n = new sr;
                            break;
                        default:
                            n = new vi
                    }
                    if (n.uuid = t.uuid, void 0 !== t.name && (n.name = t.name), void 0 !== t.matrix ? (n.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (n.matrixAutoUpdate = t.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== t.position && n.position.fromArray(t.position), void 0 !== t.rotation && n.rotation.fromArray(t.rotation), void 0 !== t.quaternion && n.quaternion.fromArray(t.quaternion), void 0 !== t.scale && n.scale.fromArray(t.scale)), void 0 !== t.castShadow && (n.castShadow = t.castShadow), void 0 !== t.receiveShadow && (n.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (n.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (n.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && n.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (n.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.frustumCulled && (n.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (n.renderOrder = t.renderOrder), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.layers && (n.layers.mask = t.layers), void 0 !== t.children)
                        for (var c = t.children, l = 0; l < c.length; l++) n.add(this.parseObject(c[l], e, i));
                    if ("LOD" === t.type)
                        for (var h = t.levels, u = 0; u < h.length; u++) {
                            var d = h[u],
                                p = n.getObjectByProperty("uuid", d.object);
                            void 0 !== p && n.addLevel(p, d.distance)
                        }
                    return n
                }
            });
            var xs, bs = {
                    UVMapping: lt,
                    CubeReflectionMapping: ht,
                    CubeRefractionMapping: ut,
                    EquirectangularReflectionMapping: dt,
                    EquirectangularRefractionMapping: pt,
                    SphericalReflectionMapping: ft,
                    CubeUVReflectionMapping: mt,
                    CubeUVRefractionMapping: gt
                },
                ws = {
                    RepeatWrapping: vt,
                    ClampToEdgeWrapping: yt,
                    MirroredRepeatWrapping: _t
                },
                Ms = {
                    NearestFilter: xt,
                    NearestMipMapNearestFilter: bt,
                    NearestMipMapLinearFilter: wt,
                    LinearFilter: Mt,
                    LinearMipMapNearestFilter: Tt,
                    LinearMipMapLinearFilter: Et
                };

            function Ts(t) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : Sa, this.options = void 0
            }

            function Es() {
                this.type = "ShapePath", this.color = new ci, this.subPaths = [], this.currentPath = null
            }

            function Ss(t) {
                this.type = "Font", this.data = t
            }

            function As(t, e, i, n, r) {
                var o = r.glyphs[t] || r.glyphs["?"];
                if (o) {
                    var a, s, c, l, h, u, d, p, f = new Es;
                    if (o.o)
                        for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), g = 0, v = m.length; g < v;) {
                            switch (m[g++]) {
                                case "m":
                                    a = m[g++] * e + i, s = m[g++] * e + n, f.moveTo(a, s);
                                    break;
                                case "l":
                                    a = m[g++] * e + i, s = m[g++] * e + n, f.lineTo(a, s);
                                    break;
                                case "q":
                                    c = m[g++] * e + i, l = m[g++] * e + n, h = m[g++] * e + i, u = m[g++] * e + n, f.quadraticCurveTo(h, u, c, l);
                                    break;
                                case "b":
                                    c = m[g++] * e + i, l = m[g++] * e + n, h = m[g++] * e + i, u = m[g++] * e + n, d = m[g++] * e + i, p = m[g++] * e + n, f.bezierCurveTo(h, u, d, p, c, l)
                            }
                        }
                    return {
                        offsetX: o.ha * e,
                        path: f
                    }
                }
            }

            function Ps(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Ls() {}
            Ts.prototype = {
                constructor: Ts,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Ta.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    fetch(t).then(function(t) {
                        return t.blob()
                    }).then(function(t) {
                        return createImageBitmap(t, r.options)
                    }).then(function(i) {
                        Ta.add(t, i), e && e(i), r.manager.itemEnd(t)
                    }).catch(function(e) {
                        n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    })
                },
                setCrossOrigin: function() {
                    return this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }, Object.assign(Es.prototype, {
                moveTo: function(t, e) {
                    this.currentPath = new is, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
                },
                lineTo: function(t, e) {
                    this.currentPath.lineTo(t, e)
                },
                quadraticCurveTo: function(t, e, i, n) {
                    this.currentPath.quadraticCurveTo(t, e, i, n)
                },
                bezierCurveTo: function(t, e, i, n, r, o) {
                    this.currentPath.bezierCurveTo(t, e, i, n, r, o)
                },
                splineThru: function(t) {
                    this.currentPath.splineThru(t)
                },
                toShapes: function(t, e) {
                    function i(t) {
                        for (var e = [], i = 0, n = t.length; i < n; i++) {
                            var r = t[i],
                                o = new ns;
                            o.curves = r.curves, e.push(o)
                        }
                        return e
                    }

                    function n(t, e) {
                        for (var i = e.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                            var a = e[r],
                                s = e[o],
                                c = s.x - a.x,
                                l = s.y - a.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (a = e[o], c = -c, s = e[r], l = -l), t.y < a.y || t.y > s.y) continue;
                                if (t.y === a.y) {
                                    if (t.x === a.x) return !0
                                } else {
                                    var h = l * (t.x - a.x) - c * (t.y - a.y);
                                    if (0 === h) return !0;
                                    if (h < 0) continue;
                                    n = !n
                                }
                            } else {
                                if (t.y !== a.y) continue;
                                if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                            }
                        }
                        return n
                    }
                    var r = So.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === e) return i(o);
                    var a, s, c, l = [];
                    if (1 === o.length) return s = o[0], (c = new ns).curves = s.curves, l.push(c), l;
                    var h = !r(o[0].getPoints());
                    h = t ? !h : h;
                    var u, d, p = [],
                        f = [],
                        m = [],
                        g = 0;
                    f[g] = void 0, m[g] = [];
                    for (var v = 0, y = o.length; v < y; v++) a = r(u = (s = o[v]).getPoints()), (a = t ? !a : a) ? (!h && f[g] && g++, f[g] = {
                        s: new ns,
                        p: u
                    }, f[g].s.curves = s.curves, h && g++, m[g] = []) : m[g].push({
                        h: s,
                        p: u[0]
                    });
                    if (!f[0]) return i(o);
                    if (f.length > 1) {
                        for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) p[b] = [];
                        for (b = 0, w = f.length; b < w; b++)
                            for (var M = m[b], T = 0; T < M.length; T++) {
                                for (var E = M[T], S = !0, A = 0; A < f.length; A++) n(E.p, f[A].p) && (b !== A && x.push({
                                    froms: b,
                                    tos: A,
                                    hole: T
                                }), S ? (S = !1, p[A].push(E)) : _ = !0);
                                S && p[b].push(E)
                            }
                        x.length > 0 && (_ || (m = p))
                    }
                    v = 0;
                    for (var P = f.length; v < P; v++) {
                        c = f[v].s, l.push(c);
                        for (var L = 0, C = (d = m[v]).length; L < C; L++) c.holes.push(d[L].h)
                    }
                    return l
                }
            }), Object.assign(Ss.prototype, {
                isFont: !0,
                generateShapes: function(t, e) {
                    void 0 === e && (e = 100);
                    for (var i = [], n = function(t, e, i) {
                            for (var n = Array.from ? Array.from(t) : String(t).split(""), r = e / i.resolution, o = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, a = [], s = 0, c = 0, l = 0; l < n.length; l++) {
                                var h = n[l];
                                if ("\n" === h) s = 0, c -= o;
                                else {
                                    var u = As(h, r, s, c, i);
                                    s += u.offsetX, a.push(u.path)
                                }
                            }
                            return a
                        }(t, e, this.data), r = 0, o = n.length; r < o; r++) Array.prototype.push.apply(i, n[r].toShapes());
                    return i
                }
            }), Object.assign(Ps.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Pa(this.manager);
                    o.setPath(this.path), o.load(t, function(t) {
                        var i;
                        try {
                            i = JSON.parse(t)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var n = r.parse(i);
                        e && e(n)
                    }, i, n)
                },
                parse: function(t) {
                    return new Ss(t)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Ls.Handlers = {
                handlers: [],
                add: function(t, e) {
                    this.handlers.push(t, e)
                },
                get: function(t) {
                    for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                        var r = e[i],
                            o = e[i + 1];
                        if (r.test(t)) return o
                    }
                    return null
                }
            }, Object.assign(Ls.prototype, {
                crossOrigin: "anonymous",
                onLoadStart: function() {},
                onLoadProgress: function() {},
                onLoadComplete: function() {},
                initMaterials: function(t, e, i) {
                    for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
                    return n
                },
                createMaterial: function() {
                    var t = {
                            NoBlending: T,
                            NormalBlending: E,
                            AdditiveBlending: S,
                            SubtractiveBlending: A,
                            MultiplyBlending: P,
                            CustomBlending: L
                        },
                        e = new ci,
                        i = new Da,
                        n = new ms;
                    return function(r, o, a) {
                        var s = {};

                        function c(t, e, n, r, c) {
                            var l, h = o + t,
                                u = Ls.Handlers.get(h);
                            null !== u ? l = u.load(h) : (i.setCrossOrigin(a), l = i.load(h)), void 0 !== e && (l.repeat.fromArray(e), 1 !== e[0] && (l.wrapS = vt), 1 !== e[1] && (l.wrapT = vt)), void 0 !== n && l.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (l.wrapS = vt), "mirror" === r[0] && (l.wrapS = _t), "repeat" === r[1] && (l.wrapT = vt), "mirror" === r[1] && (l.wrapT = _t)), void 0 !== c && (l.anisotropy = c);
                            var d = Ue.generateUUID();
                            return s[d] = l, d
                        }
                        var l = {
                            uuid: Ue.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                        for (var h in r) {
                            var u = r[h];
                            switch (h) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    l.name = u;
                                    break;
                                case "blending":
                                    l.blending = t[u];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", h, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    l.color = e.fromArray(u).getHex();
                                    break;
                                case "colorSpecular":
                                    l.specular = e.fromArray(u).getHex();
                                    break;
                                case "colorEmissive":
                                    l.emissive = e.fromArray(u).getHex();
                                    break;
                                case "specularCoef":
                                    l.shininess = u;
                                    break;
                                case "shading":
                                    "basic" === u.toLowerCase() && (l.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (l.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (l.type = "MeshStandardMaterial");
                                    break;
                                case "mapDiffuse":
                                    l.map = c(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapEmissive":
                                    l.emissiveMap = c(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                                    break;
                                case "mapEmissiveRepeat":
                                case "mapEmissiveOffset":
                                case "mapEmissiveWrap":
                                case "mapEmissiveAnisotropy":
                                    break;
                                case "mapLight":
                                    l.lightMap = c(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    l.aoMap = c(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    l.bumpMap = c(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    l.bumpScale = u;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    l.normalMap = c(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    l.normalScale = u;
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    l.specularMap = c(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapMetalness":
                                    l.metalnessMap = c(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                                    break;
                                case "mapMetalnessRepeat":
                                case "mapMetalnessOffset":
                                case "mapMetalnessWrap":
                                case "mapMetalnessAnisotropy":
                                    break;
                                case "mapRoughness":
                                    l.roughnessMap = c(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                                    break;
                                case "mapRoughnessRepeat":
                                case "mapRoughnessOffset":
                                case "mapRoughnessWrap":
                                case "mapRoughnessAnisotropy":
                                    break;
                                case "mapAlpha":
                                    l.alphaMap = c(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    l.side = v;
                                    break;
                                case "doubleSided":
                                    l.side = y;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), l.opacity = u;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    l[h] = u;
                                    break;
                                case "vertexColors":
                                    !0 === u && (l.vertexColors = M), "face" === u && (l.vertexColors = w);
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", h, u)
                            }
                        }
                        return "MeshBasicMaterial" === l.type && delete l.emissive, "MeshPhongMaterial" !== l.type && delete l.specular, l.opacity < 1 && (l.transparent = !0), n.setTextures(s), n.parse(l)
                    }
                }()
            });
            var Cs = {
                getContext: function() {
                    return void 0 === xs && (xs = new(window.AudioContext || window.webkitAudioContext)), xs
                },
                setContext: function(t) {
                    xs = t
                }
            };

            function Rs(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Os() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new lr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new lr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }

            function Is(t, e, i, n) {
                vi.call(this), this.type = "CubeCamera";
                var r = new lr(90, 1, t, e);
                r.up.set(0, -1, 0), r.lookAt(new je(1, 0, 0)), this.add(r);
                var o = new lr(90, 1, t, e);
                o.up.set(0, -1, 0), o.lookAt(new je(-1, 0, 0)), this.add(o);
                var a = new lr(90, 1, t, e);
                a.up.set(0, 0, 1), a.lookAt(new je(0, 1, 0)), this.add(a);
                var s = new lr(90, 1, t, e);
                s.up.set(0, 0, -1), s.lookAt(new je(0, -1, 0)), this.add(s);
                var c = new lr(90, 1, t, e);
                c.up.set(0, -1, 0), c.lookAt(new je(0, 0, 1)), this.add(c);
                var l = new lr(90, 1, t, e);
                l.up.set(0, -1, 0), l.lookAt(new je(0, 0, -1)), this.add(l), n = n || {
                    format: zt,
                    magFilter: Mt,
                    minFilter: Mt
                }, this.renderTarget = new Ke(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    var i = this.renderTarget,
                        n = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, r, i), i.activeCubeFace = 1, t.render(e, o, i), i.activeCubeFace = 2, t.render(e, a, i), i.activeCubeFace = 3, t.render(e, s, i), i.activeCubeFace = 4, t.render(e, c, i), i.texture.generateMipmaps = n, i.activeCubeFace = 5, t.render(e, l, i), t.setRenderTarget(null)
                }, this.clear = function(t, e, i, n) {
                    for (var r = this.renderTarget, o = 0; o < 6; o++) r.activeCubeFace = o, t.setRenderTarget(r), t.clear(e, i, n);
                    t.setRenderTarget(null)
                }
            }

            function Ds(t) {
                this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }

            function ks() {
                vi.call(this), this.type = "AudioListener", this.context = Cs.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
            }

            function Ns(t) {
                vi.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }

            function Bs(t) {
                Ns.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }

            function Fs(t, e) {
                this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }

            function zs(t, e, i) {
                this.binding = t, this.valueSize = i;
                var n, r = Float64Array;
                switch (e) {
                    case "quaternion":
                        n = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        r = Array, n = this._select;
                        break;
                    default:
                        n = this._lerp
                }
                this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }
            Object.assign(Rs.prototype, {
                load: function(t, e, i, n) {
                    var r = new Pa(this.manager);
                    r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function(t) {
                        var i = t.slice(0);
                        Cs.getContext().decodeAudioData(i, function(t) {
                            e(t)
                        })
                    }, i, n)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Os.prototype, {
                update: function() {
                    var t, e, i, n, r, o, a, s, c = new He,
                        l = new He;
                    return function(h) {
                        if (t !== this || e !== h.focus || i !== h.fov || n !== h.aspect * this.aspect || r !== h.near || o !== h.far || a !== h.zoom || s !== this.eyeSep) {
                            t = this, e = h.focus, i = h.fov, n = h.aspect * this.aspect, r = h.near, o = h.far, a = h.zoom;
                            var u, d, p = h.projectionMatrix.clone(),
                                f = (s = this.eyeSep / 2) * r / e,
                                m = r * Math.tan(Ue.DEG2RAD * i * .5) / a;
                            l.elements[12] = -s, c.elements[12] = s, u = -m * n + f, d = m * n + f, p.elements[0] = 2 * r / (d - u), p.elements[8] = (d + u) / (d - u), this.cameraL.projectionMatrix.copy(p), u = -m * n - f, d = m * n - f, p.elements[0] = 2 * r / (d - u), p.elements[8] = (d + u) / (d - u), this.cameraR.projectionMatrix.copy(p)
                        }
                        this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(c)
                    }
                }()
            }), Is.prototype = Object.create(vi.prototype), Is.prototype.constructor = Is, Object.assign(Ds.prototype, {
                start: function() {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var e = ("undefined" == typeof performance ? Date : performance).now();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            }), ks.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: ks,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(t) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                },
                updateMatrixWorld: function() {
                    var t = new je,
                        e = new Ve,
                        i = new je,
                        n = new je,
                        r = new Ds;
                    return function(o) {
                        vi.prototype.updateMatrixWorld.call(this, o);
                        var a = this.context.listener,
                            s = this.up;
                        if (this.timeDelta = r.getDelta(), this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), a.positionX) {
                            var c = this.context.currentTime + this.timeDelta;
                            a.positionX.linearRampToValueAtTime(t.x, c), a.positionY.linearRampToValueAtTime(t.y, c), a.positionZ.linearRampToValueAtTime(t.z, c), a.forwardX.linearRampToValueAtTime(n.x, c), a.forwardY.linearRampToValueAtTime(n.y, c), a.forwardZ.linearRampToValueAtTime(n.z, c), a.upX.linearRampToValueAtTime(s.x, c), a.upY.linearRampToValueAtTime(s.y, c), a.upZ.linearRampToValueAtTime(s.z, c)
                        } else a.setPosition(t.x, t.y, t.z), a.setOrientation(n.x, n.y, n.z, s.x, s.y, s.z)
                    }
                }()
            }), Ns.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Ns,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                },
                setMediaElementSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                },
                setBuffer: function(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function() {
                    if (!0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) {
                            var t = this.context.createBufferSource();
                            return t.buffer = this.buffer, t.detune.value = this.detune, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect()
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    } else console.warn("THREE.Audio: Audio is already playing.")
                },
                pause: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function() {
                    if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(t) {
                    return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
                },
                setDetune: function(t) {
                    return this.detune = t, !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                },
                getDetune: function() {
                    return this.detune
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(t) {
                    return this.setFilters(t ? [t] : [])
                },
                setPlaybackRate: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = !1
                },
                getLoop: function() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }), Bs.prototype = Object.assign(Object.create(Ns.prototype), {
                constructor: Bs,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(t) {
                    return this.panner.refDistance = t, this
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(t) {
                    return this.panner.rolloffFactor = t, this
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(t) {
                    return this.panner.distanceModel = t, this
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(t) {
                    return this.panner.maxDistance = t, this
                },
                setDirectionalCone: function(t, e, i) {
                    return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this
                },
                updateMatrixWorld: function() {
                    var t = new je,
                        e = new Ve,
                        i = new je,
                        n = new je;
                    return function(r) {
                        vi.prototype.updateMatrixWorld.call(this, r);
                        var o = this.panner;
                        if (this.matrixWorld.decompose(t, e, i), n.set(0, 0, 1).applyQuaternion(e), o.positionX) {
                            var a = this.context.currentTime + this.listener.timeDelta;
                            o.positionX.linearRampToValueAtTime(t.x, a), o.positionY.linearRampToValueAtTime(t.y, a), o.positionZ.linearRampToValueAtTime(t.z, a), o.orientationX.linearRampToValueAtTime(n.x, a), o.orientationY.linearRampToValueAtTime(n.y, a), o.orientationZ.linearRampToValueAtTime(n.z, a)
                        } else o.setPosition(t.x, t.y, t.z), o.setOrientation(n.x, n.y, n.z)
                    }
                }()
            }), Object.assign(Fs.prototype, {
                getFrequencyData: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function() {
                    for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                    return t / e.length
                }
            }), Object.assign(zs.prototype, {
                accumulate: function(t, e) {
                    var i = this.buffer,
                        n = this.valueSize,
                        r = t * n + n,
                        o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== n; ++a) i[r + a] = i[a];
                        o = e
                    } else {
                        var s = e / (o += e);
                        this._mixBufferRegion(i, r, 0, s, n)
                    }
                    this.cumulativeWeight = o
                },
                apply: function(t) {
                    var e = this.valueSize,
                        i = this.buffer,
                        n = t * e + e,
                        r = this.cumulativeWeight,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, r < 1) {
                        var a = 3 * e;
                        this._mixBufferRegion(i, n, a, 1 - r, e)
                    }
                    for (var s = e, c = e + e; s !== c; ++s)
                        if (i[s] !== i[s + e]) {
                            o.setValue(i, n);
                            break
                        }
                },
                saveOriginalState: function() {
                    var t = this.binding,
                        e = this.buffer,
                        i = this.valueSize,
                        n = 3 * i;
                    t.getValue(e, n);
                    for (var r = i, o = n; r !== o; ++r) e[r] = e[n + r % i];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _select: function(t, e, i, n, r) {
                    if (n >= .5)
                        for (var o = 0; o !== r; ++o) t[e + o] = t[i + o]
                },
                _slerp: function(t, e, i, n) {
                    Ve.slerpFlat(t, e, t, e, t, i, n)
                },
                _lerp: function(t, e, i, n, r) {
                    for (var o = 1 - n, a = 0; a !== r; ++a) {
                        var s = e + a;
                        t[s] = t[s] * o + t[i + a] * n
                    }
                }
            });
            var Us, Gs;

            function Hs(t, e, i) {
                var n = i || Vs.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, n)
            }

            function Vs(t, e, i) {
                this.path = e, this.parsedPath = i || Vs.parseTrackName(e), this.node = Vs.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }

            function js() {
                this.uuid = Ue.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var t = {};
                this._indicesByUUID = t;
                for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var n = this;
                this.stats = {
                    objects: {
                        get total() {
                            return n._objects.length
                        },
                        get inUse() {
                            return this.total - n.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return n._bindings.length
                    }
                }
            }

            function Ws(t, e, i) {
                this._mixer = t, this._clip = e, this._localRoot = i || null;
                for (var n = e.tracks, r = n.length, o = new Array(r), a = {
                        endingStart: we,
                        endingEnd: we
                    }, s = 0; s !== r; ++s) {
                    var c = n[s].createInterpolant(null);
                    o[s] = c, c.settings = a
                }
                this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ve, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function Xs(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function qs(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }

            function Ys() {
                Ii.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function Zs(t, e, i) {
                xr.call(this, t, e), this.meshPerAttribute = i || 1
            }

            function Js(t, e, i, n) {
                "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), xi.call(this, t, e, i), this.meshPerAttribute = n || 1
            }

            function Ks(t, e, i, n) {
                this.ray = new Gi(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function Qs(t, e) {
                return t.distance - e.distance
            }

            function $s(t, e, i, n) {
                if (!1 !== t.visible && (t.raycast(e, i), !0 === n))
                    for (var r = t.children, o = 0, a = r.length; o < a; o++) $s(r[o], e, i, !0)
            }

            function tc(t, e, i) {
                return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
            }

            function ec(t, e, i) {
                return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
            }

            function ic(t, e) {
                this.min = void 0 !== t ? t : new Ge(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ge(-1 / 0, -1 / 0)
            }

            function nc(t, e) {
                this.start = void 0 !== t ? t : new je, this.end = void 0 !== e ? e : new je
            }

            function rc(t) {
                vi.call(this), this.material = t, this.render = function() {}
            }

            function oc(t, e, i, n) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== i ? i : 16711680,
                    o = void 0 !== n ? n : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
                var c = new Ii,
                    l = new Pi(2 * a * 3, 3);
                c.addAttribute("position", l), Cr.call(this, c, new Pr({
                    color: r,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function ac(t, e) {
                vi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                for (var i = new Ii, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
                    var a = r / 32 * Math.PI * 2,
                        s = o / 32 * Math.PI * 2;
                    n.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
                }
                i.addAttribute("position", new Pi(n, 3));
                var c = new Pr({
                    fog: !1
                });
                this.cone = new Cr(i, c), this.add(this.cone), this.update()
            }

            function sc(t) {
                for (var e = function t(e) {
                        var i = [];
                        e && e.isBone && i.push(e);
                        for (var n = 0; n < e.children.length; n++) i.push.apply(i, t(e.children[n]));
                        return i
                    }(t), i = new Ii, n = [], r = [], o = new ci(0, 0, 1), a = new ci(0, 1, 0), s = 0; s < e.length; s++) {
                    var c = e[s];
                    c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
                }
                i.addAttribute("position", new Pi(n, 3)), i.addAttribute("color", new Pi(r, 3));
                var l = new Pr({
                    vertexColors: M,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                Cr.call(this, i, l), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }

            function cc(t, e, i) {
                this.light = t, this.light.updateMatrixWorld(), this.color = i;
                var n = new No(e, 4, 2),
                    r = new Vi({
                        wireframe: !0,
                        fog: !1
                    });
                ji.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function lc(t, e) {
                vi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                var i = new Pr({
                        fog: !1
                    }),
                    n = new Ii;
                n.addAttribute("position", new xi(new Float32Array(15), 3)), this.line = new Lr(n, i), this.add(this.line), this.update()
            }

            function hc(t, e, i) {
                vi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
                var n = new Xr(e);
                n.rotateY(.5 * Math.PI), this.material = new Vi({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = M);
                var r = n.getAttribute("position"),
                    o = new Float32Array(3 * r.count);
                n.addAttribute("color", new xi(o, 3)), this.add(new ji(n, this.material)), this.update()
            }

            function uc(t, e, i, n) {
                t = t || 10, e = e || 10, i = new ci(void 0 !== i ? i : 4473924), n = new ci(void 0 !== n ? n : 8947848);
                for (var r = e / 2, o = t / e, a = t / 2, s = [], c = [], l = 0, h = 0, u = -a; l <= e; l++, u += o) {
                    s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
                    var d = l === r ? i : n;
                    d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3
                }
                var p = new Ii;
                p.addAttribute("position", new Pi(s, 3)), p.addAttribute("color", new Pi(c, 3));
                var f = new Pr({
                    vertexColors: M
                });
                Cr.call(this, p, f)
            }

            function dc(t, e, i, n, r, o) {
                t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new ci(void 0 !== r ? r : 4473924), o = new ci(void 0 !== o ? o : 8947848);
                var a, s, c, l, h, u, d, p = [],
                    f = [];
                for (l = 0; l <= e; l++) c = l / e * (2 * Math.PI), a = Math.sin(c) * t, s = Math.cos(c) * t, p.push(0, 0, 0), p.push(a, 0, s), d = 1 & l ? r : o, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
                for (l = 0; l <= i; l++)
                    for (d = 1 & l ? r : o, u = t - t / i * l, h = 0; h < n; h++) c = h / n * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, p.push(a, 0, s), f.push(d.r, d.g, d.b), c = (h + 1) / n * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, p.push(a, 0, s), f.push(d.r, d.g, d.b);
                var m = new Ii;
                m.addAttribute("position", new Pi(p, 3)), m.addAttribute("color", new Pi(f, 3));
                var g = new Pr({
                    vertexColors: M
                });
                Cr.call(this, m, g)
            }

            function pc(t, e, i, n) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== i ? i : 16776960,
                    o = void 0 !== n ? n : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var c = new Ii,
                    l = new Pi(2 * a * 3, 3);
                c.addAttribute("position", l), Cr.call(this, c, new Pr({
                    color: r,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function fc(t, e, i) {
                vi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
                var n = new Ii;
                n.addAttribute("position", new Pi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                var r = new Pr({
                    fog: !1
                });
                this.lightPlane = new Lr(n, r), this.add(this.lightPlane), (n = new Ii).addAttribute("position", new Pi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Lr(n, r), this.add(this.targetLine), this.update()
            }

            function mc(t) {
                var e = new Ii,
                    i = new Pr({
                        color: 16777215,
                        vertexColors: w
                    }),
                    n = [],
                    r = [],
                    o = {},
                    a = new ci(16755200),
                    s = new ci(16711680),
                    c = new ci(43775),
                    l = new ci(16777215),
                    h = new ci(3355443);

                function u(t, e, i) {
                    d(t, i), d(e, i)
                }

                function d(t, e) {
                    n.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(n.length / 3 - 1)
                }
                u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", c), u("u2", "u3", c), u("u3", "u1", c), u("c", "t", l), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.addAttribute("position", new Pi(n, 3)), e.addAttribute("color", new Pi(r, 3)), Cr.call(this, e, i), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
            }

            function gc(t, e) {
                this.object = t, void 0 === e && (e = 16776960);
                var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    n = new Float32Array(24),
                    r = new Ii;
                r.setIndex(new xi(i, 1)), r.addAttribute("position", new xi(n, 3)), Cr.call(this, r, new Pr({
                    color: e
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function vc(t, e) {
                this.type = "Box3Helper", this.box = t;
                var i = void 0 !== e ? e : 16776960,
                    n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Ii;
                r.setIndex(new xi(n, 1)), r.addAttribute("position", new Pi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Cr.call(this, r, new Pr({
                    color: i
                })), this.geometry.computeBoundingSphere()
            }

            function yc(t, e, i) {
                this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
                var n = void 0 !== i ? i : 16776960,
                    r = new Ii;
                r.addAttribute("position", new Pi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), Lr.call(this, r, new Pr({
                    color: n
                }));
                var o = new Ii;
                o.addAttribute("position", new Pi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new ji(o, new Vi({
                    color: n,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }

            function _c(e, i, n, r, o, a) {
                vi.call(this), void 0 === e && (e = new t.Vector3(0, 0, 1)), void 0 === i && (i = new t.Vector3(0, 0, 0)), void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === o && (o = .2 * n), void 0 === a && (a = .2 * o), void 0 === Us && ((Us = new Ii).addAttribute("position", new Pi([0, 0, 0, 0, 1, 0], 3)), (Gs = new Xo(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(i), this.line = new Lr(Us, new Pr({
                    color: r
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ji(Gs, new Vi({
                    color: r
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, o, a)
            }

            function xc(t) {
                var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    i = new Ii;
                i.addAttribute("position", new Pi(e, 3)), i.addAttribute("color", new Pi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var n = new Pr({
                    vertexColors: M
                });
                Cr.call(this, i, n)
            }

            function bc(t, e, i, n, r, o, a) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new pi(t, e, i, r, o, a)
            }
            Object.assign(Hs.prototype, {
                    getValue: function(t, e) {
                        this.bind();
                        var i = this._targetGroup.nCachedObjects_,
                            n = this._bindings[i];
                        void 0 !== n && n.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
                    },
                    bind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
                    },
                    unbind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
                    }
                }), Object.assign(Vs, {
                    Composite: Hs,
                    create: function(t, e, i) {
                        return t && t.isAnimationObjectGroup ? new Vs.Composite(t, e, i) : new Vs(t, e, i)
                    },
                    sanitizeNodeName: function() {
                        var t = new RegExp("[\\[\\]\\.:\\/]", "g");
                        return function(e) {
                            return e.replace(/\s/g, "_").replace(t, "")
                        }
                    }(),
                    parseTrackName: function() {
                        var t = "[^\\[\\]\\.:\\/]",
                            e = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                            i = /((?:WC+[\/:])*)/.source.replace("WC", t),
                            n = /(WCOD+)?/.source.replace("WCOD", e),
                            r = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t),
                            o = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t),
                            a = new RegExp("^" + i + n + r + o + "$"),
                            s = ["material", "materials", "bones"];
                        return function(t) {
                            var e = a.exec(t);
                            if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                            var i = {
                                    nodeName: e[2],
                                    objectName: e[3],
                                    objectIndex: e[4],
                                    propertyName: e[5],
                                    propertyIndex: e[6]
                                },
                                n = i.nodeName && i.nodeName.lastIndexOf(".");
                            if (void 0 !== n && -1 !== n) {
                                var r = i.nodeName.substring(n + 1); - 1 !== s.indexOf(r) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r)
                            }
                            if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                            return i
                        }
                    }(),
                    findNode: function(t, e) {
                        if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) {
                            var i = t.skeleton.getBoneByName(e);
                            if (void 0 !== i) return i
                        }
                        if (t.children) {
                            var n = function(t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        if (r.name === e || r.uuid === e) return r;
                                        var o = n(r.children);
                                        if (o) return o
                                    }
                                    return null
                                },
                                r = n(t.children);
                            if (r) return r
                        }
                        return null
                    }
                }), Object.assign(Vs.prototype, {
                    _getValue_unavailable: function() {},
                    _setValue_unavailable: function() {},
                    BindingType: {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    },
                    Versioning: {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    },
                    GetterByBindingType: [function(t, e) {
                        t[e] = this.node[this.propertyName]
                    }, function(t, e) {
                        for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
                    }, function(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }, function(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }],
                    SetterByBindingTypeAndVersioning: [
                        [function(t, e) {
                            this.targetObject[this.propertyName] = t[e]
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                        }, function(t, e) {
                            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                            this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e]
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty.fromArray(t, e)
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                        }]
                    ],
                    getValue: function(t, e) {
                        this.bind(), this.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        this.bind(), this.setValue(t, e)
                    },
                    bind: function() {
                        var t = this.node,
                            e = this.parsedPath,
                            i = e.objectName,
                            n = e.propertyName,
                            r = e.propertyIndex;
                        if (t || (t = Vs.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                            if (i) {
                                var o = e.objectIndex;
                                switch (i) {
                                    case "materials":
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        t = t.material.materials;
                                        break;
                                    case "bones":
                                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        t = t.skeleton.bones;
                                        for (var a = 0; a < t.length; a++)
                                            if (t[a].name === o) {
                                                o = a;
                                                break
                                            }
                                        break;
                                    default:
                                        if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        t = t[i]
                                }
                                if (void 0 !== o) {
                                    if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    t = t[o]
                                }
                            }
                            var s = t[n];
                            if (void 0 !== s) {
                                var c = this.Versioning.None;
                                this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                                var l = this.BindingType.Direct;
                                if (void 0 !== r) {
                                    if ("morphTargetInfluences" === n) {
                                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                        if (t.geometry.isBufferGeometry) {
                                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                            for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                                if (t.geometry.morphAttributes.position[a].name === r) {
                                                    r = a;
                                                    break
                                                }
                                        } else {
                                            if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                            for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                                if (t.geometry.morphTargets[a].name === r) {
                                                    r = a;
                                                    break
                                                }
                                        }
                                    }
                                    l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                                this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                            } else {
                                var h = e.nodeName;
                                console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + n + " but it wasn't found.", t)
                            }
                        } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                    },
                    unbind: function() {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign(Vs.prototype, {
                    _getValue_unbound: Vs.prototype.getValue,
                    _setValue_unbound: Vs.prototype.setValue
                }), Object.assign(js.prototype, {
                    isAnimationObjectGroup: !0,
                    add: function() {
                        for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, l = 0, h = arguments.length; l !== h; ++l) {
                            var u = arguments[l],
                                d = u.uuid,
                                p = n[d];
                            if (void 0 === p) {
                                p = e++, n[d] = p, t.push(u);
                                for (var f = 0, m = s; f !== m; ++f) a[f].push(new Vs(u, r[f], o[f]))
                            } else if (p < i) {
                                c = t[p];
                                var g = --i,
                                    v = t[g];
                                n[v.uuid] = p, t[p] = v, n[d] = g, t[g] = u;
                                for (f = 0, m = s; f !== m; ++f) {
                                    var y = a[f],
                                        _ = y[g],
                                        x = y[p];
                                    y[p] = _, void 0 === x && (x = new Vs(u, r[f], o[f])), y[g] = x
                                }
                            } else t[p] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = i
                    },
                    remove: function() {
                        for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, a = arguments.length; o !== a; ++o) {
                            var s = arguments[o],
                                c = s.uuid,
                                l = i[c];
                            if (void 0 !== l && l >= e) {
                                var h = e++,
                                    u = t[h];
                                i[u.uuid] = l, t[l] = u, i[c] = h, t[h] = s;
                                for (var d = 0, p = r; d !== p; ++d) {
                                    var f = n[d],
                                        m = f[h],
                                        g = f[l];
                                    f[l] = m, f[h] = g
                                }
                            }
                        }
                        this.nCachedObjects_ = e
                    },
                    uncache: function() {
                        for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                            var c = arguments[a].uuid,
                                l = n[c];
                            if (void 0 !== l)
                                if (delete n[c], l < i) {
                                    var h = --i,
                                        u = t[h],
                                        d = t[v = --e];
                                    n[u.uuid] = l, t[l] = u, n[d.uuid] = h, t[h] = d, t.pop();
                                    for (var p = 0, f = o; p !== f; ++p) {
                                        var m = (y = r[p])[h],
                                            g = y[v];
                                        y[l] = m, y[h] = g, y.pop()
                                    }
                                } else {
                                    var v;
                                    n[(d = t[v = --e]).uuid] = l, t[l] = d, t.pop();
                                    for (p = 0, f = o; p !== f; ++p) {
                                        var y;
                                        (y = r[p])[l] = y[v], y.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = i
                    },
                    subscribe_: function(t, e) {
                        var i = this._bindingsIndicesByPath,
                            n = i[t],
                            r = this._bindings;
                        if (void 0 !== n) return r[n];
                        var o = this._paths,
                            a = this._parsedPaths,
                            s = this._objects,
                            c = s.length,
                            l = this.nCachedObjects_,
                            h = new Array(c);
                        n = r.length, i[t] = n, o.push(t), a.push(e), r.push(h);
                        for (var u = l, d = s.length; u !== d; ++u) {
                            var p = s[u];
                            h[u] = new Vs(p, t, e)
                        }
                        return h
                    },
                    unsubscribe_: function(t) {
                        var e = this._bindingsIndicesByPath,
                            i = e[t];
                        if (void 0 !== i) {
                            var n = this._paths,
                                r = this._parsedPaths,
                                o = this._bindings,
                                a = o.length - 1,
                                s = o[a];
                            e[t[a]] = i, o[i] = s, o.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
                        }
                    }
                }), Object.assign(Ws.prototype, {
                    play: function() {
                        return this._mixer._activateAction(this), this
                    },
                    stop: function() {
                        return this._mixer._deactivateAction(this), this.reset()
                    },
                    reset: function() {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    },
                    isRunning: function() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    },
                    isScheduled: function() {
                        return this._mixer._isActiveAction(this)
                    },
                    startAt: function(t) {
                        return this._startTime = t, this
                    },
                    setLoop: function(t, e) {
                        return this.loop = t, this.repetitions = e, this
                    },
                    setEffectiveWeight: function(t) {
                        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                    },
                    getEffectiveWeight: function() {
                        return this._effectiveWeight
                    },
                    fadeIn: function(t) {
                        return this._scheduleFading(t, 0, 1)
                    },
                    fadeOut: function(t) {
                        return this._scheduleFading(t, 1, 0)
                    },
                    crossFadeFrom: function(t, e, i) {
                        if (t.fadeOut(e), this.fadeIn(e), i) {
                            var n = this._clip.duration,
                                r = t._clip.duration,
                                o = r / n,
                                a = n / r;
                            t.warp(1, o, e), this.warp(a, 1, e)
                        }
                        return this
                    },
                    crossFadeTo: function(t, e, i) {
                        return t.crossFadeFrom(this, e, i)
                    },
                    stopFading: function() {
                        var t = this._weightInterpolant;
                        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    setEffectiveTimeScale: function(t) {
                        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                    },
                    getEffectiveTimeScale: function() {
                        return this._effectiveTimeScale
                    },
                    setDuration: function(t) {
                        return this.timeScale = this._clip.duration / t, this.stopWarping()
                    },
                    syncWith: function(t) {
                        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                    },
                    halt: function(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    },
                    warp: function(t, e, i) {
                        var n = this._mixer,
                            r = n.time,
                            o = this._timeScaleInterpolant,
                            a = this.timeScale;
                        null === o && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
                        var s = o.parameterPositions,
                            c = o.sampleValues;
                        return s[0] = r, s[1] = r + i, c[0] = t / a, c[1] = e / a, this
                    },
                    stopWarping: function() {
                        var t = this._timeScaleInterpolant;
                        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    getMixer: function() {
                        return this._mixer
                    },
                    getClip: function() {
                        return this._clip
                    },
                    getRoot: function() {
                        return this._localRoot || this._mixer._root
                    },
                    _update: function(t, e, i, n) {
                        if (this.enabled) {
                            var r = this._startTime;
                            if (null !== r) {
                                var o = (t - r) * i;
                                if (o < 0 || 0 === i) return;
                                this._startTime = null, e = i * o
                            }
                            e *= this._updateTimeScale(t);
                            var a = this._updateTime(e),
                                s = this._updateWeight(t);
                            if (s > 0)
                                for (var c = this._interpolants, l = this._propertyBindings, h = 0, u = c.length; h !== u; ++h) c[h].evaluate(a), l[h].accumulate(n, s)
                        } else this._updateWeight(t)
                    },
                    _updateWeight: function(t) {
                        var e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            var i = this._weightInterpolant;
                            if (null !== i) {
                                var n = i.evaluate(t)[0];
                                e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    },
                    _updateTimeScale: function(t) {
                        var e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            var i = this._timeScaleInterpolant;
                            if (null !== i) e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                        }
                        return this._effectiveTimeScale = e, e
                    },
                    _updateTime: function(t) {
                        var e = this.time + t,
                            i = this._clip.duration,
                            n = this.loop,
                            r = this._loopCount,
                            o = n === ye;
                        if (0 === t) return -1 === r ? e : o && 1 == (1 & r) ? i - e : e;
                        if (n === ge) {
                            -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (e >= i) e = i;
                                else {
                                    if (!(e < 0)) break t;
                                    e = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= i || e < 0) {
                                var a = Math.floor(e / i);
                                e -= i * a, r += Math.abs(a);
                                var s = this.repetitions - r;
                                if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? i : 0, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                                else {
                                    if (1 === s) {
                                        var c = t < 0;
                                        this._setEndings(c, !c, o)
                                    } else this._setEndings(!1, !1, o);
                                    this._loopCount = r, this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: a
                                    })
                                }
                            }
                            if (o && 1 == (1 & r)) return this.time = e, i - e
                        }
                        return this.time = e, e
                    },
                    _setEndings: function(t, e, i) {
                        var n = this._interpolantSettings;
                        i ? (n.endingStart = Me, n.endingEnd = Me) : (n.endingStart = t ? this.zeroSlopeAtStart ? Me : we : Te, n.endingEnd = e ? this.zeroSlopeAtEnd ? Me : we : Te)
                    },
                    _scheduleFading: function(t, e, i) {
                        var n = this._mixer,
                            r = n.time,
                            o = this._weightInterpolant;
                        null === o && (o = n._lendControlInterpolant(), this._weightInterpolant = o);
                        var a = o.parameterPositions,
                            s = o.sampleValues;
                        return a[0] = r, s[0] = e, a[1] = r + t, s[1] = i, this
                    }
                }), Xs.prototype = Object.assign(Object.create(n.prototype), {
                    constructor: Xs,
                    _bindAction: function(t, e) {
                        var i = t._localRoot || this._root,
                            n = t._clip.tracks,
                            r = n.length,
                            o = t._propertyBindings,
                            a = t._interpolants,
                            s = i.uuid,
                            c = this._bindingsByRootAndName,
                            l = c[s];
                        void 0 === l && (l = {}, c[s] = l);
                        for (var h = 0; h !== r; ++h) {
                            var u = n[h],
                                d = u.name,
                                p = l[d];
                            if (void 0 !== p) o[h] = p;
                            else {
                                if (void 0 !== (p = o[h])) {
                                    null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                                    continue
                                }
                                var f = e && e._propertyBindings[h].binding.parsedPath;
                                ++(p = new zs(Vs.create(i, d, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), o[h] = p
                            }
                            a[h].resultBuffer = p.buffer
                        }
                    },
                    _activateAction: function(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                var e = (t._localRoot || this._root).uuid,
                                    i = t._clip.uuid,
                                    n = this._actionsByClip[i];
                                this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                            }
                            for (var r = t._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                                var s = r[o];
                                0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    },
                    _deactivateAction: function(t) {
                        if (this._isActiveAction(t)) {
                            for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                                var r = e[i];
                                0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                            }
                            this._takeBackAction(t)
                        }
                    },
                    _initMemoryManager: function() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        var t = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    },
                    _isActiveAction: function(t) {
                        var e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions
                    },
                    _addInactiveAction: function(t, e, i) {
                        var n = this._actions,
                            r = this._actionsByClip,
                            o = r[e];
                        if (void 0 === o) o = {
                            knownActions: [t],
                            actionByRoot: {}
                        }, t._byClipCacheIndex = 0, r[e] = o;
                        else {
                            var a = o.knownActions;
                            t._byClipCacheIndex = a.length, a.push(t)
                        }
                        t._cacheIndex = n.length, n.push(t), o.actionByRoot[i] = t
                    },
                    _removeInactiveAction: function(t) {
                        var e = this._actions,
                            i = e[e.length - 1],
                            n = t._cacheIndex;
                        i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
                        var r = t._clip.uuid,
                            o = this._actionsByClip,
                            a = o[r],
                            s = a.knownActions,
                            c = s[s.length - 1],
                            l = t._byClipCacheIndex;
                        c._byClipCacheIndex = l, s[l] = c, s.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(t)
                    },
                    _removeInactiveBindingsForAction: function(t) {
                        for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                            var r = e[i];
                            0 == --r.referenceCount && this._removeInactiveBinding(r)
                        }
                    },
                    _lendAction: function(t) {
                        var e = this._actions,
                            i = t._cacheIndex,
                            n = this._nActiveActions++,
                            r = e[n];
                        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                    },
                    _takeBackAction: function(t) {
                        var e = this._actions,
                            i = t._cacheIndex,
                            n = --this._nActiveActions,
                            r = e[n];
                        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                    },
                    _addInactiveBinding: function(t, e, i) {
                        var n = this._bindingsByRootAndName,
                            r = n[e],
                            o = this._bindings;
                        void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = o.length, o.push(t)
                    },
                    _removeInactiveBinding: function(t) {
                        var e = this._bindings,
                            i = t.binding,
                            n = i.rootNode.uuid,
                            r = i.path,
                            o = this._bindingsByRootAndName,
                            a = o[n],
                            s = e[e.length - 1],
                            c = t._cacheIndex;
                        s._cacheIndex = c, e[c] = s, e.pop(), delete a[r];
                        t: {
                            for (var l in a) break t;delete o[n]
                        }
                    },
                    _lendBinding: function(t) {
                        var e = this._bindings,
                            i = t._cacheIndex,
                            n = this._nActiveBindings++,
                            r = e[n];
                        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                    },
                    _takeBackBinding: function(t) {
                        var e = this._bindings,
                            i = t._cacheIndex,
                            n = --this._nActiveBindings,
                            r = e[n];
                        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                    },
                    _lendControlInterpolant: function() {
                        var t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++,
                            i = t[e];
                        return void 0 === i && ((i = new da(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = i), i
                    },
                    _takeBackControlInterpolant: function(t) {
                        var e = this._controlInterpolants,
                            i = t.__cacheIndex,
                            n = --this._nActiveControlInterpolants,
                            r = e[n];
                        t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
                    },
                    _controlInterpolantsResultBuffer: new Float32Array(1),
                    clipAction: function(t, e) {
                        var i = e || this._root,
                            n = i.uuid,
                            r = "string" == typeof t ? wa.findByName(i, t) : t,
                            o = null !== r ? r.uuid : t,
                            a = this._actionsByClip[o],
                            s = null;
                        if (void 0 !== a) {
                            var c = a.actionByRoot[n];
                            if (void 0 !== c) return c;
                            s = a.knownActions[0], null === r && (r = s._clip)
                        }
                        if (null === r) return null;
                        var l = new Ws(this, r, e);
                        return this._bindAction(l, s), this._addInactiveAction(l, o, n), l
                    },
                    existingAction: function(t, e) {
                        var i = e || this._root,
                            n = i.uuid,
                            r = "string" == typeof t ? wa.findByName(i, t) : t,
                            o = r ? r.uuid : t,
                            a = this._actionsByClip[o];
                        return void 0 !== a && a.actionByRoot[n] || null
                    },
                    stopAllAction: function() {
                        var t = this._actions,
                            e = this._nActiveActions,
                            i = this._bindings,
                            n = this._nActiveBindings;
                        this._nActiveActions = 0, this._nActiveBindings = 0;
                        for (var r = 0; r !== e; ++r) t[r].reset();
                        for (r = 0; r !== n; ++r) i[r].useCount = 0;
                        return this
                    },
                    update: function(t) {
                        t *= this.timeScale;
                        for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== i; ++a) {
                            e[a]._update(n, t, r, o)
                        }
                        var s = this._bindings,
                            c = this._nActiveBindings;
                        for (a = 0; a !== c; ++a) s[a].apply(o);
                        return this
                    },
                    getRoot: function() {
                        return this._root
                    },
                    uncacheClip: function(t) {
                        var e = this._actions,
                            i = t.uuid,
                            n = this._actionsByClip,
                            r = n[i];
                        if (void 0 !== r) {
                            for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                                var c = o[a];
                                this._deactivateAction(c);
                                var l = c._cacheIndex,
                                    h = e[e.length - 1];
                                c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = l, e[l] = h, e.pop(), this._removeInactiveBindingsForAction(c)
                            }
                            delete n[i]
                        }
                    },
                    uncacheRoot: function(t) {
                        var e = t.uuid,
                            i = this._actionsByClip;
                        for (var n in i) {
                            var r = i[n].actionByRoot[e];
                            void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                        }
                        var o = this._bindingsByRootAndName[e];
                        if (void 0 !== o)
                            for (var a in o) {
                                var s = o[a];
                                s.restoreOriginalState(), this._removeInactiveBinding(s)
                            }
                    },
                    uncacheAction: function(t, e) {
                        var i = this.existingAction(t, e);
                        null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                    }
                }), qs.prototype.clone = function() {
                    return new qs(void 0 === this.value.clone ? this.value : this.value.clone())
                }, Ys.prototype = Object.assign(Object.create(Ii.prototype), {
                    constructor: Ys,
                    isInstancedBufferGeometry: !0,
                    copy: function(t) {
                        return Ii.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    }
                }), Zs.prototype = Object.assign(Object.create(xr.prototype), {
                    constructor: Zs,
                    isInstancedInterleavedBuffer: !0,
                    copy: function(t) {
                        return xr.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                }), Js.prototype = Object.assign(Object.create(xi.prototype), {
                    constructor: Js,
                    isInstancedBufferAttribute: !0,
                    copy: function(t) {
                        return xi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                }), Object.assign(Ks.prototype, {
                    linePrecision: 1,
                    set: function(t, e) {
                        this.ray.set(t, e)
                    },
                    setFromCamera: function(t, e) {
                        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                    },
                    intersectObject: function(t, e, i) {
                        var n = i || [];
                        return $s(t, this, n, e), n.sort(Qs), n
                    },
                    intersectObjects: function(t, e, i) {
                        var n = i || [];
                        if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
                        for (var r = 0, o = t.length; r < o; r++) $s(t[r], this, n, e);
                        return n.sort(Qs), n
                    }
                }), Object.assign(tc.prototype, {
                    set: function(t, e, i) {
                        return this.radius = t, this.phi = e, this.theta = i, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                    },
                    makeSafe: function() {
                        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, i) {
                        return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(Ue.clamp(e / this.radius, -1, 1))), this
                    }
                }), Object.assign(ec.prototype, {
                    set: function(t, e, i) {
                        return this.radius = t, this.theta = e, this.y = i, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, i) {
                        return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this
                    }
                }), Object.assign(ic.prototype, {
                    set: function(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    },
                    setFromPoints: function(t) {
                        this.makeEmpty();
                        for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                        return this
                    },
                    setFromCenterAndSize: function() {
                        var t = new Ge;
                        return function(e, i) {
                            var n = t.copy(i).multiplyScalar(.5);
                            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                        }
                    }(),
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    },
                    makeEmpty: function() {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    },
                    isEmpty: function() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    },
                    getCenter: function(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Ge), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    },
                    getSize: function(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Ge), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                    },
                    expandByPoint: function(t) {
                        return this.min.min(t), this.max.max(t), this
                    },
                    expandByVector: function(t) {
                        return this.min.sub(t), this.max.add(t), this
                    },
                    expandByScalar: function(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    },
                    containsPoint: function(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                    },
                    containsBox: function(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    },
                    getParameter: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Ge), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    },
                    intersectsBox: function(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                    },
                    clampPoint: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Ge), e.copy(t).clamp(this.min, this.max)
                    },
                    distanceToPoint: function() {
                        var t = new Ge;
                        return function(e) {
                            return t.copy(e).clamp(this.min, this.max).sub(e).length()
                        }
                    }(),
                    intersect: function(t) {
                        return this.min.max(t.min), this.max.min(t.max), this
                    },
                    union: function(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    },
                    translate: function(t) {
                        return this.min.add(t), this.max.add(t), this
                    },
                    equals: function(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }), Object.assign(nc.prototype, {
                    set: function(t, e) {
                        return this.start.copy(t), this.end.copy(e), this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.start.copy(t.start), this.end.copy(t.end), this
                    },
                    getCenter: function(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new je), t.addVectors(this.start, this.end).multiplyScalar(.5)
                    },
                    delta: function(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new je), t.subVectors(this.end, this.start)
                    },
                    distanceSq: function() {
                        return this.start.distanceToSquared(this.end)
                    },
                    distance: function() {
                        return this.start.distanceTo(this.end)
                    },
                    at: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new je), this.delta(e).multiplyScalar(t).add(this.start)
                    },
                    closestPointToPointParameter: function() {
                        var t = new je,
                            e = new je;
                        return function(i, n) {
                            t.subVectors(i, this.start), e.subVectors(this.end, this.start);
                            var r = e.dot(e),
                                o = e.dot(t) / r;
                            return n && (o = Ue.clamp(o, 0, 1)), o
                        }
                    }(),
                    closestPointToPoint: function(t, e, i) {
                        var n = this.closestPointToPointParameter(t, e);
                        return void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new je), this.delta(i).multiplyScalar(n).add(this.start)
                    },
                    applyMatrix4: function(t) {
                        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                    },
                    equals: function(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                }), rc.prototype = Object.create(vi.prototype), rc.prototype.constructor = rc, rc.prototype.isImmediateRenderObject = !0, oc.prototype = Object.create(Cr.prototype), oc.prototype.constructor = oc, oc.prototype.update = function() {
                    var t = new je,
                        e = new je,
                        i = new We;
                    return function() {
                        var n = ["a", "b", "c"];
                        this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                        var r = this.object.matrixWorld,
                            o = this.geometry.attributes.position,
                            a = this.object.geometry;
                        if (a && a.isGeometry)
                            for (var s = a.vertices, c = a.faces, l = 0, h = 0, u = c.length; h < u; h++)
                                for (var d = c[h], p = 0, f = d.vertexNormals.length; p < f; p++) {
                                    var m = s[d[n[p]]],
                                        g = d.vertexNormals[p];
                                    t.copy(m).applyMatrix4(r), e.copy(g).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(l, t.x, t.y, t.z), l += 1, o.setXYZ(l, e.x, e.y, e.z), l += 1
                                } else if (a && a.isBufferGeometry) {
                                    var v = a.attributes.position,
                                        y = a.attributes.normal;
                                    for (l = 0, p = 0, f = v.count; p < f; p++) t.set(v.getX(p), v.getY(p), v.getZ(p)).applyMatrix4(r), e.set(y.getX(p), y.getY(p), y.getZ(p)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(l, t.x, t.y, t.z), l += 1, o.setXYZ(l, e.x, e.y, e.z), l += 1
                                }
                        o.needsUpdate = !0
                    }
                }(), ac.prototype = Object.create(vi.prototype), ac.prototype.constructor = ac, ac.prototype.dispose = function() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }, ac.prototype.update = function() {
                    var t = new je;
                    return function() {
                        this.light.updateMatrixWorld();
                        var e = this.light.distance ? this.light.distance : 1e3,
                            i = e * Math.tan(this.light.angle);
                        this.cone.scale.set(i, i, e), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }(), sc.prototype = Object.create(Cr.prototype), sc.prototype.constructor = sc, sc.prototype.updateMatrixWorld = function() {
                    var t = new je,
                        e = new He,
                        i = new He;
                    return function(n) {
                        var r = this.bones,
                            o = this.geometry,
                            a = o.getAttribute("position");
                        i.getInverse(this.root.matrixWorld);
                        for (var s = 0, c = 0; s < r.length; s++) {
                            var l = r[s];
                            l.parent && l.parent.isBone && (e.multiplyMatrices(i, l.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(i, l.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c + 1, t.x, t.y, t.z), c += 2)
                        }
                        o.getAttribute("position").needsUpdate = !0, vi.prototype.updateMatrixWorld.call(this, n)
                    }
                }(), cc.prototype = Object.create(ji.prototype), cc.prototype.constructor = cc, cc.prototype.dispose = function() {
                    this.geometry.dispose(), this.material.dispose()
                }, cc.prototype.update = function() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }, lc.prototype = Object.create(vi.prototype), lc.prototype.constructor = lc, lc.prototype.dispose = function() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }, lc.prototype.update = function() {
                    var t = .5 * this.light.width,
                        e = .5 * this.light.height,
                        i = this.line.geometry.attributes.position,
                        n = i.array;
                    n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
                }, hc.prototype = Object.create(vi.prototype), hc.prototype.constructor = hc, hc.prototype.dispose = function() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }, hc.prototype.update = function() {
                    var t = new je,
                        e = new ci,
                        i = new ci;
                    return function() {
                        var n = this.children[0];
                        if (void 0 !== this.color) this.material.color.set(this.color);
                        else {
                            var r = n.geometry.getAttribute("color");
                            e.copy(this.light.color), i.copy(this.light.groundColor);
                            for (var o = 0, a = r.count; o < a; o++) {
                                var s = o < a / 2 ? e : i;
                                r.setXYZ(o, s.r, s.g, s.b)
                            }
                            r.needsUpdate = !0
                        }
                        n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }(), uc.prototype = Object.create(Cr.prototype), uc.prototype.constructor = uc, dc.prototype = Object.create(Cr.prototype), dc.prototype.constructor = dc, pc.prototype = Object.create(Cr.prototype), pc.prototype.constructor = pc, pc.prototype.update = function() {
                    var t = new je,
                        e = new je,
                        i = new We;
                    return function() {
                        this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                        for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, c = 0, l = 0, h = s.length; l < h; l++) {
                            var u = s[l],
                                d = u.normal;
                            t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(n), e.copy(d).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(c, t.x, t.y, t.z), c += 1, r.setXYZ(c, e.x, e.y, e.z), c += 1
                        }
                        r.needsUpdate = !0
                    }
                }(), fc.prototype = Object.create(vi.prototype), fc.prototype.constructor = fc, fc.prototype.dispose = function() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }, fc.prototype.update = function() {
                    var t = new je,
                        e = new je,
                        i = new je;
                    return function() {
                        t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(e), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(e), this.targetLine.scale.z = i.length()
                    }
                }(), mc.prototype = Object.create(Cr.prototype), mc.prototype.constructor = mc, mc.prototype.update = function() {
                    var t, e, i = new je,
                        n = new cr;

                    function r(r, o, a, s) {
                        i.set(o, a, s).unproject(n);
                        var c = e[r];
                        if (void 0 !== c)
                            for (var l = t.getAttribute("position"), h = 0, u = c.length; h < u; h++) l.setXYZ(c[h], i.x, i.y, i.z)
                    }
                    return function() {
                        t = this.geometry, e = this.pointMap;
                        n.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                    }
                }(), gc.prototype = Object.create(Cr.prototype), gc.prototype.constructor = gc, gc.prototype.update = function() {
                    var t = new $e;
                    return function(e) {
                        if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                            var i = t.min,
                                n = t.max,
                                r = this.geometry.attributes.position,
                                o = r.array;
                            o[0] = n.x, o[1] = n.y, o[2] = n.z, o[3] = i.x, o[4] = n.y, o[5] = n.z, o[6] = i.x, o[7] = i.y, o[8] = n.z, o[9] = n.x, o[10] = i.y, o[11] = n.z, o[12] = n.x, o[13] = n.y, o[14] = i.z, o[15] = i.x, o[16] = n.y, o[17] = i.z, o[18] = i.x, o[19] = i.y, o[20] = i.z, o[21] = n.x, o[22] = i.y, o[23] = i.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                        }
                    }
                }(), gc.prototype.setFromObject = function(t) {
                    return this.object = t, this.update(), this
                }, gc.prototype.copy = function(t) {
                    return Cr.prototype.copy.call(this, t), this.object = t.object, this
                }, gc.prototype.clone = function() {
                    return (new this.constructor).copy(this)
                }, vc.prototype = Object.create(Cr.prototype), vc.prototype.constructor = vc, vc.prototype.updateMatrixWorld = function(t) {
                    var e = this.box;
                    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), vi.prototype.updateMatrixWorld.call(this, t))
                }, yc.prototype = Object.create(Lr.prototype), yc.prototype.constructor = yc, yc.prototype.updateMatrixWorld = function(t) {
                    var e = -this.plane.constant;
                    Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? v : g, this.lookAt(this.plane.normal), vi.prototype.updateMatrixWorld.call(this, t)
                }, _c.prototype = Object.create(vi.prototype), _c.prototype.constructor = _c, _c.prototype.setDirection = function() {
                    var t, e = new je;
                    return function(i) {
                        i.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : i.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(), t = Math.acos(i.y), this.quaternion.setFromAxisAngle(e, t))
                    }
                }(), _c.prototype.setLength = function(t, e, i) {
                    void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
                }, _c.prototype.setColor = function(t) {
                    this.line.material.color.copy(t), this.cone.material.color.copy(t)
                }, _c.prototype.copy = function(t) {
                    return vi.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
                }, _c.prototype.clone = function() {
                    return (new this.constructor).copy(this)
                }, xc.prototype = Object.create(Cr.prototype), xc.prototype.constructor = xc;
            var wc = 0,
                Mc = 1;

            function Tc(t) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
            }

            function Ec(t) {
                return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                    return t.slice()
                }, t
            }

            function Sc(t, e) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ir(t, e)
            }

            function Ac(t) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Mr(t)
            }

            function Pc(t, e) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ir(t, e)
            }

            function Lc(t) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Or(t)
            }

            function Cc(t) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Or(t)
            }

            function Rc(t) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Or(t)
            }

            function Oc(t, e, i) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new je(t, e, i)
            }

            function Ic(t, e) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new xi(t, e).setDynamic(!0)
            }

            function Dc(t, e) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new bi(t, e)
            }

            function kc(t, e) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new wi(t, e)
            }

            function Nc(t, e) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Mi(t, e)
            }

            function Bc(t, e) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ti(t, e)
            }

            function Fc(t, e) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Ei(t, e)
            }

            function zc(t, e) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Si(t, e)
            }

            function Uc(t, e) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Ai(t, e)
            }

            function Gc(t, e) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Pi(t, e)
            }

            function Hc(t, e) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Li(t, e)
            }

            function Vc(t) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Va.call(this, t), this.type = "catmullrom", this.closed = !0
            }

            function jc(t) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Va.call(this, t), this.type = "catmullrom"
            }

            function Wc(t) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Va.call(this, t), this.type = "catmullrom"
            }

            function Xc(t) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new xc(t)
            }

            function qc(t, e) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new gc(t, e)
            }

            function Yc(t, e) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Cr(new jo(t.geometry), new Pr({
                    color: void 0 !== e ? e : 16777215
                }))
            }

            function Zc(t, e) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Cr(new Fr(t.geometry), new Pr({
                    color: void 0 !== e ? e : 16777215
                }))
            }

            function Jc(t) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Pa(t)
            }

            function Kc(t) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ra(t)
            }
            ka.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(ka.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Object.assign(es.prototype, {
                createPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var e = new _i, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        e.vertices.push(new je(r.x, r.y, r.z || 0))
                    }
                    return e
                }
            }), Object.assign(is.prototype, {
                fromPoints: function(t) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }
            }), Vc.prototype = Object.create(Va.prototype), jc.prototype = Object.create(Va.prototype), Wc.prototype = Object.create(Va.prototype), Object.assign(Wc.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), uc.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, sc.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(Ls.prototype, {
                extractUrlBase: function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), gs.extractUrlBase(t)
                }
            }), Object.assign(_s.prototype, {
                setTexturePath: function(t) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
                }
            }), Object.assign(ic.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign($e.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), nc.prototype.center = function(t) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Object.assign(Ue, {
                random16: function() {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Ue.floorPowerOfTwo(t)
                },
                nextPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Ue.ceilPowerOfTwo(t)
                }
            }), Object.assign(We.prototype, {
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(He.prototype, {
                extractPosition: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                getPosition: function() {
                    var t;
                    return function() {
                        return void 0 === t && (t = new je), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
                    }
                }(),
                setRotationFromQuaternion: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector4: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                },
                crossVector: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(t, e, i, n, r, o) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, o)
                }
            }), ei.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, Ve.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, Object.assign(Gi.prototype, {
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }
            }), Object.assign(Hi.prototype, {
                area: function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function(t, e) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                },
                midpoint: function(t) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                },
                normal: function(t) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                },
                plane: function(t) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                }
            }), Object.assign(Hi, {
                barycoordFromPoint: function(t, e, i, n, r) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Hi.getBarycoord(t, e, i, n, r)
                },
                normal: function(t, e, i, n) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Hi.getNormal(t, e, i, n)
                }
            }), Object.assign(ns.prototype, {
                extractAllPoints: function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                },
                extrude: function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Lo(this, t)
                },
                makeGeometry: function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Go(this, t)
                }
            }), Object.assign(Ge.prototype, {
                fromAttribute: function(t, e, i) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(je.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                },
                applyProjection: function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                },
                fromAttribute: function(t, e, i) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Ze.prototype, {
                fromAttribute: function(t, e, i) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(_i.prototype, {
                computeTangents: function() {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            }), Object.assign(vi.prototype, {
                getChildByName: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                },
                getWorldRotation: function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            }), Object.defineProperties(vi.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(Tr.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(Sr.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Er.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(ka.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                }
            }), lr.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(rs.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(xi.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                copyIndicesArray: function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }
            }), Object.assign(Ii.prototype, {
                addIndex: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                },
                addDrawCall: function(t, e, i) {
                    void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(Ii.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.assign(Co.prototype, {
                getArrays: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.defineProperties(qs.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(zi.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new ci
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === _
                    }
                }
            }), Object.defineProperties(ia.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(Ui.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), Object.assign(gr.prototype, {
                clearTarget: function(t, e, i, n) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n)
                },
                animate: function(t) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                },
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }
            }), Object.defineProperties(gr.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(rr.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(Je.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), Object.defineProperties(mr.prototype, {
                standing: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                },
                userHeight: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .userHeight has been removed.")
                    }
                }
            }), Ns.prototype.load = function(t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var e = this;
                return (new Rs).load(t, function(t) {
                    e.setBuffer(t)
                }), this
            }, Fs.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, Is.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            };
            var Qc = {
                merge: function(t, e, i) {
                    var n;
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i)
                },
                center: function(t) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
                }
            };

            function $c() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
                }, this.unprojectVector = function(t, e) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
                }, this.pickingRay = function() {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }

            function tl() {
                console.error("THREE.CanvasRenderer has been removed")
            }

            function el() {
                console.error("THREE.JSONLoader has been removed.")
            }
            Xe.crossOrigin = void 0, Xe.loadTexture = function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new Da;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, i, void 0, n);
                return e && (o.mapping = e), o
            }, Xe.loadTextureCube = function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new Ia;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, i, void 0, n);
                return e && (o.mapping = e), o
            }, Xe.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, Xe.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            var il = {
                createMultiMaterialObject: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };

            function nl() {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }
        }.call(this, i(1))
}, function(t, e, i) {
    "use strict";
    var n = i(0);
    /*!
     * VERSION: 2.0.2
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     **/
    n.e._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function() {
        var t = function(t) {
                var e, i = [],
                    n = t.length;
                for (e = 0; e !== n; i.push(t[e++]));
                return i
            },
            e = function(t, e, i) {
                var n, r, o = t.cycle;
                for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                delete t.cycle
            },
            i = function(t, e, r) {
                n.f.call(this, t, e, r), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = i.prototype.render
            },
            r = n.f._internals,
            o = r.isSelector,
            a = r.isArray,
            s = i.prototype = n.f.to({}, .1, {}),
            c = [];
        i.version = "2.0.2", s.constructor = i, s.kill()._gc = !1, i.killTweensOf = i.killDelayedCallsTo = n.f.killTweensOf, i.getTweensOf = n.f.getTweensOf, i.lagSmoothing = n.f.lagSmoothing, i.ticker = n.f.ticker, i.render = n.f.render, s.invalidate = function() {
            return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), n.f.prototype.invalidate.call(this)
        }, s.updateTo = function(t, e) {
            var i, r = this.ratio,
                o = this.vars.immediateRender || t.immediateRender;
            for (i in e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), t) this.vars[i] = t[i];
            if (this._initted || o)
                if (e) this._initted = !1, o && this.render(0, !0, !0);
                else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n.f._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                var a = this._totalTime;
                this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
            } else if (this._initted = !1, this._init(), this._time > 0 || o)
                for (var s, c = 1 / (1 - r), l = this._firstPT; l;) s = l.s + l.c, l.c *= c, l.s = s - l.c, l = l._next;
            return this
        }, s.render = function(t, e, i) {
            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
            var o, a, s, c, l, h, u, d, p, f = this._dirty ? this.totalDuration() : this._totalDuration,
                m = this._time,
                g = this._totalTime,
                v = this._cycle,
                y = this._duration,
                _ = this._rawPrevTime;
            if (t >= f - 1e-7 && t >= 0 ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (o = !0, a = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (_ < 0 || t <= 0 && t >= -1e-7 || 1e-10 === _ && "isPause" !== this.data) && _ !== t && (i = !0, _ > 1e-10 && (a = "onReverseComplete")), this._rawPrevTime = d = !e || t || _ === t ? t : 1e-10)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== g || 0 === y && _ > 0) && (a = "onReverseComplete", o = this._reversed), t < 0 && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || i) && (_ >= 0 && (i = !0), this._rawPrevTime = d = !e || t || _ === t ? t : 1e-10)), this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (c = y + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && g <= t && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 != (1 & this._cycle) && (this._time = y - this._time, (p = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== p || this._initted ? this._yoyoEase = p = !0 === p ? this._ease : p instanceof n.b ? p : n.b.map[p] : (p = this.vars.ease, this._yoyoEase = p = p ? p instanceof n.b ? p : "function" == typeof p ? new n.b(p, this.vars.easeParams) : n.b.map[p] || n.f.defaultEase : n.f.defaultEase)), this.ratio = p ? 1 - p.getRatio((y - this._time) / y) : 0)), this._time > y ? this._time = y : this._time < 0 && (this._time = 0)), this._easeType && !p ? (l = this._time / y, h = this._easeType, u = this._easePower, (1 === h || 3 === h && l >= .5) && (l = 1 - l), 3 === h && (l *= 2), 1 === u ? l *= l : 2 === u ? l *= l * l : 3 === u ? l *= l * l * l : 4 === u && (l *= l * l * l * l), 1 === h ? this.ratio = 1 - l : 2 === h ? this.ratio = l : this._time / y < .5 ? this.ratio = l / 2 : this.ratio = 1 - l / 2) : p || (this.ratio = this._ease.getRatio(this._time / y))), m !== this._time || i || v !== this._cycle) {
                if (!this._initted) {
                    if (this._init(), !this._initted || this._gc) return;
                    if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = m, this._totalTime = g, this._rawPrevTime = _, this._cycle = v, r.lazyTweens.push(this), void(this._lazy = [t, e]);
                    !this._time || o || p ? o && this._ease._calcEnd && !p && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / y)
                }
                for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== m && t >= 0 && (this._active = !0), 0 === g && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : a || (a = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== y || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, !0, i), e || (this._totalTime !== g || a) && this._callback("onUpdate")), this._cycle !== v && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), a && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, i), o && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a), 0 === y && 1e-10 === this._rawPrevTime && 1e-10 !== d && (this._rawPrevTime = 0)))
            } else g !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
        }, i.to = function(t, e, n) {
            return new i(t, e, n)
        }, i.from = function(t, e, n) {
            return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new i(t, e, n)
        }, i.fromTo = function(t, e, n, r) {
            return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, new i(t, e, r)
        }, i.staggerTo = i.allTo = function(r, s, l, h, u, d, p) {
            h = h || 0;
            var f, m, g, v, y = 0,
                _ = [],
                x = function() {
                    l.onComplete && l.onComplete.apply(l.onCompleteScope || this, arguments), u.apply(p || l.callbackScope || this, d || c)
                },
                b = l.cycle,
                w = l.startAt && l.startAt.cycle;
            for (a(r) || ("string" == typeof r && (r = n.f.selector(r) || r), o(r) && (r = t(r))), r = r || [], h < 0 && ((r = t(r)).reverse(), h *= -1), f = r.length - 1, g = 0; g <= f; g++) {
                for (v in m = {}, l) m[v] = l[v];
                if (b && (e(m, r, g), null != m.duration && (s = m.duration, delete m.duration)), w) {
                    for (v in w = m.startAt = {}, l.startAt) w[v] = l.startAt[v];
                    e(m.startAt, r, g)
                }
                m.delay = y + (m.delay || 0), g === f && u && (m.onComplete = x), _[g] = new i(r[g], s, m), y += h
            }
            return _
        }, i.staggerFrom = i.allFrom = function(t, e, n, r, o, a, s) {
            return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, i.staggerTo(t, e, n, r, o, a, s)
        }, i.staggerFromTo = i.allFromTo = function(t, e, n, r, o, a, s, c) {
            return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, i.staggerTo(t, e, r, o, a, s, c)
        }, i.delayedCall = function(t, e, n, r, o) {
            return new i(e, 0, {
                delay: t,
                onComplete: e,
                onCompleteParams: n,
                callbackScope: r,
                onReverseComplete: e,
                onReverseCompleteParams: n,
                immediateRender: !1,
                useFrames: o,
                overwrite: 0
            })
        }, i.set = function(t, e) {
            return new i(t, 0, e)
        }, i.isTweening = function(t) {
            return n.f.getTweensOf(t, !0).length > 0
        };
        var l = function(t, e) {
                for (var i = [], r = 0, o = t._first; o;) o instanceof n.f ? i[r++] = o : (e && (i[r++] = o), r = (i = i.concat(l(o, e))).length), o = o._next;
                return i
            },
            h = i.getAllTweens = function(t) {
                return l(n.a._rootTimeline, t).concat(l(n.a._rootFramesTimeline, t))
            };
        i.killAll = function(t, e, i, r) {
            null == e && (e = !0), null == i && (i = !0);
            var o, a, s, c = h(0 != r),
                l = c.length,
                u = e && i && r;
            for (s = 0; s < l; s++) a = c[s], (u || a instanceof n.c || (o = a.target === a.vars.onComplete) && i || e && !o) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
        }, i.killChildTweensOf = function(e, s) {
            if (null != e) {
                var c, l, h, u, d, p = r.tweenLookup;
                if ("string" == typeof e && (e = n.f.selector(e) || e), o(e) && (e = t(e)), a(e))
                    for (u = e.length; --u > -1;) i.killChildTweensOf(e[u], s);
                else {
                    for (h in c = [], p)
                        for (l = p[h].target.parentNode; l;) l === e && (c = c.concat(p[h].tweens)), l = l.parentNode;
                    for (d = c.length, u = 0; u < d; u++) s && c[u].totalTime(c[u].totalDuration()), c[u]._enabled(!1, !1)
                }
            }
        };
        var u = function(t, e, i, r) {
            e = !1 !== e, i = !1 !== i;
            for (var o, a, s = h(r = !1 !== r), c = e && i && r, l = s.length; --l > -1;) a = s[l], (c || a instanceof n.c || (o = a.target === a.vars.onComplete) && i || e && !o) && a.paused(t)
        };
        return i.pauseAll = function(t, e, i) {
            u(!0, t, e, i)
        }, i.resumeAll = function(t, e, i) {
            u(!1, t, e, i)
        }, i.globalTimeScale = function(t) {
            var e = n.a._rootTimeline,
                i = n.f.ticker.time;
            return arguments.length ? (t = t || 1e-10, e._startTime = i - (i - e._startTime) * e._timeScale / t, e = n.a._rootFramesTimeline, i = n.f.ticker.frame, e._startTime = i - (i - e._startTime) * e._timeScale / t, e._timeScale = n.a._rootTimeline._timeScale = t, t) : e._timeScale
        }, s.progress = function(t, e) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
        }, s.totalProgress = function(t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
        }, s.time = function(t, e) {
            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
        }, s.duration = function(t) {
            return arguments.length ? n.a.prototype.duration.call(this, t) : this._duration
        }, s.totalDuration = function(t) {
            return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
        }, s.repeat = function(t) {
            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
        }, s.repeatDelay = function(t) {
            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
        }, s.yoyo = function(t) {
            return arguments.length ? (this._yoyo = t, this) : this._yoyo
        }, i
    }, !0);
    var r = n.g.TweenMax;
    /*!
     * VERSION: 2.0.2
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    n.e._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function() {
        var t, e, i, r, o = function() {
                n.d.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = o.prototype.setRatio
            },
            a = n.e._gsDefine.globals,
            s = {},
            c = o.prototype = new n.d("css");
        c.constructor = o, o.version = "2.0.2", o.API = 2, o.defaultTransformPerspective = 0, o.defaultSkewType = "compensated", o.defaultSmoothOrigin = !0, c = "px", o.suffixMap = {
            top: c,
            right: c,
            bottom: c,
            left: c,
            width: c,
            height: c,
            fontSize: c,
            padding: c,
            margin: c,
            perspective: c,
            lineHeight: ""
        };
        var l, h, u, d, p, f, m, g, v = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
            y = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
            _ = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
            x = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
            b = /(?:\d|\-|\+|=|#|\.)*/g,
            w = /opacity *= *([^)]*)/i,
            M = /opacity:([^;]*)/i,
            T = /alpha\(opacity *=.+?\)/i,
            E = /^(rgb|hsl)/,
            S = /([A-Z])/g,
            A = /-([a-z])/gi,
            P = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
            L = function(t, e) {
                return e.toUpperCase()
            },
            C = /(?:Left|Right|Width)/i,
            R = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
            O = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
            I = /,(?=[^\)]*(?:\(|$))/gi,
            D = /[\s,\(]/i,
            k = Math.PI / 180,
            N = 180 / Math.PI,
            B = {},
            F = {
                style: {}
            },
            z = n.e.document || {
                createElement: function() {
                    return F
                }
            },
            U = function(t, e) {
                return z.createElementNS ? z.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : z.createElement(t)
            },
            G = U("div"),
            H = U("img"),
            V = o._internals = {
                _specialProps: s
            },
            j = (n.e.navigator || {}).userAgent || "",
            W = function() {
                var t = j.indexOf("Android"),
                    e = U("a");
                return u = -1 !== j.indexOf("Safari") && -1 === j.indexOf("Chrome") && (-1 === t || parseFloat(j.substr(t + 8, 2)) > 3), p = u && parseFloat(j.substr(j.indexOf("Version/") + 8, 2)) < 6, d = -1 !== j.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(j) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(j)) && (f = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
            }(),
            X = function(t) {
                return w.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
            },
            q = function(t) {
                n.e.console && console.log(t)
            },
            Y = "",
            Z = "",
            J = function(t, e) {
                var i, n, r = (e = e || G).style;
                if (void 0 !== r[t]) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === r[i[n] + t];);
                return n >= 0 ? (Y = "-" + (Z = 3 === n ? "ms" : i[n]).toLowerCase() + "-", Z + t) : null
            },
            K = ("undefined" != typeof window ? window : z.defaultView || {
                getComputedStyle: function() {}
            }).getComputedStyle,
            Q = o.getStyle = function(t, e, i, n, r) {
                var o;
                return W || "opacity" !== e ? (!n && t.style[e] ? o = t.style[e] : (i = i || K(t)) ? o = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(S, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == r || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : r) : X(t)
            },
            $ = V.convertToPixels = function(t, e, i, r, a) {
                if ("px" === r || !r && "lineHeight" !== e) return i;
                if ("auto" === r || !i) return 0;
                var s, c, l, h = C.test(e),
                    u = t,
                    d = G.style,
                    p = i < 0,
                    f = 1 === i;
                if (p && (i = -i), f && (i *= 100), "lineHeight" !== e || r)
                    if ("%" === r && -1 !== e.indexOf("border")) s = i / 100 * (h ? t.clientWidth : t.clientHeight);
                    else {
                        if (d.cssText = "border:0 solid red;position:" + Q(t, "position") + ";line-height:0;", "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[h ? "borderLeftWidth" : "borderTopWidth"] = i + r;
                        else {
                            if (u = t.parentNode || z.body, -1 !== Q(u, "display").indexOf("flex") && (d.position = "absolute"), c = u._gsCache, l = n.f.ticker.frame, c && h && c.time === l) return c.width * i / 100;
                            d[h ? "width" : "height"] = i + r
                        }
                        u.appendChild(G), s = parseFloat(G[h ? "offsetWidth" : "offsetHeight"]), u.removeChild(G), h && "%" === r && !1 !== o.cacheWidths && ((c = u._gsCache = u._gsCache || {}).time = l, c.width = s / i * 100), 0 !== s || a || (s = $(t, e, i, r, !0))
                    }
                else c = K(t).lineHeight, t.style.lineHeight = i, s = parseFloat(K(t).lineHeight), t.style.lineHeight = c;
                return f && (s /= 100), p ? -s : s
            },
            tt = V.calculateOffset = function(t, e, i) {
                if ("absolute" !== Q(t, "position", i)) return 0;
                var n = "left" === e ? "Left" : "Top",
                    r = Q(t, "margin" + n, i);
                return t["offset" + n] - ($(t, e, parseFloat(r), r.replace(b, "")) || 0)
            },
            et = function(t, e) {
                var i, n, r, o = {};
                if (e = e || K(t, null))
                    if (i = e.length)
                        for (; --i > -1;) - 1 !== (r = e[i]).indexOf("-transform") && Pt !== r || (o[r.replace(A, L)] = e.getPropertyValue(r));
                    else
                        for (i in e) - 1 !== i.indexOf("Transform") && At !== i || (o[i] = e[i]);
                else if (e = t.currentStyle || t.style)
                    for (i in e) "string" == typeof i && void 0 === o[i] && (o[i.replace(A, L)] = e[i]);
                return W || (o.opacity = X(t)), n = Gt(t, e, !1), o.rotation = n.rotation, o.skewX = n.skewX, o.scaleX = n.scaleX, o.scaleY = n.scaleY, o.x = n.x, o.y = n.y, Ct && (o.z = n.z, o.rotationX = n.rotationX, o.rotationY = n.rotationY, o.scaleZ = n.scaleZ), o.filters && delete o.filters, o
            },
            it = function(t, e, i, n, r) {
                var o, a, s, c = {},
                    l = t.style;
                for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (o = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" != typeof o && "string" != typeof o || (c[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[a] || "" === e[a].replace(x, "") ? o : 0 : tt(t, a), void 0 !== l[a] && (s = new vt(l, a, l[a], s))));
                if (n)
                    for (a in n) "className" !== a && (c[a] = n[a]);
                return {
                    difs: c,
                    firstMPT: s
                }
            },
            nt = {
                width: ["Left", "Right"],
                height: ["Top", "Bottom"]
            },
            rt = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
            ot = function(t, e, i) {
                if ("svg" === (t.nodeName + "").toLowerCase()) return (i || K(t))[e] || 0;
                if (t.getCTM && Ft(t)) return t.getBBox()[e] || 0;
                var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                    r = nt[e],
                    o = r.length;
                for (i = i || K(t, null); --o > -1;) n -= parseFloat(Q(t, "padding" + r[o], i, !0)) || 0, n -= parseFloat(Q(t, "border" + r[o] + "Width", i, !0)) || 0;
                return n
            },
            at = function(t, e) {
                if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                null != t && "" !== t || (t = "0 0");
                var i, n = t.split(" "),
                    r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : n[0],
                    o = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : n[1];
                if (n.length > 3 && !e) {
                    for (n = t.split(", ").join(",").split(","), t = [], i = 0; i < n.length; i++) t.push(at(n[i]));
                    return t.join(",")
                }
                return null == o ? o = "center" === r ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t = r + " " + o + (n.length > 2 ? " " + n[2] : ""), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== o.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === o.charAt(1), e.ox = parseFloat(r.replace(x, "")), e.oy = parseFloat(o.replace(x, "")), e.v = t), e || t
            },
            st = function(t, e) {
                return "function" == typeof t && (t = t(g, m)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
            },
            ct = function(t, e) {
                "function" == typeof t && (t = t(g, m));
                var i = "string" == typeof t && "=" === t.charAt(1);
                return "string" == typeof t && "v" === t.charAt(t.length - 2) && (t = (i ? t.substr(0, 2) : 0) + window["inner" + ("vh" === t.substr(-2) ? "Height" : "Width")] * (parseFloat(i ? t.substr(2) : t) / 100)), null == t ? e : i ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
            },
            lt = function(t, e, i, n) {
                var r, o, a, s, c;
                return "function" == typeof t && (t = t(g, m)), null == t ? s = e : "number" == typeof t ? s = t : (r = 360, o = t.split("_"), a = ((c = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === t.indexOf("rad") ? 1 : N) - (c ? 0 : e), o.length && (n && (n[i] = e + a), -1 !== t.indexOf("short") && (a %= r) !== a % (r / 2) && (a = a < 0 ? a + r : a - r), -1 !== t.indexOf("_cw") && a < 0 ? a = (a + 9999999999 * r) % r - (a / r | 0) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (a / r | 0) * r)), s = e + a), s < 1e-6 && s > -1e-6 && (s = 0), s
            },
            ht = {
                aqua: [0, 255, 255],
                lime: [0, 255, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, 255],
                navy: [0, 0, 128],
                white: [255, 255, 255],
                fuchsia: [255, 0, 255],
                olive: [128, 128, 0],
                yellow: [255, 255, 0],
                orange: [255, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [255, 0, 0],
                pink: [255, 192, 203],
                cyan: [0, 255, 255],
                transparent: [255, 255, 255, 0]
            },
            ut = function(t, e, i) {
                return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
            },
            dt = o.parseColor = function(t, e) {
                var i, n, r, o, a, s, c, l, h, u, d;
                if (t)
                    if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                    else {
                        if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ht[t]) i = ht[t];
                        else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (n = t.charAt(1)) + n + (r = t.charAt(2)) + r + (o = t.charAt(3)) + o), i = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                        else if ("hsl" === t.substr(0, 3))
                            if (i = d = t.match(v), e) {
                                if (-1 !== t.indexOf("=")) return t.match(y)
                            } else a = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, n = 2 * (c = Number(i[2]) / 100) - (r = c <= .5 ? c * (s + 1) : c + s - c * s), i.length > 3 && (i[3] = Number(i[3])), i[0] = ut(a + 1 / 3, n, r), i[1] = ut(a, n, r), i[2] = ut(a - 1 / 3, n, r);
                        else i = t.match(v) || ht.transparent;
                        i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                    }
                else i = ht.black;
                return e && !d && (n = i[0] / 255, r = i[1] / 255, o = i[2] / 255, c = ((l = Math.max(n, r, o)) + (h = Math.min(n, r, o))) / 2, l === h ? a = s = 0 : (u = l - h, s = c > .5 ? u / (2 - l - h) : u / (l + h), a = l === n ? (r - o) / u + (r < o ? 6 : 0) : l === r ? (o - n) / u + 2 : (n - r) / u + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * c + .5 | 0), i
            },
            pt = function(t, e) {
                var i, n, r, o = t.match(ft) || [],
                    a = 0,
                    s = "";
                if (!o.length) return t;
                for (i = 0; i < o.length; i++) n = o[i], a += (r = t.substr(a, t.indexOf(n, a) - a)).length + n.length, 3 === (n = dt(n, e)).length && n.push(1), s += r + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                return s + t.substr(a)
            },
            ft = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (c in ht) ft += "|" + c + "\\b";
        ft = new RegExp(ft + ")", "gi"), o.colorStringFilter = function(t) {
            var e, i = t[0] + " " + t[1];
            ft.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = pt(t[0], e), t[1] = pt(t[1], e)), ft.lastIndex = 0
        }, n.f.defaultStringFilter || (n.f.defaultStringFilter = o.colorStringFilter);
        var mt = function(t, e, i, n) {
                if (null == t) return function(t) {
                    return t
                };
                var r, o = e ? (t.match(ft) || [""])[0] : "",
                    a = t.split(o).join("").match(_) || [],
                    s = t.substr(0, t.indexOf(a[0])),
                    c = ")" === t.charAt(t.length - 1) ? ")" : "",
                    l = -1 !== t.indexOf(" ") ? " " : ",",
                    h = a.length,
                    u = h > 0 ? a[0].replace(v, "") : "";
                return h ? r = e ? function(t) {
                    var e, d, p, f;
                    if ("number" == typeof t) t += u;
                    else if (n && I.test(t)) {
                        for (f = t.replace(I, "|").split("|"), p = 0; p < f.length; p++) f[p] = r(f[p]);
                        return f.join(",")
                    }
                    if (e = (t.match(ft) || [o])[0], p = (d = t.split(e).join("").match(_) || []).length, h > p--)
                        for (; ++p < h;) d[p] = i ? d[(p - 1) / 2 | 0] : a[p];
                    return s + d.join(l) + l + e + c + (-1 !== t.indexOf("inset") ? " inset" : "")
                } : function(t) {
                    var e, o, d;
                    if ("number" == typeof t) t += u;
                    else if (n && I.test(t)) {
                        for (o = t.replace(I, "|").split("|"), d = 0; d < o.length; d++) o[d] = r(o[d]);
                        return o.join(",")
                    }
                    if (d = (e = t.match(_) || []).length, h > d--)
                        for (; ++d < h;) e[d] = i ? e[(d - 1) / 2 | 0] : a[d];
                    return s + e.join(l) + c
                } : function(t) {
                    return t
                }
            },
            gt = function(t) {
                return t = t.split(","),
                    function(e, i, n, r, o, a, s) {
                        var c, l = (i + "").split(" ");
                        for (s = {}, c = 0; c < 4; c++) s[t[c]] = l[c] = l[c] || l[(c - 1) / 2 >> 0];
                        return r.parse(e, s, o, a)
                    }
            },
            vt = (V._setPluginRatio = function(t) {
                this.plugin.setRatio(t);
                for (var e, i, n, r, o, a = this.data, s = a.proxy, c = a.firstMPT; c;) e = s[c.v], c.r ? e = c.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), c.t[c.p] = e, c = c._next;
                if (a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === t || 0 === t)
                    for (c = a.firstMPT, o = 1 === t ? "e" : "b"; c;) {
                        if ((i = c.t).type) {
                            if (1 === i.type) {
                                for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                i[o] = r
                            }
                        } else i[o] = i.s + i.xs0;
                        c = c._next
                    }
            }, function(t, e, i, n, r) {
                this.t = t, this.p = e, this.v = i, this.r = r, n && (n._prev = this, this._next = n)
            }),
            yt = (V._parseToProxy = function(t, e, i, n, r, o) {
                var a, s, c, l, h, u = n,
                    d = {},
                    p = {},
                    f = i._transform,
                    m = B;
                for (i._transform = null, B = e, n = h = i.parse(t, e, n, r), B = m, o && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) {
                    if (n.type <= 1 && (p[s = n.p] = n.s + n.c, d[s] = n.s, o || (l = new vt(n, "s", s, l, n.r), n.c = 0), 1 === n.type))
                        for (a = n.l; --a > 0;) c = "xn" + a, p[s = n.p + "_" + c] = n.data[c], d[s] = n[c], o || (l = new vt(n, c, s, l, n.rxp[c]));
                    n = n._next
                }
                return {
                    proxy: d,
                    end: p,
                    firstMPT: l,
                    pt: h
                }
            }, V.CSSPropTween = function(e, i, n, o, a, s, c, l, h, u, d) {
                this.t = e, this.p = i, this.s = n, this.c = o, this.n = c || i, e instanceof yt || r.push(this.n), this.r = l ? "function" == typeof l ? l : Math.round : l, this.type = s || 0, h && (this.pr = h, t = !0), this.b = void 0 === u ? n : u, this.e = void 0 === d ? n + o : d, a && (this._next = a, a._prev = this)
            }),
            _t = function(t, e, i, n, r, o) {
                var a = new yt(t, e, i, n - i, r, -1, o);
                return a.b = i, a.e = a.xs0 = n, a
            },
            xt = o.parseComplex = function(t, e, i, n, r, a, s, c, h, u) {
                i = i || a || "", "function" == typeof n && (n = n(g, m)), s = new yt(t, e, 0, 0, s, u ? 2 : 1, null, !1, c, i, n), n += "", r && ft.test(n + i) && (n = [i, n], o.colorStringFilter(n), i = n[0], n = n[1]);
                var d, p, f, _, x, b, w, M, T, E, S, A, P, L = i.split(", ").join(",").split(" "),
                    C = n.split(", ").join(",").split(" "),
                    R = L.length,
                    O = !1 !== l;
                for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (-1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (L = L.join(" ").replace(I, ", ").split(" "), C = C.join(" ").replace(I, ", ").split(" ")) : (L = L.join(" ").split(",").join(", ").split(" "), C = C.join(" ").split(",").join(", ").split(" ")), R = L.length), R !== C.length && (R = (L = (a || "").split(" ")).length), s.plugin = h, s.setRatio = u, ft.lastIndex = 0, d = 0; d < R; d++)
                    if (_ = L[d], x = C[d] + "", (M = parseFloat(_)) || 0 === M) s.appendXtra("", M, st(x, M), x.replace(y, ""), !(!O || -1 === x.indexOf("px")) && Math.round, !0);
                    else if (r && ft.test(_)) A = ")" + ((A = x.indexOf(")") + 1) ? x.substr(A) : ""), P = -1 !== x.indexOf("hsl") && W, E = x, _ = dt(_, P), x = dt(x, P), (T = _.length + x.length > 6) && !W && 0 === x[3] ? (s["xs" + s.l] += s.l ? " transparent" : "transparent", s.e = s.e.split(C[d]).join("transparent")) : (W || (T = !1), P ? s.appendXtra(E.substr(0, E.indexOf("hsl")) + (T ? "hsla(" : "hsl("), _[0], st(x[0], _[0]), ",", !1, !0).appendXtra("", _[1], st(x[1], _[1]), "%,", !1).appendXtra("", _[2], st(x[2], _[2]), T ? "%," : "%" + A, !1) : s.appendXtra(E.substr(0, E.indexOf("rgb")) + (T ? "rgba(" : "rgb("), _[0], x[0] - _[0], ",", Math.round, !0).appendXtra("", _[1], x[1] - _[1], ",", Math.round).appendXtra("", _[2], x[2] - _[2], T ? "," : A, Math.round), T && (_ = _.length < 4 ? 1 : _[3], s.appendXtra("", _, (x.length < 4 ? 1 : x[3]) - _, A, !1))), ft.lastIndex = 0;
                else if (b = _.match(v)) {
                    if (!(w = x.match(y)) || w.length !== b.length) return s;
                    for (f = 0, p = 0; p < b.length; p++) S = b[p], E = _.indexOf(S, f), s.appendXtra(_.substr(f, E - f), Number(S), st(w[p], S), "", !(!O || "px" !== _.substr(E + S.length, 2)) && Math.round, 0 === p), f = E + S.length;
                    s["xs" + s.l] += _.substr(f)
                } else s["xs" + s.l] += s.l || s["xs" + s.l] ? " " + x : x;
                if (-1 !== n.indexOf("=") && s.data) {
                    for (A = s.xs0 + s.data.s, d = 1; d < s.l; d++) A += s["xs" + d] + s.data["xn" + d];
                    s.e = A + s["xs" + d]
                }
                return s.l || (s.type = -1, s.xs0 = s.e), s.xfirst || s
            },
            bt = 9;
        for ((c = yt.prototype).l = c.pr = 0; --bt > 0;) c["xn" + bt] = 0, c["xs" + bt] = "";
        c.xs0 = "", c._next = c._prev = c.xfirst = c.data = c.plugin = c.setRatio = c.rxp = null, c.appendXtra = function(t, e, i, n, r, o) {
            var a = this,
                s = a.l;
            return a["xs" + s] += o && (s || a["xs" + s]) ? " " + t : t || "", i || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = n || "", s > 0 ? (a.data["xn" + s] = e + i, a.rxp["xn" + s] = r, a["xn" + s] = e, a.plugin || (a.xfirst = new yt(a, "xn" + s, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                s: e + i
            }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + s] += e + (n || ""), a)
        };
        var wt = function(t, e) {
                e = e || {}, this.p = e.prefix && J(t) || t, s[t] = s[this.p] = this, this.format = e.formatter || mt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
            },
            Mt = V._registerComplexSpecialProp = function(t, e, i) {
                "object" != typeof e && (e = {
                    parser: i
                });
                var n, r = t.split(","),
                    o = e.defaultValue;
                for (i = i || [o], n = 0; n < r.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || o, new wt(r[n], e)
            },
            Tt = V._registerPluginProp = function(t) {
                if (!s[t]) {
                    var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                    Mt(t, {
                        parser: function(t, i, n, r, o, c, l) {
                            var h = a.com.greensock.plugins[e];
                            return h ? (h._cssRegister(), s[n].parse(t, i, n, r, o, c, l)) : (q("Error: " + e + " js file not loaded."), o)
                        }
                    })
                }
            };
        (c = wt.prototype).parseComplex = function(t, e, i, n, r, o) {
            var a, s, c, l, h, u, d = this.keyword;
            if (this.multi && (I.test(i) || I.test(e) ? (s = e.replace(I, "|").split("|"), c = i.replace(I, "|").split("|")) : d && (s = [e], c = [i])), c) {
                for (l = c.length > s.length ? c.length : s.length, a = 0; a < l; a++) e = s[a] = s[a] || this.dflt, i = c[a] = c[a] || this.dflt, d && (h = e.indexOf(d)) !== (u = i.indexOf(d)) && (-1 === u ? s[a] = s[a].split(d).join("") : -1 === h && (s[a] += " " + d));
                e = s.join(", "), i = c.join(", ")
            }
            return xt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, o)
        }, c.parse = function(t, e, n, r, o, a, s) {
            return this.parseComplex(t.style, this.format(Q(t, this.p, i, !1, this.dflt)), this.format(e), o, a)
        }, o.registerSpecialProp = function(t, e, i) {
            Mt(t, {
                parser: function(t, n, r, o, a, s, c) {
                    var l = new yt(t, r, 0, 0, a, 2, r, !1, i);
                    return l.plugin = s, l.setRatio = e(t, n, o._tween, r), l
                },
                priority: i
            })
        }, o.useSVGTransformAttr = !0;
        var Et, St = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
            At = J("transform"),
            Pt = Y + "transform",
            Lt = J("transformOrigin"),
            Ct = null !== J("perspective"),
            Rt = V.Transform = function() {
                this.perspective = parseFloat(o.defaultTransformPerspective) || 0, this.force3D = !(!1 === o.defaultForce3D || !Ct) && (o.defaultForce3D || "auto")
            },
            Ot = n.e.SVGElement,
            It = function(t, e, i) {
                var n, r = z.createElementNS("http://www.w3.org/2000/svg", t),
                    o = /([a-z])([A-Z])/g;
                for (n in i) r.setAttributeNS(null, n.replace(o, "$1-$2").toLowerCase(), i[n]);
                return e.appendChild(r), r
            },
            Dt = z.documentElement || {},
            kt = function() {
                var t, e, i, r = f || /Android/i.test(j) && !n.e.chrome;
                return z.createElementNS && !r && (t = It("svg", Dt), i = (e = It("rect", t, {
                    width: 100,
                    height: 50,
                    x: 100
                })).getBoundingClientRect().width, e.style[Lt] = "50% 50%", e.style[At] = "scaleX(0.5)", r = i === e.getBoundingClientRect().width && !(d && Ct), Dt.removeChild(t)), r
            }(),
            Nt = function(t, e, i, n, r, a) {
                var s, c, l, h, u, d, p, f, m, g, v, y, _, x, b = t._gsTransform,
                    w = Ut(t, !0);
                b && (_ = b.xOrigin, x = b.yOrigin), (!n || (s = n.split(" ")).length < 2) && (0 === (p = t.getBBox()).x && 0 === p.y && p.width + p.height === 0 && (p = {
                    x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                    y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                    width: 0,
                    height: 0
                }), s = [(-1 !== (e = at(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * p.width : parseFloat(e[0])) + p.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * p.height : parseFloat(e[1])) + p.y]), i.xOrigin = h = parseFloat(s[0]), i.yOrigin = u = parseFloat(s[1]), n && w !== zt && (d = w[0], p = w[1], f = w[2], m = w[3], g = w[4], v = w[5], (y = d * m - p * f) && (c = h * (m / y) + u * (-f / y) + (f * v - m * g) / y, l = h * (-p / y) + u * (d / y) - (d * v - p * g) / y, h = i.xOrigin = s[0] = c, u = i.yOrigin = s[1] = l)), b && (a && (i.xOffset = b.xOffset, i.yOffset = b.yOffset, b = i), r || !1 !== r && !1 !== o.defaultSmoothOrigin ? (c = h - _, l = u - x, b.xOffset += c * w[0] + l * w[2] - c, b.yOffset += c * w[1] + l * w[3] - l) : b.xOffset = b.yOffset = 0), a || t.setAttribute("data-svg-origin", s.join(" "))
            },
            Bt = function(t) {
                var e, i = U("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    n = this.parentNode,
                    r = this.nextSibling,
                    o = this.style.cssText;
                if (Dt.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                    e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Bt
                } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox());
                return r ? n.insertBefore(this, r) : n.appendChild(this), Dt.removeChild(i), this.style.cssText = o, e
            },
            Ft = function(t) {
                return !(!Ot || !t.getCTM || t.parentNode && !t.ownerSVGElement || ! function(t) {
                    try {
                        return t.getBBox()
                    } catch (e) {
                        return Bt.call(t, !0)
                    }
                }(t))
            },
            zt = [1, 0, 0, 1, 0, 0],
            Ut = function(t, e) {
                var i, n, r, o, a, s, c = t._gsTransform || new Rt,
                    l = t.style;
                if (At ? n = Q(t, Pt, null, !0) : t.currentStyle && (n = (n = t.currentStyle.filter.match(R)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), c.x || 0, c.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, !At || !(s = !K(t) || "none" === K(t).display) && t.parentNode || (s && (o = l.display, l.display = "block"), t.parentNode || (a = 1, Dt.appendChild(t)), i = !(n = Q(t, Pt, null, !0)) || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, o ? l.display = o : s && Wt(l, "display"), a && Dt.removeChild(t)), (c.svg || t.getCTM && Ft(t)) && (i && -1 !== (l[At] + "").indexOf("matrix") && (n = l[At], i = 0), r = t.getAttribute("transform"), i && r && (n = "matrix(" + (r = t.transform.baseVal.consolidate().matrix).a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", i = 0)), i) return zt;
                for (r = (n || "").match(v) || [], bt = r.length; --bt > -1;) o = Number(r[bt]), r[bt] = (a = o - (o |= 0)) ? (1e5 * a + (a < 0 ? -.5 : .5) | 0) / 1e5 + o : o;
                return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
            },
            Gt = V.getTransform = function(t, e, i, r) {
                if (t._gsTransform && i && !r) return t._gsTransform;
                var a, s, c, l, h, u, d = i && t._gsTransform || new Rt,
                    p = d.scaleX < 0,
                    f = Ct && (parseFloat(Q(t, Lt, e, !1, "0 0 0").split(" ")[2]) || d.zOrigin) || 0,
                    m = parseFloat(o.defaultTransformPerspective) || 0;
                if (d.svg = !(!t.getCTM || !Ft(t)), d.svg && (Nt(t, Q(t, Lt, e, !1, "50% 50%") + "", d, t.getAttribute("data-svg-origin")), Et = o.useSVGTransformAttr || kt), (a = Ut(t)) !== zt) {
                    if (16 === a.length) {
                        var g, v, y, _, x, b = a[0],
                            w = a[1],
                            M = a[2],
                            T = a[3],
                            E = a[4],
                            S = a[5],
                            A = a[6],
                            P = a[7],
                            L = a[8],
                            C = a[9],
                            R = a[10],
                            O = a[12],
                            I = a[13],
                            D = a[14],
                            k = a[11],
                            B = Math.atan2(A, R);
                        d.zOrigin && (O = L * (D = -d.zOrigin) - a[12], I = C * D - a[13], D = R * D + d.zOrigin - a[14]), d.rotationX = B * N, B && (g = E * (_ = Math.cos(-B)) + L * (x = Math.sin(-B)), v = S * _ + C * x, y = A * _ + R * x, L = E * -x + L * _, C = S * -x + C * _, R = A * -x + R * _, k = P * -x + k * _, E = g, S = v, A = y), B = Math.atan2(-M, R), d.rotationY = B * N, B && (v = w * (_ = Math.cos(-B)) - C * (x = Math.sin(-B)), y = M * _ - R * x, C = w * x + C * _, R = M * x + R * _, k = T * x + k * _, b = g = b * _ - L * x, w = v, M = y), B = Math.atan2(w, b), d.rotation = B * N, B && (g = b * (_ = Math.cos(B)) + w * (x = Math.sin(B)), v = E * _ + S * x, y = L * _ + C * x, w = w * _ - b * x, S = S * _ - E * x, C = C * _ - L * x, b = g, E = v, L = y), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), B = Math.atan2(E, S), d.scaleX = (1e5 * Math.sqrt(b * b + w * w + M * M) + .5 | 0) / 1e5, d.scaleY = (1e5 * Math.sqrt(S * S + A * A) + .5 | 0) / 1e5, d.scaleZ = (1e5 * Math.sqrt(L * L + C * C + R * R) + .5 | 0) / 1e5, b /= d.scaleX, E /= d.scaleY, w /= d.scaleX, S /= d.scaleY, Math.abs(B) > 2e-5 ? (d.skewX = B * N, E = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(B))) : d.skewX = 0, d.perspective = k ? 1 / (k < 0 ? -k : k) : 0, d.x = O, d.y = I, d.z = D, d.svg && (d.x -= d.xOrigin - (d.xOrigin * b - d.yOrigin * E), d.y -= d.yOrigin - (d.yOrigin * w - d.xOrigin * S))
                    } else if (!Ct || r || !a.length || d.x !== a[4] || d.y !== a[5] || !d.rotationX && !d.rotationY) {
                        var F = a.length >= 6,
                            z = F ? a[0] : 1,
                            U = a[1] || 0,
                            G = a[2] || 0,
                            H = F ? a[3] : 1;
                        d.x = a[4] || 0, d.y = a[5] || 0, c = Math.sqrt(z * z + U * U), l = Math.sqrt(H * H + G * G), h = z || U ? Math.atan2(U, z) * N : d.rotation || 0, u = G || H ? Math.atan2(G, H) * N + h : d.skewX || 0, d.scaleX = c, d.scaleY = l, d.rotation = h, d.skewX = u, Ct && (d.rotationX = d.rotationY = d.z = 0, d.perspective = m, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * z + d.yOrigin * G), d.y -= d.yOrigin - (d.xOrigin * U + d.yOrigin * H))
                    }
                    for (s in Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (p ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = f, d) d[s] < 2e-5 && d[s] > -2e-5 && (d[s] = 0)
                }
                return i && (t._gsTransform = d, d.svg && (Et && t.style[At] ? n.f.delayedCall(.001, function() {
                    Wt(t.style, At)
                }) : !Et && t.getAttribute("transform") && n.f.delayedCall(.001, function() {
                    t.removeAttribute("transform")
                }))), d
            },
            Ht = function(t) {
                var e, i, n = this.data,
                    r = -n.rotation * k,
                    o = r + n.skewX * k,
                    a = (Math.cos(r) * n.scaleX * 1e5 | 0) / 1e5,
                    s = (Math.sin(r) * n.scaleX * 1e5 | 0) / 1e5,
                    c = (Math.sin(o) * -n.scaleY * 1e5 | 0) / 1e5,
                    l = (Math.cos(o) * n.scaleY * 1e5 | 0) / 1e5,
                    h = this.t.style,
                    u = this.t.currentStyle;
                if (u) {
                    i = s, s = -c, c = -i, e = u.filter, h.filter = "";
                    var d, p, m = this.t.offsetWidth,
                        g = this.t.offsetHeight,
                        v = "absolute" !== u.position,
                        y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + s + ", M21=" + c + ", M22=" + l,
                        _ = n.x + m * n.xPercent / 100,
                        x = n.y + g * n.yPercent / 100;
                    if (null != n.ox && (_ += (d = (n.oxp ? m * n.ox * .01 : n.ox) - m / 2) - (d * a + (p = (n.oyp ? g * n.oy * .01 : n.oy) - g / 2) * s), x += p - (d * c + p * l)), y += v ? ", Dx=" + ((d = m / 2) - (d * a + (p = g / 2) * s) + _) + ", Dy=" + (p - (d * c + p * l) + x) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? h.filter = e.replace(O, y) : h.filter = y + " " + e, 0 !== t && 1 !== t || 1 === a && 0 === s && 0 === c && 1 === l && (v && -1 === y.indexOf("Dx=0, Dy=0") || w.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && h.removeAttribute("filter")), !v) {
                        var M, T, E, S = f < 8 ? 1 : -1;
                        for (d = n.ieOffsetX || 0, p = n.ieOffsetY || 0, n.ieOffsetX = Math.round((m - ((a < 0 ? -a : a) * m + (s < 0 ? -s : s) * g)) / 2 + _), n.ieOffsetY = Math.round((g - ((l < 0 ? -l : l) * g + (c < 0 ? -c : c) * m)) / 2 + x), bt = 0; bt < 4; bt++) E = (i = -1 !== (M = u[T = rt[bt]]).indexOf("px") ? parseFloat(M) : $(this.t, T, parseFloat(M), M.replace(b, "")) || 0) !== n[T] ? bt < 2 ? -n.ieOffsetX : -n.ieOffsetY : bt < 2 ? d - n.ieOffsetX : p - n.ieOffsetY, h[T] = (n[T] = Math.round(i - E * (0 === bt || 2 === bt ? 1 : S))) + "px"
                    }
                }
            },
            Vt = V.set3DTransformRatio = V.setTransformRatio = function(t) {
                var e, i, n, r, o, a, s, c, l, h, u, p, f, m, g, v, y, _, x, b, w, M = this.data,
                    T = this.t.style,
                    E = M.rotation,
                    S = M.rotationX,
                    A = M.rotationY,
                    P = M.scaleX,
                    L = M.scaleY,
                    C = M.scaleZ,
                    R = M.x,
                    O = M.y,
                    I = M.z,
                    D = M.svg,
                    N = M.perspective,
                    B = M.force3D,
                    F = M.skewY,
                    z = M.skewX;
                if (F && (z += F, E += F), !((1 !== t && 0 !== t || "auto" !== B || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && B || I || N || A || S || 1 !== C) || Et && D || !Ct) E || z || D ? (E *= k, b = z * k, w = 1e5, i = Math.cos(E) * P, o = Math.sin(E) * P, n = Math.sin(E - b) * -L, a = Math.cos(E - b) * L, b && "simple" === M.skewType && (e = Math.tan(b - F * k), n *= e = Math.sqrt(1 + e * e), a *= e, F && (e = Math.tan(F * k), i *= e = Math.sqrt(1 + e * e), o *= e)), D && (R += M.xOrigin - (M.xOrigin * i + M.yOrigin * n) + M.xOffset, O += M.yOrigin - (M.xOrigin * o + M.yOrigin * a) + M.yOffset, Et && (M.xPercent || M.yPercent) && (g = this.t.getBBox(), R += .01 * M.xPercent * g.width, O += .01 * M.yPercent * g.height), R < (g = 1e-6) && R > -g && (R = 0), O < g && O > -g && (O = 0)), x = (i * w | 0) / w + "," + (o * w | 0) / w + "," + (n * w | 0) / w + "," + (a * w | 0) / w + "," + R + "," + O + ")", D && Et ? this.t.setAttribute("transform", "matrix(" + x) : T[At] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + x) : T[At] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + P + ",0,0," + L + "," + R + "," + O + ")";
                else {
                    if (d && (P < (g = 1e-4) && P > -g && (P = C = 2e-5), L < g && L > -g && (L = C = 2e-5), !N || M.z || M.rotationX || M.rotationY || (N = 0)), E || z) E *= k, v = i = Math.cos(E), y = o = Math.sin(E), z && (E -= z * k, v = Math.cos(E), y = Math.sin(E), "simple" === M.skewType && (e = Math.tan((z - F) * k), v *= e = Math.sqrt(1 + e * e), y *= e, M.skewY && (e = Math.tan(F * k), i *= e = Math.sqrt(1 + e * e), o *= e))), n = -y, a = v;
                    else {
                        if (!(A || S || 1 !== C || N || D)) return void(T[At] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) translate3d(" : "translate3d(") + R + "px," + O + "px," + I + "px)" + (1 !== P || 1 !== L ? " scale(" + P + "," + L + ")" : ""));
                        i = a = 1, n = o = 0
                    }
                    h = 1, r = s = c = l = u = p = 0, f = N ? -1 / N : 0, m = M.zOrigin, g = 1e-6, ",", "0", (E = A * k) && (v = Math.cos(E), c = -(y = Math.sin(E)), u = f * -y, r = i * y, s = o * y, h = v, f *= v, i *= v, o *= v), (E = S * k) && (e = n * (v = Math.cos(E)) + r * (y = Math.sin(E)), _ = a * v + s * y, l = h * y, p = f * y, r = n * -y + r * v, s = a * -y + s * v, h *= v, f *= v, n = e, a = _), 1 !== C && (r *= C, s *= C, h *= C, f *= C), 1 !== L && (n *= L, a *= L, l *= L, p *= L), 1 !== P && (i *= P, o *= P, c *= P, u *= P), (m || D) && (m && (R += r * -m, O += s * -m, I += h * -m + m), D && (R += M.xOrigin - (M.xOrigin * i + M.yOrigin * n) + M.xOffset, O += M.yOrigin - (M.xOrigin * o + M.yOrigin * a) + M.yOffset), R < g && R > -g && (R = "0"), O < g && O > -g && (O = "0"), I < g && I > -g && (I = 0)), x = M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix3d(" : "matrix3d(", x += (i < g && i > -g ? "0" : i) + "," + (o < g && o > -g ? "0" : o) + "," + (c < g && c > -g ? "0" : c), x += "," + (u < g && u > -g ? "0" : u) + "," + (n < g && n > -g ? "0" : n) + "," + (a < g && a > -g ? "0" : a), S || A || 1 !== C ? (x += "," + (l < g && l > -g ? "0" : l) + "," + (p < g && p > -g ? "0" : p) + "," + (r < g && r > -g ? "0" : r), x += "," + (s < g && s > -g ? "0" : s) + "," + (h < g && h > -g ? "0" : h) + "," + (f < g && f > -g ? "0" : f) + ",") : x += ",0,0,0,0,1,0,", x += R + "," + O + "," + I + "," + (N ? 1 + -I / N : 1) + ")", T[At] = x
                }
            };
        (c = Rt.prototype).x = c.y = c.z = c.skewX = c.skewY = c.rotation = c.rotationX = c.rotationY = c.zOrigin = c.xPercent = c.yPercent = c.xOffset = c.yOffset = 0, c.scaleX = c.scaleY = c.scaleZ = 1, Mt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
            parser: function(t, e, n, r, a, s, c) {
                if (r._lastParsedTransform === c) return a;
                r._lastParsedTransform = c;
                var l, h = c.scale && "function" == typeof c.scale ? c.scale : 0;
                "function" == typeof c[n] && (l = c[n], c[n] = e), h && (c.scale = h(g, t));
                var u, d, p, f, v, y, _, x, b, w = t._gsTransform,
                    M = t.style,
                    T = St.length,
                    E = c,
                    S = {},
                    A = Gt(t, i, !0, E.parseTransform),
                    P = E.transform && ("function" == typeof E.transform ? E.transform(g, m) : E.transform);
                if (A.skewType = E.skewType || A.skewType || o.defaultSkewType, r._transform = A, "rotationZ" in E && (E.rotation = E.rotationZ), P && "string" == typeof P && At)(d = G.style)[At] = P, d.display = "block", d.position = "absolute", -1 !== P.indexOf("%") && (d.width = Q(t, "width"), d.height = Q(t, "height")), z.body.appendChild(G), u = Gt(G, null, !1), "simple" === A.skewType && (u.scaleY *= Math.cos(u.skewX * k)), A.svg && (y = A.xOrigin, _ = A.yOrigin, u.x -= A.xOffset, u.y -= A.yOffset, (E.transformOrigin || E.svgOrigin) && (P = {}, Nt(t, at(E.transformOrigin), P, E.svgOrigin, E.smoothOrigin, !0), y = P.xOrigin, _ = P.yOrigin, u.x -= P.xOffset - A.xOffset, u.y -= P.yOffset - A.yOffset), (y || _) && (x = Ut(G, !0), u.x -= y - (y * x[0] + _ * x[2]), u.y -= _ - (y * x[1] + _ * x[3]))), z.body.removeChild(G), u.perspective || (u.perspective = A.perspective), null != E.xPercent && (u.xPercent = ct(E.xPercent, A.xPercent)), null != E.yPercent && (u.yPercent = ct(E.yPercent, A.yPercent));
                else if ("object" == typeof E) {
                    if (u = {
                            scaleX: ct(null != E.scaleX ? E.scaleX : E.scale, A.scaleX),
                            scaleY: ct(null != E.scaleY ? E.scaleY : E.scale, A.scaleY),
                            scaleZ: ct(E.scaleZ, A.scaleZ),
                            x: ct(E.x, A.x),
                            y: ct(E.y, A.y),
                            z: ct(E.z, A.z),
                            xPercent: ct(E.xPercent, A.xPercent),
                            yPercent: ct(E.yPercent, A.yPercent),
                            perspective: ct(E.transformPerspective, A.perspective)
                        }, null != (v = E.directionalRotation))
                        if ("object" == typeof v)
                            for (d in v) E[d] = v[d];
                        else E.rotation = v;
                    "string" == typeof E.x && -1 !== E.x.indexOf("%") && (u.x = 0, u.xPercent = ct(E.x, A.xPercent)), "string" == typeof E.y && -1 !== E.y.indexOf("%") && (u.y = 0, u.yPercent = ct(E.y, A.yPercent)), u.rotation = lt("rotation" in E ? E.rotation : "shortRotation" in E ? E.shortRotation + "_short" : A.rotation, A.rotation, "rotation", S), Ct && (u.rotationX = lt("rotationX" in E ? E.rotationX : "shortRotationX" in E ? E.shortRotationX + "_short" : A.rotationX || 0, A.rotationX, "rotationX", S), u.rotationY = lt("rotationY" in E ? E.rotationY : "shortRotationY" in E ? E.shortRotationY + "_short" : A.rotationY || 0, A.rotationY, "rotationY", S)), u.skewX = lt(E.skewX, A.skewX), u.skewY = lt(E.skewY, A.skewY)
                }
                for (Ct && null != E.force3D && (A.force3D = E.force3D, f = !0), (p = A.force3D || A.z || A.rotationX || A.rotationY || u.z || u.rotationX || u.rotationY || u.perspective) || null == E.scale || (u.scaleZ = 1); --T > -1;)((P = u[b = St[T]] - A[b]) > 1e-6 || P < -1e-6 || null != E[b] || null != B[b]) && (f = !0, a = new yt(A, b, A[b], P, a), b in S && (a.e = S[b]), a.xs0 = 0, a.plugin = s, r._overwriteProps.push(a.n));
                return P = E.transformOrigin, A.svg && (P || E.svgOrigin) && (y = A.xOffset, _ = A.yOffset, Nt(t, at(P), u, E.svgOrigin, E.smoothOrigin), a = _t(A, "xOrigin", (w ? A : u).xOrigin, u.xOrigin, a, "transformOrigin"), a = _t(A, "yOrigin", (w ? A : u).yOrigin, u.yOrigin, a, "transformOrigin"), y === A.xOffset && _ === A.yOffset || (a = _t(A, "xOffset", w ? y : A.xOffset, A.xOffset, a, "transformOrigin"), a = _t(A, "yOffset", w ? _ : A.yOffset, A.yOffset, a, "transformOrigin")), P = "0px 0px"), (P || Ct && p && A.zOrigin) && (At ? (f = !0, b = Lt, P = (P || Q(t, b, i, !1, "50% 50%")) + "", (a = new yt(M, b, 0, 0, a, -1, "transformOrigin")).b = M[b], a.plugin = s, Ct ? (d = A.zOrigin, P = P.split(" "), A.zOrigin = (P.length > 2 && (0 === d || "0px" !== P[2]) ? parseFloat(P[2]) : d) || 0, a.xs0 = a.e = P[0] + " " + (P[1] || "50%") + " 0px", (a = new yt(A, "zOrigin", 0, 0, a, -1, a.n)).b = d, a.xs0 = a.e = A.zOrigin) : a.xs0 = a.e = P) : at(P + "", A)), f && (r._transformType = A.svg && Et || !p && 3 !== this._transformType ? 2 : 3), l && (c[n] = l), h && (c.scale = h), a
            },
            prefix: !0
        }), Mt("boxShadow", {
            defaultValue: "0px 0px 0px 0px #999",
            prefix: !0,
            color: !0,
            multi: !0,
            keyword: "inset"
        }), Mt("borderRadius", {
            defaultValue: "0px",
            parser: function(t, n, r, o, a, s) {
                n = this.format(n);
                var c, l, h, u, d, p, f, m, g, v, y, _, x, b, w, M, T = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                    E = t.style;
                for (g = parseFloat(t.offsetWidth), v = parseFloat(t.offsetHeight), c = n.split(" "), l = 0; l < T.length; l++) this.p.indexOf("border") && (T[l] = J(T[l])), -1 !== (d = u = Q(t, T[l], i, !1, "0px")).indexOf(" ") && (d = (u = d.split(" "))[0], u = u[1]), p = h = c[l], f = parseFloat(d), _ = d.substr((f + "").length), (x = "=" === p.charAt(1)) ? (m = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), m *= parseFloat(p), y = p.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(p), y = p.substr((m + "").length)), "" === y && (y = e[r] || _), y !== _ && (b = $(t, "borderLeft", f, _), w = $(t, "borderTop", f, _), "%" === y ? (d = b / g * 100 + "%", u = w / v * 100 + "%") : "em" === y ? (d = b / (M = $(t, "borderLeft", 1, "em")) + "em", u = w / M + "em") : (d = b + "px", u = w + "px"), x && (p = parseFloat(d) + m + y, h = parseFloat(u) + m + y)), a = xt(E, T[l], d + " " + u, p + " " + h, !1, "0px", a);
                return a
            },
            prefix: !0,
            formatter: mt("0px 0px 0px 0px", !1, !0)
        }), Mt("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
            defaultValue: "0px",
            parser: function(t, e, n, r, o, a) {
                return xt(t.style, n, this.format(Q(t, n, i, !1, "0px 0px")), this.format(e), !1, "0px", o)
            },
            prefix: !0,
            formatter: mt("0px 0px", !1, !0)
        }), Mt("backgroundPosition", {
            defaultValue: "0 0",
            parser: function(t, e, n, r, o, a) {
                var s, c, l, h, u, d, p = "background-position",
                    m = i || K(t, null),
                    g = this.format((m ? f ? m.getPropertyValue(p + "-x") + " " + m.getPropertyValue(p + "-y") : m.getPropertyValue(p) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                    v = this.format(e);
                if (-1 !== g.indexOf("%") != (-1 !== v.indexOf("%")) && v.split(",").length < 2 && (d = Q(t, "backgroundImage").replace(P, "")) && "none" !== d) {
                    for (s = g.split(" "), c = v.split(" "), H.setAttribute("src", d), l = 2; --l > -1;)(h = -1 !== (g = s[l]).indexOf("%")) !== (-1 !== c[l].indexOf("%")) && (u = 0 === l ? t.offsetWidth - H.width : t.offsetHeight - H.height, s[l] = h ? parseFloat(g) / 100 * u + "px" : parseFloat(g) / u * 100 + "%");
                    g = s.join(" ")
                }
                return this.parseComplex(t.style, g, v, o, a)
            },
            formatter: at
        }), Mt("backgroundSize", {
            defaultValue: "0 0",
            formatter: function(t) {
                return "co" === (t += "").substr(0, 2) ? t : at(-1 === t.indexOf(" ") ? t + " " + t : t)
            }
        }), Mt("perspective", {
            defaultValue: "0px",
            prefix: !0
        }), Mt("perspectiveOrigin", {
            defaultValue: "50% 50%",
            prefix: !0
        }), Mt("transformStyle", {
            prefix: !0
        }), Mt("backfaceVisibility", {
            prefix: !0
        }), Mt("userSelect", {
            prefix: !0
        }), Mt("margin", {
            parser: gt("marginTop,marginRight,marginBottom,marginLeft")
        }), Mt("padding", {
            parser: gt("paddingTop,paddingRight,paddingBottom,paddingLeft")
        }), Mt("clip", {
            defaultValue: "rect(0px,0px,0px,0px)",
            parser: function(t, e, n, r, o, a) {
                var s, c, l;
                return f < 9 ? (c = t.currentStyle, l = f < 8 ? " " : ",", s = "rect(" + c.clipTop + l + c.clipRight + l + c.clipBottom + l + c.clipLeft + ")", e = this.format(e).split(",").join(l)) : (s = this.format(Q(t, this.p, i, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, s, e, o, a)
            }
        }), Mt("textShadow", {
            defaultValue: "0px 0px 0px #999",
            color: !0,
            multi: !0
        }), Mt("autoRound,strictUnits", {
            parser: function(t, e, i, n, r) {
                return r
            }
        }), Mt("border", {
            defaultValue: "0px solid #000",
            parser: function(t, e, n, r, o, a) {
                var s = Q(t, "borderTopWidth", i, !1, "0px"),
                    c = this.format(e).split(" "),
                    l = c[0].replace(b, "");
                return "px" !== l && (s = parseFloat(s) / $(t, "borderTopWidth", 1, l) + l), this.parseComplex(t.style, this.format(s + " " + Q(t, "borderTopStyle", i, !1, "solid") + " " + Q(t, "borderTopColor", i, !1, "#000")), c.join(" "), o, a)
            },
            color: !0,
            formatter: function(t) {
                var e = t.split(" ");
                return e[0] + " " + (e[1] || "solid") + " " + (t.match(ft) || ["#000"])[0]
            }
        }), Mt("borderWidth", {
            parser: gt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
        }), Mt("float,cssFloat,styleFloat", {
            parser: function(t, e, i, n, r, o) {
                var a = t.style,
                    s = "cssFloat" in a ? "cssFloat" : "styleFloat";
                return new yt(a, s, 0, 0, r, -1, i, !1, 0, a[s], e)
            }
        });
        var jt = function(t) {
            var e, i = this.t,
                n = i.filter || Q(this.data, "filter") || "",
                r = this.s + this.c * t | 0;
            100 === r && (-1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), e = !Q(this.data, "filter")) : (i.filter = n.replace(T, ""), e = !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(w, "opacity=" + r))
        };
        Mt("opacity,alpha,autoAlpha", {
            defaultValue: "1",
            parser: function(t, e, n, r, o, a) {
                var s = parseFloat(Q(t, "opacity", i, !1, "1")),
                    c = t.style,
                    l = "autoAlpha" === n;
                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s), l && 1 === s && "hidden" === Q(t, "visibility", i) && 0 !== e && (s = 0), W ? o = new yt(c, "opacity", s, e - s, o) : ((o = new yt(c, "opacity", 100 * s, 100 * (e - s), o)).xn1 = l ? 1 : 0, c.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = t, o.plugin = a, o.setRatio = jt), l && ((o = new yt(c, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", r._overwriteProps.push(o.n), r._overwriteProps.push(n)), o
            }
        });
        var Wt = function(t, e) {
                e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(S, "-$1").toLowerCase())) : t.removeAttribute(e))
            },
            Xt = function(t) {
                if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                    this.t.setAttribute("class", 0 === t ? this.b : this.e);
                    for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Wt(i, e.p), e = e._next;
                    1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
            };
        Mt("className", {
            parser: function(e, n, r, o, a, s, c) {
                var l, h, u, d, p, f = e.getAttribute("class") || "",
                    m = e.style.cssText;
                if ((a = o._classNamePT = new yt(e, r, 0, 0, a, 2)).setRatio = Xt, a.pr = -11, t = !0, a.b = f, h = et(e, i), u = e._gsClassPT) {
                    for (d = {}, p = u.data; p;) d[p.p] = 1, p = p._next;
                    u.setRatio(1)
                }
                return e._gsClassPT = a, a.e = "=" !== n.charAt(1) ? n : f.replace(new RegExp("(?:\\s|^)" + n.substr(2) + "(?![\\w-])"), "") + ("+" === n.charAt(0) ? " " + n.substr(2) : ""), e.setAttribute("class", a.e), l = it(e, h, et(e), c, d), e.setAttribute("class", f), a.data = l.firstMPT, e.style.cssText = m, a = a.xfirst = o.parse(e, l.difs, a, s)
            }
        });
        var qt = function(t) {
            if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                var e, i, n, r, o, a = this.t.style,
                    c = s.transform.parse;
                if ("all" === this.e) a.cssText = "", r = !0;
                else
                    for (n = (e = this.e.split(" ").join("").split(",")).length; --n > -1;) i = e[n], s[i] && (s[i].parse === c ? r = !0 : i = "transformOrigin" === i ? Lt : s[i].p), Wt(a, i);
                r && (Wt(a, At), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
            }
        };
        for (Mt("clearProps", {
                parser: function(e, i, n, r, o) {
                    return (o = new yt(e, n, 0, 0, o, 2)).setRatio = qt, o.e = i, o.pr = -10, o.data = r._tween, t = !0, o
                }
            }), c = "bezier,throwProps,physicsProps,physics2D".split(","), bt = c.length; bt--;) Tt(c[bt]);
        (c = o.prototype)._firstPT = c._lastParsedTransform = c._transform = null, c._onInitTween = function(n, a, c, d) {
            if (!n.nodeType) return !1;
            this._target = m = n, this._tween = c, this._vars = a, g = d, l = a.autoRound, t = !1, e = a.suffixMap || o.suffixMap, i = K(n, ""), r = this._overwriteProps;
            var f, v, y, _, x, b, w, T, E, S = n.style;
            if (h && "" === S.zIndex && ("auto" !== (f = Q(n, "zIndex", i)) && "" !== f || this._addLazySet(S, "zIndex", 0)), "string" == typeof a && (_ = S.cssText, f = et(n, i), S.cssText = _ + ";" + a, f = it(n, f, et(n)).difs, !W && M.test(a) && (f.opacity = parseFloat(RegExp.$1)), a = f, S.cssText = _), a.className ? this._firstPT = v = s.className.parse(n, a.className, "className", this, null, null, a) : this._firstPT = v = this.parse(n, a, null), this._transformType) {
                for (E = 3 === this._transformType, At ? u && (h = !0, "" === S.zIndex && ("auto" !== (w = Q(n, "zIndex", i)) && "" !== w || this._addLazySet(S, "zIndex", 0)), p && this._addLazySet(S, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (E ? "visible" : "hidden"))) : S.zoom = 1, y = v; y && y._next;) y = y._next;
                T = new yt(n, "transform", 0, 0, null, 2), this._linkCSSP(T, null, y), T.setRatio = At ? Vt : Ht, T.data = this._transform || Gt(n, i, !0), T.tween = c, T.pr = -1, r.pop()
            }
            if (t) {
                for (; v;) {
                    for (b = v._next, y = _; y && y.pr > v.pr;) y = y._next;
                    (v._prev = y ? y._prev : x) ? v._prev._next = v: _ = v, (v._next = y) ? y._prev = v : x = v, v = b
                }
                this._firstPT = _
            }
            return !0
        }, c.parse = function(t, n, r, o) {
            var a, c, h, u, d, p, f, v, y, _, x = t.style;
            for (a in n) {
                if ("function" == typeof(p = n[a]) && (p = p(g, m)), c = s[a]) r = c.parse(t, p, a, this, r, o, n);
                else {
                    if ("--" === a.substr(0, 2)) {
                        this._tween._propLookup[a] = this._addTween.call(this._tween, t.style, "setProperty", K(t).getPropertyValue(a) + "", p + "", a, !1, a);
                        continue
                    }
                    d = Q(t, a, i) + "", y = "string" == typeof p, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || y && E.test(p) ? (y || (p = ((p = dt(p)).length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), r = xt(x, a, d, p, !0, "transparent", r, 0, o)) : y && D.test(p) ? r = xt(x, a, d, p, !0, null, r, 0, o) : (f = (h = parseFloat(d)) || 0 === h ? d.substr((h + "").length) : "", "" !== d && "auto" !== d || ("width" === a || "height" === a ? (h = ot(t, a, i), f = "px") : "left" === a || "top" === a ? (h = tt(t, a, i), f = "px") : (h = "opacity" !== a ? 0 : 1, f = "")), (_ = y && "=" === p.charAt(1)) ? (u = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), u *= parseFloat(p), v = p.replace(b, "")) : (u = parseFloat(p), v = y ? p.replace(b, "") : ""), "" === v && (v = a in e ? e[a] : f), p = u || 0 === u ? (_ ? u + h : u) + v : n[a], f !== v && ("" === v && "lineHeight" !== a || (u || 0 === u) && h && (h = $(t, a, h, f), "%" === v ? (h /= $(t, a, 100, "%") / 100, !0 !== n.strictUnits && (d = h + "%")) : "em" === v || "rem" === v || "vw" === v || "vh" === v ? h /= $(t, a, 1, v) : "px" !== v && (u = $(t, a, u, v), v = "px"), _ && (u || 0 === u) && (p = u + h + v))), _ && (u += h), !h && 0 !== h || !u && 0 !== u ? void 0 !== x[a] && (p || p + "" != "NaN" && null != p) ? (r = new yt(x, a, u || h || 0, 0, r, -1, a, !1, 0, d, p)).xs0 = "none" !== p || "display" !== a && -1 === a.indexOf("Style") ? p : d : q("invalid " + a + " tween value: " + n[a]) : (r = new yt(x, a, h, u - h, r, 0, a, !1 !== l && ("px" === v || "zIndex" === a), 0, d, p)).xs0 = v)
                }
                o && r && !r.plugin && (r.plugin = o)
            }
            return r
        }, c.setRatio = function(t) {
            var e, i, n, r = this._firstPT;
            if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                    for (; r;) {
                        if (e = r.c * t + r.s, r.r ? e = r.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), r.type)
                            if (1 === r.type)
                                if (2 === (n = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                        else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                        else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                        else {
                            for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                            r.t[r.p] = i
                        } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                        else r.t[r.p] = e + r.xs0;
                        r = r._next
                    } else
                        for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                else
                    for (; r;) {
                        if (2 !== r.type)
                            if (r.r && -1 !== r.type)
                                if (e = r.r(r.s + r.c), r.type) {
                                    if (1 === r.type) {
                                        for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                        r.t[r.p] = i
                                    }
                                } else r.t[r.p] = e + r.xs0;
                        else r.t[r.p] = r.e;
                        else r.setRatio(t);
                        r = r._next
                    }
        }, c._enableTransforms = function(t) {
            this._transform = this._transform || Gt(this._target, i, !0), this._transformType = this._transform.svg && Et || !t && 3 !== this._transformType ? 2 : 3
        };
        var Yt = function(t) {
            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
        };
        c._addLazySet = function(t, e, i) {
            var n = this._firstPT = new yt(t, e, 0, 0, this._firstPT, 2);
            n.e = i, n.setRatio = Yt, n.data = this
        }, c._linkCSSP = function(t, e, i, n) {
            return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
        }, c._mod = function(t) {
            for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next
        }, c._kill = function(t) {
            var e, i, r, o = t;
            if (t.autoAlpha || t.alpha) {
                for (i in o = {}, t) o[i] = t[i];
                o.opacity = 1, o.autoAlpha && (o.visibility = 1)
            }
            for (t.className && (e = this._classNamePT) && ((r = e.xfirst) && r._prev ? this._linkCSSP(r._prev, e._next, r._prev._prev) : r === this._firstPT && (this._firstPT = e._next), e._next && this._linkCSSP(e._next, e._next._next, r._prev), this._classNamePT = null), e = this._firstPT; e;) e.plugin && e.plugin !== i && e.plugin._kill && (e.plugin._kill(t), i = e.plugin), e = e._next;
            return n.d.prototype._kill.call(this, o)
        };
        var Zt = function(t, e, i) {
            var n, r, o, a;
            if (t.slice)
                for (r = t.length; --r > -1;) Zt(t[r], e, i);
            else
                for (r = (n = t.childNodes).length; --r > -1;) a = (o = n[r]).type, o.style && (e.push(et(o)), i && i.push(o)), 1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || Zt(o, e, i)
        };
        return o.cascadeTo = function(t, e, i) {
            var r, o, a, s, c = n.f.to(t, e, i),
                l = [c],
                h = [],
                u = [],
                d = [],
                p = n.f._internals.reservedProps;
            for (t = c._targets || c.target, Zt(t, h, d), c.render(e, !0, !0), Zt(t, u), c.render(0, !0, !0), c._enabled(!0), r = d.length; --r > -1;)
                if ((o = it(d[r], h[r], u[r])).firstMPT) {
                    for (a in o = o.difs, i) p[a] && (o[a] = i[a]);
                    for (a in s = {}, o) s[a] = h[r][a];
                    l.push(n.f.fromTo(d[r], e, s, o))
                }
            return l
        }, n.d.activate([o]), o
    }, !0);
    var o = n.g.CSSPlugin,
        a = n.e._gsDefine.plugin({
            propName: "attr",
            API: 2,
            version: "0.6.1",
            init: function(t, e, i, n) {
                var r, o;
                if ("function" != typeof t.setAttribute) return !1;
                for (r in e) "function" == typeof(o = e[r]) && (o = o(n, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", o + "", r, !1, r), this._overwriteProps.push(r);
                return !0
            }
        }),
        s = n.e._gsDefine.plugin({
            propName: "roundProps",
            version: "1.7.0",
            priority: -1,
            API: 2,
            init: function(t, e, i) {
                return this._tween = i, !0
            }
        }),
        c = function(t) {
            var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
            return function(i) {
                return (Math.round(i / t) * t * e | 0) / e
            }
        },
        l = function(t, e) {
            for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next
        },
        h = s.prototype;
    /*!
     * VERSION: 0.6.1
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    h._onInitAllProps = function() {
        var t, e, i, n, r = this._tween,
            o = r.vars.roundProps,
            a = {},
            s = r._propLookup.roundProps;
        if ("object" != typeof o || o.push)
            for ("string" == typeof o && (o = o.split(",")), i = o.length; --i > -1;) a[o[i]] = Math.round;
        else
            for (n in o) a[n] = c(o[n]);
        for (n in a)
            for (t = r._firstPT; t;) e = t._next, t.pg ? t.t._mod(a) : t.n === n && (2 === t.f && t.t ? l(t.t._firstPT, a[n]) : (this._add(t.t, n, t.s, t.c, a[n]), e && (e._prev = t._prev), t._prev ? t._prev._next = e : r._firstPT === t && (r._firstPT = e), t._next = t._prev = null, r._propLookup[n] = s)), t = e;
        return !1
    }, h._add = function(t, e, i, n, r) {
        this._addTween(t, e, i, i + n, e, r || Math.round), this._overwriteProps.push(e)
    };
    /*!
     * VERSION: 0.3.1
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     **/
    var u = n.e._gsDefine.plugin({
        propName: "directionalRotation",
        version: "0.3.1",
        API: 2,
        init: function(t, e, i, n) {
            "object" != typeof e && (e = {
                rotation: e
            }), this.finals = {};
            var r, o, a, s, c, l, h = !0 === e.useRadians ? 2 * Math.PI : 360;
            for (r in e) "useRadians" !== r && ("function" == typeof(s = e[r]) && (s = s(n, t)), o = (l = (s + "").split("_"))[0], a = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), c = (s = this.finals[r] = "string" == typeof o && "=" === o.charAt(1) ? a + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0) - a, l.length && (-1 !== (o = l.join("_")).indexOf("short") && (c %= h) !== c % (h / 2) && (c = c < 0 ? c + h : c - h), -1 !== o.indexOf("_cw") && c < 0 ? c = (c + 9999999999 * h) % h - (c / h | 0) * h : -1 !== o.indexOf("ccw") && c > 0 && (c = (c - 9999999999 * h) % h - (c / h | 0) * h)), (c > 1e-6 || c < -1e-6) && (this._addTween(t, r, a, a + c, r), this._overwriteProps.push(r)));
            return !0
        },
        set: function(t) {
            var e;
            if (1 !== t) this._super.setRatio.call(this, t);
            else
                for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
        }
    });
    u._autoCSS = !0,
        /*!
         * VERSION: 2.0.2
         * DATE: 2018-08-27
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         * 
         * @author: Jack Doyle, jack@greensock.com
         */
        n.e._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function() {
            var t = function(t) {
                    n.c.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                    var e, i, r = this.vars;
                    for (i in r) e = r[i], o(e) && -1 !== e.join("").indexOf("{self}") && (r[i] = this._swapSelfInParams(e));
                    o(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                },
                e = n.f._internals,
                i = t._internals = {},
                r = e.isSelector,
                o = e.isArray,
                a = e.lazyTweens,
                s = e.lazyRender,
                c = n.e._gsDefine.globals,
                l = function(t) {
                    var e, i = {};
                    for (e in t) i[e] = t[e];
                    return i
                },
                h = function(t, e, i) {
                    var n, r, o = t.cycle;
                    for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                    delete t.cycle
                },
                u = i.pauseCallback = function() {},
                d = function(t) {
                    var e, i = [],
                        n = t.length;
                    for (e = 0; e !== n; i.push(t[e++]));
                    return i
                },
                p = t.prototype = new n.c;
            return t.version = "2.0.2", p.constructor = t, p.kill()._gc = p._forcingPlayhead = p._hasPause = !1, p.to = function(t, e, i, r) {
                var o = i.repeat && c.TweenMax || n.f;
                return e ? this.add(new o(t, e, i), r) : this.set(t, i, r)
            }, p.from = function(t, e, i, r) {
                return this.add((i.repeat && c.TweenMax || n.f).from(t, e, i), r)
            }, p.fromTo = function(t, e, i, r, o) {
                var a = r.repeat && c.TweenMax || n.f;
                return e ? this.add(a.fromTo(t, e, i, r), o) : this.set(t, r, o)
            }, p.staggerTo = function(e, i, o, a, s, c, u, p) {
                var f, m, g = new t({
                        onComplete: c,
                        onCompleteParams: u,
                        callbackScope: p,
                        smoothChildTiming: this.smoothChildTiming
                    }),
                    v = o.cycle;
                for ("string" == typeof e && (e = n.f.selector(e) || e), r(e = e || []) && (e = d(e)), (a = a || 0) < 0 && ((e = d(e)).reverse(), a *= -1), m = 0; m < e.length; m++)(f = l(o)).startAt && (f.startAt = l(f.startAt), f.startAt.cycle && h(f.startAt, e, m)), v && (h(f, e, m), null != f.duration && (i = f.duration, delete f.duration)), g.to(e[m], i, f, m * a);
                return this.add(g, s)
            }, p.staggerFrom = function(t, e, i, n, r, o, a, s) {
                return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, r, o, a, s)
            }, p.staggerFromTo = function(t, e, i, n, r, o, a, s, c) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, r, o, a, s, c)
            }, p.call = function(t, e, i, r) {
                return this.add(n.f.delayedCall(0, t, e, i), r)
            }, p.set = function(t, e, i) {
                return i = this._parseTimeOrLabel(i, 0, !0), null == e.immediateRender && (e.immediateRender = i === this._time && !this._paused), this.add(new n.f(t, 0, e), i)
            }, t.exportRoot = function(e, i) {
                null == (e = e || {}).smoothChildTiming && (e.smoothChildTiming = !0);
                var r, o, a, s, c = new t(e),
                    l = c._timeline;
                for (null == i && (i = !0), l._remove(c, !0), c._startTime = 0, c._rawPrevTime = c._time = c._totalTime = l._time, a = l._first; a;) s = a._next, i && a instanceof n.f && a.target === a.vars.onComplete || ((o = a._startTime - a._delay) < 0 && (r = 1), c.add(a, o)), a = s;
                return l.add(c, 0), r && c.totalDuration(), c
            }, p.add = function(e, i, r, a) {
                var s, c, l, h, u, d;
                if ("number" != typeof i && (i = this._parseTimeOrLabel(i, 0, !0, e)), !(e instanceof n.a)) {
                    if (e instanceof Array || e && e.push && o(e)) {
                        for (r = r || "normal", a = a || 0, s = i, c = e.length, l = 0; l < c; l++) o(h = e[l]) && (h = new t({
                            tweens: h
                        })), this.add(h, s), "string" != typeof h && "function" != typeof h && ("sequence" === r ? s = h._startTime + h.totalDuration() / h._timeScale : "start" === r && (h._startTime -= h.delay())), s += a;
                        return this._uncache(!0)
                    }
                    if ("string" == typeof e) return this.addLabel(e, i);
                    if ("function" != typeof e) throw "Cannot add " + e + " into the timeline; it is not a tween, timeline, function, or string.";
                    e = n.f.delayedCall(0, e)
                }
                if (n.c.prototype.add.call(this, e, i), e._time && (s = Math.max(0, Math.min(e.totalDuration(), (this.rawTime() - e._startTime) * e._timeScale)), Math.abs(s - e._totalTime) > 1e-5 && e.render(s, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                    for (d = (u = this).rawTime() > e._startTime; u._timeline;) d && u._timeline.smoothChildTiming ? u.totalTime(u._totalTime, !0) : u._gc && u._enabled(!0, !1), u = u._timeline;
                return this
            }, p.remove = function(t) {
                if (t instanceof n.a) {
                    this._remove(t, !1);
                    var e = t._timeline = t.vars.useFrames ? n.a._rootFramesTimeline : n.a._rootTimeline;
                    return t._startTime = (t._paused ? t._pauseTime : e._time) - (t._reversed ? t.totalDuration() - t._totalTime : t._totalTime) / t._timeScale, this
                }
                if (t instanceof Array || t && t.push && o(t)) {
                    for (var i = t.length; --i > -1;) this.remove(t[i]);
                    return this
                }
                return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
            }, p._remove = function(t, e) {
                return n.c.prototype._remove.call(this, t, e), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
            }, p.append = function(t, e) {
                return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
            }, p.insert = p.insertMultiple = function(t, e, i, n) {
                return this.add(t, e || 0, i, n)
            }, p.appendMultiple = function(t, e, i, n) {
                return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
            }, p.addLabel = function(t, e) {
                return this._labels[t] = this._parseTimeOrLabel(e), this
            }, p.addPause = function(t, e, i, r) {
                var o = n.f.delayedCall(0, u, i, r || this);
                return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t)
            }, p.removeLabel = function(t) {
                return delete this._labels[t], this
            }, p.getLabelTime = function(t) {
                return null != this._labels[t] ? this._labels[t] : -1
            }, p._parseTimeOrLabel = function(t, e, i, r) {
                var a, s;
                if (r instanceof n.a && r.timeline === this) this.remove(r);
                else if (r && (r instanceof Array || r.push && o(r)))
                    for (s = r.length; --s > -1;) r[s] instanceof n.a && r[s].timeline === this && this.remove(r[s]);
                if (a = "number" != typeof t || e ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof e) return this._parseTimeOrLabel(e, i && "number" == typeof t && null == this._labels[e] ? t - a : 0, i);
                if (e = e || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = a);
                else {
                    if (-1 === (s = t.indexOf("="))) return null == this._labels[t] ? i ? this._labels[t] = a + e : e : this._labels[t] + e;
                    e = parseInt(t.charAt(s - 1) + "1", 10) * Number(t.substr(s + 1)), t = s > 1 ? this._parseTimeOrLabel(t.substr(0, s - 1), 0, i) : a
                }
                return Number(t) + e
            }, p.seek = function(t, e) {
                return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
            }, p.stop = function() {
                return this.paused(!0)
            }, p.gotoAndPlay = function(t, e) {
                return this.play(t, e)
            }, p.gotoAndStop = function(t, e) {
                return this.pause(t, e)
            }, p.render = function(t, e, i) {
                this._gc && this._enabled(!0, !1);
                var n, r, o, c, l, h, u, d = this._time,
                    p = this._dirty ? this.totalDuration() : this._totalDuration,
                    f = this._startTime,
                    m = this._timeScale,
                    g = this._paused;
                if (d !== this._time && (t += this._time - d), t >= p - 1e-7 && t >= 0) this._totalTime = this._time = p, this._reversed || this._hasPausedChild() || (r = !0, c = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || 1e-10 === this._rawPrevTime) && this._rawPrevTime !== t && this._first && (l = !0, this._rawPrevTime > 1e-10 && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, t = p + 1e-4;
                else if (t < 1e-7)
                    if (this._totalTime = this._time = 0, (0 !== d || 0 === this._duration && 1e-10 !== this._rawPrevTime && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (c = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = r = !0, c = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                    else {
                        if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                            for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                        t = 0, this._initted || (l = !0)
                    }
                else {
                    if (this._hasPause && !this._forcingPlayhead && !e) {
                        if (t >= d)
                            for (n = this._first; n && n._startTime <= t && !h;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (h = n), n = n._next;
                        else
                            for (n = this._last; n && n._startTime >= t && !h;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (h = n), n = n._prev;
                        h && (this._time = t = h._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                    }
                    this._totalTime = this._time = this._rawPrevTime = t
                }
                if (this._time !== d && this._first || i || l || h) {
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== d && t > 0 && (this._active = !0), 0 === d && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (u = this._time) >= d)
                        for (n = this._first; n && (o = n._next, u === this._time && (!this._paused || g));)(n._active || n._startTime <= u && !n._paused && !n._gc) && (h === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = o;
                    else
                        for (n = this._last; n && (o = n._prev, u === this._time && (!this._paused || g));) {
                            if (n._active || n._startTime <= d && !n._paused && !n._gc) {
                                if (h === n) {
                                    for (h = n._prev; h && h.endTime() > this._time;) h.render(h._reversed ? h.totalDuration() - (t - h._startTime) * h._timeScale : (t - h._startTime) * h._timeScale, e, i), h = h._prev;
                                    h = null, this.pause()
                                }
                                n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                            }
                            n = o
                        }
                    this._onUpdate && (e || (a.length && s(), this._callback("onUpdate"))), c && (this._gc || f !== this._startTime && m === this._timeScale || (0 === this._time || p >= this.totalDuration()) && (r && (a.length && s(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[c] && this._callback(c)))
                }
            }, p._hasPausedChild = function() {
                for (var e = this._first; e;) {
                    if (e._paused || e instanceof t && e._hasPausedChild()) return !0;
                    e = e._next
                }
                return !1
            }, p.getChildren = function(t, e, i, r) {
                r = r || -9999999999;
                for (var o = [], a = this._first, s = 0; a;) a._startTime < r || (a instanceof n.f ? !1 !== e && (o[s++] = a) : (!1 !== i && (o[s++] = a), !1 !== t && (s = (o = o.concat(a.getChildren(!0, e, i))).length))), a = a._next;
                return o
            }, p.getTweensOf = function(t, e) {
                var i, r, o = this._gc,
                    a = [],
                    s = 0;
                for (o && this._enabled(!0, !0), r = (i = n.f.getTweensOf(t)).length; --r > -1;)(i[r].timeline === this || e && this._contains(i[r])) && (a[s++] = i[r]);
                return o && this._enabled(!1, !0), a
            }, p.recent = function() {
                return this._recent
            }, p._contains = function(t) {
                for (var e = t.timeline; e;) {
                    if (e === this) return !0;
                    e = e.timeline
                }
                return !1
            }, p.shiftChildren = function(t, e, i) {
                i = i || 0;
                for (var n, r = this._first, o = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                if (e)
                    for (n in o) o[n] >= i && (o[n] += t);
                return this._uncache(!0)
            }, p._kill = function(t, e) {
                if (!t && !e) return this._enabled(!1, !1);
                for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1;) i[n]._kill(t, e) && (r = !0);
                return r
            }, p.clear = function(t) {
                var e = this.getChildren(!1, !0, !0),
                    i = e.length;
                for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
                return !1 !== t && (this._labels = {}), this._uncache(!0)
            }, p.invalidate = function() {
                for (var t = this._first; t;) t.invalidate(), t = t._next;
                return n.a.prototype.invalidate.call(this)
            }, p._enabled = function(t, e) {
                if (t === this._gc)
                    for (var i = this._first; i;) i._enabled(t, !0), i = i._next;
                return n.c.prototype._enabled.call(this, t, e)
            }, p.totalTime = function(t, e, i) {
                this._forcingPlayhead = !0;
                var r = n.a.prototype.totalTime.apply(this, arguments);
                return this._forcingPlayhead = !1, r
            }, p.duration = function(t) {
                return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
            }, p.totalDuration = function(t) {
                if (!arguments.length) {
                    if (this._dirty) {
                        for (var e, i, n = 0, r = this._last, o = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > o && this._sortChildren && !r._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(r, r._startTime - r._delay), this._calculatingDuration = 0) : o = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale, this._time -= r._startTime, this._totalTime -= r._startTime, this._rawPrevTime -= r._startTime), this.shiftChildren(-r._startTime, !1, -9999999999), o = 0), (i = r._startTime + r._totalDuration / r._timeScale) > n && (n = i), r = e;
                        this._duration = this._totalDuration = n, this._dirty = !1
                    }
                    return this._totalDuration
                }
                return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
            }, p.paused = function(t) {
                if (!t)
                    for (var e = this._first, i = this._time; e;) e._startTime === i && "isPause" === e.data && (e._rawPrevTime = 0), e = e._next;
                return n.a.prototype.paused.apply(this, arguments)
            }, p.usesFrames = function() {
                for (var t = this._timeline; t._timeline;) t = t._timeline;
                return t === n.a._rootFramesTimeline
            }, p.rawTime = function(t) {
                return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
            }, t
        }, !0);
    var d = n.g.TimelineLite;
    /*!
     * VERSION: 2.0.2
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    n.e._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function() {
        var t = function(t) {
                d.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
            },
            e = n.f._internals,
            i = e.lazyTweens,
            r = e.lazyRender,
            o = n.e._gsDefine.globals,
            a = new n.b(null, null, 1, 0),
            s = t.prototype = new d;
        return s.constructor = t, s.kill()._gc = !1, t.version = "2.0.2", s.invalidate = function() {
            return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), d.prototype.invalidate.call(this)
        }, s.addCallback = function(t, e, i, r) {
            return this.add(n.f.delayedCall(0, t, i, r), e)
        }, s.removeCallback = function(t, e) {
            if (t)
                if (null == e) this._kill(null, t);
                else
                    for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); --n > -1;) i[n]._startTime === r && i[n]._enabled(!1, !1);
            return this
        }, s.removePause = function(t) {
            return this.removeCallback(d._internals.pauseCallback, t)
        }, s.tweenTo = function(t, e) {
            e = e || {};
            var i, r, s, c = {
                    ease: a,
                    useFrames: this.usesFrames(),
                    immediateRender: !1,
                    lazy: !1
                },
                l = e.repeat && o.TweenMax || n.f;
            for (r in e) c[r] = e[r];
            return c.time = this._parseTimeOrLabel(t), i = Math.abs(Number(c.time) - this._time) / this._timeScale || .001, s = new l(this, i, c), c.onStart = function() {
                s.target.paused(!0), s.vars.time === s.target.time() || i !== s.duration() || s.isFromTo || s.duration(Math.abs(s.vars.time - s.target.time()) / s.target._timeScale).render(s.time(), !0, !0), e.onStart && e.onStart.apply(e.onStartScope || e.callbackScope || s, e.onStartParams || [])
            }, s
        }, s.tweenFromTo = function(t, e, i) {
            i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                onComplete: this.seek,
                onCompleteParams: [t],
                callbackScope: this
            }, i.immediateRender = !1 !== i.immediateRender;
            var n = this.tweenTo(e, i);
            return n.isFromTo = 1, n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
        }, s.render = function(t, e, n) {
            this._gc && this._enabled(!0, !1);
            var o, a, s, c, l, h, u, d, p = this._time,
                f = this._dirty ? this.totalDuration() : this._totalDuration,
                m = this._duration,
                g = this._totalTime,
                v = this._startTime,
                y = this._timeScale,
                _ = this._rawPrevTime,
                x = this._paused,
                b = this._cycle;
            if (p !== this._time && (t += this._time - p), t >= f - 1e-7 && t >= 0) this._locked || (this._totalTime = f, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (a = !0, c = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || _ < 0 || 1e-10 === _) && _ !== t && this._first && (l = !0, _ > 1e-10 && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : (this._time = m, t = m + 1e-4);
            else if (t < 1e-7)
                if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== p || 0 === m && 1e-10 !== _ && (_ > 0 || t < 0 && _ >= 0) && !this._locked) && (c = "onReverseComplete", a = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = a = !0, c = "onReverseComplete") : _ >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                else {
                    if (this._rawPrevTime = m || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && a)
                        for (o = this._first; o && 0 === o._startTime;) o._duration || (a = !1), o = o._next;
                    t = 0, this._initted || (l = !0)
                }
            else if (0 === m && _ < 0 && (l = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (h = m + this._repeatDelay, this._cycle = this._totalTime / h >> 0, 0 !== this._cycle && this._cycle === this._totalTime / h && g <= t && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 0 != (1 & this._cycle) && (this._time = m - this._time), this._time > m ? (this._time = m, t = m + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) {
                if ((t = this._time) >= p || this._repeat && b !== this._cycle)
                    for (o = this._first; o && o._startTime <= t && !u;) o._duration || "isPause" !== o.data || o.ratio || 0 === o._startTime && 0 === this._rawPrevTime || (u = o), o = o._next;
                else
                    for (o = this._last; o && o._startTime >= t && !u;) o._duration || "isPause" === o.data && o._rawPrevTime > 0 && (u = o), o = o._prev;
                u && u._startTime < m && (this._time = t = u._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
            }
            if (this._cycle !== b && !this._locked) {
                var w = this._yoyo && 0 != (1 & b),
                    M = w === (this._yoyo && 0 != (1 & this._cycle)),
                    T = this._totalTime,
                    E = this._cycle,
                    S = this._rawPrevTime,
                    A = this._time;
                if (this._totalTime = b * m, this._cycle < b ? w = !w : this._totalTime += m, this._time = p, this._rawPrevTime = 0 === m ? _ - 1e-4 : _, this._cycle = b, this._locked = !0, p = w ? 0 : m, this.render(p, e, 0 === m), e || this._gc || this.vars.onRepeat && (this._cycle = E, this._locked = !1, this._callback("onRepeat")), p !== this._time) return;
                if (M && (this._cycle = b, this._locked = !0, p = w ? m + 1e-4 : -1e-4, this.render(p, !0, !1)), this._locked = !1, this._paused && !x) return;
                this._time = A, this._totalTime = T, this._cycle = E, this._rawPrevTime = S
            }
            if (this._time !== p && this._first || n || l || u) {
                if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== g && t > 0 && (this._active = !0), 0 === g && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (d = this._time) >= p)
                    for (o = this._first; o && (s = o._next, d === this._time && (!this._paused || x));)(o._active || o._startTime <= this._time && !o._paused && !o._gc) && (u === o && this.pause(), o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (t - o._startTime) * o._timeScale, e, n) : o.render((t - o._startTime) * o._timeScale, e, n)), o = s;
                else
                    for (o = this._last; o && (s = o._prev, d === this._time && (!this._paused || x));) {
                        if (o._active || o._startTime <= p && !o._paused && !o._gc) {
                            if (u === o) {
                                for (u = o._prev; u && u.endTime() > this._time;) u.render(u._reversed ? u.totalDuration() - (t - u._startTime) * u._timeScale : (t - u._startTime) * u._timeScale, e, n), u = u._prev;
                                u = null, this.pause()
                            }
                            o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (t - o._startTime) * o._timeScale, e, n) : o.render((t - o._startTime) * o._timeScale, e, n)
                        }
                        o = s
                    }
                this._onUpdate && (e || (i.length && r(), this._callback("onUpdate"))), c && (this._locked || this._gc || v !== this._startTime && y === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (a && (i.length && r(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[c] && this._callback(c)))
            } else g !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
        }, s.getActive = function(t, e, i) {
            null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
            var n, r, o = [],
                a = this.getChildren(t, e, i),
                s = 0,
                c = a.length;
            for (n = 0; n < c; n++)(r = a[n]).isActive() && (o[s++] = r);
            return o
        }, s.getLabelAfter = function(t) {
            t || 0 !== t && (t = this._time);
            var e, i = this.getLabelsArray(),
                n = i.length;
            for (e = 0; e < n; e++)
                if (i[e].time > t) return i[e].name;
            return null
        }, s.getLabelBefore = function(t) {
            null == t && (t = this._time);
            for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                if (e[i].time < t) return e[i].name;
            return null
        }, s.getLabelsArray = function() {
            var t, e = [],
                i = 0;
            for (t in this._labels) e[i++] = {
                time: this._labels[t],
                name: t
            };
            return e.sort(function(t, e) {
                return t.time - e.time
            }), e
        }, s.invalidate = function() {
            return this._locked = !1, d.prototype.invalidate.call(this)
        }, s.progress = function(t, e) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
        }, s.totalProgress = function(t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
        }, s.totalDuration = function(t) {
            return arguments.length ? -1 !== this._repeat && t ? this.timeScale(this.totalDuration() / t) : this : (this._dirty && (d.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
        }, s.time = function(t, e) {
            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
        }, s.repeat = function(t) {
            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
        }, s.repeatDelay = function(t) {
            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
        }, s.yoyo = function(t) {
            return arguments.length ? (this._yoyo = t, this) : this._yoyo
        }, s.currentLabel = function(t) {
            return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
        }, t
    }, !0);
    var p = n.g.TimelineMax,
        f = 180 / Math.PI,
        m = [],
        g = [],
        v = [],
        y = {},
        _ = n.e._gsDefine.globals,
        x = function(t, e, i, n) {
            i === n && (i = n - (n - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
        },
        b = function(t, e, i, n) {
            var r = {
                    a: t
                },
                o = {},
                a = {},
                s = {
                    c: n
                },
                c = (t + e) / 2,
                l = (e + i) / 2,
                h = (i + n) / 2,
                u = (c + l) / 2,
                d = (l + h) / 2,
                p = (d - u) / 8;
            return r.b = c + (t - c) / 4, o.b = u + p, r.c = o.a = (r.b + o.b) / 2, o.c = a.a = (u + d) / 2, a.b = d - p, s.b = h + (n - h) / 4, a.c = s.a = (a.b + s.b) / 2, [r, o, a, s]
        },
        w = function(t, e, i, n, r) {
            var o, a, s, c, l, h, u, d, p, f, y, _, x, w = t.length - 1,
                M = 0,
                T = t[0].a;
            for (o = 0; o < w; o++) a = (l = t[M]).a, s = l.d, c = t[M + 1].d, r ? (y = m[o], x = ((_ = g[o]) + y) * e * .25 / (n ? .5 : v[o] || .5), d = s - ((h = s - (s - a) * (n ? .5 * e : 0 !== y ? x / y : 0)) + (((u = s + (c - s) * (n ? .5 * e : 0 !== _ ? x / _ : 0)) - h) * (3 * y / (y + _) + .5) / 4 || 0))) : d = s - ((h = s - (s - a) * e * .5) + (u = s + (c - s) * e * .5)) / 2, h += d, u += d, l.c = p = h, l.b = 0 !== o ? T : T = l.a + .6 * (l.c - l.a), l.da = s - a, l.ca = p - a, l.ba = T - a, i ? (f = b(a, T, p, s), t.splice(M, 1, f[0], f[1], f[2], f[3]), M += 4) : M++, T = u;
            (l = t[M]).b = T, l.c = T + .4 * (l.d - T), l.da = l.d - l.a, l.ca = l.c - l.a, l.ba = T - l.a, i && (f = b(l.a, T, l.c, l.d), t.splice(M, 1, f[0], f[1], f[2], f[3]))
        },
        M = function(t, e, i, n) {
            var r, o, a, s, c, l, h = [];
            if (n)
                for (o = (t = [n].concat(t)).length; --o > -1;) "string" == typeof(l = t[o][e]) && "=" === l.charAt(1) && (t[o][e] = n[e] + Number(l.charAt(0) + l.substr(2)));
            if ((r = t.length - 2) < 0) return h[0] = new x(t[0][e], 0, 0, t[0][e]), h;
            for (o = 0; o < r; o++) a = t[o][e], s = t[o + 1][e], h[o] = new x(a, 0, 0, s), i && (c = t[o + 2][e], m[o] = (m[o] || 0) + (s - a) * (s - a), g[o] = (g[o] || 0) + (c - s) * (c - s));
            return h[o] = new x(t[o][e], 0, 0, t[o + 1][e]), h
        },
        T = function(t, e, i, n, r, o) {
            var a, s, c, l, h, u, d, p, f = {},
                _ = [],
                x = o || t[0];
            for (s in r = "string" == typeof r ? "," + r + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == e && (e = 1), t[0]) _.push(s);
            if (t.length > 1) {
                for (p = t[t.length - 1], d = !0, a = _.length; --a > -1;)
                    if (s = _[a], Math.abs(x[s] - p[s]) > .05) {
                        d = !1;
                        break
                    }
                d && (t = t.concat(), o && t.unshift(o), t.push(t[1]), o = t[t.length - 3])
            }
            for (m.length = g.length = v.length = 0, a = _.length; --a > -1;) s = _[a], y[s] = -1 !== r.indexOf("," + s + ","), f[s] = M(t, s, y[s], o);
            for (a = m.length; --a > -1;) m[a] = Math.sqrt(m[a]), g[a] = Math.sqrt(g[a]);
            if (!n) {
                for (a = _.length; --a > -1;)
                    if (y[s])
                        for (u = (c = f[_[a]]).length - 1, l = 0; l < u; l++) h = c[l + 1].da / g[l] + c[l].da / m[l] || 0, v[l] = (v[l] || 0) + h * h;
                for (a = v.length; --a > -1;) v[a] = Math.sqrt(v[a])
            }
            for (a = _.length, l = i ? 4 : 1; --a > -1;) c = f[s = _[a]], w(c, e, i, n, y[s]), d && (c.splice(0, l), c.splice(c.length - l, l));
            return f
        },
        E = function(t, e, i) {
            for (var n, r, o, a, s, c, l, h, u, d, p, f = 1 / i, m = t.length; --m > -1;)
                for (o = (d = t[m]).a, a = d.d - o, s = d.c - o, c = d.b - o, n = r = 0, h = 1; h <= i; h++) n = r - (r = ((l = f * h) * l * a + 3 * (u = 1 - l) * (l * s + u * c)) * l), e[p = m * i + h - 1] = (e[p] || 0) + n * n
        },
        S = n.e._gsDefine.plugin({
            propName: "bezier",
            priority: -1,
            version: "1.3.8",
            API: 2,
            global: !0,
            init: function(t, e, i) {
                this._target = t, e instanceof Array && (e = {
                    values: e
                }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                var n, r, o, a, s, c = e.values || [],
                    l = {},
                    h = c[0],
                    u = e.autoRotate || i.vars.orientToBezier;
                for (n in this._autoRotate = u ? u instanceof Array ? u : [
                        ["x", "y", "rotation", !0 === u ? 0 : Number(u) || 0]
                    ] : null, h) this._props.push(n);
                for (o = this._props.length; --o > -1;) n = this._props[o], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], l[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), s || l[n] !== c[0][n] && (s = l);
                if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? T(c, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, s) : function(t, e, i) {
                        var n, r, o, a, s, c, l, h, u, d, p, f = {},
                            m = "cubic" === (e = e || "soft") ? 3 : 2,
                            g = "soft" === e,
                            v = [];
                        if (g && i && (t = [i].concat(t)), null == t || t.length < m + 1) throw "invalid Bezier data";
                        for (u in t[0]) v.push(u);
                        for (c = v.length; --c > -1;) {
                            for (f[u = v[c]] = s = [], d = 0, h = t.length, l = 0; l < h; l++) n = null == i ? t[l][u] : "string" == typeof(p = t[l][u]) && "=" === p.charAt(1) ? i[u] + Number(p.charAt(0) + p.substr(2)) : Number(p), g && l > 1 && l < h - 1 && (s[d++] = (n + s[d - 2]) / 2), s[d++] = n;
                            for (h = d - m + 1, d = 0, l = 0; l < h; l += m) n = s[l], r = s[l + 1], o = s[l + 2], a = 2 === m ? 0 : s[l + 3], s[d++] = p = 3 === m ? new x(n, r, o, a) : new x(n, (2 * r + n) / 3, (2 * r + o) / 3, o);
                            s.length = d
                        }
                        return f
                    }(c, e.type, l), this._segCount = this._beziers[n].length, this._timeRes) {
                    var d = function(t, e) {
                        var i, n, r, o, a = [],
                            s = [],
                            c = 0,
                            l = 0,
                            h = (e = e >> 0 || 6) - 1,
                            u = [],
                            d = [];
                        for (i in t) E(t[i], a, e);
                        for (r = a.length, n = 0; n < r; n++) c += Math.sqrt(a[n]), d[o = n % e] = c, o === h && (l += c, u[o = n / e >> 0] = d, s[o] = l, c = 0, d = []);
                        return {
                            length: l,
                            lengths: s,
                            segments: u
                        }
                    }(this._beziers, this._timeRes);
                    this._length = d.length, this._lengths = d.lengths, this._segments = d.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                }
                if (u = this._autoRotate)
                    for (this._initialRotations = [], u[0] instanceof Array || (this._autoRotate = u = [u]), o = u.length; --o > -1;) {
                        for (a = 0; a < 3; a++) n = u[o][a], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                        n = u[o][2], this._initialRotations[o] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n)
                    }
                return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
            },
            set: function(t) {
                var e, i, n, r, o, a, s, c, l, h, u = this._segCount,
                    d = this._func,
                    p = this._target,
                    m = t !== this._startRatio;
                if (this._timeRes) {
                    if (l = this._lengths, h = this._curSeg, t *= this._length, n = this._li, t > this._l2 && n < u - 1) {
                        for (c = u - 1; n < c && (this._l2 = l[++n]) <= t;);
                        this._l1 = l[n - 1], this._li = n, this._curSeg = h = this._segments[n], this._s2 = h[this._s1 = this._si = 0]
                    } else if (t < this._l1 && n > 0) {
                        for (; n > 0 && (this._l1 = l[--n]) >= t;);
                        0 === n && t < this._l1 ? this._l1 = 0 : n++, this._l2 = l[n], this._li = n, this._curSeg = h = this._segments[n], this._s1 = h[(this._si = h.length - 1) - 1] || 0, this._s2 = h[this._si]
                    }
                    if (e = n, t -= this._l1, n = this._si, t > this._s2 && n < h.length - 1) {
                        for (c = h.length - 1; n < c && (this._s2 = h[++n]) <= t;);
                        this._s1 = h[n - 1], this._si = n
                    } else if (t < this._s1 && n > 0) {
                        for (; n > 0 && (this._s1 = h[--n]) >= t;);
                        0 === n && t < this._s1 ? this._s1 = 0 : n++, this._s2 = h[n], this._si = n
                    }
                    a = (n + (t - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                } else a = (t - (e = t < 0 ? 0 : t >= 1 ? u - 1 : u * t >> 0) * (1 / u)) * u;
                for (i = 1 - a, n = this._props.length; --n > -1;) r = this._props[n], s = (a * a * (o = this._beziers[r][e]).da + 3 * i * (a * o.ca + i * o.ba)) * a + o.a, this._mod[r] && (s = this._mod[r](s, p)), d[r] ? p[r](s) : p[r] = s;
                if (this._autoRotate) {
                    var g, v, y, _, x, b, w, M = this._autoRotate;
                    for (n = M.length; --n > -1;) r = M[n][2], b = M[n][3] || 0, w = !0 === M[n][4] ? 1 : f, o = this._beziers[M[n][0]], g = this._beziers[M[n][1]], o && g && (o = o[e], g = g[e], v = o.a + (o.b - o.a) * a, v += ((_ = o.b + (o.c - o.b) * a) - v) * a, _ += (o.c + (o.d - o.c) * a - _) * a, y = g.a + (g.b - g.a) * a, y += ((x = g.b + (g.c - g.b) * a) - y) * a, x += (g.c + (g.d - g.c) * a - x) * a, s = m ? Math.atan2(x - y, _ - v) * w + b : this._initialRotations[n], this._mod[r] && (s = this._mod[r](s, p)), d[r] ? p[r](s) : p[r] = s)
                }
            }
        }),
        A = S.prototype;
    
    S.bezierThrough = T, S.cubicToQuadratic = b, S._autoCSS = !0, S.quadraticToCubic = function(t, e, i) {
            return new x(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
        }, S._cssRegister = function() {
            var t = _.CSSPlugin;
            if (t) {
                var e = t._internals,
                    i = e._parseToProxy,
                    n = e._setPluginRatio,
                    r = e.CSSPropTween;
                e._registerComplexSpecialProp("bezier", {
                    parser: function(t, e, o, a, s, c) {
                        e instanceof Array && (e = {
                            values: e
                        }), c = new S;
                        var l, h, u, d = e.values,
                            p = d.length - 1,
                            f = [],
                            m = {};
                        if (p < 0) return s;
                        for (l = 0; l <= p; l++) u = i(t, d[l], a, s, c, p !== l), f[l] = u.end;
                        for (h in e) m[h] = e[h];
                        return m.values = f, (s = new r(t, "bezier", 0, 0, u.pt, 2)).data = u, s.plugin = c, s.setRatio = n, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (l = !0 === m.autoRotate ? 0 : Number(m.autoRotate), m.autoRotate = null != u.end.left ? [
                            ["left", "top", "rotation", l, !1]
                        ] : null != u.end.x && [
                            ["x", "y", "rotation", l, !1]
                        ]), m.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, a._overwriteProps.push("rotation")), c._onInitTween(u.proxy, m, a._tween), s
                    }
                })
            }
        }, A._mod = function(t) {
            for (var e, i = this._overwriteProps, n = i.length; --n > -1;)(e = t[i[n]]) && "function" == typeof e && (this._mod[i[n]] = e)
        }, A._kill = function(t) {
            var e, i, n = this._props;
            for (e in this._beziers)
                if (e in t)
                    for (delete this._beziers[e], delete this._func[e], i = n.length; --i > -1;) n[i] === e && n.splice(i, 1);
            if (n = this._autoRotate)
                for (i = n.length; --i > -1;) t[n[i][2]] && n.splice(i, 1);
            return this._super._kill.call(this, t)
        },
        /*!
         * VERSION: 1.16.1
         * DATE: 2018-08-27
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         * 
         * @author: Jack Doyle, jack@greensock.com
         **/
        n.e._gsDefine("easing.Back", ["easing.Ease"], function() {
            var t, e, i, r, o = n.e.GreenSockGlobals || n.e,
                a = o.com.greensock,
                s = 2 * Math.PI,
                c = Math.PI / 2,
                l = a._class,
                h = function(t, e) {
                    var i = l("easing." + t, function() {}, !0),
                        r = i.prototype = new n.b;
                    return r.constructor = i, r.getRatio = e, i
                },
                u = n.b.register || function() {},
                d = function(t, e, i, n, r) {
                    var o = l("easing." + t, {
                        easeOut: new e,
                        easeIn: new i,
                        easeInOut: new n
                    }, !0);
                    return u(o, t), o
                },
                p = function(t, e, i) {
                    this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
                },
                f = function(t, e) {
                    var i = l("easing." + t, function(t) {
                            this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                        }, !0),
                        r = i.prototype = new n.b;
                    return r.constructor = i, r.getRatio = e, r.config = function(t) {
                        return new i(t)
                    }, i
                },
                m = d("Back", f("BackOut", function(t) {
                    return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                }), f("BackIn", function(t) {
                    return t * t * ((this._p1 + 1) * t - this._p1)
                }), f("BackInOut", function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                })),
                g = l("easing.SlowMo", function(t, e, i) {
                    e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
                }, !0),
                v = g.prototype = new n.b;
            return v.constructor = g, v.getRatio = function(t) {
                var e = t + (.5 - t) * this._p;
                return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
            }, g.ease = new g(.7, .7), v.config = g.config = function(t, e, i) {
                return new g(t, e, i)
            }, (v = (t = l("easing.SteppedEase", function(t, e) {
                t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
            }, !0)).prototype = new n.b).constructor = t, v.getRatio = function(t) {
                return t < 0 ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
            }, v.config = t.config = function(e, i) {
                return new t(e, i)
            }, (v = (e = l("easing.ExpoScaleEase", function(t, e, i) {
                this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = i
            }, !0)).prototype = new n.b).constructor = e, v.getRatio = function(t) {
                return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2
            }, v.config = e.config = function(t, i, n) {
                return new e(t, i, n)
            }, (v = (i = l("easing.RoughEase", function(t) {
                for (var e, i, r, o, a, s, c = (t = t || {}).taper || "none", l = [], h = 0, u = 0 | (t.points || 20), d = u, f = !1 !== t.randomize, m = !0 === t.clamp, g = t.template instanceof n.b ? t.template : null, v = "number" == typeof t.strength ? .4 * t.strength : .4; --d > -1;) e = f ? Math.random() : 1 / u * d, i = g ? g.getRatio(e) : e, r = "none" === c ? v : "out" === c ? (o = 1 - e) * o * v : "in" === c ? e * e * v : e < .5 ? (o = 2 * e) * o * .5 * v : (o = 2 * (1 - e)) * o * .5 * v, f ? i += Math.random() * r - .5 * r : d % 2 ? i += .5 * r : i -= .5 * r, m && (i > 1 ? i = 1 : i < 0 && (i = 0)), l[h++] = {
                    x: e,
                    y: i
                };
                for (l.sort(function(t, e) {
                        return t.x - e.x
                    }), s = new p(1, 1, null), d = u; --d > -1;) a = l[d], s = new p(a.x, a.y, s);
                this._prev = new p(0, 0, 0 !== s.t ? s : s.next)
            }, !0)).prototype = new n.b).constructor = i, v.getRatio = function(t) {
                var e = this._prev;
                if (t > e.t) {
                    for (; e.next && t >= e.t;) e = e.next;
                    e = e.prev
                } else
                    for (; e.prev && t <= e.t;) e = e.prev;
                return this._prev = e, e.v + (t - e.t) / e.gap * e.c
            }, v.config = function(t) {
                return new i(t)
            }, i.ease = new i, d("Bounce", h("BounceOut", function(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            }), h("BounceIn", function(t) {
                return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
            }), h("BounceInOut", function(t) {
                var e = t < .5;
                return (t = e ? 1 - 2 * t : 2 * t - 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
            })), d("Circ", h("CircOut", function(t) {
                return Math.sqrt(1 - (t -= 1) * t)
            }), h("CircIn", function(t) {
                return -(Math.sqrt(1 - t * t) - 1)
            }), h("CircInOut", function(t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            })), d("Elastic", (r = function(t, e, i) {
                var r = l("easing." + t, function(t, e) {
                        this._p1 = t >= 1 ? t : 1, this._p2 = (e || i) / (t < 1 ? t : 1), this._p3 = this._p2 / s * (Math.asin(1 / this._p1) || 0), this._p2 = s / this._p2
                    }, !0),
                    o = r.prototype = new n.b;
                return o.constructor = r, o.getRatio = e, o.config = function(t, e) {
                    return new r(t, e)
                }, r
            })("ElasticOut", function(t) {
                return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
            }, .3), r("ElasticIn", function(t) {
                return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)
            }, .3), r("ElasticInOut", function(t) {
                return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
            }, .45)), d("Expo", h("ExpoOut", function(t) {
                return 1 - Math.pow(2, -10 * t)
            }), h("ExpoIn", function(t) {
                return Math.pow(2, 10 * (t - 1)) - .001
            }), h("ExpoInOut", function(t) {
                return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
            })), d("Sine", h("SineOut", function(t) {
                return Math.sin(t * c)
            }), h("SineIn", function(t) {
                return 1 - Math.cos(t * c)
            }), h("SineInOut", function(t) {
                return -.5 * (Math.cos(Math.PI * t) - 1)
            })), l("easing.EaseLookup", {
                find: function(t) {
                    return n.b.map[t]
                }
            }, !0), u(o.SlowMo, "SlowMo", "ease,"), u(i, "RoughEase", "ease,"), u(t, "SteppedEase", "ease,"), m
        }, !0);
    var P = n.g.Back,
        L = n.g.Elastic,
        C = n.g.Bounce,
        R = n.g.RoughEase,
        O = n.g.SlowMo,
        I = n.g.SteppedEase,
        D = n.g.Circ,
        k = n.g.Expo,
        N = n.g.Sine,
        B = n.g.ExpoScaleEase;
    r._autoActivated = [d, p, o, a, S, s, u, P, L, C, R, O, I, D, k, N, B], i.d(e, "a", function() {
        return n.f
    })
}, function(t, e) {
    var i;
    i = function() {
        return this
    }();
    try {
        i = i || Function("return this")() || (0, eval)("this")
    } catch (t) {
        "object" == typeof window && (i = window)
    }
    t.exports = i
}, function(t, e, i) {
    "use strict";
    (function(t) {
        var n = i(1),
            r = i(2),
            o = i(5),
            a = i.n(o),
            s = (i(11), i(12), i(13), i(16), i(6));
        i(17), i(19);

        function c(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function l(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }
        window.Zlib = a.a.Zlib;
        var h = function() {
            function e() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.$el = null, this.mixer = null, this.progressAnimation = 0, this.isFbxLoaded = !1, this.canBlow = !1, this.loopDoubleSideFuck = 1, this.isFirstAnimDone = !1, this.speed = .11, this.colors = {
                    middleFinger: 12124236,
                    ground: 720972
                }, this.middleFingers = [], this.mixers = [], this.actions = [], this.update = this.update.bind(this)
            }
            return function(t, e, i) {
                e && l(t.prototype, e), i && l(t, i)
            }(e, [{
                key: "init",
                value: function(e) {
                    var i = e.$el;
                    this.$el = i, this.scene = new n.Scene, this.scene.background = new t.Color(819), this.scene.fog = new t.Fog(this.colors.ground, 100, 500), this.camera = new n.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2e3), this.camera.position.set(-20, 50, 30), this.renderer = new n.WebGLRenderer({
                        antialias: !0
                    }), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(window.innerWidth, window.innerHeight), this.renderer.shadowMap.enabled = !0, this.$el.appendChild(this.renderer.domElement), this.controls = this.initControls(this.camera), this.clock = new t.Clock, this.loadModels(), this.initLights(), this.initSpace(), this.update(), this.initGui(), this.initEvents(), this.initDOM()
                }
            }, {
                key: "initDOM",
                value: function() {
                    this.$el = document.querySelector(".Home"), this.$els = {}, this.$els = function(t) {
                        for (var e = 1; e < arguments.length; e++) {
                            var i = null != arguments[e] ? arguments[e] : {},
                                n = Object.keys(i);
                            "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter(function(t) {
                                return Object.getOwnPropertyDescriptor(i, t).enumerable
                            }))), n.forEach(function(e) {
                                c(t, e, i[e])
                            })
                        }
                        return t
                    }({}, this.$els, {
                        blow: this.$el.querySelector(".blow"),
                        blowSpans: this.$el.querySelectorAll("span")
                    })
                }
            }, {
                key: "initEvents",
                value: function() {
                    window.addEventListener("resize", this.resize.bind(this), !1)
                }
            }, {
                key: "initGui",
                value: function() {
                    var t = this,
                        e = {
                            progressAnimation: this.progressAnimation,
                            speed: this.speed
                        };
                    s.a.add(e, "speed", .05, .3).onChange(function() {
                        t.speed = e.speed, t.progressAnimation = e.progressAnimation
                    })
                }
            }, {
                key: "initControls",
                value: function(e) {
                    var i = new t.OrbitControls(e, this.renderer.domElement);
                    return i.update(), i
                }
            }, {
                key: "initLights",
                value: function() {
                    var e = new t.HemisphereLight(16777215, 16777215, .5),
                        i = new t.DirectionalLight(16777215, .8);
                    i.position.set(200, 200, 100), i.castShadow = !0, this.debugLight(-200, 200, 100, 0);
                    var n = new t.DirectionalLight(16777215, .4);
                    n.position.set(-200, 200, 100), n.castShadow = !0, this.debugLight(-200, 200, 100, 0), this.scene.add(n), this.scene.add(e), this.scene.add(i)
                }
            }, {
                key: "debugLight",
                value: function(e, i, n, r) {
                    var o = new t.SphereGeometry(5, 32, 32),
                        a = new t.MeshPhongMaterial({
                            color: 0
                        }),
                        s = new t.Mesh(o, a);
                    s.position.set(-200, 200, 100), this.scene.add(s)
                }
            }, {
                key: "initSpace",
                value: function() {
                    var e = new t.Mesh(new t.PlaneBufferGeometry(2e3, 2e3), new t.MeshPhongMaterial({
                        color: this.colors.ground
                    }));
                    e.rotation.x = -Math.PI / 2, e.position.y = -30, this.scene.add(e);
                    var i = new t.SphereGeometry(800, 32, 32),
                        n = new t.MeshPhongMaterial({
                            color: this.colors.ground,
                            side: t.BackSide
                        }),
                        r = new t.Mesh(i, n);
                    r.receiveShadow = !0, r.position.y = 200, this.scene.add(r)
                }
            }, {
                key: "loadModels",
                value: function() {
                    var e = this,
                        i = new t.FBXLoader;
                    this.group = new t.Group;
                    for (var n = 0; n < 2; n++) i.load("assets/models/fuck-emma.FBX", function(t) {
                        return e.onLoaded(t)
                    })
                }
            }, {
                key: "onLoaded",
                value: function(t) {
                    this.isFbxLoaded = !0, this.initMiddleFinger(t)
                }
            }, {
                key: "initMiddleFinger",
                value: function(e) {
                    var i = e;
                    i.children[0].material = new t.MeshLambertMaterial({
                        color: this.colors.middleFinger,
                        skinning: !0,
                        flatShading: !0,
                        side: t.DoubleSide
                    }), i.traverse(function(t) {
                        t.isMesh && (t.receiveShadow = !0)
                    }), this.group.add(i), this.middleFingers.push(i), i.position.y = -112, i.position.z = -30, 1 == this.middleFingers.length ? (i.position.x = 35, this.showMiddleFinger(0)) : (i.position.x = -20, i.scale.x = -1, this.scene.add(this.group)), i.children[0].material.opacity = 0, i.children[0].material.transparent = !0, this.initAnimations(this.middleFingers.length - 1)
                }
            }, {
                key: "initAnimations",
                value: function(e) {
                    this.middleFingers[e].mixer = new t.AnimationMixer(this.middleFingers[e]), this.mixers.push(this.middleFingers[e].mixer), this.actions.push(this.mixers[e].clipAction(this.middleFingers[e].animations[0])), this.actions[e].play()
                }
            }, {
                key: "update",
                value: function() {
                    requestAnimationFrame(this.update), this.controls.update(), this.controls.enableZoom = !1, this.controls.enableRotate = !1, this.controls.enablePan = !1, this.updateAnimation(), this.renderer.render(this.scene, this.camera)
                }
            }, {
                key: "updateAnimation",
                value: function() {
                    var t = this;
                    if (this.isFbxLoaded) {
                        for (var e = 0; e < this.mixers.length; e++) this.mixers[e].update(0);
                        for (var i = 0; i < this.actions.length; i++) this.isBlowEnd || (this.actions[i].time = this.progressAnimation)
                    }
                    this.isFbxLoaded && !this.isFirstAnimDone && (this.isFirstAnimDone = !0, r.a.to(this, 2.3, {
                        progressAnimation: .66,
                        delay: 2.2,
                        onComplete: function() {
                            t.showMiddleFinger(1), t.moveX(), t.animateTwice(), t.isBlowEnd = !0
                        }
                    }))
                }
            }, {
                key: "resize",
                value: function() {
                    this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(window.innerWidth, window.innerHeight)
                }
            }, {
                key: "showMiddleFinger",
                value: function(t) {
                    var e = this;
                    r.a.to(this.middleFingers[t].children[0].material, .5, {
                        opacity: 1,
                        onComplete: function() {
                            0 == t && e.animate()
                        }
                    })
                }
            }, {
                key: "animate",
                value: function() {
                    r.a.to(this.camera.position, 4, {
                        x: 0,
                        z: 35,
                        y: 0,
                        ease: Expo.easeInOut
                    }), r.a.to(this, 4, {
                        progressAnimation: .3,
                        ease: Expo.easeOut
                    }), TweenMax.delayedCall(.4, this.showBlow.bind(this))
                }
            }, {
                key: "showBlow",
                value: function() {
                    var t;
                    TweenMax.staggerFromTo(this.$els.blowSpans, .5, {
                        y: 200,
                        opacity: 0
                    }, (c(t = {
                        y: 0,
                        opacity: 1,
                        delay: 1,
                        ease: Back.easeOut
                    }, "delay", 2), c(t, "onComplete", this.hideBlow.bind(this)), t), .04)
                }
            }, {
                key: "hideBlow",
                value: function() {
                    var t = this;
                    TweenMax.to(this.$els.blow, .5, {
                        y: 240,
                        scale: .4,
                        delay: 1,
                        ease: Back.easeOut,
                        onComplete: function() {
                            t.canBlow = !0
                        }
                    }, .04)
                }
            }, {
                key: "moveX",
                value: function() {
                    r.a.to(this.group.position, .8, {
                        x: -8,
                        ease: Expo.easeOut
                    })
                }
            }, {
                key: "animateTwice",
                value: function() {
                    this.loopDoubleSideFuck = -1 * this.loopDoubleSideFuck, 1 == this.loopDoubleSideFuck ? (TweenMax.to(this.middleFingers[0].position, this.speed, {
                        z: -35,
                        y: -120,
                        onComplete: this.animateTwice.bind(this)
                    }), TweenMax.to(this.middleFingers[1].position, this.speed, {
                        z: -30,
                        y: -112
                    }), TweenMax.to(this.group.position, this.speed, {
                        x: -6
                    })) : (TweenMax.to(this.middleFingers[0].position, this.speed, {
                        z: -30,
                        y: -112,
                        onComplete: this.animateTwice.bind(this)
                    }), TweenMax.to(this.middleFingers[1].position, this.speed, {
                        z: -35,
                        y: -120
                    }), TweenMax.to(this.group.position, this.speed, {
                        x: -10
                    }))
                }
            }]), e
        }();
        e.a = new h
    }).call(this, i(1))
}, function(t, e) {
    /** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
    (function() {
        "use strict";
        var t = void 0,
            e = this;

        function i(i, n) {
            var r, o = i.split("."),
                a = e;
            !(o[0] in a) && a.execScript && a.execScript("var " + o[0]);
            for (; o.length && (r = o.shift());) o.length || n === t ? a = a[r] ? a[r] : a[r] = {} : a[r] = n
        }
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array && "undefined" != typeof DataView;

        function r(t) {
            var e, i, r, o, a, s, c, l, h, u, d = t.length,
                p = 0,
                f = Number.POSITIVE_INFINITY;
            for (l = 0; l < d; ++l) t[l] > p && (p = t[l]), t[l] < f && (f = t[l]);
            for (e = 1 << p, i = new(n ? Uint32Array : Array)(e), r = 1, o = 0, a = 2; r <= p;) {
                for (l = 0; l < d; ++l)
                    if (t[l] === r) {
                        for (s = 0, c = o, h = 0; h < r; ++h) s = s << 1 | 1 & c, c >>= 1;
                        for (u = r << 16 | l, h = s; h < e; h += a) i[h] = u;
                        ++o
                    }++r, o <<= 1, a <<= 1
            }
            return [i, p, f]
        }

        function o(t, e) {
            switch (this.g = [], this.h = 32768, this.d = this.f = this.a = this.l = 0, this.input = n ? new Uint8Array(t) : t, this.m = !1, this.i = s, this.r = !1, !e && (e = {}) || (e.index && (this.a = e.index), e.bufferSize && (this.h = e.bufferSize), e.bufferType && (this.i = e.bufferType), e.resize && (this.r = e.resize)), this.i) {
                case a:
                    this.b = 32768, this.c = new(n ? Uint8Array : Array)(32768 + this.h + 258);
                    break;
                case s:
                    this.b = 0, this.c = new(n ? Uint8Array : Array)(this.h), this.e = this.z, this.n = this.v, this.j = this.w;
                    break;
                default:
                    throw Error("invalid inflate mode")
            }
        }
        var a = 0,
            s = 1,
            c = {
                t: a,
                s: s
            };
        o.prototype.k = function() {
            for (; !this.m;) {
                var e = A(this, 3);
                switch (1 & e && (this.m = !0), e >>>= 1) {
                    case 0:
                        var i = this.input,
                            o = this.a,
                            c = this.c,
                            l = this.b,
                            h = i.length,
                            u = t,
                            p = c.length,
                            f = t;
                        if (this.d = this.f = 0, o + 1 >= h) throw Error("invalid uncompressed block header: LEN");
                        if (u = i[o++] | i[o++] << 8, o + 1 >= h) throw Error("invalid uncompressed block header: NLEN");
                        if (u === ~(i[o++] | i[o++] << 8)) throw Error("invalid uncompressed block header: length verify");
                        if (o + u > i.length) throw Error("input buffer is broken");
                        switch (this.i) {
                            case a:
                                for (; l + u > c.length;) {
                                    if (u -= f = p - l, n) c.set(i.subarray(o, o + f), l), l += f, o += f;
                                    else
                                        for (; f--;) c[l++] = i[o++];
                                    this.b = l, c = this.e(), l = this.b
                                }
                                break;
                            case s:
                                for (; l + u > c.length;) c = this.e({
                                    p: 2
                                });
                                break;
                            default:
                                throw Error("invalid inflate mode")
                        }
                        if (n) c.set(i.subarray(o, o + u), l), l += u, o += u;
                        else
                            for (; u--;) c[l++] = i[o++];
                        this.a = o, this.b = l, this.c = c;
                        break;
                    case 1:
                        this.j(T, S);
                        break;
                    case 2:
                        var m, g, v, y, _ = A(this, 5) + 257,
                            x = A(this, 5) + 1,
                            b = A(this, 4) + 4,
                            w = new(n ? Uint8Array : Array)(d.length),
                            M = t,
                            E = t,
                            L = t,
                            C = t,
                            R = t;
                        for (R = 0; R < b; ++R) w[d[R]] = A(this, 3);
                        if (!n)
                            for (R = b, b = w.length; R < b; ++R) w[d[R]] = 0;
                        for (m = r(w), M = new(n ? Uint8Array : Array)(_ + x), R = 0, y = _ + x; R < y;) switch (E = P(this, m), E) {
                            case 16:
                                for (C = 3 + A(this, 2); C--;) M[R++] = L;
                                break;
                            case 17:
                                for (C = 3 + A(this, 3); C--;) M[R++] = 0;
                                L = 0;
                                break;
                            case 18:
                                for (C = 11 + A(this, 7); C--;) M[R++] = 0;
                                L = 0;
                                break;
                            default:
                                L = M[R++] = E
                        }
                        g = r(n ? M.subarray(0, _) : M.slice(0, _)), v = r(n ? M.subarray(_) : M.slice(_)), this.j(g, v);
                        break;
                    default:
                        throw Error("unknown BTYPE: " + e)
                }
            }
            return this.n()
        };
        var l, h, u = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
            d = n ? new Uint16Array(u) : u,
            p = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
            f = n ? new Uint16Array(p) : p,
            m = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
            g = n ? new Uint8Array(m) : m,
            v = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
            y = n ? new Uint16Array(v) : v,
            _ = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
            x = n ? new Uint8Array(_) : _,
            b = new(n ? Uint8Array : Array)(288);
        for (l = 0, h = b.length; l < h; ++l) b[l] = 143 >= l ? 8 : 255 >= l ? 9 : 279 >= l ? 7 : 8;
        var w, M, T = r(b),
            E = new(n ? Uint8Array : Array)(30);
        for (w = 0, M = E.length; w < M; ++w) E[w] = 5;
        var S = r(E);

        function A(t, e) {
            for (var i, n = t.f, r = t.d, o = t.input, a = t.a, s = o.length; r < e;) {
                if (a >= s) throw Error("input buffer is broken");
                n |= o[a++] << r, r += 8
            }
            return i = n & (1 << e) - 1, t.f = n >>> e, t.d = r - e, t.a = a, i
        }

        function P(t, e) {
            for (var i, n, r = t.f, o = t.d, a = t.input, s = t.a, c = a.length, l = e[0], h = e[1]; o < h && !(s >= c);) r |= a[s++] << o, o += 8;
            if ((n = (i = l[r & (1 << h) - 1]) >>> 16) > o) throw Error("invalid code length: " + n);
            return t.f = r >> n, t.d = o - n, t.a = s, 65535 & i
        }

        function L(t, e) {
            var i, n;
            switch (this.input = t, this.a = 0, !e && (e = {}) || (e.index && (this.a = e.index), e.verify && (this.A = e.verify)), i = t[this.a++], n = t[this.a++], 15 & i) {
                case C:
                    this.method = C;
                    break;
                default:
                    throw Error("unsupported compression method")
            }
            if (0 != ((i << 8) + n) % 31) throw Error("invalid fcheck flag:" + ((i << 8) + n) % 31);
            if (32 & n) throw Error("fdict flag is not supported");
            this.q = new o(t, {
                index: this.a,
                bufferSize: e.bufferSize,
                bufferType: e.bufferType,
                resize: e.resize
            })
        }
        o.prototype.j = function(t, e) {
            var i = this.c,
                n = this.b;
            this.o = t;
            for (var r, o, a, s, c = i.length - 258; 256 !== (r = P(this, t));)
                if (256 > r) n >= c && (this.b = n, i = this.e(), n = this.b), i[n++] = r;
                else
                    for (s = f[o = r - 257], 0 < g[o] && (s += A(this, g[o])), r = P(this, e), a = y[r], 0 < x[r] && (a += A(this, x[r])), n >= c && (this.b = n, i = this.e(), n = this.b); s--;) i[n] = i[n++ - a];
            for (; 8 <= this.d;) this.d -= 8, this.a--;
            this.b = n
        }, o.prototype.w = function(t, e) {
            var i = this.c,
                n = this.b;
            this.o = t;
            for (var r, o, a, s, c = i.length; 256 !== (r = P(this, t));)
                if (256 > r) n >= c && (c = (i = this.e()).length), i[n++] = r;
                else
                    for (s = f[o = r - 257], 0 < g[o] && (s += A(this, g[o])), r = P(this, e), a = y[r], 0 < x[r] && (a += A(this, x[r])), n + s > c && (c = (i = this.e()).length); s--;) i[n] = i[n++ - a];
            for (; 8 <= this.d;) this.d -= 8, this.a--;
            this.b = n
        }, o.prototype.e = function() {
            var t, e, i = new(n ? Uint8Array : Array)(this.b - 32768),
                r = this.b - 32768,
                o = this.c;
            if (n) i.set(o.subarray(32768, i.length));
            else
                for (t = 0, e = i.length; t < e; ++t) i[t] = o[t + 32768];
            if (this.g.push(i), this.l += i.length, n) o.set(o.subarray(r, r + 32768));
            else
                for (t = 0; 32768 > t; ++t) o[t] = o[r + t];
            return this.b = 32768, o
        }, o.prototype.z = function(t) {
            var e, i, r, o = this.input.length / this.a + 1 | 0,
                a = this.input,
                s = this.c;
            return t && ("number" == typeof t.p && (o = t.p), "number" == typeof t.u && (o += t.u)), 2 > o ? i = (r = (a.length - this.a) / this.o[2] / 2 * 258 | 0) < s.length ? s.length + r : s.length << 1 : i = s.length * o, n ? (e = new Uint8Array(i)).set(s) : e = s, this.c = e
        }, o.prototype.n = function() {
            var t, e, i, r, o, a = 0,
                s = this.c,
                c = this.g,
                l = new(n ? Uint8Array : Array)(this.l + (this.b - 32768));
            if (0 === c.length) return n ? this.c.subarray(32768, this.b) : this.c.slice(32768, this.b);
            for (e = 0, i = c.length; e < i; ++e)
                for (r = 0, o = (t = c[e]).length; r < o; ++r) l[a++] = t[r];
            for (e = 32768, i = this.b; e < i; ++e) l[a++] = s[e];
            return this.g = [], this.buffer = l
        }, o.prototype.v = function() {
            var t, e = this.b;
            return n ? this.r ? (t = new Uint8Array(e)).set(this.c.subarray(0, e)) : t = this.c.subarray(0, e) : (this.c.length > e && (this.c.length = e), t = this.c), this.buffer = t
        }, L.prototype.k = function() {
            var t, e, i = this.input;
            if (t = this.q.k(), this.a = this.q.a, this.A) {
                e = (i[this.a++] << 24 | i[this.a++] << 16 | i[this.a++] << 8 | i[this.a++]) >>> 0;
                var n = t;
                if ("string" == typeof n) {
                    var r, o, a = n.split("");
                    for (r = 0, o = a.length; r < o; r++) a[r] = (255 & a[r].charCodeAt(0)) >>> 0;
                    n = a
                }
                for (var s, c = 1, l = 0, h = n.length, u = 0; 0 < h;) {
                    h -= s = 1024 < h ? 1024 : h;
                    do {
                        l += c += n[u++]
                    } while (--s);
                    c %= 65521, l %= 65521
                }
                if (e !== (l << 16 | c) >>> 0) throw Error("invalid adler-32 checksum")
            }
            return t
        };
        var C = 8;
        i("Zlib.Inflate", L), i("Zlib.Inflate.prototype.decompress", L.prototype.k);
        var R, O, I, D, k = {
            ADAPTIVE: c.s,
            BLOCK: c.t
        };
        if (Object.keys) R = Object.keys(k);
        else
            for (O in R = [], I = 0, k) R[I++] = O;
        for (I = 0, D = R.length; I < D; ++I) i("Zlib.Inflate.BufferType." + (O = R[I]), k[O])
    }).call(this)
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        var i = t.__state.conversionName.toString(),
            n = Math.round(t.r),
            r = Math.round(t.g),
            o = Math.round(t.b),
            a = t.a,
            s = Math.round(t.h),
            c = t.s.toFixed(1),
            l = t.v.toFixed(1);
        if (e || "THREE_CHAR_HEX" === i || "SIX_CHAR_HEX" === i) {
            for (var h = t.hex.toString(16); h.length < 6;) h = "0" + h;
            return "#" + h
        }
        return "CSS_RGB" === i ? "rgb(" + n + "," + r + "," + o + ")" : "CSS_RGBA" === i ? "rgba(" + n + "," + r + "," + o + "," + a + ")" : "HEX" === i ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === i ? "[" + n + "," + r + "," + o + "]" : "RGBA_ARRAY" === i ? "[" + n + "," + r + "," + o + "," + a + "]" : "RGB_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + o + "}" : "RGBA_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + o + ",a:" + a + "}" : "HSV_OBJ" === i ? "{h:" + s + ",s:" + c + ",v:" + l + "}" : "HSVA_OBJ" === i ? "{h:" + s + ",s:" + c + ",v:" + l + ",a:" + a + "}" : "unknown format"
    }
    var r = Array.prototype.forEach,
        o = Array.prototype.slice,
        a = {
            BREAK: {},
            extend: function(t) {
                return this.each(o.call(arguments, 1), function(e) {
                    (this.isObject(e) ? Object.keys(e) : []).forEach(function(i) {
                        this.isUndefined(e[i]) || (t[i] = e[i])
                    }.bind(this))
                }, this), t
            },
            defaults: function(t) {
                return this.each(o.call(arguments, 1), function(e) {
                    (this.isObject(e) ? Object.keys(e) : []).forEach(function(i) {
                        this.isUndefined(t[i]) && (t[i] = e[i])
                    }.bind(this))
                }, this), t
            },
            compose: function() {
                var t = o.call(arguments);
                return function() {
                    for (var e = o.call(arguments), i = t.length - 1; i >= 0; i--) e = [t[i].apply(this, e)];
                    return e[0]
                }
            },
            each: function(t, e, i) {
                if (t)
                    if (r && t.forEach && t.forEach === r) t.forEach(e, i);
                    else if (t.length === t.length + 0) {
                    var n, o = void 0;
                    for (o = 0, n = t.length; o < n; o++)
                        if (o in t && e.call(i, t[o], o) === this.BREAK) return
                } else
                    for (var a in t)
                        if (e.call(i, t[a], a) === this.BREAK) return
            },
            defer: function(t) {
                setTimeout(t, 0)
            },
            debounce: function(t, e, i) {
                var n = void 0;
                return function() {
                    var r = this,
                        o = arguments;
                    var a = i || !n;
                    clearTimeout(n), n = setTimeout(function() {
                        n = null, i || t.apply(r, o)
                    }, e), a && t.apply(r, o)
                }
            },
            toArray: function(t) {
                return t.toArray ? t.toArray() : o.call(t)
            },
            isUndefined: function(t) {
                return void 0 === t
            },
            isNull: function(t) {
                return null === t
            },
            isNaN: function(t) {
                function e(e) {
                    return t.apply(this, arguments)
                }
                return e.toString = function() {
                    return t.toString()
                }, e
            }(function(t) {
                return isNaN(t)
            }),
            isArray: Array.isArray || function(t) {
                return t.constructor === Array
            },
            isObject: function(t) {
                return t === Object(t)
            },
            isNumber: function(t) {
                return t === t + 0
            },
            isString: function(t) {
                return t === t + ""
            },
            isBoolean: function(t) {
                return !1 === t || !0 === t
            },
            isFunction: function(t) {
                return "[object Function]" === Object.prototype.toString.call(t)
            }
        },
        s = [{
            litmus: a.isString,
            conversions: {
                THREE_CHAR_HEX: {
                    read: function(t) {
                        var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                        return null !== e && {
                            space: "HEX",
                            hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
                        }
                    },
                    write: n
                },
                SIX_CHAR_HEX: {
                    read: function(t) {
                        var e = t.match(/^#([A-F0-9]{6})$/i);
                        return null !== e && {
                            space: "HEX",
                            hex: parseInt("0x" + e[1].toString(), 0)
                        }
                    },
                    write: n
                },
                CSS_RGB: {
                    read: function(t) {
                        var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                        return null !== e && {
                            space: "RGB",
                            r: parseFloat(e[1]),
                            g: parseFloat(e[2]),
                            b: parseFloat(e[3])
                        }
                    },
                    write: n
                },
                CSS_RGBA: {
                    read: function(t) {
                        var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                        return null !== e && {
                            space: "RGB",
                            r: parseFloat(e[1]),
                            g: parseFloat(e[2]),
                            b: parseFloat(e[3]),
                            a: parseFloat(e[4])
                        }
                    },
                    write: n
                }
            }
        }, {
            litmus: a.isNumber,
            conversions: {
                HEX: {
                    read: function(t) {
                        return {
                            space: "HEX",
                            hex: t,
                            conversionName: "HEX"
                        }
                    },
                    write: function(t) {
                        return t.hex
                    }
                }
            }
        }, {
            litmus: a.isArray,
            conversions: {
                RGB_ARRAY: {
                    read: function(t) {
                        return 3 === t.length && {
                            space: "RGB",
                            r: t[0],
                            g: t[1],
                            b: t[2]
                        }
                    },
                    write: function(t) {
                        return [t.r, t.g, t.b]
                    }
                },
                RGBA_ARRAY: {
                    read: function(t) {
                        return 4 === t.length && {
                            space: "RGB",
                            r: t[0],
                            g: t[1],
                            b: t[2],
                            a: t[3]
                        }
                    },
                    write: function(t) {
                        return [t.r, t.g, t.b, t.a]
                    }
                }
            }
        }, {
            litmus: a.isObject,
            conversions: {
                RGBA_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.r) && a.isNumber(t.g) && a.isNumber(t.b) && a.isNumber(t.a)) && {
                            space: "RGB",
                            r: t.r,
                            g: t.g,
                            b: t.b,
                            a: t.a
                        }
                    },
                    write: function(t) {
                        return {
                            r: t.r,
                            g: t.g,
                            b: t.b,
                            a: t.a
                        }
                    }
                },
                RGB_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.r) && a.isNumber(t.g) && a.isNumber(t.b)) && {
                            space: "RGB",
                            r: t.r,
                            g: t.g,
                            b: t.b
                        }
                    },
                    write: function(t) {
                        return {
                            r: t.r,
                            g: t.g,
                            b: t.b
                        }
                    }
                },
                HSVA_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.h) && a.isNumber(t.s) && a.isNumber(t.v) && a.isNumber(t.a)) && {
                            space: "HSV",
                            h: t.h,
                            s: t.s,
                            v: t.v,
                            a: t.a
                        }
                    },
                    write: function(t) {
                        return {
                            h: t.h,
                            s: t.s,
                            v: t.v,
                            a: t.a
                        }
                    }
                },
                HSV_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.h) && a.isNumber(t.s) && a.isNumber(t.v)) && {
                            space: "HSV",
                            h: t.h,
                            s: t.s,
                            v: t.v
                        }
                    },
                    write: function(t) {
                        return {
                            h: t.h,
                            s: t.s,
                            v: t.v
                        }
                    }
                }
            }
        }],
        c = void 0,
        l = void 0,
        h = function() {
            l = !1;
            var t = arguments.length > 1 ? a.toArray(arguments) : arguments[0];
            return a.each(s, function(e) {
                if (e.litmus(t)) return a.each(e.conversions, function(e, i) {
                    if (c = e.read(t), !1 === l && !1 !== c) return l = c, c.conversionName = i, c.conversion = e, a.BREAK
                }), a.BREAK
            }), l
        },
        u = void 0,
        d = {
            hsv_to_rgb: function(t, e, i) {
                var n = Math.floor(t / 60) % 6,
                    r = t / 60 - Math.floor(t / 60),
                    o = i * (1 - e),
                    a = i * (1 - r * e),
                    s = i * (1 - (1 - r) * e),
                    c = [
                        [i, s, o],
                        [a, i, o],
                        [o, i, s],
                        [o, a, i],
                        [s, o, i],
                        [i, o, a]
                    ][n];
                return {
                    r: 255 * c[0],
                    g: 255 * c[1],
                    b: 255 * c[2]
                }
            },
            rgb_to_hsv: function(t, e, i) {
                var n = Math.min(t, e, i),
                    r = Math.max(t, e, i),
                    o = r - n,
                    a = void 0;
                return 0 === r ? {
                    h: NaN,
                    s: 0,
                    v: 0
                } : (a = t === r ? (e - i) / o : e === r ? 2 + (i - t) / o : 4 + (t - e) / o, (a /= 6) < 0 && (a += 1), {
                    h: 360 * a,
                    s: o / r,
                    v: r / 255
                })
            },
            rgb_to_hex: function(t, e, i) {
                var n = this.hex_with_component(0, 2, t);
                return n = this.hex_with_component(n, 1, e), n = this.hex_with_component(n, 0, i)
            },
            component_from_hex: function(t, e) {
                return t >> 8 * e & 255
            },
            hex_with_component: function(t, e, i) {
                return i << (u = 8 * e) | t & ~(255 << u)
            }
        },
        p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        },
        f = function(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        },
        m = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        g = function t(e, i, n) {
            null === e && (e = Function.prototype);
            var r = Object.getOwnPropertyDescriptor(e, i);
            if (void 0 === r) {
                var o = Object.getPrototypeOf(e);
                return null === o ? void 0 : t(o, i, n)
            }
            if ("value" in r) return r.value;
            var a = r.get;
            return void 0 !== a ? a.call(n) : void 0
        },
        v = function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
        },
        y = function(t, e) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !e || "object" != typeof e && "function" != typeof e ? t : e
        },
        _ = function() {
            function t() {
                if (f(this, t), this.__state = h.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
                this.__state.a = this.__state.a || 1
            }
            return m(t, [{
                key: "toString",
                value: function() {
                    return n(this)
                }
            }, {
                key: "toHexString",
                value: function() {
                    return n(this, !0)
                }
            }, {
                key: "toOriginal",
                value: function() {
                    return this.__state.conversion.write(this)
                }
            }]), t
        }();

    function x(t, e, i) {
        Object.defineProperty(t, e, {
            get: function() {
                return "RGB" === this.__state.space ? this.__state[e] : (_.recalculateRGB(this, e, i), this.__state[e])
            },
            set: function(t) {
                "RGB" !== this.__state.space && (_.recalculateRGB(this, e, i), this.__state.space = "RGB"), this.__state[e] = t
            }
        })
    }

    function b(t, e) {
        Object.defineProperty(t, e, {
            get: function() {
                return "HSV" === this.__state.space ? this.__state[e] : (_.recalculateHSV(this), this.__state[e])
            },
            set: function(t) {
                "HSV" !== this.__state.space && (_.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t
            }
        })
    }
    _.recalculateRGB = function(t, e, i) {
        if ("HEX" === t.__state.space) t.__state[e] = d.component_from_hex(t.__state.hex, i);
        else {
            if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
            a.extend(t.__state, d.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
        }
    }, _.recalculateHSV = function(t) {
        var e = d.rgb_to_hsv(t.r, t.g, t.b);
        a.extend(t.__state, {
            s: e.s,
            v: e.v
        }), a.isNaN(e.h) ? a.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
    }, _.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], x(_.prototype, "r", 2), x(_.prototype, "g", 1), x(_.prototype, "b", 0), b(_.prototype, "h"), b(_.prototype, "s"), b(_.prototype, "v"), Object.defineProperty(_.prototype, "a", {
        get: function() {
            return this.__state.a
        },
        set: function(t) {
            this.__state.a = t
        }
    }), Object.defineProperty(_.prototype, "hex", {
        get: function() {
            return "HEX" !== !this.__state.space && (this.__state.hex = d.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex
        },
        set: function(t) {
            this.__state.space = "HEX", this.__state.hex = t
        }
    });
    var w = function() {
            function t(e, i) {
                f(this, t), this.initialValue = e[i], this.domElement = document.createElement("div"), this.object = e, this.property = i, this.__onChange = void 0, this.__onFinishChange = void 0
            }
            return m(t, [{
                key: "onChange",
                value: function(t) {
                    return this.__onChange = t, this
                }
            }, {
                key: "onFinishChange",
                value: function(t) {
                    return this.__onFinishChange = t, this
                }
            }, {
                key: "setValue",
                value: function(t) {
                    return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this
                }
            }, {
                key: "getValue",
                value: function() {
                    return this.object[this.property]
                }
            }, {
                key: "updateDisplay",
                value: function() {
                    return this
                }
            }, {
                key: "isModified",
                value: function() {
                    return this.initialValue !== this.getValue()
                }
            }]), t
        }(),
        M = {};
    a.each({
        HTMLEvents: ["change"],
        MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
        KeyboardEvents: ["keydown"]
    }, function(t, e) {
        a.each(t, function(t) {
            M[t] = e
        })
    });
    var T = /(\d+(\.\d+)?)px/;

    function E(t) {
        if ("0" === t || a.isUndefined(t)) return 0;
        var e = t.match(T);
        return a.isNull(e) ? 0 : parseFloat(e[1])
    }
    var S = {
            makeSelectable: function(t, e) {
                void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() {
                    return !1
                } : function() {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off")
            },
            makeFullscreen: function(t, e, i) {
                var n = i,
                    r = e;
                a.isUndefined(r) && (r = !0), a.isUndefined(n) && (n = !0), t.style.position = "absolute", r && (t.style.left = 0, t.style.right = 0), n && (t.style.top = 0, t.style.bottom = 0)
            },
            fakeEvent: function(t, e, i, n) {
                var r = i || {},
                    o = M[e];
                if (!o) throw new Error("Event type " + e + " not supported.");
                var s = document.createEvent(o);
                switch (o) {
                    case "MouseEvents":
                        var c = r.x || r.clientX || 0,
                            l = r.y || r.clientY || 0;
                        s.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, c, l, !1, !1, !1, !1, 0, null);
                        break;
                    case "KeyboardEvents":
                        var h = s.initKeyboardEvent || s.initKeyEvent;
                        a.defaults(r, {
                            cancelable: !0,
                            ctrlKey: !1,
                            altKey: !1,
                            shiftKey: !1,
                            metaKey: !1,
                            keyCode: void 0,
                            charCode: void 0
                        }), h(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
                        break;
                    default:
                        s.initEvent(e, r.bubbles || !1, r.cancelable || !0)
                }
                a.defaults(s, n), t.dispatchEvent(s)
            },
            bind: function(t, e, i, n) {
                var r = n || !1;
                return t.addEventListener ? t.addEventListener(e, i, r) : t.attachEvent && t.attachEvent("on" + e, i), S
            },
            unbind: function(t, e, i, n) {
                var r = n || !1;
                return t.removeEventListener ? t.removeEventListener(e, i, r) : t.detachEvent && t.detachEvent("on" + e, i), S
            },
            addClass: function(t, e) {
                if (void 0 === t.className) t.className = e;
                else if (t.className !== e) {
                    var i = t.className.split(/ +/); - 1 === i.indexOf(e) && (i.push(e), t.className = i.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                }
                return S
            },
            removeClass: function(t, e) {
                if (e)
                    if (t.className === e) t.removeAttribute("class");
                    else {
                        var i = t.className.split(/ +/),
                            n = i.indexOf(e); - 1 !== n && (i.splice(n, 1), t.className = i.join(" "))
                    }
                else t.className = void 0;
                return S
            },
            hasClass: function(t, e) {
                return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
            },
            getWidth: function(t) {
                var e = getComputedStyle(t);
                return E(e["border-left-width"]) + E(e["border-right-width"]) + E(e["padding-left"]) + E(e["padding-right"]) + E(e.width)
            },
            getHeight: function(t) {
                var e = getComputedStyle(t);
                return E(e["border-top-width"]) + E(e["border-bottom-width"]) + E(e["padding-top"]) + E(e["padding-bottom"]) + E(e.height)
            },
            getOffset: function(t) {
                var e = t,
                    i = {
                        left: 0,
                        top: 0
                    };
                if (e.offsetParent)
                    do {
                        i.left += e.offsetLeft, i.top += e.offsetTop, e = e.offsetParent
                    } while (e);
                return i
            },
            isActive: function(t) {
                return t === document.activeElement && (t.type || t.href)
            }
        },
        A = function(t) {
            function e(t, i) {
                f(this, e);
                var n = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                    r = n;
                return n.__prev = n.getValue(), n.__checkbox = document.createElement("input"), n.__checkbox.setAttribute("type", "checkbox"), S.bind(n.__checkbox, "change", function() {
                    r.setValue(!r.__prev)
                }, !1), n.domElement.appendChild(n.__checkbox), n.updateDisplay(), n
            }
            return v(e, w), m(e, [{
                key: "setValue",
                value: function(t) {
                    var i = g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), i
                }
            }, {
                key: "updateDisplay",
                value: function() {
                    return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                }
            }]), e
        }(),
        P = function(t) {
            function e(t, i, n) {
                f(this, e);
                var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                    o = n,
                    s = r;
                if (r.__select = document.createElement("select"), a.isArray(o)) {
                    var c = {};
                    a.each(o, function(t) {
                        c[t] = t
                    }), o = c
                }
                return a.each(o, function(t, e) {
                    var i = document.createElement("option");
                    i.innerHTML = e, i.setAttribute("value", t), s.__select.appendChild(i)
                }), r.updateDisplay(), S.bind(r.__select, "change", function() {
                    var t = this.options[this.selectedIndex].value;
                    s.setValue(t)
                }), r.domElement.appendChild(r.__select), r
            }
            return v(e, w), m(e, [{
                key: "setValue",
                value: function(t) {
                    var i = g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), i
                }
            }, {
                key: "updateDisplay",
                value: function() {
                    return S.isActive(this.__select) ? this : (this.__select.value = this.getValue(), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
                }
            }]), e
        }(),
        L = function(t) {
            function e(t, i) {
                f(this, e);
                var n = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                    r = n;

                function o() {
                    r.setValue(r.__input.value)
                }
                return n.__input = document.createElement("input"), n.__input.setAttribute("type", "text"), S.bind(n.__input, "keyup", o), S.bind(n.__input, "change", o), S.bind(n.__input, "blur", function() {
                    r.__onFinishChange && r.__onFinishChange.call(r, r.getValue())
                }), S.bind(n.__input, "keydown", function(t) {
                    13 === t.keyCode && this.blur()
                }), n.updateDisplay(), n.domElement.appendChild(n.__input), n
            }
            return v(e, w), m(e, [{
                key: "updateDisplay",
                value: function() {
                    return S.isActive(this.__input) || (this.__input.value = this.getValue()), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                }
            }]), e
        }();

    function C(t) {
        var e = t.toString();
        return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
    }
    var R = function(t) {
        function e(t, i, n) {
            f(this, e);
            var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                o = n || {};
            return r.__min = o.min, r.__max = o.max, r.__step = o.step, a.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step, r.__precision = C(r.__impliedStep), r
        }
        return v(e, w), m(e, [{
            key: "setValue",
            value: function(t) {
                var i = t;
                return void 0 !== this.__min && i < this.__min ? i = this.__min : void 0 !== this.__max && i > this.__max && (i = this.__max), void 0 !== this.__step && i % this.__step != 0 && (i = Math.round(i / this.__step) * this.__step), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, i)
            }
        }, {
            key: "min",
            value: function(t) {
                return this.__min = t, this
            }
        }, {
            key: "max",
            value: function(t) {
                return this.__max = t, this
            }
        }, {
            key: "step",
            value: function(t) {
                return this.__step = t, this.__impliedStep = t, this.__precision = C(t), this
            }
        }]), e
    }();
    var O = function(t) {
        function e(t, i, n) {
            f(this, e);
            var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, n));
            r.__truncationSuspended = !1;
            var o = r,
                s = void 0;

            function c() {
                o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
            }

            function l(t) {
                var e = s - t.clientY;
                o.setValue(o.getValue() + e * o.__impliedStep), s = t.clientY
            }

            function h() {
                S.unbind(window, "mousemove", l), S.unbind(window, "mouseup", h), c()
            }
            return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), S.bind(r.__input, "change", function() {
                var t = parseFloat(o.__input.value);
                a.isNaN(t) || o.setValue(t)
            }), S.bind(r.__input, "blur", function() {
                c()
            }), S.bind(r.__input, "mousedown", function(t) {
                S.bind(window, "mousemove", l), S.bind(window, "mouseup", h), s = t.clientY
            }), S.bind(r.__input, "keydown", function(t) {
                13 === t.keyCode && (o.__truncationSuspended = !0, this.blur(), o.__truncationSuspended = !1, c())
            }), r.updateDisplay(), r.domElement.appendChild(r.__input), r
        }
        return v(e, R), m(e, [{
            key: "updateDisplay",
            value: function() {
                return this.__input.value = this.__truncationSuspended ? this.getValue() : function(t, e) {
                    var i = Math.pow(10, e);
                    return Math.round(t * i) / i
                }(this.getValue(), this.__precision), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
            }
        }]), e
    }();

    function I(t, e, i, n, r) {
        return n + (t - e) / (i - e) * (r - n)
    }
    var D = function(t) {
            function e(t, i, n, r, o) {
                f(this, e);
                var a = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, {
                        min: n,
                        max: r,
                        step: o
                    })),
                    s = a;

                function c(t) {
                    t.preventDefault();
                    var e = s.__background.getBoundingClientRect();
                    return s.setValue(I(t.clientX, e.left, e.right, s.__min, s.__max)), !1
                }

                function l() {
                    S.unbind(window, "mousemove", c), S.unbind(window, "mouseup", l), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                }

                function h(t) {
                    var e = t.touches[0].clientX,
                        i = s.__background.getBoundingClientRect();
                    s.setValue(I(e, i.left, i.right, s.__min, s.__max))
                }

                function u() {
                    S.unbind(window, "touchmove", h), S.unbind(window, "touchend", u), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                }
                return a.__background = document.createElement("div"), a.__foreground = document.createElement("div"), S.bind(a.__background, "mousedown", function(t) {
                    document.activeElement.blur(), S.bind(window, "mousemove", c), S.bind(window, "mouseup", l), c(t)
                }), S.bind(a.__background, "touchstart", function(t) {
                    if (1 !== t.touches.length) return;
                    S.bind(window, "touchmove", h), S.bind(window, "touchend", u), h(t)
                }), S.addClass(a.__background, "slider"), S.addClass(a.__foreground, "slider-fg"), a.updateDisplay(), a.__background.appendChild(a.__foreground), a.domElement.appendChild(a.__background), a
            }
            return v(e, R), m(e, [{
                key: "updateDisplay",
                value: function() {
                    var t = (this.getValue() - this.__min) / (this.__max - this.__min);
                    return this.__foreground.style.width = 100 * t + "%", g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                }
            }]), e
        }(),
        k = function(t) {
            function e(t, i, n) {
                f(this, e);
                var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                    o = r;
                return r.__button = document.createElement("div"), r.__button.innerHTML = void 0 === n ? "Fire" : n, S.bind(r.__button, "click", function(t) {
                    return t.preventDefault(), o.fire(), !1
                }), S.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r
            }
            return v(e, w), m(e, [{
                key: "fire",
                value: function() {
                    this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
                }
            }]), e
        }(),
        N = function(t) {
            function e(t, i) {
                f(this, e);
                var n = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                n.__color = new _(n.getValue()), n.__temp = new _(0);
                var r = n;
                n.domElement = document.createElement("div"), S.makeSelectable(n.domElement, !1), n.__selector = document.createElement("div"), n.__selector.className = "selector", n.__saturation_field = document.createElement("div"), n.__saturation_field.className = "saturation-field", n.__field_knob = document.createElement("div"), n.__field_knob.className = "field-knob", n.__field_knob_border = "2px solid ", n.__hue_knob = document.createElement("div"), n.__hue_knob.className = "hue-knob", n.__hue_field = document.createElement("div"), n.__hue_field.className = "hue-field", n.__input = document.createElement("input"), n.__input.type = "text", n.__input_textShadow = "0 1px 1px ", S.bind(n.__input, "keydown", function(t) {
                    13 === t.keyCode && d.call(this)
                }), S.bind(n.__input, "blur", d), S.bind(n.__selector, "mousedown", function() {
                    S.addClass(this, "drag").bind(window, "mouseup", function() {
                        S.removeClass(r.__selector, "drag")
                    })
                }), S.bind(n.__selector, "touchstart", function() {
                    S.addClass(this, "drag").bind(window, "touchend", function() {
                        S.removeClass(r.__selector, "drag")
                    })
                });
                var o = document.createElement("div");

                function s(t) {
                    m(t), S.bind(window, "mousemove", m), S.bind(window, "touchmove", m), S.bind(window, "mouseup", l), S.bind(window, "touchend", l)
                }

                function c(t) {
                    g(t), S.bind(window, "mousemove", g), S.bind(window, "touchmove", g), S.bind(window, "mouseup", u), S.bind(window, "touchend", u)
                }

                function l() {
                    S.unbind(window, "mousemove", m), S.unbind(window, "touchmove", m), S.unbind(window, "mouseup", l), S.unbind(window, "touchend", l), p()
                }

                function u() {
                    S.unbind(window, "mousemove", g), S.unbind(window, "touchmove", g), S.unbind(window, "mouseup", u), S.unbind(window, "touchend", u), p()
                }

                function d() {
                    var t = h(this.value);
                    !1 !== t ? (r.__color.__state = t, r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString()
                }

                function p() {
                    r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal())
                }

                function m(t) {
                    -1 === t.type.indexOf("touch") && t.preventDefault();
                    var e = r.__saturation_field.getBoundingClientRect(),
                        i = t.touches && t.touches[0] || t,
                        n = i.clientX,
                        o = i.clientY,
                        a = (n - e.left) / (e.right - e.left),
                        s = 1 - (o - e.top) / (e.bottom - e.top);
                    return s > 1 ? s = 1 : s < 0 && (s = 0), a > 1 ? a = 1 : a < 0 && (a = 0), r.__color.v = s, r.__color.s = a, r.setValue(r.__color.toOriginal()), !1
                }

                function g(t) {
                    -1 === t.type.indexOf("touch") && t.preventDefault();
                    var e = r.__hue_field.getBoundingClientRect(),
                        i = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top);
                    return i > 1 ? i = 1 : i < 0 && (i = 0), r.__color.h = 360 * i, r.setValue(r.__color.toOriginal()), !1
                }
                return a.extend(n.__selector.style, {
                        width: "122px",
                        height: "102px",
                        padding: "3px",
                        backgroundColor: "#222",
                        boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                    }), a.extend(n.__field_knob.style, {
                        position: "absolute",
                        width: "12px",
                        height: "12px",
                        border: n.__field_knob_border + (n.__color.v < .5 ? "#fff" : "#000"),
                        boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                        borderRadius: "12px",
                        zIndex: 1
                    }), a.extend(n.__hue_knob.style, {
                        position: "absolute",
                        width: "15px",
                        height: "2px",
                        borderRight: "4px solid #fff",
                        zIndex: 1
                    }), a.extend(n.__saturation_field.style, {
                        width: "100px",
                        height: "100px",
                        border: "1px solid #555",
                        marginRight: "3px",
                        display: "inline-block",
                        cursor: "pointer"
                    }), a.extend(o.style, {
                        width: "100%",
                        height: "100%",
                        background: "none"
                    }), F(o, "top", "rgba(0,0,0,0)", "#000"), a.extend(n.__hue_field.style, {
                        width: "15px",
                        height: "100px",
                        border: "1px solid #555",
                        cursor: "ns-resize",
                        position: "absolute",
                        top: "3px",
                        right: "3px"
                    }),
                    function(t) {
                        t.style.background = "", t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
                    }(n.__hue_field), a.extend(n.__input.style, {
                        outline: "none",
                        textAlign: "center",
                        color: "#fff",
                        border: 0,
                        fontWeight: "bold",
                        textShadow: n.__input_textShadow + "rgba(0,0,0,0.7)"
                    }), S.bind(n.__saturation_field, "mousedown", s), S.bind(n.__saturation_field, "touchstart", s), S.bind(n.__field_knob, "mousedown", s), S.bind(n.__field_knob, "touchstart", s), S.bind(n.__hue_field, "mousedown", c), S.bind(n.__hue_field, "touchstart", c), n.__saturation_field.appendChild(o), n.__selector.appendChild(n.__field_knob), n.__selector.appendChild(n.__saturation_field), n.__selector.appendChild(n.__hue_field), n.__hue_field.appendChild(n.__hue_knob), n.domElement.appendChild(n.__input), n.domElement.appendChild(n.__selector), n.updateDisplay(), n
            }
            return v(e, w), m(e, [{
                key: "updateDisplay",
                value: function() {
                    var t = h(this.getValue());
                    if (!1 !== t) {
                        var e = !1;
                        a.each(_.COMPONENTS, function(i) {
                            if (!a.isUndefined(t[i]) && !a.isUndefined(this.__color.__state[i]) && t[i] !== this.__color.__state[i]) return e = !0, {}
                        }, this), e && a.extend(this.__color.__state, t)
                    }
                    a.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
                    var i = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
                        n = 255 - i;
                    a.extend(this.__field_knob.style, {
                        marginLeft: 100 * this.__color.s - 7 + "px",
                        marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                        backgroundColor: this.__temp.toHexString(),
                        border: this.__field_knob_border + "rgb(" + i + "," + i + "," + i + ")"
                    }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, F(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), a.extend(this.__input.style, {
                        backgroundColor: this.__color.toHexString(),
                        color: "rgb(" + i + "," + i + "," + i + ")",
                        textShadow: this.__input_textShadow + "rgba(" + n + "," + n + "," + n + ",.7)"
                    })
                }
            }]), e
        }(),
        B = ["-moz-", "-o-", "-webkit-", "-ms-", ""];

    function F(t, e, i, n) {
        t.style.background = "", a.each(B, function(r) {
            t.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + i + " 0%, " + n + " 100%); "
        })
    }
    var z = function(t, e) {
            var i = e || document,
                n = document.createElement("style");
            n.type = "text/css", n.innerHTML = t;
            var r = i.getElementsByTagName("head")[0];
            try {
                r.appendChild(n)
            } catch (t) {}
        },
        U = function(t, e) {
            var i = t[e];
            return a.isArray(arguments[2]) || a.isObject(arguments[2]) ? new P(t, e, arguments[2]) : a.isNumber(i) ? a.isNumber(arguments[2]) && a.isNumber(arguments[3]) ? a.isNumber(arguments[4]) ? new D(t, e, arguments[2], arguments[3], arguments[4]) : new D(t, e, arguments[2], arguments[3]) : a.isNumber(arguments[4]) ? new O(t, e, {
                min: arguments[2],
                max: arguments[3],
                step: arguments[4]
            }) : new O(t, e, {
                min: arguments[2],
                max: arguments[3]
            }) : a.isString(i) ? new L(t, e) : a.isFunction(i) ? new k(t, e, "") : a.isBoolean(i) ? new A(t, e) : null
        };
    var G = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
            setTimeout(t, 1e3 / 60)
        },
        H = function() {
            function t() {
                f(this, t), this.backgroundElement = document.createElement("div"), a.extend(this.backgroundElement.style, {
                    backgroundColor: "rgba(0,0,0,0.8)",
                    top: 0,
                    left: 0,
                    display: "none",
                    zIndex: "1000",
                    opacity: 0,
                    WebkitTransition: "opacity 0.2s linear",
                    transition: "opacity 0.2s linear"
                }), S.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), a.extend(this.domElement.style, {
                    position: "fixed",
                    display: "none",
                    zIndex: "1001",
                    opacity: 0,
                    WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                    transition: "transform 0.2s ease-out, opacity 0.2s linear"
                }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
                var e = this;
                S.bind(this.backgroundElement, "click", function() {
                    e.hide()
                })
            }
            return m(t, [{
                key: "show",
                value: function() {
                    var t = this;
                    this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), a.defer(function() {
                        t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)"
                    })
                }
            }, {
                key: "hide",
                value: function() {
                    var t = this,
                        e = function e() {
                            t.domElement.style.display = "none", t.backgroundElement.style.display = "none", S.unbind(t.domElement, "webkitTransitionEnd", e), S.unbind(t.domElement, "transitionend", e), S.unbind(t.domElement, "oTransitionEnd", e)
                        };
                    S.bind(this.domElement, "webkitTransitionEnd", e), S.bind(this.domElement, "transitionend", e), S.bind(this.domElement, "oTransitionEnd", e), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
                }
            }, {
                key: "layout",
                value: function() {
                    this.domElement.style.left = window.innerWidth / 2 - S.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - S.getHeight(this.domElement) / 2 + "px"
                }
            }]), t
        }();
    z(function(t) {
        if (t && "undefined" != typeof window) {
            var e = document.createElement("style");
            return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t
        }
    }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
    var V = "Default",
        j = function() {
            try {
                return !!window.localStorage
            } catch (t) {
                return !1
            }
        }(),
        W = void 0,
        X = !0,
        q = void 0,
        Y = !1,
        Z = [],
        J = function t(e) {
            var i = this,
                n = e || {};
            this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), S.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], n = a.defaults(n, {
                closeOnTop: !1,
                autoPlace: !0,
                width: t.DEFAULT_WIDTH
            }), n = a.defaults(n, {
                resizable: n.autoPlace,
                hideable: n.autoPlace
            }), a.isUndefined(n.load) ? n.load = {
                preset: V
            } : n.preset && (n.load.preset = n.preset), a.isUndefined(n.parent) && n.hideable && Z.push(this), n.resizable = a.isUndefined(n.parent) && n.resizable, n.autoPlace && a.isUndefined(n.scrollable) && (n.scrollable = !0);
            var r = j && "true" === localStorage.getItem(it(this, "isLocal")),
                o = void 0,
                s = void 0;
            if (Object.defineProperties(this, {
                    parent: {
                        get: function() {
                            return n.parent
                        }
                    },
                    scrollable: {
                        get: function() {
                            return n.scrollable
                        }
                    },
                    autoPlace: {
                        get: function() {
                            return n.autoPlace
                        }
                    },
                    closeOnTop: {
                        get: function() {
                            return n.closeOnTop
                        }
                    },
                    preset: {
                        get: function() {
                            return i.parent ? i.getRoot().preset : n.load.preset
                        },
                        set: function(t) {
                            i.parent ? i.getRoot().preset = t : n.load.preset = t,
                                function(t) {
                                    for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
                                }(this), i.revert()
                        }
                    },
                    width: {
                        get: function() {
                            return n.width
                        },
                        set: function(t) {
                            n.width = t, at(i, t)
                        }
                    },
                    name: {
                        get: function() {
                            return n.name
                        },
                        set: function(t) {
                            n.name = t, s && (s.innerHTML = n.name)
                        }
                    },
                    closed: {
                        get: function() {
                            return n.closed
                        },
                        set: function(e) {
                            n.closed = e, n.closed ? S.addClass(i.__ul, t.CLASS_CLOSED) : S.removeClass(i.__ul, t.CLASS_CLOSED), this.onResize(), i.__closeButton && (i.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                        }
                    },
                    load: {
                        get: function() {
                            return n.load
                        }
                    },
                    useLocalStorage: {
                        get: function() {
                            return r
                        },
                        set: function(t) {
                            j && (r = t, t ? S.bind(window, "unload", o) : S.unbind(window, "unload", o), localStorage.setItem(it(i, "isLocal"), t))
                        }
                    }
                }), a.isUndefined(n.parent)) {
                if (n.closed = !1, S.addClass(this.domElement, t.CLASS_MAIN), S.makeSelectable(this.domElement, !1), j && r) {
                    i.useLocalStorage = !0;
                    var c = localStorage.getItem(it(this, "gui"));
                    c && (n.load = JSON.parse(c))
                }
                this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, S.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), n.closeOnTop ? (S.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (S.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), S.bind(this.__closeButton, "click", function() {
                    i.closed = !i.closed
                })
            } else {
                void 0 === n.closed && (n.closed = !0);
                var l = document.createTextNode(n.name);
                S.addClass(l, "controller-name"), s = K(i, l);
                S.addClass(this.__ul, t.CLASS_CLOSED), S.addClass(s, "title"), S.bind(s, "click", function(t) {
                    return t.preventDefault(), i.closed = !i.closed, !1
                }), n.closed || (this.closed = !1)
            }
            n.autoPlace && (a.isUndefined(n.parent) && (X && (q = document.createElement("div"), S.addClass(q, "dg"), S.addClass(q, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(q), X = !1), q.appendChild(this.domElement), S.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || at(i, n.width)), this.__resizeHandler = function() {
                i.onResizeDebounced()
            }, S.bind(window, "resize", this.__resizeHandler), S.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), S.bind(this.__ul, "transitionend", this.__resizeHandler), S.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), n.resizable && ot(this), o = function() {
                j && "true" === localStorage.getItem(it(i, "isLocal")) && localStorage.setItem(it(i, "gui"), JSON.stringify(i.getSaveObject()))
            }, this.saveToLocalStorageIfPossible = o, n.parent || function() {
                var t = i.getRoot();
                t.width += 1, a.defer(function() {
                    t.width -= 1
                })
            }()
        };

    function K(t, e, i) {
        var n = document.createElement("li");
        return e && n.appendChild(e), i ? t.__ul.insertBefore(n, i) : t.__ul.appendChild(n), t.onResize(), n
    }

    function Q(t) {
        S.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && S.unbind(window, "unload", t.saveToLocalStorageIfPossible)
    }

    function $(t, e) {
        var i = t.__preset_select[t.__preset_select.selectedIndex];
        i.innerHTML = e ? i.value + "*" : i.value
    }

    function tt(t, e) {
        var i = t.getRoot(),
            n = i.__rememberedObjects.indexOf(e.object);
        if (-1 !== n) {
            var r = i.__rememberedObjectIndecesToControllers[n];
            if (void 0 === r && (r = {}, i.__rememberedObjectIndecesToControllers[n] = r), r[e.property] = e, i.load && i.load.remembered) {
                var o = i.load.remembered,
                    a = void 0;
                if (o[t.preset]) a = o[t.preset];
                else {
                    if (!o[V]) return;
                    a = o[V]
                }
                if (a[n] && void 0 !== a[n][e.property]) {
                    var s = a[n][e.property];
                    e.initialValue = s, e.setValue(s)
                }
            }
        }
    }

    function et(t, e, i, n) {
        if (void 0 === e[i]) throw new Error('Object "' + e + '" has no property "' + i + '"');
        var r = void 0;
        if (n.color) r = new N(e, i);
        else {
            var o = [e, i].concat(n.factoryArgs);
            r = U.apply(t, o)
        }
        n.before instanceof w && (n.before = n.before.__li), tt(t, r), S.addClass(r.domElement, "c");
        var s = document.createElement("span");
        S.addClass(s, "property-name"), s.innerHTML = r.property;
        var c = document.createElement("div");
        c.appendChild(s), c.appendChild(r.domElement);
        var l = K(t, c, n.before);
        return S.addClass(l, J.CLASS_CONTROLLER_ROW), r instanceof N ? S.addClass(l, "color") : S.addClass(l, p(r.getValue())),
            function(t, e, i) {
                if (i.__li = e, i.__gui = t, a.extend(i, {
                        options: function(e) {
                            if (arguments.length > 1) {
                                var n = i.__li.nextElementSibling;
                                return i.remove(), et(t, i.object, i.property, {
                                    before: n,
                                    factoryArgs: [a.toArray(arguments)]
                                })
                            }
                            if (a.isArray(e) || a.isObject(e)) {
                                var r = i.__li.nextElementSibling;
                                return i.remove(), et(t, i.object, i.property, {
                                    before: r,
                                    factoryArgs: [e]
                                })
                            }
                        },
                        name: function(t) {
                            return i.__li.firstElementChild.firstElementChild.innerHTML = t, i
                        },
                        listen: function() {
                            return i.__gui.listen(i), i
                        },
                        remove: function() {
                            return i.__gui.remove(i), i
                        }
                    }), i instanceof D) {
                    var n = new O(i.object, i.property, {
                        min: i.__min,
                        max: i.__max,
                        step: i.__step
                    });
                    a.each(["updateDisplay", "onChange", "onFinishChange", "step"], function(t) {
                        var e = i[t],
                            r = n[t];
                        i[t] = n[t] = function() {
                            var t = Array.prototype.slice.call(arguments);
                            return r.apply(n, t), e.apply(i, t)
                        }
                    }), S.addClass(e, "has-slider"), i.domElement.insertBefore(n.domElement, i.domElement.firstElementChild)
                } else if (i instanceof O) {
                    var r = function(e) {
                        if (a.isNumber(i.__min) && a.isNumber(i.__max)) {
                            var n = i.__li.firstElementChild.firstElementChild.innerHTML,
                                r = i.__gui.__listening.indexOf(i) > -1;
                            i.remove();
                            var o = et(t, i.object, i.property, {
                                before: i.__li.nextElementSibling,
                                factoryArgs: [i.__min, i.__max, i.__step]
                            });
                            return o.name(n), r && o.listen(), o
                        }
                        return e
                    };
                    i.min = a.compose(r, i.min), i.max = a.compose(r, i.max)
                } else i instanceof A ? (S.bind(e, "click", function() {
                    S.fakeEvent(i.__checkbox, "click")
                }), S.bind(i.__checkbox, "click", function(t) {
                    t.stopPropagation()
                })) : i instanceof k ? (S.bind(e, "click", function() {
                    S.fakeEvent(i.__button, "click")
                }), S.bind(e, "mouseover", function() {
                    S.addClass(i.__button, "hover")
                }), S.bind(e, "mouseout", function() {
                    S.removeClass(i.__button, "hover")
                })) : i instanceof N && (S.addClass(e, "color"), i.updateDisplay = a.compose(function(t) {
                    return e.style.borderLeftColor = i.__color.toString(), t
                }, i.updateDisplay), i.updateDisplay());
                i.setValue = a.compose(function(e) {
                    return t.getRoot().__preset_select && i.isModified() && $(t.getRoot(), !0), e
                }, i.setValue)
            }(t, l, r), t.__controllers.push(r), r
    }

    function it(t, e) {
        return document.location.href + "." + e
    }

    function nt(t, e, i) {
        var n = document.createElement("option");
        n.innerHTML = e, n.value = e, t.__preset_select.appendChild(n), i && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
    }

    function rt(t, e) {
        e.style.display = t.useLocalStorage ? "block" : "none"
    }

    function ot(t) {
        var e = void 0;

        function i(i) {
            return i.preventDefault(), t.width += e - i.clientX, t.onResize(), e = i.clientX, !1
        }

        function n() {
            S.removeClass(t.__closeButton, J.CLASS_DRAG), S.unbind(window, "mousemove", i), S.unbind(window, "mouseup", n)
        }

        function r(r) {
            return r.preventDefault(), e = r.clientX, S.addClass(t.__closeButton, J.CLASS_DRAG), S.bind(window, "mousemove", i), S.bind(window, "mouseup", n), !1
        }
        t.__resize_handle = document.createElement("div"), a.extend(t.__resize_handle.style, {
            width: "6px",
            marginLeft: "-3px",
            height: "200px",
            cursor: "ew-resize",
            position: "absolute"
        }), S.bind(t.__resize_handle, "mousedown", r), S.bind(t.__closeButton, "mousedown", r), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
    }

    function at(t, e) {
        t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px")
    }

    function st(t, e) {
        var i = {};
        return a.each(t.__rememberedObjects, function(n, r) {
            var o = {},
                s = t.__rememberedObjectIndecesToControllers[r];
            a.each(s, function(t, i) {
                o[i] = e ? t.initialValue : t.getValue()
            }), i[r] = o
        }), i
    }
    J.toggleHide = function() {
        Y = !Y, a.each(Z, function(t) {
            t.domElement.style.display = Y ? "none" : ""
        })
    }, J.CLASS_AUTO_PLACE = "a", J.CLASS_AUTO_PLACE_CONTAINER = "ac", J.CLASS_MAIN = "main", J.CLASS_CONTROLLER_ROW = "cr", J.CLASS_TOO_TALL = "taller-than-window", J.CLASS_CLOSED = "closed", J.CLASS_CLOSE_BUTTON = "close-button", J.CLASS_CLOSE_TOP = "close-top", J.CLASS_CLOSE_BOTTOM = "close-bottom", J.CLASS_DRAG = "drag", J.DEFAULT_WIDTH = 245, J.TEXT_CLOSED = "Close Controls", J.TEXT_OPEN = "Open Controls", J._keydownHandler = function(t) {
        "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || J.toggleHide()
    }, S.bind(window, "keydown", J._keydownHandler, !1), a.extend(J.prototype, {
        add: function(t, e) {
            return et(this, t, e, {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
            })
        },
        addColor: function(t, e) {
            return et(this, t, e, {
                color: !0
            })
        },
        remove: function(t) {
            this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
            var e = this;
            a.defer(function() {
                e.onResize()
            })
        },
        destroy: function() {
            if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
            this.autoPlace && q.removeChild(this.domElement);
            var t = this;
            a.each(this.__folders, function(e) {
                t.removeFolder(e)
            }), S.unbind(window, "keydown", J._keydownHandler, !1), Q(this)
        },
        addFolder: function(t) {
            if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"');
            var e = {
                name: t,
                parent: this
            };
            e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
            var i = new J(e);
            this.__folders[t] = i;
            var n = K(this, i.domElement);
            return S.addClass(n, "folder"), i
        },
        removeFolder: function(t) {
            this.__ul.removeChild(t.domElement.parentElement), delete this.__folders[t.name], this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name], Q(t);
            var e = this;
            a.each(t.__folders, function(e) {
                t.removeFolder(e)
            }), a.defer(function() {
                e.onResize()
            })
        },
        open: function() {
            this.closed = !1
        },
        close: function() {
            this.closed = !0
        },
        onResize: function() {
            var t = this.getRoot();
            if (t.scrollable) {
                var e = S.getOffset(t.__ul).top,
                    i = 0;
                a.each(t.__ul.childNodes, function(e) {
                    t.autoPlace && e === t.__save_row || (i += S.getHeight(e))
                }), window.innerHeight - e - 20 < i ? (S.addClass(t.domElement, J.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - 20 + "px") : (S.removeClass(t.domElement, J.CLASS_TOO_TALL), t.__ul.style.height = "auto")
            }
            t.__resize_handle && a.defer(function() {
                t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
            }), t.__closeButton && (t.__closeButton.style.width = t.width + "px")
        },
        onResizeDebounced: a.debounce(function() {
            this.onResize()
        }, 50),
        remember: function() {
            if (a.isUndefined(W) && ((W = new H).domElement.innerHTML = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'), this.parent) throw new Error("You can only call remember on a top level GUI.");
            var t = this;
            a.each(Array.prototype.slice.call(arguments), function(e) {
                0 === t.__rememberedObjects.length && function(t) {
                    var e = t.__save_row = document.createElement("li");
                    S.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), S.addClass(e, "save-row");
                    var i = document.createElement("span");
                    i.innerHTML = "&nbsp;", S.addClass(i, "button gears");
                    var n = document.createElement("span");
                    n.innerHTML = "Save", S.addClass(n, "button"), S.addClass(n, "save");
                    var r = document.createElement("span");
                    r.innerHTML = "New", S.addClass(r, "button"), S.addClass(r, "save-as");
                    var o = document.createElement("span");
                    o.innerHTML = "Revert", S.addClass(o, "button"), S.addClass(o, "revert");
                    var s = t.__preset_select = document.createElement("select");
                    t.load && t.load.remembered ? a.each(t.load.remembered, function(e, i) {
                        nt(t, i, i === t.preset)
                    }) : nt(t, V, !1);
                    if (S.bind(s, "change", function() {
                            for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                            t.preset = this.value
                        }), e.appendChild(s), e.appendChild(i), e.appendChild(n), e.appendChild(r), e.appendChild(o), j) {
                        var c = document.getElementById("dg-local-explain"),
                            l = document.getElementById("dg-local-storage"),
                            h = document.getElementById("dg-save-locally");
                        h.style.display = "block", "true" === localStorage.getItem(it(t, "isLocal")) && l.setAttribute("checked", "checked"), rt(t, c), S.bind(l, "change", function() {
                            t.useLocalStorage = !t.useLocalStorage, rt(t, c)
                        })
                    }
                    var u = document.getElementById("dg-new-constructor");
                    S.bind(u, "keydown", function(t) {
                        !t.metaKey || 67 !== t.which && 67 !== t.keyCode || W.hide()
                    }), S.bind(i, "click", function() {
                        u.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), W.show(), u.focus(), u.select()
                    }), S.bind(n, "click", function() {
                        t.save()
                    }), S.bind(r, "click", function() {
                        var e = prompt("Enter a new preset name.");
                        e && t.saveAs(e)
                    }), S.bind(o, "click", function() {
                        t.revert()
                    })
                }(t), -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
            }), this.autoPlace && at(this, this.width)
        },
        getRoot: function() {
            for (var t = this; t.parent;) t = t.parent;
            return t
        },
        getSaveObject: function() {
            var t = this.load;
            return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = st(this)), t.folders = {}, a.each(this.__folders, function(e, i) {
                t.folders[i] = e.getSaveObject()
            }), t
        },
        save: function() {
            this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = st(this), $(this, !1), this.saveToLocalStorageIfPossible()
        },
        saveAs: function(t) {
            this.load.remembered || (this.load.remembered = {}, this.load.remembered[V] = st(this, !0)), this.load.remembered[t] = st(this), this.preset = t, nt(this, t, !0), this.saveToLocalStorageIfPossible()
        },
        revert: function(t) {
            a.each(this.__controllers, function(e) {
                this.getRoot().load.remembered ? tt(t || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
            }, this), a.each(this.__folders, function(t) {
                t.revert(t)
            }), t || $(this.getRoot(), !1)
        },
        listen: function(t) {
            var e = 0 === this.__listening.length;
            this.__listening.push(t), e && function t(e) {
                0 !== e.length && G.call(window, function() {
                    t(e)
                });
                a.each(e, function(t) {
                    t.updateDisplay()
                })
            }(this.__listening)
        },
        updateDisplay: function() {
            a.each(this.__controllers, function(t) {
                t.updateDisplay()
            }), a.each(this.__folders, function(t) {
                t.updateDisplay()
            })
        }
    });
    var ct = new J;
    e.a = ct
}, function(t, e, i) {}, function(t, e, i) {}, function(t, e, i) {}, function(t, e) {
    t.exports = function(t) {
        if (!t.webpackPolyfill) {
            var e = Object.create(t);
            e.children || (e.children = []), Object.defineProperty(e, "loaded", {
                enumerable: !0,
                get: function() {
                    return e.l
                }
            }), Object.defineProperty(e, "id", {
                enumerable: !0,
                get: function() {
                    return e.i
                }
            }), Object.defineProperty(e, "exports", {
                enumerable: !0
            }), e.webpackPolyfill = 1
        }
        return e
    }
}, function(t, e, i) {
    (function(t) {
        function e(t) {
            return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        t.FBXLoader = function() {
            var i, n, r;

            function o(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager
            }

            function a(t) {
                this.textureLoader = t
            }

            function s() {}

            function c() {}

            function l() {}

            function h() {}

            function u(t, e) {
                this.dv = new DataView(t), this.offset = 0, this.littleEndian = void 0 === e || e
            }

            function d() {}

            function p(t) {
                var e = t.match(/FBXVersion: (\d+)/);
                if (e) return parseInt(e[1]);
                throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
            }

            function f(t) {
                return t / 46186158e3
            }
            o.prototype = {
                constructor: o,
                crossOrigin: "anonymous",
                load: function(e, i, n, r) {
                    var o = this,
                        a = void 0 === o.path ? t.LoaderUtils.extractUrlBase(e) : o.path,
                        s = new t.FileLoader(this.manager);
                    s.setResponseType("arraybuffer"), s.load(e, function(t) {
                        try {
                            i(o.parse(t, a))
                        } catch (t) {
                            setTimeout(function() {
                                r && r(t), o.manager.itemError(e)
                            }, 0)
                        }
                    }, n, r)
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                parse: function(e, n) {
                    if (function(t) {
                            var e = "Kaydara FBX Binary  \0";
                            return t.byteLength >= e.length && e === w(t, 0, e.length)
                        }(e)) i = (new h).parse(e);
                    else {
                        var r = w(e);
                        if (! function(t) {
                                var e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"],
                                    i = 0;

                                function n(e) {
                                    var n = t[e - 1];
                                    return t = t.slice(i + e), i++, n
                                }
                                for (var r = 0; r < e.length; ++r) {
                                    var o = n(1);
                                    if (o === e[r]) return !1
                                }
                                return !0
                            }(r)) throw new Error("THREE.FBXLoader: Unknown format.");
                        if (p(r) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + p(r));
                        i = (new l).parse(r)
                    }
                    return new a(new t.TextureLoader(this.manager).setPath(this.resourcePath || n).setCrossOrigin(this.crossOrigin)).parse(i)
                }
            }, a.prototype = {
                constructor: a,
                parse: function() {
                    n = this.parseConnections();
                    var t = this.parseImages(),
                        e = this.parseTextures(t),
                        i = this.parseMaterials(e),
                        o = this.parseDeformers(),
                        a = (new s).parse(o);
                    return this.parseScene(o, a, i), r
                },
                parseConnections: function() {
                    var t = new Map;
                    "Connections" in i && i.Connections.connections.forEach(function(e) {
                        var i = e[0],
                            n = e[1],
                            r = e[2];
                        t.has(i) || t.set(i, {
                            parents: [],
                            children: []
                        });
                        var o = {
                            ID: n,
                            relationship: r
                        };
                        t.get(i).parents.push(o), t.has(n) || t.set(n, {
                            parents: [],
                            children: []
                        });
                        var a = {
                            ID: i,
                            relationship: r
                        };
                        t.get(n).children.push(a)
                    });
                    return t
                },
                parseImages: function() {
                    var t = {},
                        e = {};
                    if ("Video" in i.Objects) {
                        var n = i.Objects.Video;
                        for (var r in n) {
                            var o = n[r];
                            if (t[l = parseInt(r)] = o.RelativeFilename || o.Filename, "Content" in o) {
                                var a = o.Content instanceof ArrayBuffer && o.Content.byteLength > 0,
                                    s = "string" == typeof o.Content && "" !== o.Content;
                                if (a || s) {
                                    var c = this.parseImage(n[r]);
                                    e[o.RelativeFilename || o.Filename] = c
                                }
                            }
                        }
                    }
                    for (var l in t) {
                        var h = t[l];
                        void 0 !== e[h] ? t[l] = e[h] : t[l] = t[l].split("\\").pop()
                    }
                    return t
                },
                parseImage: function(e) {
                    var i, n = e.Content,
                        r = e.RelativeFilename || e.Filename,
                        o = r.slice(r.lastIndexOf(".") + 1).toLowerCase();
                    switch (o) {
                        case "bmp":
                            i = "image/bmp";
                            break;
                        case "jpg":
                        case "jpeg":
                            i = "image/jpeg";
                            break;
                        case "png":
                            i = "image/png";
                            break;
                        case "tif":
                            i = "image/tiff";
                            break;
                        case "tga":
                            if ("function" != typeof t.TGALoader) return void console.warn("FBXLoader: THREE.TGALoader is required to load TGA textures");
                            if (null === t.Loader.Handlers.get(".tga")) {
                                var a = new t.TGALoader;
                                a.setPath(this.textureLoader.path), t.Loader.Handlers.add(/\.tga$/i, a)
                            }
                            i = "image/tga";
                            break;
                        default:
                            return void console.warn('FBXLoader: Image type "' + o + '" is not supported.')
                    }
                    if ("string" == typeof n) return "data:" + i + ";base64," + n;
                    var s = new Uint8Array(n);
                    return window.URL.createObjectURL(new Blob([s], {
                        type: i
                    }))
                },
                parseTextures: function(t) {
                    var e = new Map;
                    if ("Texture" in i.Objects) {
                        var n = i.Objects.Texture;
                        for (var r in n) {
                            var o = this.parseTexture(n[r], t);
                            e.set(parseInt(r), o)
                        }
                    }
                    return e
                },
                parseTexture: function(e, i) {
                    var n = this.loadTexture(e, i);
                    n.ID = e.id, n.name = e.attrName;
                    var r = e.WrapModeU,
                        o = e.WrapModeV,
                        a = void 0 !== r ? r.value : 0,
                        s = void 0 !== o ? o.value : 0;
                    if (n.wrapS = 0 === a ? t.RepeatWrapping : t.ClampToEdgeWrapping, n.wrapT = 0 === s ? t.RepeatWrapping : t.ClampToEdgeWrapping, "Scaling" in e) {
                        var c = e.Scaling.value;
                        n.repeat.x = c[0], n.repeat.y = c[1]
                    }
                    return n
                },
                loadTexture: function(e, i) {
                    var r, o, a = this.textureLoader.path,
                        s = n.get(e.id).children;
                    void 0 !== s && s.length > 0 && void 0 !== i[s[0].ID] && (0 !== (r = i[s[0].ID]).indexOf("blob:") && 0 !== r.indexOf("data:") || this.textureLoader.setPath(void 0));
                    var c = e.FileName.slice(-3).toLowerCase();
                    if ("tga" === c) {
                        var l = t.Loader.Handlers.get(".tga");
                        null === l ? (console.warn("FBXLoader: TGALoader not found, creating empty placeholder texture for", r), o = new t.Texture) : o = l.load(r)
                    } else "psd" === c ? (console.warn("FBXLoader: PSD textures are not supported, creating empty placeholder texture for", r), o = new t.Texture) : o = this.textureLoader.load(r);
                    return this.textureLoader.setPath(a), o
                },
                parseMaterials: function(t) {
                    var e = new Map;
                    if ("Material" in i.Objects) {
                        var n = i.Objects.Material;
                        for (var r in n) {
                            var o = this.parseMaterial(n[r], t);
                            null !== o && e.set(parseInt(r), o)
                        }
                    }
                    return e
                },
                parseMaterial: function(i, r) {
                    var o = i.id,
                        a = i.attrName,
                        s = i.ShadingModel;
                    if ("object" === e(s) && (s = s.value), !n.has(o)) return null;
                    var c, l = this.parseParameters(i, r, o);
                    switch (s.toLowerCase()) {
                        case "phong":
                            c = new t.MeshPhongMaterial;
                            break;
                        case "lambert":
                            c = new t.MeshLambertMaterial;
                            break;
                        default:
                            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), c = new t.MeshPhongMaterial({
                                color: 3342591
                            })
                    }
                    return c.setValues(l), c.name = a, c
                },
                parseParameters: function(e, i, r) {
                    var o = {};
                    e.BumpFactor && (o.bumpScale = e.BumpFactor.value), e.Diffuse ? o.color = (new t.Color).fromArray(e.Diffuse.value) : e.DiffuseColor && "Color" === e.DiffuseColor.type && (o.color = (new t.Color).fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (o.displacementScale = e.DisplacementFactor.value), e.Emissive ? o.emissive = (new t.Color).fromArray(e.Emissive.value) : e.EmissiveColor && "Color" === e.EmissiveColor.type && (o.emissive = (new t.Color).fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (o.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (o.opacity = parseFloat(e.Opacity.value)), o.opacity < 1 && (o.transparent = !0), e.ReflectionFactor && (o.reflectivity = e.ReflectionFactor.value), e.Shininess && (o.shininess = e.Shininess.value), e.Specular ? o.specular = (new t.Color).fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (o.specular = (new t.Color).fromArray(e.SpecularColor.value));
                    var a = this;
                    return n.get(r).children.forEach(function(e) {
                        var n = e.relationship;
                        switch (n) {
                            case "Bump":
                                o.bumpMap = a.getTexture(i, e.ID);
                                break;
                            case "DiffuseColor":
                                o.map = a.getTexture(i, e.ID);
                                break;
                            case "DisplacementColor":
                                o.displacementMap = a.getTexture(i, e.ID);
                                break;
                            case "EmissiveColor":
                                o.emissiveMap = a.getTexture(i, e.ID);
                                break;
                            case "NormalMap":
                                o.normalMap = a.getTexture(i, e.ID);
                                break;
                            case "ReflectionColor":
                                o.envMap = a.getTexture(i, e.ID), o.envMap.mapping = t.EquirectangularReflectionMapping;
                                break;
                            case "SpecularColor":
                                o.specularMap = a.getTexture(i, e.ID);
                                break;
                            case "TransparentColor":
                                o.alphaMap = a.getTexture(i, e.ID), o.transparent = !0;
                                break;
                            case "AmbientColor":
                            case "ShininessExponent":
                            case "SpecularFactor":
                            case "VectorDisplacementColor":
                            default:
                                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n)
                        }
                    }), o
                },
                getTexture: function(t, e) {
                    return "LayeredTexture" in i.Objects && e in i.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), e = n.get(e).children[0].ID), t.get(e)
                },
                parseDeformers: function() {
                    var t = {},
                        e = {};
                    if ("Deformer" in i.Objects) {
                        var r = i.Objects.Deformer;
                        for (var o in r) {
                            var a = r[o],
                                s = n.get(parseInt(o));
                            if ("Skin" === a.attrType) {
                                var c = this.parseSkeleton(s, r);
                                c.ID = o, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), c.geometryID = s.parents[0].ID, t[o] = c
                            } else if ("BlendShape" === a.attrType) {
                                var l = {
                                    id: o
                                };
                                l.rawTargets = this.parseMorphTargets(s, r), l.id = o, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), e[o] = l
                            }
                        }
                    }
                    return {
                        skeletons: t,
                        morphTargets: e
                    }
                },
                parseSkeleton: function(e, i) {
                    var n = [];
                    return e.children.forEach(function(e) {
                        var r = i[e.ID];
                        if ("Cluster" === r.attrType) {
                            var o = {
                                ID: e.ID,
                                indices: [],
                                weights: [],
                                transformLink: (new t.Matrix4).fromArray(r.TransformLink.a)
                            };
                            "Indexes" in r && (o.indices = r.Indexes.a, o.weights = r.Weights.a), n.push(o)
                        }
                    }), {
                        rawBones: n,
                        bones: []
                    }
                },
                parseMorphTargets: function(t, e) {
                    for (var i = [], r = 0; r < t.children.length; r++) {
                        var o = t.children[r],
                            a = e[o.ID],
                            s = {
                                name: a.attrName,
                                initialWeight: a.DeformPercent,
                                id: a.id,
                                fullWeights: a.FullWeights.a
                            };
                        if ("BlendShapeChannel" !== a.attrType) return;
                        s.geoID = n.get(parseInt(o.ID)).children.filter(function(t) {
                            return void 0 === t.relationship
                        })[0].ID, i.push(s)
                    }
                    return i
                },
                parseScene: function(e, o, a) {
                    r = new t.Group;
                    var s = this.parseModels(e.skeletons, o, a),
                        l = i.Objects.Model,
                        h = this;
                    s.forEach(function(t) {
                        var e = l[t.ID];
                        h.setLookAtProperties(t, e), n.get(t.ID).parents.forEach(function(e) {
                            var i = s.get(e.ID);
                            void 0 !== i && i.add(t)
                        }), null === t.parent && r.add(t)
                    }), this.bindSkeleton(e.skeletons, o, s), this.createAmbientLight(), this.setupMorphMaterials(), r.traverse(function(t) {
                        if (t.userData.transformData) {
                            t.parent && (t.userData.transformData.parentMatrixWorld = t.parent.matrix);
                            var e = _(t.userData.transformData);
                            t.applyMatrix(e)
                        }
                    });
                    var u = (new c).parse();
                    1 === r.children.length && r.children[0].isGroup && (r.children[0].animations = u, r = r.children[0]), r.animations = u
                },
                parseModels: function(e, r, o) {
                    var a = new Map,
                        s = i.Objects.Model;
                    for (var c in s) {
                        var l = parseInt(c),
                            h = s[c],
                            u = n.get(l),
                            d = this.buildSkeleton(u, e, l, h.attrName);
                        if (!d) {
                            switch (h.attrType) {
                                case "Camera":
                                    d = this.createCamera(u);
                                    break;
                                case "Light":
                                    d = this.createLight(u);
                                    break;
                                case "Mesh":
                                    d = this.createMesh(u, r, o);
                                    break;
                                case "NurbsCurve":
                                    d = this.createCurve(u, r);
                                    break;
                                case "LimbNode":
                                case "Root":
                                    d = new t.Bone;
                                    break;
                                case "Null":
                                default:
                                    d = new t.Group
                            }
                            d.name = t.PropertyBinding.sanitizeNodeName(h.attrName), d.ID = l
                        }
                        this.getTransformData(d, h), a.set(l, d)
                    }
                    return a
                },
                buildSkeleton: function(e, i, n, r) {
                    var o = null;
                    return e.parents.forEach(function(e) {
                        for (var a in i) {
                            var s = i[a];
                            s.rawBones.forEach(function(i, a) {
                                if (i.ID === e.ID) {
                                    var c = o;
                                    (o = new t.Bone).matrixWorld.copy(i.transformLink), o.name = t.PropertyBinding.sanitizeNodeName(r), o.ID = n, s.bones[a] = o, null !== c && o.add(c)
                                }
                            })
                        }
                    }), o
                },
                createCamera: function(e) {
                    var n, r;
                    if (e.children.forEach(function(t) {
                            var e = i.Objects.NodeAttribute[t.ID];
                            void 0 !== e && (r = e)
                        }), void 0 === r) n = new t.Object3D;
                    else {
                        var o = 0;
                        void 0 !== r.CameraProjectionType && 1 === r.CameraProjectionType.value && (o = 1);
                        var a = 1;
                        void 0 !== r.NearPlane && (a = r.NearPlane.value / 1e3);
                        var s = 1e3;
                        void 0 !== r.FarPlane && (s = r.FarPlane.value / 1e3);
                        var c = window.innerWidth,
                            l = window.innerHeight;
                        void 0 !== r.AspectWidth && void 0 !== r.AspectHeight && (c = r.AspectWidth.value, l = r.AspectHeight.value);
                        var h = c / l,
                            u = 45;
                        void 0 !== r.FieldOfView && (u = r.FieldOfView.value);
                        var d = r.FocalLength ? r.FocalLength.value : null;
                        switch (o) {
                            case 0:
                                n = new t.PerspectiveCamera(u, h, a, s), null !== d && n.setFocalLength(d);
                                break;
                            case 1:
                                n = new t.OrthographicCamera(-c / 2, c / 2, l / 2, -l / 2, a, s);
                                break;
                            default:
                                console.warn("THREE.FBXLoader: Unknown camera type " + o + "."), n = new t.Object3D
                        }
                    }
                    return n
                },
                createLight: function(e) {
                    var n, r;
                    if (e.children.forEach(function(t) {
                            var e = i.Objects.NodeAttribute[t.ID];
                            void 0 !== e && (r = e)
                        }), void 0 === r) n = new t.Object3D;
                    else {
                        var o;
                        o = void 0 === r.LightType ? 0 : r.LightType.value;
                        var a = 16777215;
                        void 0 !== r.Color && (a = (new t.Color).fromArray(r.Color.value));
                        var s = void 0 === r.Intensity ? 1 : r.Intensity.value / 100;
                        void 0 !== r.CastLightOnObject && 0 === r.CastLightOnObject.value && (s = 0);
                        var c = 0;
                        void 0 !== r.FarAttenuationEnd && (c = void 0 !== r.EnableFarAttenuation && 0 === r.EnableFarAttenuation.value ? 0 : r.FarAttenuationEnd.value);
                        switch (o) {
                            case 0:
                                n = new t.PointLight(a, s, c, 1);
                                break;
                            case 1:
                                n = new t.DirectionalLight(a, s);
                                break;
                            case 2:
                                var l = Math.PI / 3;
                                void 0 !== r.InnerAngle && (l = t.Math.degToRad(r.InnerAngle.value));
                                var h = 0;
                                void 0 !== r.OuterAngle && (h = t.Math.degToRad(r.OuterAngle.value), h = Math.max(h, 1)), n = new t.SpotLight(a, s, c, l, h, 1);
                                break;
                            default:
                                console.warn("THREE.FBXLoader: Unknown light type " + r.LightType.value + ", defaulting to a THREE.PointLight."), n = new t.PointLight(a, s)
                        }
                        void 0 !== r.CastShadows && 1 === r.CastShadows.value && (n.castShadow = !0)
                    }
                    return n
                },
                createMesh: function(e, i, n) {
                    var r, o = null,
                        a = null,
                        s = [];
                    return e.children.forEach(function(t) {
                        i.has(t.ID) && (o = i.get(t.ID)), n.has(t.ID) && s.push(n.get(t.ID))
                    }), s.length > 1 ? a = s : s.length > 0 ? a = s[0] : (a = new t.MeshPhongMaterial({
                        color: 13421772
                    }), s.push(a)), "color" in o.attributes && s.forEach(function(e) {
                        e.vertexColors = t.VertexColors
                    }), o.FBX_Deformer ? (s.forEach(function(t) {
                        t.skinning = !0
                    }), r = new t.SkinnedMesh(o, a)) : r = new t.Mesh(o, a), r
                },
                createCurve: function(e, i) {
                    var n = e.children.reduce(function(t, e) {
                            return i.has(e.ID) && (t = i.get(e.ID)), t
                        }, null),
                        r = new t.LineBasicMaterial({
                            color: 3342591,
                            linewidth: 1
                        });
                    return new t.Line(n, r)
                },
                getTransformData: function(t, e) {
                    var i = {};
                    "InheritType" in e && (i.inheritType = parseInt(e.InheritType.value)), i.eulerOrder = "RotationOrder" in e ? x(e.RotationOrder.value) : "ZYX", "Lcl_Translation" in e && (i.translation = e.Lcl_Translation.value), "PreRotation" in e && (i.preRotation = e.PreRotation.value), "Lcl_Rotation" in e && (i.rotation = e.Lcl_Rotation.value), "PostRotation" in e && (i.postRotation = e.PostRotation.value), "Lcl_Scaling" in e && (i.scale = e.Lcl_Scaling.value), "ScalingOffset" in e && (i.scalingOffset = e.ScalingOffset.value), "ScalingPivot" in e && (i.scalingPivot = e.ScalingPivot.value), "RotationOffset" in e && (i.rotationOffset = e.RotationOffset.value), "RotationPivot" in e && (i.rotationPivot = e.RotationPivot.value), t.userData.transformData = i
                },
                setLookAtProperties: function(e, o) {
                    "LookAtProperty" in o && n.get(e.ID).children.forEach(function(n) {
                        if ("LookAtProperty" === n.relationship) {
                            var o = i.Objects.Model[n.ID];
                            if ("Lcl_Translation" in o) {
                                var a = o.Lcl_Translation.value;
                                void 0 !== e.target ? (e.target.position.fromArray(a), r.add(e.target)) : e.lookAt((new t.Vector3).fromArray(a))
                            }
                        }
                    })
                },
                bindSkeleton: function(e, i, r) {
                    var o = this.parsePoseNodes();
                    for (var a in e) {
                        var s = e[a];
                        n.get(parseInt(s.ID)).parents.forEach(function(e) {
                            if (i.has(e.ID)) {
                                var a = e.ID;
                                n.get(a).parents.forEach(function(e) {
                                    r.has(e.ID) && r.get(e.ID).bind(new t.Skeleton(s.bones), o[e.ID])
                                })
                            }
                        })
                    }
                },
                parsePoseNodes: function() {
                    var e = {};
                    if ("Pose" in i.Objects) {
                        var n = i.Objects.Pose;
                        for (var r in n)
                            if ("BindPose" === n[r].attrType) {
                                var o = n[r].PoseNode;
                                Array.isArray(o) ? o.forEach(function(i) {
                                    e[i.Node] = (new t.Matrix4).fromArray(i.Matrix.a)
                                }) : e[o.Node] = (new t.Matrix4).fromArray(o.Matrix.a)
                            }
                    }
                    return e
                },
                createAmbientLight: function() {
                    if ("GlobalSettings" in i && "AmbientColor" in i.GlobalSettings) {
                        var e = i.GlobalSettings.AmbientColor.value,
                            n = e[0],
                            o = e[1],
                            a = e[2];
                        if (0 !== n || 0 !== o || 0 !== a) {
                            var s = new t.Color(n, o, a);
                            r.add(new t.AmbientLight(s, 1))
                        }
                    }
                },
                setupMorphMaterials: function() {
                    var t = this;
                    r.traverse(function(e) {
                        e.isMesh && e.geometry.morphAttributes.position && e.geometry.morphAttributes.position.length && (Array.isArray(e.material) ? e.material.forEach(function(i, n) {
                            t.setupMorphMaterial(e, i, n)
                        }) : t.setupMorphMaterial(e, e.material))
                    })
                },
                setupMorphMaterial: function(t, e, i) {
                    var n = t.uuid,
                        o = e.uuid,
                        a = !1;
                    if (r.traverse(function(t) {
                            t.isMesh && (Array.isArray(t.material) ? t.material.forEach(function(e) {
                                e.uuid === o && t.uuid !== n && (a = !0)
                            }) : t.material.uuid === o && t.uuid !== n && (a = !0))
                        }), !0 === a) {
                        var s = e.clone();
                        s.morphTargets = !0, void 0 === i ? t.material = s : t.material[i] = s
                    } else e.morphTargets = !0
                }
            }, s.prototype = {
                constructor: s,
                parse: function(t) {
                    var e = new Map;
                    if ("Geometry" in i.Objects) {
                        var r = i.Objects.Geometry;
                        for (var o in r) {
                            var a = n.get(parseInt(o)),
                                s = this.parseGeometry(a, r[o], t);
                            e.set(parseInt(o), s)
                        }
                    }
                    return e
                },
                parseGeometry: function(t, e, i) {
                    switch (e.attrType) {
                        case "Mesh":
                            return this.parseMeshGeometry(t, e, i);
                        case "NurbsCurve":
                            return this.parseNurbsGeometry(e)
                    }
                },
                parseMeshGeometry: function(t, e, n) {
                    var r = n.skeletons,
                        o = n.morphTargets,
                        a = t.parents.map(function(t) {
                            return i.Objects.Model[t.ID]
                        });
                    if (0 !== a.length) {
                        var s = t.children.reduce(function(t, e) {
                                return void 0 !== r[e.ID] && (t = r[e.ID]), t
                            }, null),
                            c = t.children.reduce(function(t, e) {
                                return void 0 !== o[e.ID] && (t = o[e.ID]), t
                            }, null),
                            l = a[0],
                            h = {};
                        "RotationOrder" in l && (h.eulerOrder = x(l.RotationOrder.value)), "InheritType" in l && (h.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (h.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (h.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (h.scale = l.GeometricScaling.value);
                        var u = _(h);
                        return this.genGeometry(e, s, c, u)
                    }
                },
                genGeometry: function(e, i, n, r) {
                    var o = new t.BufferGeometry;
                    e.attrName && (o.name = e.attrName);
                    var a = this.parseGeoNode(e, i),
                        s = this.genBuffers(a),
                        c = new t.Float32BufferAttribute(s.vertex, 3);
                    if (r.applyToBufferAttribute(c), o.addAttribute("position", c), s.colors.length > 0 && o.addAttribute("color", new t.Float32BufferAttribute(s.colors, 3)), i && (o.addAttribute("skinIndex", new t.Uint16BufferAttribute(s.weightsIndices, 4)), o.addAttribute("skinWeight", new t.Float32BufferAttribute(s.vertexWeights, 4)), o.FBX_Deformer = i), s.normal.length > 0) {
                        var l = new t.Float32BufferAttribute(s.normal, 3);
                        (new t.Matrix3).getNormalMatrix(r).applyToBufferAttribute(l), o.addAttribute("normal", l)
                    }
                    if (s.uvs.forEach(function(e, i) {
                            var n = "uv" + (i + 1).toString();
                            0 === i && (n = "uv"), o.addAttribute(n, new t.Float32BufferAttribute(s.uvs[i], 2))
                        }), a.material && "AllSame" !== a.material.mappingType) {
                        var h = s.materialIndex[0],
                            u = 0;
                        if (s.materialIndex.forEach(function(t, e) {
                                t !== h && (o.addGroup(u, e - u, h), h = t, u = e)
                            }), o.groups.length > 0) {
                            var d = o.groups[o.groups.length - 1],
                                p = d.start + d.count;
                            p !== s.materialIndex.length && o.addGroup(p, s.materialIndex.length - p, h)
                        }
                        0 === o.groups.length && o.addGroup(0, s.materialIndex.length, s.materialIndex[0])
                    }
                    return this.addMorphTargets(o, e, n, r), o
                },
                parseGeoNode: function(t, e) {
                    var i = {};
                    if (i.vertexPositions = void 0 !== t.Vertices ? t.Vertices.a : [], i.vertexIndices = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], t.LayerElementColor && (i.color = this.parseVertexColors(t.LayerElementColor[0])), t.LayerElementMaterial && (i.material = this.parseMaterialIndices(t.LayerElementMaterial[0])), t.LayerElementNormal && (i.normal = this.parseNormals(t.LayerElementNormal[0])), t.LayerElementUV) {
                        i.uv = [];
                        for (var n = 0; t.LayerElementUV[n];) i.uv.push(this.parseUVs(t.LayerElementUV[n])), n++
                    }
                    return i.weightTable = {}, null !== e && (i.skeleton = e, e.rawBones.forEach(function(t, e) {
                        t.indices.forEach(function(n, r) {
                            void 0 === i.weightTable[n] && (i.weightTable[n] = []), i.weightTable[n].push({
                                id: e,
                                weight: t.weights[r]
                            })
                        })
                    })), i
                },
                genBuffers: function(t) {
                    var e = {
                            vertex: [],
                            normal: [],
                            colors: [],
                            uvs: [],
                            materialIndex: [],
                            vertexWeights: [],
                            weightsIndices: []
                        },
                        i = 0,
                        n = 0,
                        r = !1,
                        o = [],
                        a = [],
                        s = [],
                        c = [],
                        l = [],
                        h = [],
                        u = this;
                    return t.vertexIndices.forEach(function(d, p) {
                        var f = !1;
                        d < 0 && (d ^= -1, f = !0);
                        var m = [],
                            v = [];
                        if (o.push(3 * d, 3 * d + 1, 3 * d + 2), t.color) {
                            var y = g(p, i, d, t.color);
                            s.push(y[0], y[1], y[2])
                        }
                        if (t.skeleton) {
                            if (void 0 !== t.weightTable[d] && t.weightTable[d].forEach(function(t) {
                                    v.push(t.weight), m.push(t.id)
                                }), v.length > 4) {
                                r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r = !0);
                                var _ = [0, 0, 0, 0],
                                    x = [0, 0, 0, 0];
                                v.forEach(function(t, e) {
                                    var i = t,
                                        n = m[e];
                                    x.forEach(function(t, e, r) {
                                        if (i > t) {
                                            r[e] = i, i = t;
                                            var o = _[e];
                                            _[e] = n, n = o
                                        }
                                    })
                                }), m = _, v = x
                            }
                            for (; v.length < 4;) v.push(0), m.push(0);
                            for (var b = 0; b < 4; ++b) l.push(v[b]), h.push(m[b])
                        }
                        if (t.normal) {
                            y = g(p, i, d, t.normal);
                            a.push(y[0], y[1], y[2])
                        }
                        if (t.material && "AllSame" !== t.material.mappingType) var w = g(p, i, d, t.material)[0];
                        t.uv && t.uv.forEach(function(t, e) {
                            var n = g(p, i, d, t);
                            void 0 === c[e] && (c[e] = []), c[e].push(n[0]), c[e].push(n[1])
                        }), n++, f && (u.genFace(e, t, o, w, a, s, c, l, h, n), i++, n = 0, o = [], a = [], s = [], c = [], l = [], h = [])
                    }), e
                },
                genFace: function(t, e, i, n, r, o, a, s, c, l) {
                    for (var h = 2; h < l; h++) t.vertex.push(e.vertexPositions[i[0]]), t.vertex.push(e.vertexPositions[i[1]]), t.vertex.push(e.vertexPositions[i[2]]), t.vertex.push(e.vertexPositions[i[3 * (h - 1)]]), t.vertex.push(e.vertexPositions[i[3 * (h - 1) + 1]]), t.vertex.push(e.vertexPositions[i[3 * (h - 1) + 2]]), t.vertex.push(e.vertexPositions[i[3 * h]]), t.vertex.push(e.vertexPositions[i[3 * h + 1]]), t.vertex.push(e.vertexPositions[i[3 * h + 2]]), e.skeleton && (t.vertexWeights.push(s[0]), t.vertexWeights.push(s[1]), t.vertexWeights.push(s[2]), t.vertexWeights.push(s[3]), t.vertexWeights.push(s[4 * (h - 1)]), t.vertexWeights.push(s[4 * (h - 1) + 1]), t.vertexWeights.push(s[4 * (h - 1) + 2]), t.vertexWeights.push(s[4 * (h - 1) + 3]), t.vertexWeights.push(s[4 * h]), t.vertexWeights.push(s[4 * h + 1]), t.vertexWeights.push(s[4 * h + 2]), t.vertexWeights.push(s[4 * h + 3]), t.weightsIndices.push(c[0]), t.weightsIndices.push(c[1]), t.weightsIndices.push(c[2]), t.weightsIndices.push(c[3]), t.weightsIndices.push(c[4 * (h - 1)]), t.weightsIndices.push(c[4 * (h - 1) + 1]), t.weightsIndices.push(c[4 * (h - 1) + 2]), t.weightsIndices.push(c[4 * (h - 1) + 3]), t.weightsIndices.push(c[4 * h]), t.weightsIndices.push(c[4 * h + 1]), t.weightsIndices.push(c[4 * h + 2]), t.weightsIndices.push(c[4 * h + 3])), e.color && (t.colors.push(o[0]), t.colors.push(o[1]), t.colors.push(o[2]), t.colors.push(o[3 * (h - 1)]), t.colors.push(o[3 * (h - 1) + 1]), t.colors.push(o[3 * (h - 1) + 2]), t.colors.push(o[3 * h]), t.colors.push(o[3 * h + 1]), t.colors.push(o[3 * h + 2])), e.material && "AllSame" !== e.material.mappingType && (t.materialIndex.push(n), t.materialIndex.push(n), t.materialIndex.push(n)), e.normal && (t.normal.push(r[0]), t.normal.push(r[1]), t.normal.push(r[2]), t.normal.push(r[3 * (h - 1)]), t.normal.push(r[3 * (h - 1) + 1]), t.normal.push(r[3 * (h - 1) + 2]), t.normal.push(r[3 * h]), t.normal.push(r[3 * h + 1]), t.normal.push(r[3 * h + 2])), e.uv && e.uv.forEach(function(e, i) {
                        void 0 === t.uvs[i] && (t.uvs[i] = []), t.uvs[i].push(a[i][0]), t.uvs[i].push(a[i][1]), t.uvs[i].push(a[i][2 * (h - 1)]), t.uvs[i].push(a[i][2 * (h - 1) + 1]), t.uvs[i].push(a[i][2 * h]), t.uvs[i].push(a[i][2 * h + 1])
                    })
                },
                addMorphTargets: function(t, e, n, r) {
                    if (null !== n) {
                        t.morphAttributes.position = [];
                        var o = this;
                        n.rawTargets.forEach(function(n) {
                            var a = i.Objects.Geometry[n.geoID];
                            void 0 !== a && o.genMorphGeometry(t, e, a, r, n.name)
                        })
                    }
                },
                genMorphGeometry: function(e, i, n, r, o) {
                    var a = new t.BufferGeometry;
                    n.attrName && (a.name = n.attrName);
                    for (var s = void 0 !== i.PolygonVertexIndex ? i.PolygonVertexIndex.a : [], c = void 0 !== i.Vertices ? i.Vertices.a.slice() : [], l = void 0 !== n.Vertices ? n.Vertices.a : [], h = void 0 !== n.Indexes ? n.Indexes.a : [], u = 0; u < h.length; u++) {
                        var d = 3 * h[u];
                        c[d] += l[3 * u], c[d + 1] += l[3 * u + 1], c[d + 2] += l[3 * u + 2]
                    }
                    var p = {
                            vertexIndices: s,
                            vertexPositions: c
                        },
                        f = this.genBuffers(p),
                        m = new t.Float32BufferAttribute(f.vertex, 3);
                    m.name = o || n.attrName, r.applyToBufferAttribute(m), e.morphAttributes.position.push(m)
                },
                parseNormals: function(t) {
                    var e = t.MappingInformationType,
                        i = t.ReferenceInformationType,
                        n = t.Normals.a,
                        r = [];
                    return "IndexToDirect" === i && ("NormalIndex" in t ? r = t.NormalIndex.a : "NormalsIndex" in t && (r = t.NormalsIndex.a)), {
                        dataSize: 3,
                        buffer: n,
                        indices: r,
                        mappingType: e,
                        referenceType: i
                    }
                },
                parseUVs: function(t) {
                    var e = t.MappingInformationType,
                        i = t.ReferenceInformationType,
                        n = t.UV.a,
                        r = [];
                    return "IndexToDirect" === i && (r = t.UVIndex.a), {
                        dataSize: 2,
                        buffer: n,
                        indices: r,
                        mappingType: e,
                        referenceType: i
                    }
                },
                parseVertexColors: function(t) {
                    var e = t.MappingInformationType,
                        i = t.ReferenceInformationType,
                        n = t.Colors.a,
                        r = [];
                    return "IndexToDirect" === i && (r = t.ColorIndex.a), {
                        dataSize: 4,
                        buffer: n,
                        indices: r,
                        mappingType: e,
                        referenceType: i
                    }
                },
                parseMaterialIndices: function(t) {
                    var e = t.MappingInformationType,
                        i = t.ReferenceInformationType;
                    if ("NoMappingInformation" === e) return {
                        dataSize: 1,
                        buffer: [0],
                        indices: [0],
                        mappingType: "AllSame",
                        referenceType: i
                    };
                    for (var n = t.Materials.a, r = [], o = 0; o < n.length; ++o) r.push(o);
                    return {
                        dataSize: 1,
                        buffer: n,
                        indices: r,
                        mappingType: e,
                        referenceType: i
                    }
                },
                parseNurbsGeometry: function(e) {
                    if (void 0 === t.NURBSCurve) return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new t.BufferGeometry;
                    var i = parseInt(e.Order);
                    if (isNaN(i)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new t.BufferGeometry;
                    for (var n, r, o = i - 1, a = e.KnotVector.a, s = [], c = e.Points.a, l = 0, h = c.length; l < h; l += 4) s.push((new t.Vector4).fromArray(c, l));
                    if ("Closed" === e.Form) s.push(s[0]);
                    else if ("Periodic" === e.Form) {
                        n = o, r = a.length - 1 - n;
                        for (l = 0; l < o; ++l) s.push(s[l])
                    }
                    var u = new t.NURBSCurve(o, a, s, n, r).getPoints(7 * s.length),
                        d = new Float32Array(3 * u.length);
                    u.forEach(function(t, e) {
                        t.toArray(d, 3 * e)
                    });
                    var p = new t.BufferGeometry;
                    return p.addAttribute("position", new t.BufferAttribute(d, 3)), p
                }
            }, c.prototype = {
                constructor: c,
                parse: function() {
                    var t = [],
                        e = this.parseClips();
                    if (void 0 !== e) {
                        for (var i in e) {
                            var n = e[i],
                                r = this.addClip(n);
                            t.push(r)
                        }
                        return t
                    }
                },
                parseClips: function() {
                    if (void 0 !== i.Objects.AnimationCurve) {
                        var t = this.parseAnimationCurveNodes();
                        this.parseAnimationCurves(t);
                        var e = this.parseAnimationLayers(t);
                        return this.parseAnimStacks(e)
                    }
                },
                parseAnimationCurveNodes: function() {
                    var t = i.Objects.AnimationCurveNode,
                        e = new Map;
                    for (var n in t) {
                        var r = t[n];
                        if (null !== r.attrName.match(/S|R|T|DeformPercent/)) {
                            var o = {
                                id: r.id,
                                attr: r.attrName,
                                curves: {}
                            };
                            e.set(o.id, o)
                        }
                    }
                    return e
                },
                parseAnimationCurves: function(t) {
                    var e = i.Objects.AnimationCurve;
                    for (var r in e) {
                        var o = {
                                id: e[r].id,
                                times: e[r].KeyTime.a.map(f),
                                values: e[r].KeyValueFloat.a
                            },
                            a = n.get(o.id);
                        if (void 0 !== a) {
                            var s = a.parents[0].ID,
                                c = a.parents[0].relationship;
                            c.match(/X/) ? t.get(s).curves.x = o : c.match(/Y/) ? t.get(s).curves.y = o : c.match(/Z/) ? t.get(s).curves.z = o : c.match(/d|DeformPercent/) && t.has(s) && (t.get(s).curves.morph = o)
                        }
                    }
                },
                parseAnimationLayers: function(e) {
                    var o = i.Objects.AnimationLayer,
                        a = new Map;
                    for (var s in o) {
                        var c = [],
                            l = n.get(parseInt(s));
                        if (void 0 !== l) l.children.forEach(function(o, a) {
                            if (e.has(o.ID)) {
                                var s = e.get(o.ID);
                                if (void 0 !== s.curves.x || void 0 !== s.curves.y || void 0 !== s.curves.z) {
                                    if (void 0 === c[a])
                                        if (void 0 !== (f = n.get(o.ID).parents.filter(function(t) {
                                                return void 0 !== t.relationship
                                            })[0].ID)) {
                                            var l = i.Objects.Model[f.toString()],
                                                h = {
                                                    modelName: t.PropertyBinding.sanitizeNodeName(l.attrName),
                                                    ID: l.id,
                                                    initialPosition: [0, 0, 0],
                                                    initialRotation: [0, 0, 0],
                                                    initialScale: [1, 1, 1]
                                                };
                                            r.traverse(function(t) {
                                                (t.ID = l.id) && (h.transform = t.matrix, t.userData.transformData && (h.eulerOrder = t.userData.transformData.eulerOrder))
                                            }), h.transform || (h.transform = new t.Matrix4), "PreRotation" in l && (h.preRotation = l.PreRotation.value), "PostRotation" in l && (h.postRotation = l.PostRotation.value), c[a] = h
                                        }
                                    c[a] && (c[a][s.attr] = s)
                                } else if (void 0 !== s.curves.morph) {
                                    if (void 0 === c[a]) {
                                        var u = n.get(o.ID).parents.filter(function(t) {
                                                return void 0 !== t.relationship
                                            })[0].ID,
                                            d = n.get(u).parents[0].ID,
                                            p = n.get(d).parents[0].ID,
                                            f = n.get(p).parents[0].ID;
                                        l = i.Objects.Model[f], h = {
                                            modelName: t.PropertyBinding.sanitizeNodeName(l.attrName),
                                            morphName: i.Objects.Deformer[u].attrName
                                        };
                                        c[a] = h
                                    }
                                    c[a][s.attr] = s
                                }
                            }
                        }), a.set(parseInt(s), c)
                    }
                    return a
                },
                parseAnimStacks: function(t) {
                    var e = i.Objects.AnimationStack,
                        r = {};
                    for (var o in e) {
                        var a = n.get(parseInt(o)).children;
                        a.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                        var s = t.get(a[0].ID);
                        r[o] = {
                            name: e[o].attrName,
                            layer: s
                        }
                    }
                    return r
                },
                addClip: function(e) {
                    var i = [],
                        n = this;
                    return e.layer.forEach(function(t) {
                        i = i.concat(n.generateTracks(t))
                    }), new t.AnimationClip(e.name, -1, i)
                },
                generateTracks: function(e) {
                    var i = [],
                        n = new t.Vector3,
                        r = new t.Quaternion,
                        o = new t.Vector3;
                    if (e.transform && e.transform.decompose(n, r, o), n = n.toArray(), r = (new t.Euler).setFromQuaternion(r, e.eulerOrder).toArray(), o = o.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) {
                        var a = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
                        void 0 !== a && i.push(a)
                    }
                    if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
                        var s = this.generateRotationTrack(e.modelName, e.R.curves, r, e.preRotation, e.postRotation, e.eulerOrder);
                        void 0 !== s && i.push(s)
                    }
                    if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
                        var c = this.generateVectorTrack(e.modelName, e.S.curves, o, "scale");
                        void 0 !== c && i.push(c)
                    }
                    if (void 0 !== e.DeformPercent) {
                        var l = this.generateMorphTrack(e);
                        void 0 !== l && i.push(l)
                    }
                    return i
                },
                generateVectorTrack: function(e, i, n, r) {
                    var o = this.getTimesForAllAxes(i),
                        a = this.getKeyframeTrackValues(o, i, n);
                    return new t.VectorKeyframeTrack(e + "." + r, o, a)
                },
                generateRotationTrack: function(e, i, n, r, o, a) {
                    void 0 !== i.x && (this.interpolateRotations(i.x), i.x.values = i.x.values.map(t.Math.degToRad)), void 0 !== i.y && (this.interpolateRotations(i.y), i.y.values = i.y.values.map(t.Math.degToRad)), void 0 !== i.z && (this.interpolateRotations(i.z), i.z.values = i.z.values.map(t.Math.degToRad));
                    var s = this.getTimesForAllAxes(i),
                        c = this.getKeyframeTrackValues(s, i, n);
                    void 0 !== r && ((r = r.map(t.Math.degToRad)).push(a), r = (new t.Euler).fromArray(r), r = (new t.Quaternion).setFromEuler(r)), void 0 !== o && ((o = o.map(t.Math.degToRad)).push(a), o = (new t.Euler).fromArray(o), o = (new t.Quaternion).setFromEuler(o).inverse());
                    for (var l = new t.Quaternion, h = new t.Euler, u = [], d = 0; d < c.length; d += 3) h.set(c[d], c[d + 1], c[d + 2], a), l.setFromEuler(h), void 0 !== r && l.premultiply(r), void 0 !== o && l.multiply(o), l.toArray(u, d / 3 * 4);
                    return new t.QuaternionKeyframeTrack(e + ".quaternion", s, u)
                },
                generateMorphTrack: function(e) {
                    var i = e.DeformPercent.curves.morph,
                        n = i.values.map(function(t) {
                            return t / 100
                        }),
                        o = r.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
                    return new t.NumberKeyframeTrack(e.modelName + ".morphTargetInfluences[" + o + "]", i.times, n)
                },
                getTimesForAllAxes: function(t) {
                    var e = [];
                    return void 0 !== t.x && (e = e.concat(t.x.times)), void 0 !== t.y && (e = e.concat(t.y.times)), void 0 !== t.z && (e = e.concat(t.z.times)), e = e.sort(function(t, e) {
                        return t - e
                    }).filter(function(t, e, i) {
                        return i.indexOf(t) == e
                    })
                },
                getKeyframeTrackValues: function(t, e, i) {
                    var n = i,
                        r = [],
                        o = -1,
                        a = -1,
                        s = -1;
                    return t.forEach(function(t) {
                        if (e.x && (o = e.x.times.indexOf(t)), e.y && (a = e.y.times.indexOf(t)), e.z && (s = e.z.times.indexOf(t)), -1 !== o) {
                            var i = e.x.values[o];
                            r.push(i), n[0] = i
                        } else r.push(n[0]);
                        if (-1 !== a) {
                            var c = e.y.values[a];
                            r.push(c), n[1] = c
                        } else r.push(n[1]);
                        if (-1 !== s) {
                            var l = e.z.values[s];
                            r.push(l), n[2] = l
                        } else r.push(n[2])
                    }), r
                },
                interpolateRotations: function(t) {
                    for (var e = 1; e < t.values.length; e++) {
                        var i = t.values[e - 1],
                            n = t.values[e] - i,
                            r = Math.abs(n);
                        if (r >= 180) {
                            for (var o = r / 180, a = n / o, s = i + a, c = t.times[e - 1], l = (t.times[e] - c) / o, h = c + l, u = [], d = []; h < t.times[e];) u.push(h), h += l, d.push(s), s += a;
                            t.times = M(t.times, e, u), t.values = M(t.values, e, d)
                        }
                    }
                }
            }, l.prototype = {
                constructor: l,
                getPrevNode: function() {
                    return this.nodeStack[this.currentIndent - 2]
                },
                getCurrentNode: function() {
                    return this.nodeStack[this.currentIndent - 1]
                },
                getCurrentProp: function() {
                    return this.currentProp
                },
                pushStack: function(t) {
                    this.nodeStack.push(t), this.currentIndent += 1
                },
                popStack: function() {
                    this.nodeStack.pop(), this.currentIndent -= 1
                },
                setCurrentProp: function(t, e) {
                    this.currentProp = t, this.currentPropName = e
                },
                parse: function(t) {
                    this.currentIndent = 0, this.allNodes = new d, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
                    var e = this,
                        i = t.split(/[\r\n]+/);
                    return i.forEach(function(t, n) {
                        var r = t.match(/^[\s\t]*;/),
                            o = t.match(/^[\s\t]*$/);
                        if (!r && !o) {
                            var a = t.match("^\\t{" + e.currentIndent + "}(\\w+):(.*){", ""),
                                s = t.match("^\\t{" + e.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
                                c = t.match("^\\t{" + (e.currentIndent - 1) + "}}");
                            a ? e.parseNodeBegin(t, a) : s ? e.parseNodeProperty(t, s, i[++n]) : c ? e.popStack() : t.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(t)
                        }
                    }), this.allNodes
                },
                parseNodeBegin: function(t, e) {
                    var i = e[1].trim().replace(/^"/, "").replace(/"$/, ""),
                        n = e[2].split(",").map(function(t) {
                            return t.trim().replace(/^"/, "").replace(/"$/, "")
                        }),
                        r = {
                            name: i
                        },
                        o = this.parseNodeAttr(n),
                        a = this.getCurrentNode();
                    0 === this.currentIndent ? this.allNodes.add(i, r) : i in a ? ("PoseNode" === i ? a.PoseNode.push(r) : void 0 !== a[i].id && (a[i] = {}, a[i][a[i].id] = a[i]), "" !== o.id && (a[i][o.id] = r)) : "number" == typeof o.id ? (a[i] = {}, a[i][o.id] = r) : "Properties70" !== i && (a[i] = "PoseNode" === i ? [r] : r), "number" == typeof o.id && (r.id = o.id), "" !== o.name && (r.attrName = o.name), "" !== o.type && (r.attrType = o.type), this.pushStack(r)
                },
                parseNodeAttr: function(t) {
                    var e = t[0];
                    "" !== t[0] && (e = parseInt(t[0]), isNaN(e) && (e = t[0]));
                    var i = "",
                        n = "";
                    return t.length > 1 && (i = t[1].replace(/^(\w+)::/, ""), n = t[2]), {
                        id: e,
                        name: i,
                        type: n
                    }
                },
                parseNodeProperty: function(t, e, i) {
                    var n = e[1].replace(/^"/, "").replace(/"$/, "").trim(),
                        r = e[2].replace(/^"/, "").replace(/"$/, "").trim();
                    "Content" === n && "," === r && (r = i.replace(/"/g, "").replace(/,$/, "").trim());
                    var o = this.getCurrentNode();
                    if ("Properties70" !== o.name) {
                        if ("C" === n) {
                            var a = r.split(",").slice(1),
                                s = parseInt(a[0]),
                                c = parseInt(a[1]),
                                l = r.split(",").slice(3);
                            n = "connections",
                                function(t, e) {
                                    for (var i = 0, n = t.length, r = e.length; i < r; i++, n++) t[n] = e[i]
                                }(r = [s, c], l = l.map(function(t) {
                                    return t.trim().replace(/^"/, "")
                                })), void 0 === o[n] && (o[n] = [])
                        }
                        "Node" === n && (o.id = r), n in o && Array.isArray(o[n]) ? o[n].push(r) : "a" !== n ? o[n] = r : o.a = r, this.setCurrentProp(o, n), "a" === n && "," !== r.slice(-1) && (o.a = b(r))
                    } else this.parseNodeSpecialProperty(t, n, r)
                },
                parseNodePropertyContinued: function(t) {
                    var e = this.getCurrentNode();
                    e.a += t, "," !== t.slice(-1) && (e.a = b(e.a))
                },
                parseNodeSpecialProperty: function(t, e, i) {
                    var n = i.split('",').map(function(t) {
                            return t.trim().replace(/^\"/, "").replace(/\s/, "_")
                        }),
                        r = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        c = n[4];
                    switch (o) {
                        case "int":
                        case "enum":
                        case "bool":
                        case "ULongLong":
                        case "double":
                        case "Number":
                        case "FieldOfView":
                            c = parseFloat(c);
                            break;
                        case "Color":
                        case "ColorRGB":
                        case "Vector3D":
                        case "Lcl_Translation":
                        case "Lcl_Rotation":
                        case "Lcl_Scaling":
                            c = b(c)
                    }
                    this.getPrevNode()[r] = {
                        type: o,
                        type2: a,
                        flag: s,
                        value: c
                    }, this.setCurrentProp(this.getPrevNode(), r)
                }
            }, h.prototype = {
                constructor: h,
                parse: function(t) {
                    var e = new u(t);
                    e.skip(23);
                    var i = e.getUint32();
                    console.log("THREE.FBXLoader: FBX binary version: " + i);
                    for (var n = new d; !this.endOfContent(e);) {
                        var r = this.parseNode(e, i);
                        null !== r && n.add(r.name, r)
                    }
                    return n
                },
                endOfContent: function(t) {
                    return t.size() % 16 == 0 ? (t.getOffset() + 160 + 16 & -16) >= t.size() : t.getOffset() + 160 + 16 >= t.size()
                },
                parseNode: function(t, e) {
                    var i = {},
                        n = e >= 7500 ? t.getUint64() : t.getUint32(),
                        r = e >= 7500 ? t.getUint64() : t.getUint32(),
                        o = (e >= 7500 ? t.getUint64() : t.getUint32(), t.getUint8()),
                        a = t.getString(o);
                    if (0 === n) return null;
                    for (var s = [], c = 0; c < r; c++) s.push(this.parseProperty(t));
                    var l = s.length > 0 ? s[0] : "",
                        h = s.length > 1 ? s[1] : "",
                        u = s.length > 2 ? s[2] : "";
                    for (i.singleProperty = 1 === r && t.getOffset() === n; n > t.getOffset();) {
                        var d = this.parseNode(t, e);
                        null !== d && this.parseSubNode(a, i, d)
                    }
                    return i.propertyList = s, "number" == typeof l && (i.id = l), "" !== h && (i.attrName = h), "" !== u && (i.attrType = u), "" !== a && (i.name = a), i
                },
                parseSubNode: function(t, e, i) {
                    if (!0 === i.singleProperty) {
                        var n = i.propertyList[0];
                        Array.isArray(n) ? (e[i.name] = i, i.a = n) : e[i.name] = n
                    } else if ("Connections" === t && "C" === i.name) {
                        var r = [];
                        i.propertyList.forEach(function(t, e) {
                            0 !== e && r.push(t)
                        }), void 0 === e.connections && (e.connections = []), e.connections.push(r)
                    } else if ("Properties70" === i.name) {
                        Object.keys(i).forEach(function(t) {
                            e[t] = i[t]
                        })
                    } else if ("Properties70" === t && "P" === i.name) {
                        var o, a = i.propertyList[0],
                            s = i.propertyList[1],
                            c = i.propertyList[2],
                            l = i.propertyList[3];
                        0 === a.indexOf("Lcl ") && (a = a.replace("Lcl ", "Lcl_")), 0 === s.indexOf("Lcl ") && (s = s.replace("Lcl ", "Lcl_")), o = "Color" === s || "ColorRGB" === s || "Vector" === s || "Vector3D" === s || 0 === s.indexOf("Lcl_") ? [i.propertyList[4], i.propertyList[5], i.propertyList[6]] : i.propertyList[4], e[a] = {
                            type: s,
                            type2: c,
                            flag: l,
                            value: o
                        }
                    } else void 0 === e[i.name] ? "number" == typeof i.id ? (e[i.name] = {}, e[i.name][i.id] = i) : e[i.name] = i : "PoseNode" === i.name ? (Array.isArray(e[i.name]) || (e[i.name] = [e[i.name]]), e[i.name].push(i)) : void 0 === e[i.name][i.id] && (e[i.name][i.id] = i)
                },
                parseProperty: function(t) {
                    var e = t.getString(1);
                    switch (e) {
                        case "C":
                            return t.getBoolean();
                        case "D":
                            return t.getFloat64();
                        case "F":
                            return t.getFloat32();
                        case "I":
                            return t.getInt32();
                        case "L":
                            return t.getInt64();
                        case "R":
                            var i = t.getUint32();
                            return t.getArrayBuffer(i);
                        case "S":
                            i = t.getUint32();
                            return t.getString(i);
                        case "Y":
                            return t.getInt16();
                        case "b":
                        case "c":
                        case "d":
                        case "f":
                        case "i":
                        case "l":
                            var n = t.getUint32(),
                                r = t.getUint32(),
                                o = t.getUint32();
                            if (0 === r) switch (e) {
                                case "b":
                                case "c":
                                    return t.getBooleanArray(n);
                                case "d":
                                    return t.getFloat64Array(n);
                                case "f":
                                    return t.getFloat32Array(n);
                                case "i":
                                    return t.getInt32Array(n);
                                case "l":
                                    return t.getInt64Array(n)
                            }
                            "undefined" == typeof Zlib && console.error("THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js");
                            var a = new u(new Zlib.Inflate(new Uint8Array(t.getArrayBuffer(o))).decompress().buffer);
                            switch (e) {
                                case "b":
                                case "c":
                                    return a.getBooleanArray(n);
                                case "d":
                                    return a.getFloat64Array(n);
                                case "f":
                                    return a.getFloat32Array(n);
                                case "i":
                                    return a.getInt32Array(n);
                                case "l":
                                    return a.getInt64Array(n)
                            }
                        default:
                            throw new Error("THREE.FBXLoader: Unknown property type " + e)
                    }
                }
            }, u.prototype = {
                constructor: u,
                getOffset: function() {
                    return this.offset
                },
                size: function() {
                    return this.dv.buffer.byteLength
                },
                skip: function(t) {
                    this.offset += t
                },
                getBoolean: function() {
                    return 1 == (1 & this.getUint8())
                },
                getBooleanArray: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getBoolean());
                    return e
                },
                getUint8: function() {
                    var t = this.dv.getUint8(this.offset);
                    return this.offset += 1, t
                },
                getInt16: function() {
                    var t = this.dv.getInt16(this.offset, this.littleEndian);
                    return this.offset += 2, t
                },
                getInt32: function() {
                    var t = this.dv.getInt32(this.offset, this.littleEndian);
                    return this.offset += 4, t
                },
                getInt32Array: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getInt32());
                    return e
                },
                getUint32: function() {
                    var t = this.dv.getUint32(this.offset, this.littleEndian);
                    return this.offset += 4, t
                },
                getInt64: function() {
                    var t, e;
                    return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 2147483648 & e ? (e = 4294967295 & ~e, 4294967295 === (t = 4294967295 & ~t) && (e = e + 1 & 4294967295), -(4294967296 * e + (t = t + 1 & 4294967295))) : 4294967296 * e + t
                },
                getInt64Array: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getInt64());
                    return e
                },
                getUint64: function() {
                    var t, e;
                    return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 4294967296 * e + t
                },
                getFloat32: function() {
                    var t = this.dv.getFloat32(this.offset, this.littleEndian);
                    return this.offset += 4, t
                },
                getFloat32Array: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getFloat32());
                    return e
                },
                getFloat64: function() {
                    var t = this.dv.getFloat64(this.offset, this.littleEndian);
                    return this.offset += 8, t
                },
                getFloat64Array: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getFloat64());
                    return e
                },
                getArrayBuffer: function(t) {
                    var e = this.dv.buffer.slice(this.offset, this.offset + t);
                    return this.offset += t, e
                },
                getString: function(e) {
                    for (var i = [], n = 0; n < e; n++) i[n] = this.getUint8();
                    var r = i.indexOf(0);
                    return r >= 0 && (i = i.slice(0, r)), t.LoaderUtils.decodeText(new Uint8Array(i))
                }
            }, d.prototype = {
                constructor: d,
                add: function(t, e) {
                    this[t] = e
                }
            };
            var m = [];

            function g(t, e, i, n) {
                var r;
                switch (n.mappingType) {
                    case "ByPolygonVertex":
                        r = t;
                        break;
                    case "ByPolygon":
                        r = e;
                        break;
                    case "ByVertice":
                        r = i;
                        break;
                    case "AllSame":
                        r = n.indices[0];
                        break;
                    default:
                        console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType)
                }
                "IndexToDirect" === n.referenceType && (r = n.indices[r]);
                var o = r * n.dataSize,
                    a = o + n.dataSize;
                return function(t, e, i, n) {
                    for (var r = i, o = 0; r < n; r++, o++) t[o] = e[r];
                    return t
                }(m, n.buffer, o, a)
            }
            var v = new t.Euler,
                y = new t.Vector3;

            function _(e) {
                var i, n = new t.Matrix4,
                    r = new t.Matrix4,
                    o = new t.Matrix4,
                    a = new t.Matrix4,
                    s = new t.Matrix4,
                    c = new t.Matrix4,
                    l = new t.Matrix4,
                    h = new t.Matrix4,
                    u = new t.Matrix4,
                    d = new t.Matrix4,
                    p = new t.Matrix4,
                    f = e.inheritType ? e.inheritType : 0;
                (e.translation && n.setPosition(y.fromArray(e.translation)), e.preRotation) && ((i = e.preRotation.map(t.Math.degToRad)).push(e.eulerOrder), r.makeRotationFromEuler(v.fromArray(i)));
                e.rotation && ((i = e.rotation.map(t.Math.degToRad)).push(e.eulerOrder), o.makeRotationFromEuler(v.fromArray(i)));
                e.postRotation && ((i = e.postRotation.map(t.Math.degToRad)).push(e.eulerOrder), a.makeRotationFromEuler(v.fromArray(i)));
                e.scale && s.scale(y.fromArray(e.scale)), e.scalingOffset && l.setPosition(y.fromArray(e.scalingOffset)), e.scalingPivot && c.setPosition(y.fromArray(e.scalingPivot)), e.rotationOffset && h.setPosition(y.fromArray(e.rotationOffset)), e.rotationPivot && u.setPosition(y.fromArray(e.rotationPivot)), e.parentMatrixWorld && (d = e.parentMatrixWorld);
                var m = r.multiply(o).multiply(a),
                    g = new t.Matrix4;
                d.extractRotation(g);
                var _, x, b, w, M = new t.Matrix4;
                if (M.copyPosition(d), b = M.getInverse(M).multiply(d), x = g.getInverse(g).multiply(b), _ = s, 0 === f) w = g.multiply(m).multiply(x).multiply(_);
                else if (1 === f) w = g.multiply(x).multiply(m).multiply(_);
                else {
                    var T = (new t.Matrix4).copy(s),
                        E = x.multiply(T.getInverse(T));
                    w = g.multiply(m).multiply(E).multiply(_)
                }
                var S = n.multiply(h).multiply(u).multiply(r).multiply(o).multiply(a).multiply(u.getInverse(u)).multiply(l).multiply(c).multiply(s).multiply(c.getInverse(c)),
                    A = (new t.Matrix4).copyPosition(S),
                    P = d.multiply(A);
                return p.copyPosition(P), S = p.multiply(w)
            }

            function x(t) {
                var e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
                return 6 === (t = t || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[t]
            }

            function b(t) {
                return t.split(",").map(function(t) {
                    return parseFloat(t)
                })
            }

            function w(e, i, n) {
                return void 0 === i && (i = 0), void 0 === n && (n = e.byteLength), t.LoaderUtils.decodeText(new Uint8Array(e, i, n))
            }

            function M(t, e, i) {
                return t.slice(0, e).concat(i).concat(t.slice(e))
            }
            return o
        }()
    }).call(this, i(1))
}, function(t, e, i) {
    (function(t) {
        t.OrbitControls = function(e, i) {
            this.object = e, this.domElement = void 0 !== i ? i : document, this.enabled = !0, this.target = new t.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                BOTTOM: 40
            }, this.mouseButtons = {
                LEFT: t.MOUSE.LEFT,
                MIDDLE: t.MOUSE.MIDDLE,
                RIGHT: t.MOUSE.RIGHT
            }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
                return h.phi
            }, this.getAzimuthalAngle = function() {
                return h.theta
            }, this.saveState = function() {
                n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
            }, this.reset = function() {
                n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(r), n.update(), c = s.NONE
            }, this.update = function() {
                var i = new t.Vector3,
                    o = (new t.Quaternion).setFromUnitVectors(e.up, new t.Vector3(0, 1, 0)),
                    a = o.clone().inverse(),
                    m = new t.Vector3,
                    g = new t.Quaternion;
                return function() {
                    var t = n.object.position;
                    return i.copy(t).sub(n.target), i.applyQuaternion(o), h.setFromVector3(i), n.autoRotate && c === s.NONE && E(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), h.theta += u.theta, h.phi += u.phi, h.theta = Math.max(n.minAzimuthAngle, Math.min(n.maxAzimuthAngle, h.theta)), h.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, h.phi)), h.makeSafe(), h.radius *= d, h.radius = Math.max(n.minDistance, Math.min(n.maxDistance, h.radius)), n.target.add(p), i.setFromSpherical(h), i.applyQuaternion(a), t.copy(n.target).add(i), n.object.lookAt(n.target), !0 === n.enableDamping ? (u.theta *= 1 - n.dampingFactor, u.phi *= 1 - n.dampingFactor, p.multiplyScalar(1 - n.dampingFactor)) : (u.set(0, 0, 0), p.set(0, 0, 0)), d = 1, !!(f || m.distanceToSquared(n.object.position) > l || 8 * (1 - g.dot(n.object.quaternion)) > l) && (n.dispatchEvent(r), m.copy(n.object.position), g.copy(n.object.quaternion), f = !1, !0)
                }
            }(), this.dispose = function() {
                n.domElement.removeEventListener("contextmenu", G, !1), n.domElement.removeEventListener("mousedown", I, !1), n.domElement.removeEventListener("wheel", N, !1), n.domElement.removeEventListener("touchstart", F, !1), n.domElement.removeEventListener("touchend", U, !1), n.domElement.removeEventListener("touchmove", z, !1), document.removeEventListener("mousemove", D, !1), document.removeEventListener("mouseup", k, !1), window.removeEventListener("keydown", B, !1)
            };
            var n = this,
                r = {
                    type: "change"
                },
                o = {
                    type: "start"
                },
                a = {
                    type: "end"
                },
                s = {
                    NONE: -1,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                    TOUCH_ROTATE: 3,
                    TOUCH_DOLLY_PAN: 4
                },
                c = s.NONE,
                l = 1e-6,
                h = new t.Spherical,
                u = new t.Spherical,
                d = 1,
                p = new t.Vector3,
                f = !1,
                m = new t.Vector2,
                g = new t.Vector2,
                v = new t.Vector2,
                y = new t.Vector2,
                _ = new t.Vector2,
                x = new t.Vector2,
                b = new t.Vector2,
                w = new t.Vector2,
                M = new t.Vector2;

            function T() {
                return Math.pow(.95, n.zoomSpeed)
            }

            function E(t) {
                u.theta -= t
            }

            function S(t) {
                u.phi -= t
            }
            var A = function() {
                    var e = new t.Vector3;
                    return function(t, i) {
                        e.setFromMatrixColumn(i, 0), e.multiplyScalar(-t), p.add(e)
                    }
                }(),
                P = function() {
                    var e = new t.Vector3;
                    return function(t, i) {
                        !0 === n.screenSpacePanning ? e.setFromMatrixColumn(i, 1) : (e.setFromMatrixColumn(i, 0), e.crossVectors(n.object.up, e)), e.multiplyScalar(t), p.add(e)
                    }
                }(),
                L = function() {
                    var e = new t.Vector3;
                    return function(t, i) {
                        var r = n.domElement === document ? n.domElement.body : n.domElement;
                        if (n.object.isPerspectiveCamera) {
                            var o = n.object.position;
                            e.copy(o).sub(n.target);
                            var a = e.length();
                            a *= Math.tan(n.object.fov / 2 * Math.PI / 180), A(2 * t * a / r.clientHeight, n.object.matrix), P(2 * i * a / r.clientHeight, n.object.matrix)
                        } else n.object.isOrthographicCamera ? (A(t * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix), P(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                    }
                }();

            function C(t) {
                n.object.isPerspectiveCamera ? d /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)), n.object.updateProjectionMatrix(), f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
            }

            function R(t) {
                n.object.isPerspectiveCamera ? d *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)), n.object.updateProjectionMatrix(), f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
            }

            function O(t) {
                y.set(t.clientX, t.clientY)
            }

            function I(t) {
                if (!1 !== n.enabled) {
                    switch (t.preventDefault(), t.button) {
                        case n.mouseButtons.LEFT:
                            if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                if (!1 === n.enablePan) return;
                                O(t), c = s.PAN
                            } else {
                                if (!1 === n.enableRotate) return;
                                ! function(t) {
                                    m.set(t.clientX, t.clientY)
                                }(t), c = s.ROTATE
                            }
                            break;
                        case n.mouseButtons.MIDDLE:
                            if (!1 === n.enableZoom) return;
                            ! function(t) {
                                b.set(t.clientX, t.clientY)
                            }(t), c = s.DOLLY;
                            break;
                        case n.mouseButtons.RIGHT:
                            if (!1 === n.enablePan) return;
                            O(t), c = s.PAN
                    }
                    c !== s.NONE && (document.addEventListener("mousemove", D, !1), document.addEventListener("mouseup", k, !1), n.dispatchEvent(o))
                }
            }

            function D(t) {
                if (!1 !== n.enabled) switch (t.preventDefault(), c) {
                    case s.ROTATE:
                        if (!1 === n.enableRotate) return;
                        ! function(t) {
                            g.set(t.clientX, t.clientY), v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
                            var e = n.domElement === document ? n.domElement.body : n.domElement;
                            E(2 * Math.PI * v.x / e.clientHeight), S(2 * Math.PI * v.y / e.clientHeight), m.copy(g), n.update()
                        }(t);
                        break;
                    case s.DOLLY:
                        if (!1 === n.enableZoom) return;
                        ! function(t) {
                            w.set(t.clientX, t.clientY), M.subVectors(w, b), M.y > 0 ? C(T()) : M.y < 0 && R(T()), b.copy(w), n.update()
                        }(t);
                        break;
                    case s.PAN:
                        if (!1 === n.enablePan) return;
                        ! function(t) {
                            _.set(t.clientX, t.clientY), x.subVectors(_, y).multiplyScalar(n.panSpeed), L(x.x, x.y), y.copy(_), n.update()
                        }(t)
                }
            }

            function k(t) {
                !1 !== n.enabled && (document.removeEventListener("mousemove", D, !1), document.removeEventListener("mouseup", k, !1), n.dispatchEvent(a), c = s.NONE)
            }

            function N(t) {
                !1 === n.enabled || !1 === n.enableZoom || c !== s.NONE && c !== s.ROTATE || (t.preventDefault(), t.stopPropagation(), n.dispatchEvent(o), function(t) {
                    t.deltaY < 0 ? R(T()) : t.deltaY > 0 && C(T()), n.update()
                }(t), n.dispatchEvent(a))
            }

            function B(t) {
                !1 !== n.enabled && !1 !== n.enableKeys && !1 !== n.enablePan && function(t) {
                    switch (t.keyCode) {
                        case n.keys.UP:
                            L(0, n.keyPanSpeed), n.update();
                            break;
                        case n.keys.BOTTOM:
                            L(0, -n.keyPanSpeed), n.update();
                            break;
                        case n.keys.LEFT:
                            L(n.keyPanSpeed, 0), n.update();
                            break;
                        case n.keys.RIGHT:
                            L(-n.keyPanSpeed, 0), n.update()
                    }
                }(t)
            }

            function F(t) {
                if (!1 !== n.enabled) {
                    switch (t.preventDefault(), t.touches.length) {
                        case 1:
                            if (!1 === n.enableRotate) return;
                            ! function(t) {
                                m.set(t.touches[0].pageX, t.touches[0].pageY)
                            }(t), c = s.TOUCH_ROTATE;
                            break;
                        case 2:
                            if (!1 === n.enableZoom && !1 === n.enablePan) return;
                            ! function(t) {
                                if (n.enableZoom) {
                                    var e = t.touches[0].pageX - t.touches[1].pageX,
                                        i = t.touches[0].pageY - t.touches[1].pageY,
                                        r = Math.sqrt(e * e + i * i);
                                    b.set(0, r)
                                }
                                if (n.enablePan) {
                                    var o = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                                        a = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                                    y.set(o, a)
                                }
                            }(t), c = s.TOUCH_DOLLY_PAN;
                            break;
                        default:
                            c = s.NONE
                    }
                    c !== s.NONE && n.dispatchEvent(o)
                }
            }

            function z(t) {
                if (!1 !== n.enabled) switch (t.preventDefault(), t.stopPropagation(), t.touches.length) {
                    case 1:
                        if (!1 === n.enableRotate) return;
                        if (c !== s.TOUCH_ROTATE) return;
                        ! function(t) {
                            g.set(t.touches[0].pageX, t.touches[0].pageY), v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
                            var e = n.domElement === document ? n.domElement.body : n.domElement;
                            E(2 * Math.PI * v.x / e.clientHeight), S(2 * Math.PI * v.y / e.clientHeight), m.copy(g), n.update()
                        }(t);
                        break;
                    case 2:
                        if (!1 === n.enableZoom && !1 === n.enablePan) return;
                        if (c !== s.TOUCH_DOLLY_PAN) return;
                        ! function(t) {
                            if (n.enableZoom) {
                                var e = t.touches[0].pageX - t.touches[1].pageX,
                                    i = t.touches[0].pageY - t.touches[1].pageY,
                                    r = Math.sqrt(e * e + i * i);
                                w.set(0, r), M.set(0, Math.pow(w.y / b.y, n.zoomSpeed)), C(M.y), b.copy(w)
                            }
                            if (n.enablePan) {
                                var o = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                                    a = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                                _.set(o, a), x.subVectors(_, y).multiplyScalar(n.panSpeed), L(x.x, x.y), y.copy(_)
                            }
                            n.update()
                        }(t);
                        break;
                    default:
                        c = s.NONE
                }
            }

            function U(t) {
                !1 !== n.enabled && (n.dispatchEvent(a), c = s.NONE)
            }

            function G(t) {
                !1 !== n.enabled && t.preventDefault()
            }
            n.domElement.addEventListener("contextmenu", G, !1), n.domElement.addEventListener("mousedown", I, !1), n.domElement.addEventListener("wheel", N, !1), n.domElement.addEventListener("touchstart", F, !1), n.domElement.addEventListener("touchend", U, !1), n.domElement.addEventListener("touchmove", z, !1), window.addEventListener("keydown", B, !1), this.update()
        }, t.OrbitControls.prototype = Object.create(t.EventDispatcher.prototype), t.OrbitControls.prototype.constructor = t.OrbitControls, Object.defineProperties(t.OrbitControls.prototype, {
            center: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target
                }
            },
            noZoom: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !t
                }
            },
            noRotate: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !t
                }
            },
            noPan: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !t
                }
            },
            noKeys: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !t
                }
            },
            staticMoving: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !t
                }
            },
            dynamicDampingFactor: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = t
                }
            }
        })
    }).call(this, i(1))
}, function(t, e, i) {
    "use strict";
    i(1), i(14), i(15)
}, function(t, e) {
    t.exports = ""
}, function(t, e) {
    t.exports = ""
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
        }
    }
    new(function() {
        function t() {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.mediaStreamSource = null, this.audioContext = null, this.meter = null
        }
        return function(t, e, i) {
            e && n(t.prototype, e), i && n(t, i)
        }(t, [{
            key: "init",
            value: function() {
                this.startAudioContext()
            }
        }, {
            key: "startAudioContext",
            value: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext, this.audioContext = new AudioContext;
                navigator.mediaDevices.getUserMedia({
                    audio: !0,
                    video: !1
                }).then(this.gotStream.bind(this)).catch(this.didntGetStream.bind(this))
            }
        }, {
            key: "didntGetStream",
            value: function() {
                alert("Stream generation failed.")
            }
        }, {
            key: "gotStream",
            value: function(t) {
                console.log("l"), this.mediaStreamSource = this.audioContext.createMediaStreamSource(t), this.meter = this.createAudioMeter(this.audioContext), this.mediaStreamSource.connect(this.meter)
            }
        }, {
            key: "createAudioMeter",
            value: function(t, e, i, n) {
                var r = t.createScriptProcessor(512);
                return r.onaudioprocess = this.volumeAudioProcess, r.clipping = !1, r.lastClip = 0, r.volume = 0, r.clipLevel = e || .98, r.averaging = i || .95, r.clipLag = n || 750, r.connect(t.destination), r.checkClipping = function() {
                    return !!this.clipping && (this.lastClip + this.clipLag < window.performance.now() && (this.clipping = !1), this.clipping)
                }, r.shutdown = function() {
                    this.disconnect(), this.onaudioprocess = null
                }, r
            }
        }, {
            key: "volumeAudioProcess",
            value: function(t) {
                for (var e, i = t.inputBuffer.getChannelData(0), n = i.length, r = 0, o = 0; o < n; o++) e = i[o], Math.abs(e) >= this.clipLevel && (this.clipping = !0, this.lastClip = window.performance.now()), r += e * e;
                var a = Math.sqrt(r / n);
                this.volume = Math.max(a, this.volume * this.averaging)
            }
        }]), t
    }())
}, function(t, e, i) {
    "use strict";
    (function(e) {
        var n, r, o, a = new(i(18)),
            s = t.exports = {
                noiseLevelConst: 5e3,
                noiseOffConst: 2e3,
                noiseOffSlowConst: 2e3,
                onFastConstant: -.4,
                onFastNumOfVar: 4,
                offSlowNumOfPow: 10,
                offFastConst: .5,
                functionRunning: !1,
                ThrOnFast: 1,
                ThrOffFast: 1,
                ThrOffSlow: 1,
                maxVariance: 0,
                minVariance: 0,
                pow: 0,
                noiseLevel: -1,
                pwVariance: 0,
                varOffVar: 0,
                sampleSize: 1024,
                fftSize: 1024,
                frequencyBin: [],
                countBlow: 0,
                windowArray: [],
                vcd: 0,
                windowArray_2: [],
                vcd_2: 0,
                mainCondition: !1,
                offFastVar: 0,
                offFastVarCount: 0,
                pcd: 0,
                PowerWindow: [],
                pw: 0,
                run: function(t) {
                    this.pfu = t || {}, this.pfu.onFNlc && (s.noiseLevelConst = this.pfu.onFNlc), this.pfu.onFvar && (s.onFastNumOfVar = this.pfu.onFvar), this.pfu.onFCvar && (s.onFastConstant = this.pfu.onFCvar, s.onFastConstant = -1 * s.onFastConstant),
                        function(t, e) {
                            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia, navigator.getUserMedia(t, e, h)
                        }({
                            audio: !0
                        }, l)
                },
                events: a
            };
        window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.oAudioContext || window.msAudioContext;
        var c = new e.AudioContext;

        function l(t) {
            var e;
            n = c.createMediaStreamSource(t), (r = c.createAnalyser()).smoothingTimeConstant = .3, r.fftSize = s.fftSize, (o = c.createScriptProcessor(s.sampleSize, 1, 1)).onaudioprocess = function() {
                s.pow = 0, e = new Uint8Array(r.frequencyBinCount), r.getByteFrequencyData(e);
                for (var t = 0; t < e.length; t++) s.frequencyBin[t] = e[t];
                s.frequencyBin.forEach(function(t) {
                    s.pow += t
                }), -1 === s.noiseLevel ? s.noiseLevel = s.pow : s.pow < s.noiseLevel ? s.noiseLevel = s.pow : s.pow > s.noiseLevel && (s.countBlow < 30 ? s.noiseLevel = s.noiseLevel + 10 : s.countBlow > 30 && (s.noiseLevel = s.noiseLevel + 0)), s.ThrOnFast = Math.round(s.noiseLevel + s.noiseLevelConst), s.ThrOffFast = Math.round(s.noiseLevel + s.noiseOffConst), s.ThrOffSlow = Math.round(s.noiseLevel + s.noiseOffSlowConst), s.PowerWindow[s.pw] = s.pow, s.pw > 0 && s.pw < 500 ? s.pwVariance = Math.round(s.PowerWindow[s.pw] - s.PowerWindow[s.pw - 1]) : s.pw > 500 && (s.pw = 0, s.PowerWindow.length = 0), s.pw++, !1 === s.functionRunning ? (s.countBlow = 0, function(t, e) {
                    t > s.ThrOnFast && !1 === s.mainCondition ? e > 0 && e > s.maxVariance ? (s.maxVariance = e, s.minVariance = Math.round(s.onFastConstant * s.maxVariance), s.varOffVar = s.minVariance * s.offFastConst) : e < 0 && e < s.maxVariance && (s.mainCondition = !0) : t > s.ThrOnFast && !0 === s.mainCondition && (s.windowArray[s.vcd] = e, s.vcd === s.onFastNumOfVar ? s.windowArray.every(d) ? (s.functionRunning = !0, u.start()) : (s.mainCondition = !1, s.vcd = 0, s.windowArray.length = 0, s.maxVariance = 0, s.minVariance = 0) : s.vcd++);
                    s.pcd < 35 ? t > s.ThrOnFast && e > -3e3 ? s.pcd++ : s.pcd = 0 : (s.functionRunning = !0, u.start(), s.pcd = 0)
                }(s.pow, s.pwVariance)) : !0 === s.functionRunning && (s.countBlow++, function(t, e) {
                    s.offFastVarCount < 15 ? (e < s.offFastVar && (s.offFastVar = e), s.offFastVarCount++) : s.offFastVarCount = 0;
                    t < s.ThrOffFast && s.offFastVar < s.varOffVar ? f() : t < s.ThrOffFast && s.offFastVar > s.varOffVar && (s.windowArray_2[s.vcd_2] = t, s.vcd_2 === s.offSlowNumOfPow ? (s.windowArray_2.every(p) && f(), s.windowArray_2.splice(0, 1)) : s.vcd_2++)
                }(s.pow, s.pwVariance))
            }, n.connect(r), r.connect(o), o.connect(c.destination)
        }

        function h() {
            e.alert("Stream generation failed")
        }
        var u = {
            stop: function() {
                a.emit("stop")
            },
            start: function() {
                s.functionRunning = !0, a.emit("start")
            }
        };

        function d(t, e, i) {
            return t > s.minVariance && t < -1 * s.minVariance
        }

        function p(t, e, i) {
            return t < s.ThrOffSlow
        }

        function f() {
            s.vcd = 0, s.vcd_2 = 0, s.pw = 0, s.pcd = 0, s.maxVariance = 0, s.minVariance = 0, s.varOffVar = 0, s.mainCondition = !1, s.windowArray.length = 0, s.windowArray_2.length = 0, s.offFastVar = 0, s.offFastVarCount = 0, s.functionRunning = !1, u.stop()
        }
    }).call(this, i(3))
}, function(t, e) {
    function i() {
        this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0
    }

    function n(t) {
        return "function" == typeof t
    }

    function r(t) {
        return "object" == typeof t && null !== t
    }

    function o(t) {
        return void 0 === t
    }
    t.exports = i, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._maxListeners = void 0, i.defaultMaxListeners = 10, i.prototype.setMaxListeners = function(t) {
        if (! function(t) {
                return "number" == typeof t
            }(t) || t < 0 || isNaN(t)) throw TypeError("n must be a positive number");
        return this._maxListeners = t, this
    }, i.prototype.emit = function(t) {
        var e, i, a, s, c, l;
        if (this._events || (this._events = {}), "error" === t && (!this._events.error || r(this._events.error) && !this._events.error.length)) {
            if ((e = arguments[1]) instanceof Error) throw e;
            var h = new Error('Uncaught, unspecified "error" event. (' + e + ")");
            throw h.context = e, h
        }
        if (o(i = this._events[t])) return !1;
        if (n(i)) switch (arguments.length) {
            case 1:
                i.call(this);
                break;
            case 2:
                i.call(this, arguments[1]);
                break;
            case 3:
                i.call(this, arguments[1], arguments[2]);
                break;
            default:
                s = Array.prototype.slice.call(arguments, 1), i.apply(this, s)
        } else if (r(i))
            for (s = Array.prototype.slice.call(arguments, 1), a = (l = i.slice()).length, c = 0; c < a; c++) l[c].apply(this, s);
        return !0
    }, i.prototype.addListener = function(t, e) {
        var a;
        if (!n(e)) throw TypeError("listener must be a function");
        return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", t, n(e.listener) ? e.listener : e), this._events[t] ? r(this._events[t]) ? this._events[t].push(e) : this._events[t] = [this._events[t], e] : this._events[t] = e, r(this._events[t]) && !this._events[t].warned && (a = o(this._maxListeners) ? i.defaultMaxListeners : this._maxListeners) && a > 0 && this._events[t].length > a && (this._events[t].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[t].length), "function" == typeof console.trace && console.trace()), this
    }, i.prototype.on = i.prototype.addListener, i.prototype.once = function(t, e) {
        if (!n(e)) throw TypeError("listener must be a function");
        var i = !1;

        function r() {
            this.removeListener(t, r), i || (i = !0, e.apply(this, arguments))
        }
        return r.listener = e, this.on(t, r), this
    }, i.prototype.removeListener = function(t, e) {
        var i, o, a, s;
        if (!n(e)) throw TypeError("listener must be a function");
        if (!this._events || !this._events[t]) return this;
        if (a = (i = this._events[t]).length, o = -1, i === e || n(i.listener) && i.listener === e) delete this._events[t], this._events.removeListener && this.emit("removeListener", t, e);
        else if (r(i)) {
            for (s = a; s-- > 0;)
                if (i[s] === e || i[s].listener && i[s].listener === e) {
                    o = s;
                    break
                }
            if (o < 0) return this;
            1 === i.length ? (i.length = 0, delete this._events[t]) : i.splice(o, 1), this._events.removeListener && this.emit("removeListener", t, e)
        }
        return this
    }, i.prototype.removeAllListeners = function(t) {
        var e, i;
        if (!this._events) return this;
        if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[t] && delete this._events[t], this;
        if (0 === arguments.length) {
            for (e in this._events) "removeListener" !== e && this.removeAllListeners(e);
            return this.removeAllListeners("removeListener"), this._events = {}, this
        }
        if (n(i = this._events[t])) this.removeListener(t, i);
        else if (i)
            for (; i.length;) this.removeListener(t, i[i.length - 1]);
        return delete this._events[t], this
    }, i.prototype.listeners = function(t) {
        return this._events && this._events[t] ? n(this._events[t]) ? [this._events[t]] : this._events[t].slice() : []
    }, i.prototype.listenerCount = function(t) {
        if (this._events) {
            var e = this._events[t];
            if (n(e)) return 1;
            if (e) return e.length
        }
        return 0
    }, i.listenerCount = function(t, e) {
        return t.listenerCount(e)
    }
}, function(t, e, i) {}, function(t, e, i) {
    "use strict";
    i.r(e);
    i(7), i(8), i(9);
    var n = i(4);
    i(2);

    function r(t, e, i) {
        return e in t ? Object.defineProperty(t, e, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = i, t
    }

    function o(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
        }
    }
    var a = function() {
        function t(e) {
            var i = e.$el;
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.$el = i
        }
        return function(t, e, i) {
            e && o(t.prototype, e), i && o(t, i)
        }(t, [{
            key: "init",
            value: function() {
                this.initDOM(), this.initWebGL()
            }
        }, {
            key: "initDOM",
            value: function() {
                this.$el = document.querySelector(".Home"), this.$els = {}, this.$els = function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = null != arguments[e] ? arguments[e] : {},
                            n = Object.keys(i);
                        "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter(function(t) {
                            return Object.getOwnPropertyDescriptor(i, t).enumerable
                        }))), n.forEach(function(e) {
                            r(t, e, i[e])
                        })
                    }
                    return t
                }({}, this.$els, {
                    blow: this.$el.querySelector(".blow"),
                    blowSpans: this.$el.querySelectorAll("span")
                })
            }
        }, {
            key: "initWebGL",
            value: function() {
                n.a.init({
                    $el: document.querySelector(".App-wrapWebGL")
                })
            }
        }]), t
    }();

    function s(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
        }
    }
    var c = new(function() {
        function t() {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.$el = document.querySelector(".App"), this.home = new a({
                $el: this.$el.querySelector(".Home")
            })
        }
        return function(t, e, i) {
            e && s(t.prototype, e), i && s(t, i)
        }(t, [{
            key: "init",
            value: function() {
                this.home.init()
            }
        }]), t
    }());
    document.querySelector(".dg.ac").style.display = "none", c.init()
}]);
//# sourceMappingURL=app.47563f24.js.map! function(t) {
    var e = {};

    function i(n) {
        if (e[n]) return e[n].exports;
        var r = e[n] = {
            i: n,
            l: !1,
            exports: {}
        };
        return t[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports
    }
    i.m = t, i.c = e, i.d = function(t, e, n) {
        i.o(t, e) || Object.defineProperty(t, e, {
            enumerable: !0,
            get: n
        })
    }, i.r = function(t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, i.t = function(t, e) {
        if (1 & e && (t = i(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var n = Object.create(null);
        if (i.r(n), Object.defineProperty(n, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t)
            for (var r in t) i.d(n, r, function(e) {
                return t[e]
            }.bind(null, r));
        return n
    }, i.n = function(t) {
        var e = t && t.__esModule ? function() {
            return t.default
        } : function() {
            return t
        };
        return i.d(e, "a", e), e
    }, i.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, i.p = "", i(i.s = 20)
}([function(t, e, i) {
    "use strict";
    (function(t, n) {
        i.d(e, "e", function() {
            return r
        }), i.d(e, "g", function() {
            return a
        }), i.d(e, "f", function() {
            return o
        }), i.d(e, "c", function() {
            return c
        }), i.d(e, "a", function() {
            return l
        }), i.d(e, "b", function() {
            return h
        }), i.d(e, "d", function() {
            return u
        });
        /*!
         * VERSION: 2.0.2
         * DATE: 2018-08-27
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         *
         * @author: Jack Doyle, jack@greensock.com
         */
        var r = "undefined" != typeof window ? window : t.exports && void 0 !== n ? n : {},
            o = function(t, e) {
                var i = {},
                    n = t.document,
                    r = t.GreenSockGlobals = t.GreenSockGlobals || t;
                if (r.TweenLite) return r.TweenLite;
                var o, a, s, c, l, h = function(t) {
                        var e, i = t.split("."),
                            n = r;
                        for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
                        return n
                    },
                    u = h("com.greensock"),
                    d = function(t) {
                        var e, i = [],
                            n = t.length;
                        for (e = 0; e !== n; i.push(t[e++]));
                        return i
                    },
                    p = function() {},
                    f = function() {
                        var t = Object.prototype.toString,
                            e = t.call([]);
                        return function(i) {
                            return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
                        }
                    }(),
                    m = {},
                    g = function(t, e, n, o) {
                        this.sc = m[t] ? m[t].sc : [], m[t] = this, this.gsClass = null, this.func = n;
                        var a = [];
                        this.check = function(s) {
                            for (var c, l, u, d, p = e.length, f = p; --p > -1;)(c = m[e[p]] || new g(e[p], [])).gsClass ? (a[p] = c.gsClass, f--) : s && c.sc.push(this);
                            if (0 === f && n)
                                for (u = (l = ("com.greensock." + t).split(".")).pop(), d = h(l.join("."))[u] = this.gsClass = n.apply(n, a), o && (r[u] = i[u] = d), p = 0; p < this.sc.length; p++) this.sc[p].check()
                        }, this.check(!0)
                    },
                    v = t._gsDefine = function(t, e, i, n) {
                        return new g(t, e, i, n)
                    },
                    y = u._class = function(t, e, i) {
                        return e = e || function() {}, v(t, [], function() {
                            return e
                        }, i), e
                    };
                v.globals = r;
                var _ = [0, 0, 1, 1],
                    x = y("easing.Ease", function(t, e, i, n) {
                        this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? _.concat(e) : _
                    }, !0),
                    b = x.map = {},
                    w = x.register = function(t, e, i, n) {
                        for (var r, o, a, s, c = e.split(","), l = c.length, h = (i || "easeIn,easeOut,easeInOut").split(","); --l > -1;)
                            for (o = c[l], r = n ? y("easing." + o, null, !0) : u.easing[o] || {}, a = h.length; --a > -1;) s = h[a], b[o + "." + s] = b[s + o] = r[s] = t.getRatio ? t : t[s] || new t
                    };
                for ((s = x.prototype)._calcEnd = !1, s.getRatio = function(t) {
                        if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
                        var e = this._type,
                            i = this._power,
                            n = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t);
                        return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : t < .5 ? n / 2 : 1 - n / 2
                    }, a = (o = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --a > -1;) s = o[a] + ",Power" + a, w(new x(null, null, 1, a), s, "easeOut", !0), w(new x(null, null, 2, a), s, "easeIn" + (0 === a ? ",easeNone" : "")), w(new x(null, null, 3, a), s, "easeInOut");
                b.linear = u.easing.Linear.easeIn, b.swing = u.easing.Quad.easeInOut;
                var M = y("events.EventDispatcher", function(t) {
                    this._listeners = {}, this._eventTarget = t || this
                });
                (s = M.prototype).addEventListener = function(t, e, i, n, r) {
                    r = r || 0;
                    var o, a, s = this._listeners[t],
                        h = 0;
                    for (this !== c || l || c.wake(), null == s && (this._listeners[t] = s = []), a = s.length; --a > -1;)(o = s[a]).c === e && o.s === i ? s.splice(a, 1) : 0 === h && o.pr < r && (h = a + 1);
                    s.splice(h, 0, {
                        c: e,
                        s: i,
                        up: n,
                        pr: r
                    })
                }, s.removeEventListener = function(t, e) {
                    var i, n = this._listeners[t];
                    if (n)
                        for (i = n.length; --i > -1;)
                            if (n[i].c === e) return void n.splice(i, 1)
                }, s.dispatchEvent = function(t) {
                    var e, i, n, r = this._listeners[t];
                    if (r)
                        for ((e = r.length) > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;)(n = r[e]) && (n.up ? n.c.call(n.s || i, {
                            type: t,
                            target: i
                        }) : n.c.call(n.s || i))
                };
                var T = t.requestAnimationFrame,
                    E = t.cancelAnimationFrame,
                    S = Date.now || function() {
                        return (new Date).getTime()
                    },
                    A = S();
                for (a = (o = ["ms", "moz", "webkit", "o"]).length; --a > -1 && !T;) T = t[o[a] + "RequestAnimationFrame"], E = t[o[a] + "CancelAnimationFrame"] || t[o[a] + "CancelRequestAnimationFrame"];
                y("Ticker", function(t, e) {
                    var i, r, o, a, s, h = this,
                        u = S(),
                        d = !(!1 === e || !T) && "auto",
                        f = 500,
                        m = 33,
                        g = function(t) {
                            var e, n, c = S() - A;
                            c > f && (u += c - m), A += c, h.time = (A - u) / 1e3, e = h.time - s, (!i || e > 0 || !0 === t) && (h.frame++, s += e + (e >= a ? .004 : a - e), n = !0), !0 !== t && (o = r(g)), n && h.dispatchEvent("tick")
                        };
                    M.call(h), h.time = h.frame = 0, h.tick = function() {
                        g(!0)
                    }, h.lagSmoothing = function(t, e) {
                        if (!arguments.length) return f < 1e10;
                        f = t || 1e10, m = Math.min(e, f, 0)
                    }, h.sleep = function() {
                        null != o && (d && E ? E(o) : clearTimeout(o), r = p, o = null, h === c && (l = !1))
                    }, h.wake = function(t) {
                        null !== o ? h.sleep() : t ? u += -A + (A = S()) : h.frame > 10 && (A = S() - f + 5), r = 0 === i ? p : d && T ? T : function(t) {
                            return setTimeout(t, 1e3 * (s - h.time) + 1 | 0)
                        }, h === c && (l = !0), g(2)
                    }, h.fps = function(t) {
                        if (!arguments.length) return i;
                        a = 1 / ((i = t) || 60), s = this.time + a, h.wake()
                    }, h.useRAF = function(t) {
                        if (!arguments.length) return d;
                        h.sleep(), d = t, h.fps(i)
                    }, h.fps(t), setTimeout(function() {
                        "auto" === d && h.frame < 5 && "hidden" !== (n || {}).visibilityState && h.useRAF(!1)
                    }, 1500)
                }), (s = u.Ticker.prototype = new u.events.EventDispatcher).constructor = u.Ticker;
                var P = y("core.Animation", function(t, e) {
                    if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, q) {
                        l || c.wake();
                        var i = this.vars.useFrames ? X : q;
                        i.add(this, i._time), this.vars.paused && this.paused(!0)
                    }
                });
                c = P.ticker = new u.Ticker, (s = P.prototype)._dirty = s._gc = s._initted = s._paused = !1, s._totalTime = s._time = 0, s._rawPrevTime = -1, s._next = s._last = s._onUpdate = s._timeline = s.timeline = null, s._paused = !1;
                var L = function() {
                    l && S() - A > 2e3 && ("hidden" !== (n || {}).visibilityState || !c.lagSmoothing()) && c.wake();
                    var t = setTimeout(L, 2e3);
                    t.unref && t.unref()
                };
                L(), s.play = function(t, e) {
                    return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                }, s.pause = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!0)
                }, s.resume = function(t, e) {
                    return null != t && this.seek(t, e), this.paused(!1)
                }, s.seek = function(t, e) {
                    return this.totalTime(Number(t), !1 !== e)
                }, s.restart = function(t, e) {
                    return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0)
                }, s.reverse = function(t, e) {
                    return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                }, s.render = function(t, e, i) {}, s.invalidate = function() {
                    return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                }, s.isActive = function() {
                    var t, e = this._timeline,
                        i = this._startTime;
                    return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7
                }, s._enabled = function(t, e) {
                    return l || c.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
                }, s._kill = function(t, e) {
                    return this._enabled(!1, !1)
                }, s.kill = function(t, e) {
                    return this._kill(t, e), this
                }, s._uncache = function(t) {
                    for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
                    return this
                }, s._swapSelfInParams = function(t) {
                    for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
                    return i
                }, s._callback = function(t) {
                    var e = this.vars,
                        i = e[t],
                        n = e[t + "Params"],
                        r = e[t + "Scope"] || e.callbackScope || this;
                    switch (n ? n.length : 0) {
                        case 0:
                            i.call(r);
                            break;
                        case 1:
                            i.call(r, n[0]);
                            break;
                        case 2:
                            i.call(r, n[0], n[1]);
                            break;
                        default:
                            i.apply(r, n)
                    }
                }, s.eventCallback = function(t, e, i, n) {
                    if ("on" === (t || "").substr(0, 2)) {
                        var r = this.vars;
                        if (1 === arguments.length) return r[t];
                        null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = f(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
                    }
                    return this
                }, s.delay = function(t) {
                    return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
                }, s.duration = function(t) {
                    return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
                }, s.totalDuration = function(t) {
                    return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
                }, s.time = function(t, e) {
                    return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
                }, s.totalTime = function(t, e, i) {
                    if (l || c.wake(), !arguments.length) return this._totalTime;
                    if (this._timeline) {
                        if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                            this._dirty && this.totalDuration();
                            var n = this._totalDuration,
                                r = this._timeline;
                            if (t > n && !i && (t = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                        }
                        this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (I.length && Z(), this.render(t, e, !1), I.length && Z())
                    }
                    return this
                }, s.progress = s.totalProgress = function(t, e) {
                    var i = this.duration();
                    return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
                }, s.startTime = function(t) {
                    return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
                }, s.endTime = function(t) {
                    return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
                }, s.timeScale = function(t) {
                    if (!arguments.length) return this._timeScale;
                    var e, i;
                    for (t = t || 1e-10, this._timeline && this._timeline.smoothChildTiming && (i = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
                    return this
                }, s.reversed = function(t) {
                    return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                }, s.paused = function(t) {
                    if (!arguments.length) return this._paused;
                    var e, i, n = this._timeline;
                    return t != this._paused && n && (l || t || c.wake(), i = (e = n.rawTime()) - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
                };
                var C = y("core.SimpleTimeline", function(t) {
                    P.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
                });
                (s = C.prototype = new P).constructor = C, s.kill()._gc = !1, s._first = s._last = s._recent = null, s._sortChildren = !1, s.add = s.insert = function(t, e, i, n) {
                    var r, o;
                    if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren)
                        for (o = t._startTime; r && r._startTime > o;) r = r._prev;
                    return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
                }, s._remove = function(t, e) {
                    return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                }, s.render = function(t, e, i) {
                    var n, r = this._first;
                    for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
                }, s.rawTime = function() {
                    return l || c.wake(), this._totalTime
                };
                var R = y("TweenLite", function(e, i, n) {
                        if (P.call(this, i, n), this.render = R.prototype.render, null == e) throw "Cannot tween a null target.";
                        this.target = e = "string" != typeof e ? e : R.selector(e) || e;
                        var r, o, a, s = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
                            c = this.vars.overwrite;
                        if (this._overwrite = c = null == c ? W[R.defaultOverwrite] : "number" == typeof c ? c >> 0 : W[c], (s || e instanceof Array || e.push && f(e)) && "number" != typeof e[0])
                            for (this._targets = a = d(e), this._propLookup = [], this._siblings = [], r = 0; r < a.length; r++)(o = a[r]) ? "string" != typeof o ? o.length && o !== t && o[0] && (o[0] === t || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(d(o))) : (this._siblings[r] = J(o, this, !1), 1 === c && this._siblings[r].length > 1 && Q(o, this, null, 1, this._siblings[r])) : "string" == typeof(o = a[r--] = R.selector(o)) && a.splice(r + 1, 1) : a.splice(r--, 1);
                        else this._propLookup = {}, this._siblings = J(e, this, !1), 1 === c && this._siblings.length > 1 && Q(e, this, null, 1, this._siblings);
                        (this.vars.immediateRender || 0 === i && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay)))
                    }, !0),
                    O = function(e) {
                        return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType)
                    };
                (s = R.prototype = new P).constructor = R, s.kill()._gc = !1, s.ratio = 0, s._firstPT = s._targets = s._overwrittenProps = s._startAt = null, s._notifyPluginsOfEnabled = s._lazy = !1, R.version = "2.0.2", R.defaultEase = s._ease = new x(null, null, 1, 1), R.defaultOverwrite = "auto", R.ticker = c, R.autoSleep = 120, R.lagSmoothing = function(t, e) {
                    c.lagSmoothing(t, e)
                }, R.selector = t.$ || t.jQuery || function(e) {
                    var i = t.$ || t.jQuery;
                    return i ? (R.selector = i, i(e)) : (n || (n = t.document), n ? n.querySelectorAll ? n.querySelectorAll(e) : n.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e)
                };
                var I = [],
                    D = {},
                    k = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    N = /[\+-]=-?[\.\d]/,
                    B = function(t) {
                        for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : e < 1e-6 && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
                    },
                    F = function(t, e, i, n) {
                        var r, o, a, s, c, l, h, u = [],
                            d = 0,
                            p = "",
                            f = 0;
                        for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(k) || [], o = e.match(k) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), c = o.length, s = 0; s < c; s++) h = o[s], p += (l = e.substr(d, e.indexOf(h, d) - d)) || !s ? l : ",", d += l.length, f ? f = (f + 1) % 5 : "rgba(" === l.substr(-5) && (f = 1), h === r[s] || r.length <= s ? p += h : (p && (u.push(p), p = ""), a = parseFloat(r[s]), u.push(a), u._firstPT = {
                            _next: u._firstPT,
                            t: u,
                            p: u.length - 1,
                            s: a,
                            c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - a) || 0,
                            f: 0,
                            m: f && f < 4 ? Math.round : 0
                        }), d += h.length;
                        return (p += e.substr(d)) && u.push(p), u.setRatio = B, N.test(e) && (u.end = null), u
                    },
                    z = function(t, e, i, n, r, o, a, s, c) {
                        "function" == typeof n && (n = n(c || 0, t));
                        var l = typeof t[e],
                            h = "function" !== l ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                            u = "get" !== i ? i : h ? a ? t[h](a) : t[h]() : t[e],
                            d = "string" == typeof n && "=" === n.charAt(1),
                            p = {
                                t: t,
                                p: e,
                                s: u,
                                f: "function" === l,
                                pg: 0,
                                n: r || e,
                                m: o ? "function" == typeof o ? o : Math.round : 0,
                                pr: 0,
                                c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - u || 0
                            };
                        if (("number" != typeof u || "number" != typeof n && !d) && (a || isNaN(u) || !d && isNaN(n) || "boolean" == typeof u || "boolean" == typeof n ? (p.fp = a, p = {
                                t: F(u, d ? parseFloat(p.s) + p.c + (p.s + "").replace(/[0-9\-\.]/g, "") : n, s || R.defaultStringFilter, p),
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 2,
                                pg: 0,
                                n: r || e,
                                pr: 0,
                                m: 0
                            }) : (p.s = parseFloat(u), d || (p.c = parseFloat(n) - p.s || 0))), p.c) return (p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p
                    },
                    U = R._internals = {
                        isArray: f,
                        isSelector: O,
                        lazyTweens: I,
                        blobDif: F
                    },
                    G = R._plugins = {},
                    H = U.tweenLookup = {},
                    V = 0,
                    j = U.reservedProps = {
                        ease: 1,
                        delay: 1,
                        overwrite: 1,
                        onComplete: 1,
                        onCompleteParams: 1,
                        onCompleteScope: 1,
                        useFrames: 1,
                        runBackwards: 1,
                        startAt: 1,
                        onUpdate: 1,
                        onUpdateParams: 1,
                        onUpdateScope: 1,
                        onStart: 1,
                        onStartParams: 1,
                        onStartScope: 1,
                        onReverseComplete: 1,
                        onReverseCompleteParams: 1,
                        onReverseCompleteScope: 1,
                        onRepeat: 1,
                        onRepeatParams: 1,
                        onRepeatScope: 1,
                        easeParams: 1,
                        yoyo: 1,
                        immediateRender: 1,
                        repeat: 1,
                        repeatDelay: 1,
                        data: 1,
                        paused: 1,
                        reversed: 1,
                        autoCSS: 1,
                        lazy: 1,
                        onOverwrite: 1,
                        callbackScope: 1,
                        stringFilter: 1,
                        id: 1,
                        yoyoEase: 1
                    },
                    W = {
                        none: 0,
                        all: 1,
                        auto: 2,
                        concurrent: 3,
                        allOnStart: 4,
                        preexisting: 5,
                        true: 1,
                        false: 0
                    },
                    X = P._rootFramesTimeline = new C,
                    q = P._rootTimeline = new C,
                    Y = 30,
                    Z = U.lazyRender = function() {
                        var t, e = I.length;
                        for (D = {}; --e > -1;)(t = I[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                        I.length = 0
                    };
                q._startTime = c.time, X._startTime = c.frame, q._active = X._active = !0, setTimeout(Z, 1), P._updateRoot = R.render = function() {
                    var t, e, i;
                    if (I.length && Z(), q.render((c.time - q._startTime) * q._timeScale, !1, !1), X.render((c.frame - X._startTime) * X._timeScale, !1, !1), I.length && Z(), c.frame >= Y) {
                        for (i in Y = c.frame + (parseInt(R.autoSleep, 10) || 120), H) {
                            for (t = (e = H[i].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
                            0 === e.length && delete H[i]
                        }
                        if ((!(i = q._first) || i._paused) && R.autoSleep && !X._first && 1 === c._listeners.tick.length) {
                            for (; i && i._paused;) i = i._next;
                            i || c.sleep()
                        }
                    }
                }, c.addEventListener("tick", P._updateRoot);
                var J = function(t, e, i) {
                        var n, r, o = t._gsTweenID;
                        if (H[o || (t._gsTweenID = o = "t" + V++)] || (H[o] = {
                                target: t,
                                tweens: []
                            }), e && ((n = H[o].tweens)[r = n.length] = e, i))
                            for (; --r > -1;) n[r] === e && n.splice(r, 1);
                        return H[o].tweens
                    },
                    K = function(t, e, i, n) {
                        var r, o, a = t.vars.onOverwrite;
                        return a && (r = a(t, e, i, n)), (a = R.onOverwrite) && (o = a(t, e, i, n)), !1 !== r && !1 !== o
                    },
                    Q = function(t, e, i, n, r) {
                        var o, a, s, c;
                        if (1 === n || n >= 4) {
                            for (c = r.length, o = 0; o < c; o++)
                                if ((s = r[o]) !== e) s._gc || s._kill(null, t, e) && (a = !0);
                                else if (5 === n) break;
                            return a
                        }
                        var l, h = e._startTime + 1e-10,
                            u = [],
                            d = 0,
                            p = 0 === e._duration;
                        for (o = r.length; --o > -1;)(s = r[o]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (l = l || $(e, 0, p), 0 === $(s, l, p) && (u[d++] = s)) : s._startTime <= h && s._startTime + s.totalDuration() / s._timeScale > h && ((p || !s._initted) && h - s._startTime <= 2e-10 || (u[d++] = s)));
                        for (o = d; --o > -1;)
                            if (c = (s = u[o])._firstPT, 2 === n && s._kill(i, t, e) && (a = !0), 2 !== n || !s._firstPT && s._initted && c) {
                                if (2 !== n && !K(s, e)) continue;
                                s._enabled(!1, !1) && (a = !0)
                            }
                        return a
                    },
                    $ = function(t, e, i) {
                        for (var n = t._timeline, r = n._timeScale, o = t._startTime; n._timeline;) {
                            if (o += n._startTime, r *= n._timeScale, n._paused) return -100;
                            n = n._timeline
                        }
                        return (o /= r) > e ? o - e : i && o === e || !t._initted && o - e < 2e-10 ? 1e-10 : (o += t.totalDuration() / t._timeScale / r) > e + 1e-10 ? 0 : o - e - 1e-10
                    };
                s._init = function() {
                    var t, e, i, n, r, o, a = this.vars,
                        s = this._overwrittenProps,
                        c = this._duration,
                        l = !!a.immediateRender,
                        h = a.ease;
                    if (a.startAt) {
                        for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}, a.startAt) r[n] = a.startAt[n];
                        if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = l && !1 !== a.lazy, r.startAt = r.delay = null, r.onUpdate = a.onUpdate, r.onUpdateParams = a.onUpdateParams, r.onUpdateScope = a.onUpdateScope || a.callbackScope || this, this._startAt = R.to(this.target || {}, 0, r), l)
                            if (this._time > 0) this._startAt = null;
                            else if (0 !== c) return
                    } else if (a.runBackwards && 0 !== c)
                        if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                        else {
                            for (n in 0 !== this._time && (l = !1), i = {}, a) j[n] && "autoCSS" !== n || (i[n] = a[n]);
                            if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && !1 !== a.lazy, i.immediateRender = l, this._startAt = R.to(this.target, 0, i), l) {
                                if (0 === this._time) return
                            } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                        }
                    if (this._ease = h = h ? h instanceof x ? h : "function" == typeof h ? new x(h, a.easeParams) : b[h] || R.defaultEase : R.defaultEase, a.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, a.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                        for (o = this._targets.length, t = 0; t < o; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0);
                    else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                    if (e && R._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), a.runBackwards)
                        for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                    this._onUpdate = a.onUpdate, this._initted = !0
                }, s._initProps = function(e, i, n, r, o) {
                    var a, s, c, l, h, u;
                    if (null == e) return !1;
                    for (a in D[e._gsTweenID] && Z(), this.vars.css || e.style && e !== t && e.nodeType && G.css && !1 !== this.vars.autoCSS && function(t, e) {
                            var i, n = {};
                            for (i in t) j[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!G[i] || G[i] && G[i]._autoCSS) || (n[i] = t[i], delete t[i]);
                            t.css = n
                        }(this.vars, e), this.vars)
                        if (u = this.vars[a], j[a]) u && (u instanceof Array || u.push && f(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[a] = u = this._swapSelfInParams(u, this));
                        else if (G[a] && (l = new G[a])._onInitTween(e, this.vars[a], this, o)) {
                        for (this._firstPT = h = {
                                _next: this._firstPT,
                                t: l,
                                p: "setRatio",
                                s: 0,
                                c: 1,
                                f: 1,
                                n: a,
                                pg: 1,
                                pr: l._priority,
                                m: 0
                            }, s = l._overwriteProps.length; --s > -1;) i[l._overwriteProps[s]] = this._firstPT;
                        (l._priority || l._onInitAllProps) && (c = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
                    } else i[a] = z.call(this, e, a, "get", u, a, 0, null, this.vars.stringFilter, o);
                    return r && this._kill(r, e) ? this._initProps(e, i, n, r, o) : this._overwrite > 1 && this._firstPT && n.length > 1 && Q(e, this, i, this._overwrite, n) ? (this._kill(i, e), this._initProps(e, i, n, r, o)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (D[e._gsTweenID] = !0), c)
                }, s.render = function(t, e, i) {
                    var n, r, o, a, s = this._time,
                        c = this._duration,
                        l = this._rawPrevTime;
                    if (t >= c - 1e-7 && t >= 0) this._totalTime = this._time = c, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === c && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (l < 0 || t <= 0 && t >= -1e-7 || 1e-10 === l && "isPause" !== this.data) && l !== t && (i = !0, l > 1e-10 && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || l === t ? t : 1e-10);
                    else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === c && l > 0) && (r = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === c && (this._initted || !this.vars.lazy || i) && (l >= 0 && (1e-10 !== l || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || l === t ? t : 1e-10)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
                    else if (this._totalTime = this._time = t, this._easeType) {
                        var h = t / c,
                            u = this._easeType,
                            d = this._easePower;
                        (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === d ? h *= h : 2 === d ? h *= h * h : 3 === d ? h *= h * h * h : 4 === d && (h *= h * h * h * h), this.ratio = 1 === u ? 1 - h : 2 === u ? h : t / c < .5 ? h / 2 : 1 - h / 2
                    } else this.ratio = this._ease.getRatio(t / c);
                    if (this._time !== s || i) {
                        if (!this._initted) {
                            if (this._init(), !this._initted || this._gc) return;
                            if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = l, I.push(this), void(this._lazy = [t, e]);
                            this._time && !n ? this.ratio = this._ease.getRatio(this._time / c) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                        }
                        for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && t >= 0 && (this._active = !0), 0 === s && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== c || e || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                        this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== s || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r), 0 === c && 1e-10 === this._rawPrevTime && 1e-10 !== a && (this._rawPrevTime = 0)))
                    }
                }, s._kill = function(t, e, i) {
                    if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                    e = "string" != typeof e ? e || this._targets || this.target : R.selector(e) || e;
                    var n, r, o, a, s, c, l, h, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline,
                        p = this._firstPT;
                    if ((f(e) || O(e)) && "number" != typeof e[0])
                        for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (c = !0);
                    else {
                        if (this._targets) {
                            for (n = this._targets.length; --n > -1;)
                                if (e === this._targets[n]) {
                                    s = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                                    break
                                }
                        } else {
                            if (e !== this.target) return !1;
                            s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
                        }
                        if (s) {
                            if (l = t || s, h = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill), i && (R.onOverwrite || this.vars.onOverwrite)) {
                                for (o in l) s[o] && (u || (u = []), u.push(o));
                                if ((u || !t) && !K(this, i, e, u)) return !1
                            }
                            for (o in l)(a = s[o]) && (d && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, c = !0), a.pg && a.t._kill(l) && (c = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), h && (r[o] = 1);
                            !this._firstPT && this._initted && p && this._enabled(!1, !1)
                        }
                    }
                    return c
                }, s.invalidate = function() {
                    return this._notifyPluginsOfEnabled && R._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], P.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this
                }, s._enabled = function(t, e) {
                    if (l || c.wake(), t && this._gc) {
                        var i, n = this._targets;
                        if (n)
                            for (i = n.length; --i > -1;) this._siblings[i] = J(n[i], this, !0);
                        else this._siblings = J(this.target, this, !0)
                    }
                    return P.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && R._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
                }, R.to = function(t, e, i) {
                    return new R(t, e, i)
                }, R.from = function(t, e, i) {
                    return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new R(t, e, i)
                }, R.fromTo = function(t, e, i, n) {
                    return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new R(t, e, n)
                }, R.delayedCall = function(t, e, i, n, r) {
                    return new R(e, 0, {
                        delay: t,
                        onComplete: e,
                        onCompleteParams: i,
                        callbackScope: n,
                        onReverseComplete: e,
                        onReverseCompleteParams: i,
                        immediateRender: !1,
                        lazy: !1,
                        useFrames: r,
                        overwrite: 0
                    })
                }, R.set = function(t, e) {
                    return new R(t, 0, e)
                }, R.getTweensOf = function(t, e) {
                    if (null == t) return [];
                    var i, n, r, o;
                    if (t = "string" != typeof t ? t : R.selector(t) || t, (f(t) || O(t)) && "number" != typeof t[0]) {
                        for (i = t.length, n = []; --i > -1;) n = n.concat(R.getTweensOf(t[i], e));
                        for (i = n.length; --i > -1;)
                            for (o = n[i], r = i; --r > -1;) o === n[r] && n.splice(i, 1)
                    } else if (t._gsTweenID)
                        for (i = (n = J(t).concat()).length; --i > -1;)(n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
                    return n || []
                }, R.killTweensOf = R.killDelayedCallsTo = function(t, e, i) {
                    "object" == typeof e && (i = e, e = !1);
                    for (var n = R.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
                };
                var tt = y("plugins.TweenPlugin", function(t, e) {
                    this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = tt.prototype
                }, !0);
                if (s = tt.prototype, tt.version = "1.19.0", tt.API = 2, s._firstPT = null, s._addTween = z, s.setRatio = B, s._kill = function(t) {
                        var e, i = this._overwriteProps,
                            n = this._firstPT;
                        if (null != t[this._propName]) this._overwriteProps = [];
                        else
                            for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
                        for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                        return !1
                    }, s._mod = s._roundProps = function(t) {
                        for (var e, i = this._firstPT; i;)(e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
                    }, R._onPluginEvent = function(t, e) {
                        var i, n, r, o, a, s = e._firstPT;
                        if ("_onInitAllProps" === t) {
                            for (; s;) {
                                for (a = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                                (s._prev = n ? n._prev : o) ? s._prev._next = s: r = s, (s._next = n) ? n._prev = s : o = s, s = a
                            }
                            s = e._firstPT = r
                        }
                        for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (i = !0), s = s._next;
                        return i
                    }, tt.activate = function(t) {
                        for (var e = t.length; --e > -1;) t[e].API === tt.API && (G[(new t[e])._propName] = t[e]);
                        return !0
                    }, v.plugin = function(t) {
                        if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
                        var e, i = t.propName,
                            n = t.priority || 0,
                            r = t.overwriteProps,
                            o = {
                                init: "_onInitTween",
                                set: "setRatio",
                                kill: "_kill",
                                round: "_mod",
                                mod: "_mod",
                                initAll: "_onInitAllProps"
                            },
                            a = y("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                                tt.call(this, i, n), this._overwriteProps = r || []
                            }, !0 === t.global),
                            s = a.prototype = new tt(i);
                        for (e in s.constructor = a, a.API = t.API, o) "function" == typeof t[e] && (s[o[e]] = t[e]);
                        return a.version = t.version, tt.activate([a]), a
                    }, o = t._gsQueue) {
                    for (a = 0; a < o.length; a++) o[a]();
                    for (s in m) m[s].func || t.console.log("GSAP encountered missing dependency: " + s)
                }
                return l = !1, R
            }(r),
            a = r.GreenSockGlobals,
            s = a.com.greensock,
            c = s.core.SimpleTimeline,
            l = s.core.Animation,
            h = a.Ease,
            u = (a.Linear, a.Power1, a.Power2, a.Power3, a.Power4, a.TweenPlugin);
        s.events.EventDispatcher
    }).call(this, i(10)(t), i(3))
}, function(t, e, i) {
    "use strict";
    i.r(e),
        function(t) {
            function n() {}
            i.d(e, "WebGLRenderTargetCube", function() {
                return Ke
            }), i.d(e, "WebGLRenderTarget", function() {
                return Je
            }), i.d(e, "WebGLRenderer", function() {
                return gr
            }), i.d(e, "ShaderLib", function() {
                return hi
            }), i.d(e, "UniformsLib", function() {
                return li
            }), i.d(e, "UniformsUtils", function() {
                return ai
            }), i.d(e, "ShaderChunk", function() {
                return ni
            }), i.d(e, "FogExp2", function() {
                return vr
            }), i.d(e, "Fog", function() {
                return yr
            }), i.d(e, "Scene", function() {
                return _r
            }), i.d(e, "Sprite", function() {
                return Mr
            }), i.d(e, "LOD", function() {
                return Tr
            }), i.d(e, "SkinnedMesh", function() {
                return Er
            }), i.d(e, "Skeleton", function() {
                return Sr
            }), i.d(e, "Bone", function() {
                return Ar
            }), i.d(e, "Mesh", function() {
                return ji
            }), i.d(e, "LineSegments", function() {
                return Cr
            }), i.d(e, "LineLoop", function() {
                return Rr
            }), i.d(e, "Line", function() {
                return Lr
            }), i.d(e, "Points", function() {
                return Ir
            }), i.d(e, "Group", function() {
                return sr
            }), i.d(e, "VideoTexture", function() {
                return Dr
            }), i.d(e, "DataTexture", function() {
                return Qe
            }), i.d(e, "DataTexture3D", function() {
                return qi
            }), i.d(e, "CompressedTexture", function() {
                return kr
            }), i.d(e, "CubeTexture", function() {
                return Xi
            }), i.d(e, "CanvasTexture", function() {
                return Nr
            }), i.d(e, "DepthTexture", function() {
                return Br
            }), i.d(e, "Texture", function() {
                return Ye
            }), i.d(e, "AnimationLoader", function() {
                return La
            }), i.d(e, "CompressedTextureLoader", function() {
                return Ca
            }), i.d(e, "DataTextureLoader", function() {
                return Ra
            }), i.d(e, "CubeTextureLoader", function() {
                return Ia
            }), i.d(e, "TextureLoader", function() {
                return Da
            }), i.d(e, "ObjectLoader", function() {
                return _s
            }), i.d(e, "MaterialLoader", function() {
                return ms
            }), i.d(e, "BufferGeometryLoader", function() {
                return vs
            }), i.d(e, "DefaultLoadingManager", function() {
                return Sa
            }), i.d(e, "LoadingManager", function() {
                return Ea
            }), i.d(e, "ImageLoader", function() {
                return Oa
            }), i.d(e, "ImageBitmapLoader", function() {
                return Ts
            }), i.d(e, "FontLoader", function() {
                return Ps
            }), i.d(e, "FileLoader", function() {
                return Pa
            }), i.d(e, "Loader", function() {
                return Ls
            }), i.d(e, "LoaderUtils", function() {
                return gs
            }), i.d(e, "Cache", function() {
                return Ta
            }), i.d(e, "AudioLoader", function() {
                return Rs
            }), i.d(e, "SpotLightShadow", function() {
                return ss
            }), i.d(e, "SpotLight", function() {
                return cs
            }), i.d(e, "PointLight", function() {
                return ls
            }), i.d(e, "RectAreaLight", function() {
                return fs
            }), i.d(e, "HemisphereLight", function() {
                return os
            }), i.d(e, "DirectionalLightShadow", function() {
                return us
            }), i.d(e, "DirectionalLight", function() {
                return ds
            }), i.d(e, "AmbientLight", function() {
                return ps
            }), i.d(e, "LightShadow", function() {
                return as
            }), i.d(e, "Light", function() {
                return rs
            }), i.d(e, "StereoCamera", function() {
                return Os
            }), i.d(e, "PerspectiveCamera", function() {
                return lr
            }), i.d(e, "OrthographicCamera", function() {
                return hs
            }), i.d(e, "CubeCamera", function() {
                return Is
            }), i.d(e, "ArrayCamera", function() {
                return hr
            }), i.d(e, "Camera", function() {
                return cr
            }), i.d(e, "AudioListener", function() {
                return ks
            }), i.d(e, "PositionalAudio", function() {
                return Bs
            }), i.d(e, "AudioContext", function() {
                return Cs
            }), i.d(e, "AudioAnalyser", function() {
                return Fs
            }), i.d(e, "Audio", function() {
                return Ns
            }), i.d(e, "VectorKeyframeTrack", function() {
                return ba
            }), i.d(e, "StringKeyframeTrack", function() {
                return xa
            }), i.d(e, "QuaternionKeyframeTrack", function() {
                return _a
            }), i.d(e, "NumberKeyframeTrack", function() {
                return va
            }), i.d(e, "ColorKeyframeTrack", function() {
                return ga
            }), i.d(e, "BooleanKeyframeTrack", function() {
                return ma
            }), i.d(e, "PropertyMixer", function() {
                return zs
            }), i.d(e, "PropertyBinding", function() {
                return Vs
            }), i.d(e, "KeyframeTrack", function() {
                return fa
            }), i.d(e, "AnimationUtils", function() {
                return la
            }), i.d(e, "AnimationObjectGroup", function() {
                return js
            }), i.d(e, "AnimationMixer", function() {
                return Xs
            }), i.d(e, "AnimationClip", function() {
                return wa
            }), i.d(e, "Uniform", function() {
                return qs
            }), i.d(e, "InstancedBufferGeometry", function() {
                return Ys
            }), i.d(e, "BufferGeometry", function() {
                return Ii
            }), i.d(e, "Geometry", function() {
                return _i
            }), i.d(e, "InterleavedBufferAttribute", function() {
                return br
            }), i.d(e, "InstancedInterleavedBuffer", function() {
                return Zs
            }), i.d(e, "InterleavedBuffer", function() {
                return xr
            }), i.d(e, "InstancedBufferAttribute", function() {
                return Js
            }), i.d(e, "Face3", function() {
                return pi
            }), i.d(e, "Object3D", function() {
                return vi
            }), i.d(e, "Raycaster", function() {
                return Ks
            }), i.d(e, "Layers", function() {
                return mi
            }), i.d(e, "EventDispatcher", function() {
                return n
            }), i.d(e, "Clock", function() {
                return Ds
            }), i.d(e, "QuaternionLinearInterpolant", function() {
                return ya
            }), i.d(e, "LinearInterpolant", function() {
                return da
            }), i.d(e, "DiscreteInterpolant", function() {
                return pa
            }), i.d(e, "CubicInterpolant", function() {
                return ua
            }), i.d(e, "Interpolant", function() {
                return ha
            }), i.d(e, "Triangle", function() {
                return Hi
            }), i.d(e, "Math", function() {
                return Ue
            }), i.d(e, "Spherical", function() {
                return tc
            }), i.d(e, "Cylindrical", function() {
                return ec
            }), i.d(e, "Plane", function() {
                return ei
            }), i.d(e, "Frustum", function() {
                return ii
            }), i.d(e, "Sphere", function() {
                return ti
            }), i.d(e, "Ray", function() {
                return Gi
            }), i.d(e, "Matrix4", function() {
                return He
            }), i.d(e, "Matrix3", function() {
                return We
            }), i.d(e, "Box3", function() {
                return $e
            }), i.d(e, "Box2", function() {
                return ic
            }), i.d(e, "Line3", function() {
                return nc
            }), i.d(e, "Euler", function() {
                return fi
            }), i.d(e, "Vector4", function() {
                return Ze
            }), i.d(e, "Vector3", function() {
                return je
            }), i.d(e, "Vector2", function() {
                return Ge
            }), i.d(e, "Quaternion", function() {
                return Ve
            }), i.d(e, "Color", function() {
                return ci
            }), i.d(e, "ImmediateRenderObject", function() {
                return rc
            }), i.d(e, "VertexNormalsHelper", function() {
                return oc
            }), i.d(e, "SpotLightHelper", function() {
                return ac
            }), i.d(e, "SkeletonHelper", function() {
                return sc
            }), i.d(e, "PointLightHelper", function() {
                return cc
            }), i.d(e, "RectAreaLightHelper", function() {
                return lc
            }), i.d(e, "HemisphereLightHelper", function() {
                return hc
            }), i.d(e, "GridHelper", function() {
                return uc
            }), i.d(e, "PolarGridHelper", function() {
                return dc
            }), i.d(e, "FaceNormalsHelper", function() {
                return pc
            }), i.d(e, "DirectionalLightHelper", function() {
                return fc
            }), i.d(e, "CameraHelper", function() {
                return mc
            }), i.d(e, "BoxHelper", function() {
                return gc
            }), i.d(e, "Box3Helper", function() {
                return vc
            }), i.d(e, "PlaneHelper", function() {
                return yc
            }), i.d(e, "ArrowHelper", function() {
                return _c
            }), i.d(e, "AxesHelper", function() {
                return xc
            }), i.d(e, "Shape", function() {
                return ns
            }), i.d(e, "Path", function() {
                return is
            }), i.d(e, "ShapePath", function() {
                return Es
            }), i.d(e, "Font", function() {
                return Ss
            }), i.d(e, "CurvePath", function() {
                return es
            }), i.d(e, "Curve", function() {
                return ka
            }), i.d(e, "ImageUtils", function() {
                return Xe
            }), i.d(e, "ShapeUtils", function() {
                return So
            }), i.d(e, "WebGLUtils", function() {
                return ar
            }), i.d(e, "WireframeGeometry", function() {
                return Fr
            }), i.d(e, "ParametricGeometry", function() {
                return zr
            }), i.d(e, "ParametricBufferGeometry", function() {
                return Ur
            }), i.d(e, "TetrahedronGeometry", function() {
                return Vr
            }), i.d(e, "TetrahedronBufferGeometry", function() {
                return jr
            }), i.d(e, "OctahedronGeometry", function() {
                return Wr
            }), i.d(e, "OctahedronBufferGeometry", function() {
                return Xr
            }), i.d(e, "IcosahedronGeometry", function() {
                return qr
            }), i.d(e, "IcosahedronBufferGeometry", function() {
                return Yr
            }), i.d(e, "DodecahedronGeometry", function() {
                return Zr
            }), i.d(e, "DodecahedronBufferGeometry", function() {
                return Jr
            }), i.d(e, "PolyhedronGeometry", function() {
                return Gr
            }), i.d(e, "PolyhedronBufferGeometry", function() {
                return Hr
            }), i.d(e, "TubeGeometry", function() {
                return Kr
            }), i.d(e, "TubeBufferGeometry", function() {
                return Qr
            }), i.d(e, "TorusKnotGeometry", function() {
                return $r
            }), i.d(e, "TorusKnotBufferGeometry", function() {
                return to
            }), i.d(e, "TorusGeometry", function() {
                return eo
            }), i.d(e, "TorusBufferGeometry", function() {
                return io
            }), i.d(e, "TextGeometry", function() {
                return Io
            }), i.d(e, "TextBufferGeometry", function() {
                return Do
            }), i.d(e, "SphereGeometry", function() {
                return ko
            }), i.d(e, "SphereBufferGeometry", function() {
                return No
            }), i.d(e, "RingGeometry", function() {
                return Bo
            }), i.d(e, "RingBufferGeometry", function() {
                return Fo
            }), i.d(e, "PlaneGeometry", function() {
                return Ni
            }), i.d(e, "PlaneBufferGeometry", function() {
                return Bi
            }), i.d(e, "LatheGeometry", function() {
                return zo
            }), i.d(e, "LatheBufferGeometry", function() {
                return Uo
            }), i.d(e, "ShapeGeometry", function() {
                return Go
            }), i.d(e, "ShapeBufferGeometry", function() {
                return Ho
            }), i.d(e, "ExtrudeGeometry", function() {
                return Lo
            }), i.d(e, "ExtrudeBufferGeometry", function() {
                return Co
            }), i.d(e, "EdgesGeometry", function() {
                return jo
            }), i.d(e, "ConeGeometry", function() {
                return qo
            }), i.d(e, "ConeBufferGeometry", function() {
                return Yo
            }), i.d(e, "CylinderGeometry", function() {
                return Wo
            }), i.d(e, "CylinderBufferGeometry", function() {
                return Xo
            }), i.d(e, "CircleGeometry", function() {
                return Zo
            }), i.d(e, "CircleBufferGeometry", function() {
                return Jo
            }), i.d(e, "BoxGeometry", function() {
                return Di
            }), i.d(e, "BoxBufferGeometry", function() {
                return ki
            }), i.d(e, "ShadowMaterial", function() {
                return Qo
            }), i.d(e, "SpriteMaterial", function() {
                return wr
            }), i.d(e, "RawShaderMaterial", function() {
                return $o
            }), i.d(e, "ShaderMaterial", function() {
                return Ui
            }), i.d(e, "PointsMaterial", function() {
                return Or
            }), i.d(e, "MeshPhysicalMaterial", function() {
                return ea
            }), i.d(e, "MeshStandardMaterial", function() {
                return ta
            }), i.d(e, "MeshPhongMaterial", function() {
                return ia
            }), i.d(e, "MeshToonMaterial", function() {
                return na
            }), i.d(e, "MeshNormalMaterial", function() {
                return ra
            }), i.d(e, "MeshLambertMaterial", function() {
                return oa
            }), i.d(e, "MeshDepthMaterial", function() {
                return ir
            }), i.d(e, "MeshDistanceMaterial", function() {
                return nr
            }), i.d(e, "MeshBasicMaterial", function() {
                return Vi
            }), i.d(e, "MeshMatcapMaterial", function() {
                return aa
            }), i.d(e, "LineDashedMaterial", function() {
                return sa
            }), i.d(e, "LineBasicMaterial", function() {
                return Pr
            }), i.d(e, "Material", function() {
                return zi
            }), i.d(e, "Float64BufferAttribute", function() {
                return Li
            }), i.d(e, "Float32BufferAttribute", function() {
                return Pi
            }), i.d(e, "Uint32BufferAttribute", function() {
                return Ai
            }), i.d(e, "Int32BufferAttribute", function() {
                return Si
            }), i.d(e, "Uint16BufferAttribute", function() {
                return Ei
            }), i.d(e, "Int16BufferAttribute", function() {
                return Ti
            }), i.d(e, "Uint8ClampedBufferAttribute", function() {
                return Mi
            }), i.d(e, "Uint8BufferAttribute", function() {
                return wi
            }), i.d(e, "Int8BufferAttribute", function() {
                return bi
            }), i.d(e, "BufferAttribute", function() {
                return xi
            }), i.d(e, "ArcCurve", function() {
                return Ba
            }), i.d(e, "CatmullRomCurve3", function() {
                return Va
            }), i.d(e, "CubicBezierCurve", function() {
                return qa
            }), i.d(e, "CubicBezierCurve3", function() {
                return Ya
            }), i.d(e, "EllipseCurve", function() {
                return Na
            }), i.d(e, "LineCurve", function() {
                return Za
            }), i.d(e, "LineCurve3", function() {
                return Ja
            }), i.d(e, "QuadraticBezierCurve", function() {
                return Ka
            }), i.d(e, "QuadraticBezierCurve3", function() {
                return Qa
            }), i.d(e, "SplineCurve", function() {
                return $a
            }), i.d(e, "REVISION", function() {
                return o
            }), i.d(e, "MOUSE", function() {
                return a
            }), i.d(e, "CullFaceNone", function() {
                return s
            }), i.d(e, "CullFaceBack", function() {
                return c
            }), i.d(e, "CullFaceFront", function() {
                return l
            }), i.d(e, "CullFaceFrontBack", function() {
                return h
            }), i.d(e, "FrontFaceDirectionCW", function() {
                return u
            }), i.d(e, "FrontFaceDirectionCCW", function() {
                return d
            }), i.d(e, "BasicShadowMap", function() {
                return p
            }), i.d(e, "PCFShadowMap", function() {
                return f
            }), i.d(e, "PCFSoftShadowMap", function() {
                return m
            }), i.d(e, "FrontSide", function() {
                return g
            }), i.d(e, "BackSide", function() {
                return v
            }), i.d(e, "DoubleSide", function() {
                return y
            }), i.d(e, "FlatShading", function() {
                return _
            }), i.d(e, "SmoothShading", function() {
                return x
            }), i.d(e, "NoColors", function() {
                return b
            }), i.d(e, "FaceColors", function() {
                return w
            }), i.d(e, "VertexColors", function() {
                return M
            }), i.d(e, "NoBlending", function() {
                return T
            }), i.d(e, "NormalBlending", function() {
                return E
            }), i.d(e, "AdditiveBlending", function() {
                return S
            }), i.d(e, "SubtractiveBlending", function() {
                return A
            }), i.d(e, "MultiplyBlending", function() {
                return P
            }), i.d(e, "CustomBlending", function() {
                return L
            }), i.d(e, "AddEquation", function() {
                return C
            }), i.d(e, "SubtractEquation", function() {
                return R
            }), i.d(e, "ReverseSubtractEquation", function() {
                return O
            }), i.d(e, "MinEquation", function() {
                return I
            }), i.d(e, "MaxEquation", function() {
                return D
            }), i.d(e, "ZeroFactor", function() {
                return k
            }), i.d(e, "OneFactor", function() {
                return N
            }), i.d(e, "SrcColorFactor", function() {
                return B
            }), i.d(e, "OneMinusSrcColorFactor", function() {
                return F
            }), i.d(e, "SrcAlphaFactor", function() {
                return z
            }), i.d(e, "OneMinusSrcAlphaFactor", function() {
                return U
            }), i.d(e, "DstAlphaFactor", function() {
                return G
            }), i.d(e, "OneMinusDstAlphaFactor", function() {
                return H
            }), i.d(e, "DstColorFactor", function() {
                return V
            }), i.d(e, "OneMinusDstColorFactor", function() {
                return j
            }), i.d(e, "SrcAlphaSaturateFactor", function() {
                return W
            }), i.d(e, "NeverDepth", function() {
                return X
            }), i.d(e, "AlwaysDepth", function() {
                return q
            }), i.d(e, "LessDepth", function() {
                return Y
            }), i.d(e, "LessEqualDepth", function() {
                return Z
            }), i.d(e, "EqualDepth", function() {
                return J
            }), i.d(e, "GreaterEqualDepth", function() {
                return K
            }), i.d(e, "GreaterDepth", function() {
                return Q
            }), i.d(e, "NotEqualDepth", function() {
                return $
            }), i.d(e, "MultiplyOperation", function() {
                return tt
            }), i.d(e, "MixOperation", function() {
                return et
            }), i.d(e, "AddOperation", function() {
                return it
            }), i.d(e, "NoToneMapping", function() {
                return nt
            }), i.d(e, "LinearToneMapping", function() {
                return rt
            }), i.d(e, "ReinhardToneMapping", function() {
                return ot
            }), i.d(e, "Uncharted2ToneMapping", function() {
                return at
            }), i.d(e, "CineonToneMapping", function() {
                return st
            }), i.d(e, "ACESFilmicToneMapping", function() {
                return ct
            }), i.d(e, "UVMapping", function() {
                return lt
            }), i.d(e, "CubeReflectionMapping", function() {
                return ht
            }), i.d(e, "CubeRefractionMapping", function() {
                return ut
            }), i.d(e, "EquirectangularReflectionMapping", function() {
                return dt
            }), i.d(e, "EquirectangularRefractionMapping", function() {
                return pt
            }), i.d(e, "SphericalReflectionMapping", function() {
                return ft
            }), i.d(e, "CubeUVReflectionMapping", function() {
                return mt
            }), i.d(e, "CubeUVRefractionMapping", function() {
                return gt
            }), i.d(e, "RepeatWrapping", function() {
                return vt
            }), i.d(e, "ClampToEdgeWrapping", function() {
                return yt
            }), i.d(e, "MirroredRepeatWrapping", function() {
                return _t
            }), i.d(e, "NearestFilter", function() {
                return xt
            }), i.d(e, "NearestMipMapNearestFilter", function() {
                return bt
            }), i.d(e, "NearestMipMapLinearFilter", function() {
                return wt
            }), i.d(e, "LinearFilter", function() {
                return Mt
            }), i.d(e, "LinearMipMapNearestFilter", function() {
                return Tt
            }), i.d(e, "LinearMipMapLinearFilter", function() {
                return Et
            }), i.d(e, "UnsignedByteType", function() {
                return St
            }), i.d(e, "ByteType", function() {
                return At
            }), i.d(e, "ShortType", function() {
                return Pt
            }), i.d(e, "UnsignedShortType", function() {
                return Lt
            }), i.d(e, "IntType", function() {
                return Ct
            }), i.d(e, "UnsignedIntType", function() {
                return Rt
            }), i.d(e, "FloatType", function() {
                return Ot
            }), i.d(e, "HalfFloatType", function() {
                return It
            }), i.d(e, "UnsignedShort4444Type", function() {
                return Dt
            }), i.d(e, "UnsignedShort5551Type", function() {
                return kt
            }), i.d(e, "UnsignedShort565Type", function() {
                return Nt
            }), i.d(e, "UnsignedInt248Type", function() {
                return Bt
            }), i.d(e, "AlphaFormat", function() {
                return Ft
            }), i.d(e, "RGBFormat", function() {
                return zt
            }), i.d(e, "RGBAFormat", function() {
                return Ut
            }), i.d(e, "LuminanceFormat", function() {
                return Gt
            }), i.d(e, "LuminanceAlphaFormat", function() {
                return Ht
            }), i.d(e, "RGBEFormat", function() {
                return Vt
            }), i.d(e, "DepthFormat", function() {
                return jt
            }), i.d(e, "DepthStencilFormat", function() {
                return Wt
            }), i.d(e, "RedFormat", function() {
                return Xt
            }), i.d(e, "RGB_S3TC_DXT1_Format", function() {
                return qt
            }), i.d(e, "RGBA_S3TC_DXT1_Format", function() {
                return Yt
            }), i.d(e, "RGBA_S3TC_DXT3_Format", function() {
                return Zt
            }), i.d(e, "RGBA_S3TC_DXT5_Format", function() {
                return Jt
            }), i.d(e, "RGB_PVRTC_4BPPV1_Format", function() {
                return Kt
            }), i.d(e, "RGB_PVRTC_2BPPV1_Format", function() {
                return Qt
            }), i.d(e, "RGBA_PVRTC_4BPPV1_Format", function() {
                return $t
            }), i.d(e, "RGBA_PVRTC_2BPPV1_Format", function() {
                return te
            }), i.d(e, "RGB_ETC1_Format", function() {
                return ee
            }), i.d(e, "RGBA_ASTC_4x4_Format", function() {
                return ie
            }), i.d(e, "RGBA_ASTC_5x4_Format", function() {
                return ne
            }), i.d(e, "RGBA_ASTC_5x5_Format", function() {
                return re
            }), i.d(e, "RGBA_ASTC_6x5_Format", function() {
                return oe
            }), i.d(e, "RGBA_ASTC_6x6_Format", function() {
                return ae
            }), i.d(e, "RGBA_ASTC_8x5_Format", function() {
                return se
            }), i.d(e, "RGBA_ASTC_8x6_Format", function() {
                return ce
            }), i.d(e, "RGBA_ASTC_8x8_Format", function() {
                return le
            }), i.d(e, "RGBA_ASTC_10x5_Format", function() {
                return he
            }), i.d(e, "RGBA_ASTC_10x6_Format", function() {
                return ue
            }), i.d(e, "RGBA_ASTC_10x8_Format", function() {
                return de
            }), i.d(e, "RGBA_ASTC_10x10_Format", function() {
                return pe
            }), i.d(e, "RGBA_ASTC_12x10_Format", function() {
                return fe
            }), i.d(e, "RGBA_ASTC_12x12_Format", function() {
                return me
            }), i.d(e, "LoopOnce", function() {
                return ge
            }), i.d(e, "LoopRepeat", function() {
                return ve
            }), i.d(e, "LoopPingPong", function() {
                return ye
            }), i.d(e, "InterpolateDiscrete", function() {
                return _e
            }), i.d(e, "InterpolateLinear", function() {
                return xe
            }), i.d(e, "InterpolateSmooth", function() {
                return be
            }), i.d(e, "ZeroCurvatureEnding", function() {
                return we
            }), i.d(e, "ZeroSlopeEnding", function() {
                return Me
            }), i.d(e, "WrapAroundEnding", function() {
                return Te
            }), i.d(e, "TrianglesDrawMode", function() {
                return Ee
            }), i.d(e, "TriangleStripDrawMode", function() {
                return Se
            }), i.d(e, "TriangleFanDrawMode", function() {
                return Ae
            }), i.d(e, "LinearEncoding", function() {
                return Pe
            }), i.d(e, "sRGBEncoding", function() {
                return Le
            }), i.d(e, "GammaEncoding", function() {
                return Ce
            }), i.d(e, "RGBEEncoding", function() {
                return Re
            }), i.d(e, "LogLuvEncoding", function() {
                return Oe
            }), i.d(e, "RGBM7Encoding", function() {
                return Ie
            }), i.d(e, "RGBM16Encoding", function() {
                return De
            }), i.d(e, "RGBDEncoding", function() {
                return ke
            }), i.d(e, "BasicDepthPacking", function() {
                return Ne
            }), i.d(e, "RGBADepthPacking", function() {
                return Be
            }), i.d(e, "TangentSpaceNormalMap", function() {
                return Fe
            }), i.d(e, "ObjectSpaceNormalMap", function() {
                return ze
            }), i.d(e, "CubeGeometry", function() {
                return Di
            }), i.d(e, "Face4", function() {
                return bc
            }), i.d(e, "LineStrip", function() {
                return wc
            }), i.d(e, "LinePieces", function() {
                return Mc
            }), i.d(e, "MeshFaceMaterial", function() {
                return Tc
            }), i.d(e, "MultiMaterial", function() {
                return Ec
            }), i.d(e, "PointCloud", function() {
                return Sc
            }), i.d(e, "Particle", function() {
                return Ac
            }), i.d(e, "ParticleSystem", function() {
                return Pc
            }), i.d(e, "PointCloudMaterial", function() {
                return Lc
            }), i.d(e, "ParticleBasicMaterial", function() {
                return Cc
            }), i.d(e, "ParticleSystemMaterial", function() {
                return Rc
            }), i.d(e, "Vertex", function() {
                return Oc
            }), i.d(e, "DynamicBufferAttribute", function() {
                return Ic
            }), i.d(e, "Int8Attribute", function() {
                return Dc
            }), i.d(e, "Uint8Attribute", function() {
                return kc
            }), i.d(e, "Uint8ClampedAttribute", function() {
                return Nc
            }), i.d(e, "Int16Attribute", function() {
                return Bc
            }), i.d(e, "Uint16Attribute", function() {
                return Fc
            }), i.d(e, "Int32Attribute", function() {
                return zc
            }), i.d(e, "Uint32Attribute", function() {
                return Uc
            }), i.d(e, "Float32Attribute", function() {
                return Gc
            }), i.d(e, "Float64Attribute", function() {
                return Hc
            }), i.d(e, "ClosedSplineCurve3", function() {
                return Vc
            }), i.d(e, "SplineCurve3", function() {
                return jc
            }), i.d(e, "Spline", function() {
                return Wc
            }), i.d(e, "AxisHelper", function() {
                return Xc
            }), i.d(e, "BoundingBoxHelper", function() {
                return qc
            }), i.d(e, "EdgesHelper", function() {
                return Yc
            }), i.d(e, "WireframeHelper", function() {
                return Zc
            }), i.d(e, "XHRLoader", function() {
                return Jc
            }), i.d(e, "BinaryTextureLoader", function() {
                return Kc
            }), i.d(e, "GeometryUtils", function() {
                return Qc
            }), i.d(e, "Projector", function() {
                return $c
            }), i.d(e, "CanvasRenderer", function() {
                return tl
            }), i.d(e, "JSONLoader", function() {
                return el
            }), i.d(e, "SceneUtils", function() {
                return il
            }), i.d(e, "LensFlare", function() {
                return nl
            }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
                return "number" == typeof t && isFinite(t) && Math.floor(t) === t
            }), void 0 === Math.sign && (Math.sign = function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : +t
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function(t) {
                if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), i = 1; i < arguments.length; i++) {
                    var n = arguments[i];
                    if (void 0 !== n && null !== n)
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }), Object.assign(n.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var i = this._listeners;
                    void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    return void 0 !== i[t] && -1 !== i[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 !== this._listeners) {
                        var i = this._listeners[t];
                        if (void 0 !== i) {
                            var n = i.indexOf(e); - 1 !== n && i.splice(n, 1)
                        }
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 !== this._listeners) {
                        var e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, t)
                        }
                    }
                }
            });
            var r, o = "99",
                a = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                },
                s = 0,
                c = 1,
                l = 2,
                h = 3,
                u = 0,
                d = 1,
                p = 0,
                f = 1,
                m = 2,
                g = 0,
                v = 1,
                y = 2,
                _ = 1,
                x = 2,
                b = 0,
                w = 1,
                M = 2,
                T = 0,
                E = 1,
                S = 2,
                A = 3,
                P = 4,
                L = 5,
                C = 100,
                R = 101,
                O = 102,
                I = 103,
                D = 104,
                k = 200,
                N = 201,
                B = 202,
                F = 203,
                z = 204,
                U = 205,
                G = 206,
                H = 207,
                V = 208,
                j = 209,
                W = 210,
                X = 0,
                q = 1,
                Y = 2,
                Z = 3,
                J = 4,
                K = 5,
                Q = 6,
                $ = 7,
                tt = 0,
                et = 1,
                it = 2,
                nt = 0,
                rt = 1,
                ot = 2,
                at = 3,
                st = 4,
                ct = 5,
                lt = 300,
                ht = 301,
                ut = 302,
                dt = 303,
                pt = 304,
                ft = 305,
                mt = 306,
                gt = 307,
                vt = 1e3,
                yt = 1001,
                _t = 1002,
                xt = 1003,
                bt = 1004,
                wt = 1005,
                Mt = 1006,
                Tt = 1007,
                Et = 1008,
                St = 1009,
                At = 1010,
                Pt = 1011,
                Lt = 1012,
                Ct = 1013,
                Rt = 1014,
                Ot = 1015,
                It = 1016,
                Dt = 1017,
                kt = 1018,
                Nt = 1019,
                Bt = 1020,
                Ft = 1021,
                zt = 1022,
                Ut = 1023,
                Gt = 1024,
                Ht = 1025,
                Vt = Ut,
                jt = 1026,
                Wt = 1027,
                Xt = 1028,
                qt = 33776,
                Yt = 33777,
                Zt = 33778,
                Jt = 33779,
                Kt = 35840,
                Qt = 35841,
                $t = 35842,
                te = 35843,
                ee = 36196,
                ie = 37808,
                ne = 37809,
                re = 37810,
                oe = 37811,
                ae = 37812,
                se = 37813,
                ce = 37814,
                le = 37815,
                he = 37816,
                ue = 37817,
                de = 37818,
                pe = 37819,
                fe = 37820,
                me = 37821,
                ge = 2200,
                ve = 2201,
                ye = 2202,
                _e = 2300,
                xe = 2301,
                be = 2302,
                we = 2400,
                Me = 2401,
                Te = 2402,
                Ee = 0,
                Se = 1,
                Ae = 2,
                Pe = 3e3,
                Le = 3001,
                Ce = 3007,
                Re = 3002,
                Oe = 3003,
                Ie = 3004,
                De = 3005,
                ke = 3006,
                Ne = 3200,
                Be = 3201,
                Fe = 0,
                ze = 1,
                Ue = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
                        return function() {
                            var e = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0;
                            return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & i] + t[i >> 8 & 255] + "-" + t[i >> 16 & 15 | 64] + t[i >> 24 & 255] + "-" + t[63 & n | 128] + t[n >> 8 & 255] + "-" + t[n >> 16 & 255] + t[n >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255]).toUpperCase()
                        }
                    }(),
                    clamp: function(t, e, i) {
                        return Math.max(e, Math.min(i, t))
                    },
                    euclideanModulo: function(t, e) {
                        return (t % e + e) % e
                    },
                    mapLinear: function(t, e, i, n, r) {
                        return n + (t - e) * (r - n) / (i - e)
                    },
                    lerp: function(t, e, i) {
                        return (1 - i) * t + i * e
                    },
                    smoothstep: function(t, e, i) {
                        return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, i) {
                        return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    degToRad: function(t) {
                        return t * Ue.DEG2RAD
                    },
                    radToDeg: function(t) {
                        return t * Ue.RAD2DEG
                    },
                    isPowerOfTwo: function(t) {
                        return 0 == (t & t - 1) && 0 !== t
                    },
                    ceilPowerOfTwo: function(t) {
                        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                    },
                    floorPowerOfTwo: function(t) {
                        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                    }
                };

            function Ge(t, e) {
                this.x = t || 0, this.y = e || 0
            }

            function He() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            function Ve(t, e, i, n) {
                this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
            }

            function je(t, e, i) {
                this.x = t || 0, this.y = e || 0, this.z = i || 0
            }

            function We() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.defineProperties(Ge.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }
            }), Object.assign(Ge.prototype, {
                isVector2: !0,
                set: function(t, e) {
                    return this.x = t, this.y = e, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                },
                multiply: function(t) {
                    return this.x *= t.x, this.y *= t.y, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                applyMatrix3: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = t.elements;
                    return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                },
                clampScalar: function() {
                    var t = new Ge,
                        e = new Ge;
                    return function(i, n) {
                        return t.set(i, i), e.set(n, n), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                cross: function(t) {
                    return this.x * t.y - this.y * t.x
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function() {
                    var t = Math.atan2(this.y, this.x);
                    return t < 0 && (t += 2 * Math.PI), t
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        i = this.y - t.y;
                    return e * e + i * i
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                },
                lerpVectors: function(t, e, i) {
                    return this.subVectors(e, t).multiplyScalar(i).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
                },
                fromBufferAttribute: function(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                },
                rotateAround: function(t, e) {
                    var i = Math.cos(e),
                        n = Math.sin(e),
                        r = this.x - t.x,
                        o = this.y - t.y;
                    return this.x = r * i - o * n + t.x, this.y = r * n + o * i + t.y, this
                }
            }), Object.assign(He.prototype, {
                isMatrix4: !0,
                set: function(t, e, i, n, r, o, a, s, c, l, h, u, d, p, f, m) {
                    var g = this.elements;
                    return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = a, g[13] = s, g[2] = c, g[6] = l, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new He).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this
                },
                copyPosition: function(t) {
                    var e = this.elements,
                        i = t.elements;
                    return e[12] = i[12], e[13] = i[13], e[14] = i[14], this
                },
                extractBasis: function(t, e, i) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(t, e, i) {
                    return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function() {
                    var t = new je;
                    return function(e) {
                        var i = this.elements,
                            n = e.elements,
                            r = 1 / t.setFromMatrixColumn(e, 0).length(),
                            o = 1 / t.setFromMatrixColumn(e, 1).length(),
                            a = 1 / t.setFromMatrixColumn(e, 2).length();
                        return i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * o, i[5] = n[5] * o, i[6] = n[6] * o, i[7] = 0, i[8] = n[8] * a, i[9] = n[9] * a, i[10] = n[10] * a, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
                    }
                }(),
                makeRotationFromEuler: function(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var e = this.elements,
                        i = t.x,
                        n = t.y,
                        r = t.z,
                        o = Math.cos(i),
                        a = Math.sin(i),
                        s = Math.cos(n),
                        c = Math.sin(n),
                        l = Math.cos(r),
                        h = Math.sin(r);
                    if ("XYZ" === t.order) {
                        var u = o * l,
                            d = o * h,
                            p = a * l,
                            f = a * h;
                        e[0] = s * l, e[4] = -s * h, e[8] = c, e[1] = d + p * c, e[5] = u - f * c, e[9] = -a * s, e[2] = f - u * c, e[6] = p + d * c, e[10] = o * s
                    } else if ("YXZ" === t.order) {
                        var m = s * l,
                            g = s * h,
                            v = c * l,
                            y = c * h;
                        e[0] = m + y * a, e[4] = v * a - g, e[8] = o * c, e[1] = o * h, e[5] = o * l, e[9] = -a, e[2] = g * a - v, e[6] = y + m * a, e[10] = o * s
                    } else if ("ZXY" === t.order) {
                        m = s * l, g = s * h, v = c * l, y = c * h;
                        e[0] = m - y * a, e[4] = -o * h, e[8] = v + g * a, e[1] = g + v * a, e[5] = o * l, e[9] = y - m * a, e[2] = -o * c, e[6] = a, e[10] = o * s
                    } else if ("ZYX" === t.order) {
                        u = o * l, d = o * h, p = a * l, f = a * h;
                        e[0] = s * l, e[4] = p * c - d, e[8] = u * c + f, e[1] = s * h, e[5] = f * c + u, e[9] = d * c - p, e[2] = -c, e[6] = a * s, e[10] = o * s
                    } else if ("YZX" === t.order) {
                        var _ = o * s,
                            x = o * c,
                            b = a * s,
                            w = a * c;
                        e[0] = s * l, e[4] = w - _ * h, e[8] = b * h + x, e[1] = h, e[5] = o * l, e[9] = -a * l, e[2] = -c * l, e[6] = x * h + b, e[10] = _ - w * h
                    } else if ("XZY" === t.order) {
                        _ = o * s, x = o * c, b = a * s, w = a * c;
                        e[0] = s * l, e[4] = -h, e[8] = c * l, e[1] = _ * h + w, e[5] = o * l, e[9] = x * h - b, e[2] = b * h - x, e[6] = a * l, e[10] = w * h + _
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                },
                makeRotationFromQuaternion: function() {
                    var t = new je(0, 0, 0),
                        e = new je(1, 1, 1);
                    return function(i) {
                        return this.compose(t, i, e)
                    }
                }(),
                lookAt: function() {
                    var t = new je,
                        e = new je,
                        i = new je;
                    return function(n, r, o) {
                        var a = this.elements;
                        return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), t.crossVectors(o, i), 0 === t.lengthSq() && (1 === Math.abs(o.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(o, i)), t.normalize(), e.crossVectors(i, t), a[0] = t.x, a[4] = e.x, a[8] = i.x, a[1] = t.y, a[5] = e.y, a[9] = i.y, a[2] = t.z, a[6] = e.z, a[10] = i.z, this
                    }
                }(),
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        o = i[0],
                        a = i[4],
                        s = i[8],
                        c = i[12],
                        l = i[1],
                        h = i[5],
                        u = i[9],
                        d = i[13],
                        p = i[2],
                        f = i[6],
                        m = i[10],
                        g = i[14],
                        v = i[3],
                        y = i[7],
                        _ = i[11],
                        x = i[15],
                        b = n[0],
                        w = n[4],
                        M = n[8],
                        T = n[12],
                        E = n[1],
                        S = n[5],
                        A = n[9],
                        P = n[13],
                        L = n[2],
                        C = n[6],
                        R = n[10],
                        O = n[14],
                        I = n[3],
                        D = n[7],
                        k = n[11],
                        N = n[15];
                    return r[0] = o * b + a * E + s * L + c * I, r[4] = o * w + a * S + s * C + c * D, r[8] = o * M + a * A + s * R + c * k, r[12] = o * T + a * P + s * O + c * N, r[1] = l * b + h * E + u * L + d * I, r[5] = l * w + h * S + u * C + d * D, r[9] = l * M + h * A + u * R + d * k, r[13] = l * T + h * P + u * O + d * N, r[2] = p * b + f * E + m * L + g * I, r[6] = p * w + f * S + m * C + g * D, r[10] = p * M + f * A + m * R + g * k, r[14] = p * T + f * P + m * O + g * N, r[3] = v * b + y * E + _ * L + x * I, r[7] = v * w + y * S + _ * C + x * D, r[11] = v * M + y * A + _ * R + x * k, r[15] = v * T + y * P + _ * O + x * N, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                },
                applyToBufferAttribute: function() {
                    var t = new je;
                    return function(e) {
                        for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
                        return e
                    }
                }(),
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        i = t[4],
                        n = t[8],
                        r = t[12],
                        o = t[1],
                        a = t[5],
                        s = t[9],
                        c = t[13],
                        l = t[2],
                        h = t[6],
                        u = t[10],
                        d = t[14];
                    return t[3] * (+r * s * h - n * c * h - r * a * u + i * c * u + n * a * d - i * s * d) + t[7] * (+e * s * d - e * c * u + r * o * u - n * o * d + n * c * l - r * s * l) + t[11] * (+e * c * h - e * a * d - r * o * h + i * o * d + r * a * l - i * c * l) + t[15] * (-n * a * l - e * s * h + e * a * u + n * o * h - i * o * u + i * s * l)
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                },
                setPosition: function(t) {
                    var e = this.elements;
                    return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
                },
                getInverse: function(t, e) {
                    var i = this.elements,
                        n = t.elements,
                        r = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        c = n[4],
                        l = n[5],
                        h = n[6],
                        u = n[7],
                        d = n[8],
                        p = n[9],
                        f = n[10],
                        m = n[11],
                        g = n[12],
                        v = n[13],
                        y = n[14],
                        _ = n[15],
                        x = p * y * u - v * f * u + v * h * m - l * y * m - p * h * _ + l * f * _,
                        b = g * f * u - d * y * u - g * h * m + c * y * m + d * h * _ - c * f * _,
                        w = d * v * u - g * p * u + g * l * m - c * v * m - d * l * _ + c * p * _,
                        M = g * p * h - d * v * h - g * l * f + c * v * f + d * l * y - c * p * y,
                        T = r * x + o * b + a * w + s * M;
                    if (0 === T) {
                        var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(E);
                        return console.warn(E), this.identity()
                    }
                    var S = 1 / T;
                    return i[0] = x * S, i[1] = (v * f * s - p * y * s - v * a * m + o * y * m + p * a * _ - o * f * _) * S, i[2] = (l * y * s - v * h * s + v * a * u - o * y * u - l * a * _ + o * h * _) * S, i[3] = (p * h * s - l * f * s - p * a * u + o * f * u + l * a * m - o * h * m) * S, i[4] = b * S, i[5] = (d * y * s - g * f * s + g * a * m - r * y * m - d * a * _ + r * f * _) * S, i[6] = (g * h * s - c * y * s - g * a * u + r * y * u + c * a * _ - r * h * _) * S, i[7] = (c * f * s - d * h * s + d * a * u - r * f * u - c * a * m + r * h * m) * S, i[8] = w * S, i[9] = (g * p * s - d * v * s - g * o * m + r * v * m + d * o * _ - r * p * _) * S, i[10] = (c * v * s - g * l * s + g * o * u - r * v * u - c * o * _ + r * l * _) * S, i[11] = (d * l * s - c * p * s - d * o * u + r * p * u + c * o * m - r * l * m) * S, i[12] = M * S, i[13] = (d * v * a - g * p * a + g * o * f - r * v * f - d * o * y + r * p * y) * S, i[14] = (g * l * a - c * v * a - g * o * h + r * v * h + c * o * y - r * l * y) * S, i[15] = (c * p * a - d * l * a + d * o * h - r * p * h - c * o * f + r * l * f) * S, this
                },
                scale: function(t) {
                    var e = this.elements,
                        i = t.x,
                        n = t.y,
                        r = t.z;
                    return e[0] *= i, e[4] *= n, e[8] *= r, e[1] *= i, e[5] *= n, e[9] *= r, e[2] *= i, e[6] *= n, e[10] *= r, e[3] *= i, e[7] *= n, e[11] *= r, this
                },
                getMaxScaleOnAxis: function() {
                    var t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, i, n))
                },
                makeTranslation: function(t, e, i) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
                },
                makeRotationX: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(t, e) {
                    var i = Math.cos(e),
                        n = Math.sin(e),
                        r = 1 - i,
                        o = t.x,
                        a = t.y,
                        s = t.z,
                        c = r * o,
                        l = r * a;
                    return this.set(c * o + i, c * a - n * s, c * s + n * a, 0, c * a + n * s, l * a + i, l * s - n * o, 0, c * s - n * a, l * s + n * o, r * s * s + i, 0, 0, 0, 0, 1), this
                },
                makeScale: function(t, e, i) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                },
                makeShear: function(t, e, i) {
                    return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
                },
                compose: function(t, e, i) {
                    var n = this.elements,
                        r = e._x,
                        o = e._y,
                        a = e._z,
                        s = e._w,
                        c = r + r,
                        l = o + o,
                        h = a + a,
                        u = r * c,
                        d = r * l,
                        p = r * h,
                        f = o * l,
                        m = o * h,
                        g = a * h,
                        v = s * c,
                        y = s * l,
                        _ = s * h,
                        x = i.x,
                        b = i.y,
                        w = i.z;
                    return n[0] = (1 - (f + g)) * x, n[1] = (d + _) * x, n[2] = (p - y) * x, n[3] = 0, n[4] = (d - _) * b, n[5] = (1 - (u + g)) * b, n[6] = (m + v) * b, n[7] = 0, n[8] = (p + y) * w, n[9] = (m - v) * w, n[10] = (1 - (u + f)) * w, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
                },
                decompose: function() {
                    var t = new je,
                        e = new He;
                    return function(i, n, r) {
                        var o = this.elements,
                            a = t.set(o[0], o[1], o[2]).length(),
                            s = t.set(o[4], o[5], o[6]).length(),
                            c = t.set(o[8], o[9], o[10]).length();
                        this.determinant() < 0 && (a = -a), i.x = o[12], i.y = o[13], i.z = o[14], e.copy(this);
                        var l = 1 / a,
                            h = 1 / s,
                            u = 1 / c;
                        return e.elements[0] *= l, e.elements[1] *= l, e.elements[2] *= l, e.elements[4] *= h, e.elements[5] *= h, e.elements[6] *= h, e.elements[8] *= u, e.elements[9] *= u, e.elements[10] *= u, n.setFromRotationMatrix(e), r.x = a, r.y = s, r.z = c, this
                    }
                }(),
                makePerspective: function(t, e, i, n, r, o) {
                    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var a = this.elements,
                        s = 2 * r / (e - t),
                        c = 2 * r / (i - n),
                        l = (e + t) / (e - t),
                        h = (i + n) / (i - n),
                        u = -(o + r) / (o - r),
                        d = -2 * o * r / (o - r);
                    return a[0] = s, a[4] = 0, a[8] = l, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makeOrthographic: function(t, e, i, n, r, o) {
                    var a = this.elements,
                        s = 1 / (e - t),
                        c = 1 / (i - n),
                        l = 1 / (o - r),
                        h = (e + t) * s,
                        u = (i + n) * c,
                        d = (o + r) * l;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * l, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                equals: function(t) {
                    for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
                }
            }), Object.assign(Ve, {
                slerp: function(t, e, i, n) {
                    return i.copy(t).slerp(e, n)
                },
                slerpFlat: function(t, e, i, n, r, o, a) {
                    var s = i[n + 0],
                        c = i[n + 1],
                        l = i[n + 2],
                        h = i[n + 3],
                        u = r[o + 0],
                        d = r[o + 1],
                        p = r[o + 2],
                        f = r[o + 3];
                    if (h !== f || s !== u || c !== d || l !== p) {
                        var m = 1 - a,
                            g = s * u + c * d + l * p + h * f,
                            v = g >= 0 ? 1 : -1,
                            y = 1 - g * g;
                        if (y > Number.EPSILON) {
                            var _ = Math.sqrt(y),
                                x = Math.atan2(_, g * v);
                            m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                        }
                        var b = a * v;
                        if (s = s * m + u * b, c = c * m + d * b, l = l * m + p * b, h = h * m + f * b, m === 1 - a) {
                            var w = 1 / Math.sqrt(s * s + c * c + l * l + h * h);
                            s *= w, c *= w, l *= w, h *= w
                        }
                    }
                    t[e] = s, t[e + 1] = c, t[e + 2] = l, t[e + 3] = h
                }
            }), Object.defineProperties(Ve.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(t) {
                        this._w = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(Ve.prototype, {
                isQuaternion: !0,
                set: function(t, e, i, n) {
                    return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
                },
                setFromEuler: function(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var i = t._x,
                        n = t._y,
                        r = t._z,
                        o = t.order,
                        a = Math.cos,
                        s = Math.sin,
                        c = a(i / 2),
                        l = a(n / 2),
                        h = a(r / 2),
                        u = s(i / 2),
                        d = s(n / 2),
                        p = s(r / 2);
                    return "XYZ" === o ? (this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p) : "YXZ" === o ? (this._x = u * l * h + c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p) : "ZXY" === o ? (this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h - u * d * p) : "ZYX" === o ? (this._x = u * l * h - c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h + u * d * p) : "YZX" === o ? (this._x = u * l * h + c * d * p, this._y = c * d * h + u * l * p, this._z = c * l * p - u * d * h, this._w = c * l * h - u * d * p) : "XZY" === o && (this._x = u * l * h - c * d * p, this._y = c * d * h - u * l * p, this._z = c * l * p + u * d * h, this._w = c * l * h + u * d * p), !1 !== e && this.onChangeCallback(), this
                },
                setFromAxisAngle: function(t, e) {
                    var i = e / 2,
                        n = Math.sin(i);
                    return this._x = t.x * n, this._y = t.y * n, this._z = t.z * n, this._w = Math.cos(i), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t) {
                    var e, i = t.elements,
                        n = i[0],
                        r = i[4],
                        o = i[8],
                        a = i[1],
                        s = i[5],
                        c = i[9],
                        l = i[2],
                        h = i[6],
                        u = i[10],
                        d = n + s + u;
                    return d > 0 ? (e = .5 / Math.sqrt(d + 1), this._w = .25 / e, this._x = (h - c) * e, this._y = (o - l) * e, this._z = (a - r) * e) : n > s && n > u ? (e = 2 * Math.sqrt(1 + n - s - u), this._w = (h - c) / e, this._x = .25 * e, this._y = (r + a) / e, this._z = (o + l) / e) : s > u ? (e = 2 * Math.sqrt(1 + s - n - u), this._w = (o - l) / e, this._x = (r + a) / e, this._y = .25 * e, this._z = (c + h) / e) : (e = 2 * Math.sqrt(1 + u - n - s), this._w = (a - r) / e, this._x = (o + l) / e, this._y = (c + h) / e, this._z = .25 * e), this.onChangeCallback(), this
                },
                setFromUnitVectors: function() {
                    var t, e = new je;
                    return function(i, n) {
                        return void 0 === e && (e = new je), (t = i.dot(n) + 1) < 1e-6 ? (t = 0, Math.abs(i.x) > Math.abs(i.z) ? e.set(-i.y, i.x, 0) : e.set(0, -i.z, i.y)) : e.crossVectors(i, n), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize()
                    }
                }(),
                angleTo: function(t) {
                    return 2 * Math.acos(Math.abs(Ue.clamp(this.dot(t), -1, 1)))
                },
                rotateTowards: function(t, e) {
                    var i = this.angleTo(t);
                    if (0 === i) return this;
                    var n = Math.min(1, e / i);
                    return this.slerp(t, n), this
                },
                inverse: function() {
                    return this.conjugate()
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this.onChangeCallback(), this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyQuaternions(t, this)
                },
                multiplyQuaternions: function(t, e) {
                    var i = t._x,
                        n = t._y,
                        r = t._z,
                        o = t._w,
                        a = e._x,
                        s = e._y,
                        c = e._z,
                        l = e._w;
                    return this._x = i * l + o * a + n * c - r * s, this._y = n * l + o * s + r * a - i * c, this._z = r * l + o * c + i * s - n * a, this._w = o * l - i * a - n * s - r * c, this.onChangeCallback(), this
                },
                slerp: function(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    var i = this._x,
                        n = this._y,
                        r = this._z,
                        o = this._w,
                        a = o * t._w + i * t._x + n * t._y + r * t._z;
                    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = i, this._y = n, this._z = r, this;
                    var s = 1 - a * a;
                    if (s <= Number.EPSILON) {
                        var c = 1 - e;
                        return this._w = c * o + e * this._w, this._x = c * i + e * this._x, this._y = c * n + e * this._y, this._z = c * r + e * this._z, this.normalize()
                    }
                    var l = Math.sqrt(s),
                        h = Math.atan2(l, a),
                        u = Math.sin((1 - e) * h) / l,
                        d = Math.sin(e * h) / l;
                    return this._w = o * u + this._w * d, this._x = i * u + this._x * d, this._y = n * u + this._y * d, this._z = r * u + this._z * d, this.onChangeCallback(), this
                },
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(je.prototype, {
                isVector3: !0,
                set: function(t, e, i) {
                    return this.x = t, this.y = e, this.z = i, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                },
                multiplyVectors: function(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                },
                applyEuler: function() {
                    var t = new Ve;
                    return function(e) {
                        return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
                    }
                }(),
                applyAxisAngle: function() {
                    var t = new Ve;
                    return function(e, i) {
                        return this.applyQuaternion(t.setFromAxisAngle(e, i))
                    }
                }(),
                applyMatrix3: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * i + r[6] * n, this.y = r[1] * e + r[4] * i + r[7] * n, this.z = r[2] * e + r[5] * i + r[8] * n, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements,
                        o = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
                    return this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * o, this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * o, this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * o, this
                },
                applyQuaternion: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.x,
                        o = t.y,
                        a = t.z,
                        s = t.w,
                        c = s * e + o * n - a * i,
                        l = s * i + a * e - r * n,
                        h = s * n + r * i - o * e,
                        u = -r * e - o * i - a * n;
                    return this.x = c * s + u * -r + l * -a - h * -o, this.y = l * s + u * -o + h * -r - c * -a, this.z = h * s + u * -a + c * -o - l * -r, this
                },
                project: function(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                },
                unproject: function() {
                    var t = new He;
                    return function(e) {
                        return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(e.matrixWorld)
                    }
                }(),
                transformDirection: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * i + r[8] * n, this.y = r[1] * e + r[5] * i + r[9] * n, this.z = r[2] * e + r[6] * i + r[10] * n, this.normalize()
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                },
                clampScalar: function() {
                    var t = new je,
                        e = new je;
                    return function(i, n) {
                        return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                },
                lerpVectors: function(t, e, i) {
                    return this.subVectors(e, t).multiplyScalar(i).add(t)
                },
                cross: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                },
                crossVectors: function(t, e) {
                    var i = t.x,
                        n = t.y,
                        r = t.z,
                        o = e.x,
                        a = e.y,
                        s = e.z;
                    return this.x = n * s - r * a, this.y = r * o - i * s, this.z = i * a - n * o, this
                },
                projectOnVector: function(t) {
                    var e = t.dot(this) / t.lengthSq();
                    return this.copy(t).multiplyScalar(e)
                },
                projectOnPlane: function() {
                    var t = new je;
                    return function(e) {
                        return t.copy(this).projectOnVector(e), this.sub(t)
                    }
                }(),
                reflect: function() {
                    var t = new je;
                    return function(e) {
                        return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                    }
                }(),
                angleTo: function(t) {
                    var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                    return Math.acos(Ue.clamp(e, -1, 1))
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        i = this.y - t.y,
                        n = this.z - t.z;
                    return e * e + i * i + n * n
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                },
                setFromSpherical: function(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                },
                setFromSphericalCoords: function(t, e, i) {
                    var n = Math.sin(e) * t;
                    return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
                },
                setFromCylindrical: function(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                },
                setFromCylindricalCoords: function(t, e, i) {
                    return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
                },
                setFromMatrixPosition: function(t) {
                    var e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                },
                setFromMatrixScale: function(t) {
                    var e = this.setFromMatrixColumn(t, 0).length(),
                        i = this.setFromMatrixColumn(t, 1).length(),
                        n = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = i, this.z = n, this
                },
                setFromMatrixColumn: function(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                },
                fromBufferAttribute: function(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
            }), Object.assign(We.prototype, {
                isMatrix3: !0,
                set: function(t, e, i, n, r, o, a, s, c) {
                    var l = this.elements;
                    return l[0] = t, l[1] = n, l[2] = a, l[3] = e, l[4] = r, l[5] = s, l[6] = i, l[7] = o, l[8] = c, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        i = t.elements;
                    return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this
                },
                setFromMatrix4: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                },
                applyToBufferAttribute: function() {
                    var t = new je;
                    return function(e) {
                        for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
                        return e
                    }
                }(),
                multiply: function(t) {
                    return this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var i = t.elements,
                        n = e.elements,
                        r = this.elements,
                        o = i[0],
                        a = i[3],
                        s = i[6],
                        c = i[1],
                        l = i[4],
                        h = i[7],
                        u = i[2],
                        d = i[5],
                        p = i[8],
                        f = n[0],
                        m = n[3],
                        g = n[6],
                        v = n[1],
                        y = n[4],
                        _ = n[7],
                        x = n[2],
                        b = n[5],
                        w = n[8];
                    return r[0] = o * f + a * v + s * x, r[3] = o * m + a * y + s * b, r[6] = o * g + a * _ + s * w, r[1] = c * f + l * v + h * x, r[4] = c * m + l * y + h * b, r[7] = c * g + l * _ + h * w, r[2] = u * f + d * v + p * x, r[5] = u * m + d * y + p * b, r[8] = u * g + d * _ + p * w, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                },
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        r = t[3],
                        o = t[4],
                        a = t[5],
                        s = t[6],
                        c = t[7],
                        l = t[8];
                    return e * o * l - e * a * c - i * r * l + i * a * s + n * r * c - n * o * s
                },
                getInverse: function(t, e) {
                    t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var i = t.elements,
                        n = this.elements,
                        r = i[0],
                        o = i[1],
                        a = i[2],
                        s = i[3],
                        c = i[4],
                        l = i[5],
                        h = i[6],
                        u = i[7],
                        d = i[8],
                        p = d * c - l * u,
                        f = l * h - d * s,
                        m = u * s - c * h,
                        g = r * p + o * f + a * m;
                    if (0 === g) {
                        var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(v);
                        return console.warn(v), this.identity()
                    }
                    var y = 1 / g;
                    return n[0] = p * y, n[1] = (a * u - d * o) * y, n[2] = (l * o - a * c) * y, n[3] = f * y, n[4] = (d * r - a * h) * y, n[5] = (a * s - l * r) * y, n[6] = m * y, n[7] = (o * h - u * r) * y, n[8] = (c * r - o * s) * y, this
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                },
                getNormalMatrix: function(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                },
                transposeIntoArray: function(t) {
                    var e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                },
                setUvTransform: function(t, e, i, n, r, o, a) {
                    var s = Math.cos(r),
                        c = Math.sin(r);
                    this.set(i * s, i * c, -i * (s * o + c * a) + o + t, -n * c, n * s, -n * (-c * o + s * a) + a + e, 0, 0, 1)
                },
                scale: function(t, e) {
                    var i = this.elements;
                    return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        i = Math.sin(t),
                        n = this.elements,
                        r = n[0],
                        o = n[3],
                        a = n[6],
                        s = n[1],
                        c = n[4],
                        l = n[7];
                    return n[0] = e * r + i * s, n[3] = e * o + i * c, n[6] = e * a + i * l, n[1] = -i * r + e * s, n[4] = -i * o + e * c, n[7] = -i * a + e * l, this
                },
                translate: function(t, e) {
                    var i = this.elements;
                    return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
                },
                equals: function(t) {
                    for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
                        if (e[n] !== i[n]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var i = this.elements;
                    return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
                }
            });
            var Xe = {
                    getDataURL: function(t) {
                        var e;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === r && (r = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), r.width = t.width, r.height = t.height;
                            var i = r.getContext("2d");
                            t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), e = r
                        }
                        return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }
                },
                qe = 0;

            function Ye(t, e, i, n, r, o, a, s, c, l) {
                Object.defineProperty(this, "id", {
                    value: qe++
                }), this.uuid = Ue.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Ye.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Ye.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : yt, this.wrapT = void 0 !== n ? n : yt, this.magFilter = void 0 !== r ? r : Mt, this.minFilter = void 0 !== o ? o : Et, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : Ut, this.type = void 0 !== s ? s : St, this.offset = new Ge(0, 0), this.repeat = new Ge(1, 1), this.center = new Ge(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new We, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== l ? l : Pe, this.version = 0, this.onUpdate = null
            }

            function Ze(t, e, i, n) {
                this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
            }

            function Je(t, e, i) {
                this.width = t, this.height = e, this.scissor = new Ze(0, 0, t, e), this.scissorTest = !1, this.viewport = new Ze(0, 0, t, e), i = i || {}, this.texture = new Ye(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : Mt, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
            }

            function Ke(t, e, i) {
                Je.call(this, t, e, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
            }

            function Qe(t, e, i, n, r, o, a, s, c, l, h, u) {
                Ye.call(this, null, o, a, s, c, l, n, r, h, u), this.image = {
                    data: t,
                    width: e,
                    height: i
                }, this.magFilter = void 0 !== c ? c : xt, this.minFilter = void 0 !== l ? l : xt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }

            function $e(t, e) {
                this.min = void 0 !== t ? t : new je(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new je(-1 / 0, -1 / 0, -1 / 0)
            }

            function ti(t, e) {
                this.center = void 0 !== t ? t : new je, this.radius = void 0 !== e ? e : 0
            }

            function ei(t, e) {
                this.normal = void 0 !== t ? t : new je(1, 0, 0), this.constant = void 0 !== e ? e : 0
            }

            function ii(t, e, i, n, r, o) {
                this.planes = [void 0 !== t ? t : new ei, void 0 !== e ? e : new ei, void 0 !== i ? i : new ei, void 0 !== n ? n : new ei, void 0 !== r ? r : new ei, void 0 !== o ? o : new ei]
            }
            Ye.DEFAULT_IMAGE = void 0, Ye.DEFAULT_MAPPING = lt, Ye.prototype = Object.assign(Object.create(n.prototype), {
                constructor: Ye,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    var i = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY
                    };
                    if (void 0 !== this.image) {
                        var n = this.image;
                        if (void 0 === n.uuid && (n.uuid = Ue.generateUUID()), !e && void 0 === t.images[n.uuid]) {
                            var r;
                            if (Array.isArray(n)) {
                                r = [];
                                for (var o = 0, a = n.length; o < a; o++) r.push(Xe.getDataURL(n[o]))
                            } else r = Xe.getDataURL(n);
                            t.images[n.uuid] = {
                                uuid: n.uuid,
                                url: r
                            }
                        }
                        i.image = n.uuid
                    }
                    return e || (t.textures[this.uuid] = i), i
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (this.mapping !== lt) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case vt:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case yt:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case _t:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case vt:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case yt:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case _t:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
            }), Object.defineProperty(Ye.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(Ze.prototype, {
                isVector4: !0,
                set: function(t, e, i, n) {
                    return this.x = t, this.y = e, this.z = i, this.w = n, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setW: function(t) {
                    return this.w = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        i = this.y,
                        n = this.z,
                        r = this.w,
                        o = t.elements;
                    return this.x = o[0] * e + o[4] * i + o[8] * n + o[12] * r, this.y = o[1] * e + o[5] * i + o[9] * n + o[13] * r, this.z = o[2] * e + o[6] * i + o[10] * n + o[14] * r, this.w = o[3] * e + o[7] * i + o[11] * n + o[15] * r, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                setAxisAngleFromQuaternion: function(t) {
                    this.w = 2 * Math.acos(t.w);
                    var e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                },
                setAxisAngleFromRotationMatrix: function(t) {
                    var e, i, n, r, o = t.elements,
                        a = o[0],
                        s = o[4],
                        c = o[8],
                        l = o[1],
                        h = o[5],
                        u = o[9],
                        d = o[2],
                        p = o[6],
                        f = o[10];
                    if (Math.abs(s - l) < .01 && Math.abs(c - d) < .01 && Math.abs(u - p) < .01) {
                        if (Math.abs(s + l) < .1 && Math.abs(c + d) < .1 && Math.abs(u + p) < .1 && Math.abs(a + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        var m = (a + 1) / 2,
                            g = (h + 1) / 2,
                            v = (f + 1) / 2,
                            y = (s + l) / 4,
                            _ = (c + d) / 4,
                            x = (u + p) / 4;
                        return m > g && m > v ? m < .01 ? (i = 0, n = .707106781, r = .707106781) : (n = y / (i = Math.sqrt(m)), r = _ / i) : g > v ? g < .01 ? (i = .707106781, n = 0, r = .707106781) : (i = y / (n = Math.sqrt(g)), r = x / n) : v < .01 ? (i = .707106781, n = .707106781, r = 0) : (i = _ / (r = Math.sqrt(v)), n = x / r), this.set(i, n, r, e), this
                    }
                    var b = Math.sqrt((p - u) * (p - u) + (c - d) * (c - d) + (l - s) * (l - s));
                    return Math.abs(b) < .001 && (b = 1), this.x = (p - u) / b, this.y = (c - d) / b, this.z = (l - s) / b, this.w = Math.acos((a + h + f - 1) / 2), this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                },
                clampScalar: function() {
                    var t, e;
                    return function(i, n) {
                        return void 0 === t && (t = new Ze, e = new Ze), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                },
                lerpVectors: function(t, e, i) {
                    return this.subVectors(e, t).multiplyScalar(i).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                },
                fromBufferAttribute: function(t, e, i) {
                    return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
            }), Je.prototype = Object.assign(Object.create(n.prototype), {
                constructor: Je,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Ke.prototype = Object.create(Je.prototype), Ke.prototype.constructor = Ke, Ke.prototype.isWebGLRenderTargetCube = !0, Qe.prototype = Object.create(Ye.prototype), Qe.prototype.constructor = Qe, Qe.prototype.isDataTexture = !0, Object.assign($e.prototype, {
                isBox3: !0,
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromArray: function(t) {
                    for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                        var l = t[s],
                            h = t[s + 1],
                            u = t[s + 2];
                        l < e && (e = l), h < i && (i = h), u < n && (n = u), l > r && (r = l), h > o && (o = h), u > a && (a = u)
                    }
                    return this.min.set(e, i, n), this.max.set(r, o, a), this
                },
                setFromBufferAttribute: function(t) {
                    for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) {
                        var l = t.getX(s),
                            h = t.getY(s),
                            u = t.getZ(s);
                        l < e && (e = l), h < i && (i = h), u < n && (n = u), l > r && (r = l), h > o && (o = h), u > a && (a = u)
                    }
                    return this.min.set(e, i, n), this.max.set(r, o, a), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var t = new je;
                    return function(e, i) {
                        var n = t.copy(i).multiplyScalar(.5);
                        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                    }
                }(),
                setFromObject: function(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new je), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new je), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                expandByObject: function() {
                    var t, e, i, n = new je;

                    function r(r) {
                        var o = r.geometry;
                        if (void 0 !== o)
                            if (o.isGeometry) {
                                var a = o.vertices;
                                for (e = 0, i = a.length; e < i; e++) n.copy(a[e]), n.applyMatrix4(r.matrixWorld), t.expandByPoint(n)
                            } else if (o.isBufferGeometry) {
                            var s = o.attributes.position;
                            if (void 0 !== s)
                                for (e = 0, i = s.count; e < i; e++) n.fromBufferAttribute(s, e).applyMatrix4(r.matrixWorld), t.expandByPoint(n)
                        }
                    }
                    return function(e) {
                        return t = this, e.updateMatrixWorld(!0), e.traverse(r), this
                    }
                }(),
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                },
                getParameter: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new je), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                },
                intersectsSphere: function() {
                    var t = new je;
                    return function(e) {
                        return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
                    }
                }(),
                intersectsPlane: function(t) {
                    var e, i;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, i = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, i = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
                },
                intersectsTriangle: function() {
                    var t = new je,
                        e = new je,
                        i = new je,
                        n = new je,
                        r = new je,
                        o = new je,
                        a = new je,
                        s = new je,
                        c = new je,
                        l = new je;

                    function h(n) {
                        var r, o;
                        for (r = 0, o = n.length - 3; r <= o; r += 3) {
                            a.fromArray(n, r);
                            var s = c.x * Math.abs(a.x) + c.y * Math.abs(a.y) + c.z * Math.abs(a.z),
                                l = t.dot(a),
                                h = e.dot(a),
                                u = i.dot(a);
                            if (Math.max(-Math.max(l, h, u), Math.min(l, h, u)) > s) return !1
                        }
                        return !0
                    }
                    return function(a) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(s), c.subVectors(this.max, s), t.subVectors(a.a, s), e.subVectors(a.b, s), i.subVectors(a.c, s), n.subVectors(e, t), r.subVectors(i, e), o.subVectors(t, i);
                        var u = [0, -n.z, n.y, 0, -r.z, r.y, 0, -o.z, o.y, n.z, 0, -n.x, r.z, 0, -r.x, o.z, 0, -o.x, -n.y, n.x, 0, -r.y, r.x, 0, -o.y, o.x, 0];
                        return !!h(u) && (!!h(u = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (l.crossVectors(n, r), h(u = [l.x, l.y, l.z])))
                    }
                }(),
                clampPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new je), e.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var t = new je;
                    return function(e) {
                        return t.copy(e).clamp(this.min, this.max).sub(e).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var t = new je;
                    return function(e) {
                        return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new ti), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
                    }
                }(),
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                applyMatrix4: function() {
                    var t = [new je, new je, new je, new je, new je, new je, new je, new je];
                    return function(e) {
                        return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
                    }
                }(),
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }), Object.assign(ti.prototype, {
                set: function(t, e) {
                    return this.center.copy(t), this.radius = e, this
                },
                setFromPoints: function() {
                    var t = new $e;
                    return function(e, i) {
                        var n = this.center;
                        void 0 !== i ? n.copy(i) : t.setFromPoints(e).getCenter(n);
                        for (var r = 0, o = 0, a = e.length; o < a; o++) r = Math.max(r, n.distanceToSquared(e[o]));
                        return this.radius = Math.sqrt(r), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(t) {
                    return t.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(t) {
                    var e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                },
                intersectsBox: function(t) {
                    return t.intersectsSphere(this)
                },
                intersectsPlane: function(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function(t, e) {
                    var i = this.center.distanceToSquared(t);
                    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new je), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                },
                getBoundingBox: function(t) {
                    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new $e), t.set(this.center, this.center), t.expandByScalar(this.radius), t
                },
                applyMatrix4: function(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                },
                translate: function(t) {
                    return this.center.add(t), this
                },
                equals: function(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            }), Object.assign(ei.prototype, {
                set: function(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                },
                setComponents: function(t, e, i, n) {
                    return this.normal.set(t, e, i), this.constant = n, this
                },
                setFromNormalAndCoplanarPoint: function(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                },
                setFromCoplanarPoints: function() {
                    var t = new je,
                        e = new je;
                    return function(i, n, r) {
                        var o = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize();
                        return this.setFromNormalAndCoplanarPoint(o, i), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                },
                normalize: function() {
                    var t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(t) {
                    return this.normal.dot(t) + this.constant
                },
                distanceToSphere: function(t) {
                    return this.distanceToPoint(t.center) - t.radius
                },
                projectPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new je), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                },
                intersectLine: function() {
                    var t = new je;
                    return function(e, i) {
                        void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new je);
                        var n = e.delta(t),
                            r = this.normal.dot(n);
                        if (0 === r) return 0 === this.distanceToPoint(e.start) ? i.copy(e.start) : void 0;
                        var o = -(e.start.dot(this.normal) + this.constant) / r;
                        return o < 0 || o > 1 ? void 0 : i.copy(n).multiplyScalar(o).add(e.start)
                    }
                }(),
                intersectsLine: function(t) {
                    var e = this.distanceToPoint(t.start),
                        i = this.distanceToPoint(t.end);
                    return e < 0 && i > 0 || i < 0 && e > 0
                },
                intersectsBox: function(t) {
                    return t.intersectsPlane(this)
                },
                intersectsSphere: function(t) {
                    return t.intersectsPlane(this)
                },
                coplanarPoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new je), t.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var t = new je,
                        e = new We;
                    return function(i, n) {
                        var r = n || e.getNormalMatrix(i),
                            o = this.coplanarPoint(t).applyMatrix4(i),
                            a = this.normal.applyMatrix3(r).normalize();
                        return this.constant = -o.dot(a), this
                    }
                }(),
                translate: function(t) {
                    return this.constant -= t.dot(this.normal), this
                },
                equals: function(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            }), Object.assign(ii.prototype, {
                set: function(t, e, i, n, r, o) {
                    var a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                    return this
                },
                setFromMatrix: function(t) {
                    var e = this.planes,
                        i = t.elements,
                        n = i[0],
                        r = i[1],
                        o = i[2],
                        a = i[3],
                        s = i[4],
                        c = i[5],
                        l = i[6],
                        h = i[7],
                        u = i[8],
                        d = i[9],
                        p = i[10],
                        f = i[11],
                        m = i[12],
                        g = i[13],
                        v = i[14],
                        y = i[15];
                    return e[0].setComponents(a - n, h - s, f - u, y - m).normalize(), e[1].setComponents(a + n, h + s, f + u, y + m).normalize(), e[2].setComponents(a + r, h + c, f + d, y + g).normalize(), e[3].setComponents(a - r, h - c, f - d, y - g).normalize(), e[4].setComponents(a - o, h - l, f - p, y - v).normalize(), e[5].setComponents(a + o, h + l, f + p, y + v).normalize(), this
                },
                intersectsObject: function() {
                    var t = new ti;
                    return function(e) {
                        var i = e.geometry;
                        return null === i.boundingSphere && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                    }
                }(),
                intersectsSprite: function() {
                    var t = new ti;
                    return function(e) {
                        return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                    }
                }(),
                intersectsSphere: function(t) {
                    for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
                        if (e[r].distanceToPoint(i) < n) return !1
                    }
                    return !0
                },
                intersectsBox: function() {
                    var t = new je;
                    return function(e) {
                        for (var i = this.planes, n = 0; n < 6; n++) {
                            var r = i[n];
                            if (t.x = r.normal.x > 0 ? e.max.x : e.min.x, t.y = r.normal.y > 0 ? e.max.y : e.min.y, t.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(t) < 0) return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function(t) {
                    for (var e = this.planes, i = 0; i < 6; i++)
                        if (e[i].distanceToPoint(t) < 0) return !1;
                    return !0
                }
            });
            var ni = {
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );",
                bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
                lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
                map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif",
                normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
                uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
                background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
            };

            function ri(t) {
                var e = {};
                for (var i in t)
                    for (var n in e[i] = {}, t[i]) {
                        var r = t[i][n];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
                    }
                return e
            }

            function oi(t) {
                for (var e = {}, i = 0; i < t.length; i++) {
                    var n = ri(t[i]);
                    for (var r in n) e[r] = n[r]
                }
                return e
            }
            var ai = {
                    clone: ri,
                    merge: oi
                },
                si = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                };

            function ci(t, e, i) {
                return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
            }
            Object.assign(ci.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                },
                setScalar: function(t) {
                    return this.r = t, this.g = t, this.b = t, this
                },
                setHex: function(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                },
                setRGB: function(t, e, i) {
                    return this.r = t, this.g = e, this.b = i, this
                },
                setHSL: function() {
                    function t(t, e, i) {
                        return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
                    }
                    return function(e, i, n) {
                        if (e = Ue.euclideanModulo(e, 1), i = Ue.clamp(i, 0, 1), n = Ue.clamp(n, 0, 1), 0 === i) this.r = this.g = this.b = n;
                        else {
                            var r = n <= .5 ? n * (1 + i) : n + i - n * i,
                                o = 2 * n - r;
                            this.r = t(o, r, e + 1 / 3), this.g = t(o, r, e), this.b = t(o, r, e - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    var i;
                    if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var n, r = i[1],
                            o = i[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                                if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                    var a = parseFloat(n[1]) / 360,
                                        s = parseInt(n[2], 10) / 100,
                                        c = parseInt(n[3], 10) / 100;
                                    return e(n[5]), this.setHSL(a, s, c)
                                }
                        }
                    } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var l, h = (l = i[1]).length;
                        if (3 === h) return this.r = parseInt(l.charAt(0) + l.charAt(0), 16) / 255, this.g = parseInt(l.charAt(1) + l.charAt(1), 16) / 255, this.b = parseInt(l.charAt(2) + l.charAt(2), 16) / 255, this;
                        if (6 === h) return this.r = parseInt(l.charAt(0) + l.charAt(1), 16) / 255, this.g = parseInt(l.charAt(2) + l.charAt(3), 16) / 255, this.b = parseInt(l.charAt(4) + l.charAt(5), 16) / 255, this
                    }
                    t && t.length > 0 && (void 0 !== (l = si[t]) ? this.setHex(l) : console.warn("THREE.Color: Unknown color " + t));
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                },
                copyGammaToLinear: function(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                },
                copyLinearToGamma: function(t, e) {
                    void 0 === e && (e = 2);
                    var i = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, i), this.g = Math.pow(t.g, i), this.b = Math.pow(t.b, i), this
                },
                convertGammaToLinear: function(t) {
                    return this.copyGammaToLinear(this, t), this
                },
                convertLinearToGamma: function(t) {
                    return this.copyLinearToGamma(this, t), this
                },
                copySRGBToLinear: function() {
                    function t(t) {
                        return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
                    }
                    return function(e) {
                        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                    }
                }(),
                copyLinearToSRGB: function() {
                    function t(t) {
                        return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
                    }
                    return function(e) {
                        return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
                    }
                }(),
                convertSRGBToLinear: function() {
                    return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function() {
                    return this.copyLinearToSRGB(this), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(t) {
                    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var e, i, n = this.r,
                        r = this.g,
                        o = this.b,
                        a = Math.max(n, r, o),
                        s = Math.min(n, r, o),
                        c = (s + a) / 2;
                    if (s === a) e = 0, i = 0;
                    else {
                        var l = a - s;
                        switch (i = c <= .5 ? l / (a + s) : l / (2 - a - s), a) {
                            case n:
                                e = (r - o) / l + (r < o ? 6 : 0);
                                break;
                            case r:
                                e = (o - n) / l + 2;
                                break;
                            case o:
                                e = (n - r) / l + 4
                        }
                        e /= 6
                    }
                    return t.h = e, t.s = i, t.l = c, t
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function() {
                    var t = {};
                    return function(e, i, n) {
                        return this.getHSL(t), t.h += e, t.s += i, t.l += n, this.setHSL(t.h, t.s, t.l), this
                    }
                }(),
                add: function(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                },
                addColors: function(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                },
                addScalar: function(t) {
                    return this.r += t, this.g += t, this.b += t, this
                },
                sub: function(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                },
                multiply: function(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                },
                multiplyScalar: function(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                },
                lerp: function(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                },
                lerpHSL: function() {
                    var t = {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        e = {
                            h: 0,
                            s: 0,
                            l: 0
                        };
                    return function(i, n) {
                        this.getHSL(t), i.getHSL(e);
                        var r = Ue.lerp(t.h, e.h, n),
                            o = Ue.lerp(t.s, e.s, n),
                            a = Ue.lerp(t.l, e.l, n);
                        return this.setHSL(r, o, a), this
                    }
                }(),
                equals: function(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                },
                toJSON: function() {
                    return this.getHex()
                }
            });
            var li = {
                    common: {
                        diffuse: {
                            value: new ci(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new We
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Ge(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new ci(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new ci(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new We
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new ci(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new Ge(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new We
                        }
                    }
                },
                hi = {
                    basic: {
                        uniforms: oi([li.common, li.specularmap, li.envmap, li.aomap, li.lightmap, li.fog]),
                        vertexShader: ni.meshbasic_vert,
                        fragmentShader: ni.meshbasic_frag
                    },
                    lambert: {
                        uniforms: oi([li.common, li.specularmap, li.envmap, li.aomap, li.lightmap, li.emissivemap, li.fog, li.lights, {
                            emissive: {
                                value: new ci(0)
                            }
                        }]),
                        vertexShader: ni.meshlambert_vert,
                        fragmentShader: ni.meshlambert_frag
                    },
                    phong: {
                        uniforms: oi([li.common, li.specularmap, li.envmap, li.aomap, li.lightmap, li.emissivemap, li.bumpmap, li.normalmap, li.displacementmap, li.gradientmap, li.fog, li.lights, {
                            emissive: {
                                value: new ci(0)
                            },
                            specular: {
                                value: new ci(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: ni.meshphong_vert,
                        fragmentShader: ni.meshphong_frag
                    },
                    standard: {
                        uniforms: oi([li.common, li.envmap, li.aomap, li.lightmap, li.emissivemap, li.bumpmap, li.normalmap, li.displacementmap, li.roughnessmap, li.metalnessmap, li.fog, li.lights, {
                            emissive: {
                                value: new ci(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ni.meshphysical_vert,
                        fragmentShader: ni.meshphysical_frag
                    },
                    matcap: {
                        uniforms: oi([li.common, li.bumpmap, li.normalmap, li.displacementmap, li.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: ni.meshmatcap_vert,
                        fragmentShader: ni.meshmatcap_frag
                    },
                    points: {
                        uniforms: oi([li.points, li.fog]),
                        vertexShader: ni.points_vert,
                        fragmentShader: ni.points_frag
                    },
                    dashed: {
                        uniforms: oi([li.common, li.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: ni.linedashed_vert,
                        fragmentShader: ni.linedashed_frag
                    },
                    depth: {
                        uniforms: oi([li.common, li.displacementmap]),
                        vertexShader: ni.depth_vert,
                        fragmentShader: ni.depth_frag
                    },
                    normal: {
                        uniforms: oi([li.common, li.bumpmap, li.normalmap, li.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ni.normal_vert,
                        fragmentShader: ni.normal_frag
                    },
                    sprite: {
                        uniforms: oi([li.sprite, li.fog]),
                        vertexShader: ni.sprite_vert,
                        fragmentShader: ni.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new We
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: ni.background_vert,
                        fragmentShader: ni.background_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: ni.cube_vert,
                        fragmentShader: ni.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: ni.equirect_vert,
                        fragmentShader: ni.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: oi([li.common, li.displacementmap, {
                            referencePosition: {
                                value: new je
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: ni.distanceRGBA_vert,
                        fragmentShader: ni.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: oi([li.lights, li.fog, {
                            color: {
                                value: new ci(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ni.shadow_vert,
                        fragmentShader: ni.shadow_frag
                    }
                };

            function ui() {
                var t = null,
                    e = !1,
                    i = null;

                function n(r, o) {
                    !1 !== e && (i(r, o), t.requestAnimationFrame(n))
                }
                return {
                    start: function() {
                        !0 !== e && null !== i && (t.requestAnimationFrame(n), e = !0)
                    },
                    stop: function() {
                        e = !1
                    },
                    setAnimationLoop: function(t) {
                        i = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function di(t) {
                var e = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                    },
                    remove: function(i) {
                        i.isInterleavedBufferAttribute && (i = i.data);
                        var n = e.get(i);
                        n && (t.deleteBuffer(n.buffer), e.delete(i))
                    },
                    update: function(i, n) {
                        i.isInterleavedBufferAttribute && (i = i.data);
                        var r = e.get(i);
                        void 0 === r ? e.set(i, function(e, i) {
                            var n = e.array,
                                r = e.dynamic ? 35048 : 35044,
                                o = t.createBuffer();
                            t.bindBuffer(i, o), t.bufferData(i, n, r), e.onUploadCallback();
                            var a = 5126;
                            return n instanceof Float32Array ? a = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? a = 5123 : n instanceof Int16Array ? a = 5122 : n instanceof Uint32Array ? a = 5125 : n instanceof Int32Array ? a = 5124 : n instanceof Int8Array ? a = 5120 : n instanceof Uint8Array && (a = 5121), {
                                buffer: o,
                                type: a,
                                bytesPerElement: n.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(i, n)) : r.version < i.version && (function(e, i, n) {
                            var r = i.array,
                                o = i.updateRange;
                            t.bindBuffer(n, e), !1 === i.dynamic ? t.bufferData(n, r, 35044) : -1 === o.count ? t.bufferSubData(n, 0, r) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, o.offset * r.BYTES_PER_ELEMENT, r.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(r.buffer, i, n), r.version = i.version)
                    }
                }
            }

            function pi(t, e, i, n, r, o) {
                this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new je, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new ci, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
            }

            function fi(t, e, i, n) {
                this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || fi.DefaultOrder
            }

            function mi() {
                this.mask = 1
            }
            hi.physical = {
                uniforms: oi([hi.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: ni.meshphysical_vert,
                fragmentShader: ni.meshphysical_frag
            }, Object.assign(pi.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            }), fi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], fi.DefaultOrder = "XYZ", Object.defineProperties(fi.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this.onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this.onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this.onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(t) {
                        this._order = t, this.onChangeCallback()
                    }
                }
            }), Object.assign(fi.prototype, {
                isEuler: !0,
                set: function(t, e, i, n) {
                    return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(t, e, i) {
                    var n = Ue.clamp,
                        r = t.elements,
                        o = r[0],
                        a = r[4],
                        s = r[8],
                        c = r[1],
                        l = r[5],
                        h = r[9],
                        u = r[2],
                        d = r[6],
                        p = r[10];
                    return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(h, -1, 1)), Math.abs(h) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-u, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === e ? (this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === e ? (this._z = Math.asin(n(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === e ? (this._z = Math.asin(-n(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(d, l), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-h, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
                },
                setFromQuaternion: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n)
                    }
                }(),
                setFromVector3: function(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                },
                reorder: function() {
                    var t = new Ve;
                    return function(e) {
                        return t.setFromEuler(this), this.setFromQuaternion(t, e)
                    }
                }(),
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                },
                fromArray: function(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                },
                toVector3: function(t) {
                    return t ? t.set(this._x, this._y, this._z) : new je(this._x, this._y, this._z)
                },
                onChange: function(t) {
                    return this.onChangeCallback = t, this
                },
                onChangeCallback: function() {}
            }), Object.assign(mi.prototype, {
                set: function(t) {
                    this.mask = 1 << t | 0
                },
                enable: function(t) {
                    this.mask |= 1 << t | 0
                },
                toggle: function(t) {
                    this.mask ^= 1 << t | 0
                },
                disable: function(t) {
                    this.mask &= ~(1 << t | 0)
                },
                test: function(t) {
                    return 0 != (this.mask & t.mask)
                }
            });
            var gi = 0;

            function vi() {
                Object.defineProperty(this, "id", {
                    value: gi++
                }), this.uuid = Ue.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = vi.DefaultUp.clone();
                var t = new je,
                    e = new fi,
                    i = new Ve,
                    n = new je(1, 1, 1);
                e.onChange(function() {
                    i.setFromEuler(e, !1)
                }), i.onChange(function() {
                    e.setFromQuaternion(i, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    modelViewMatrix: {
                        value: new He
                    },
                    normalMatrix: {
                        value: new We
                    }
                }), this.matrix = new He, this.matrixWorld = new He, this.matrixAutoUpdate = vi.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new mi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }
            vi.DefaultUp = new je(0, 1, 0), vi.DefaultMatrixAutoUpdate = !0, vi.prototype = Object.assign(Object.create(n.prototype), {
                constructor: vi,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(t) {
                    this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function() {
                    var t = new Ve;
                    return function(e, i) {
                        return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this
                    }
                }(),
                rotateOnWorldAxis: function() {
                    var t = new Ve;
                    return function(e, i) {
                        return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this
                    }
                }(),
                rotateX: function() {
                    var t = new je(1, 0, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateY: function() {
                    var t = new je(0, 1, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateZ: function() {
                    var t = new je(0, 0, 1);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                translateOnAxis: function() {
                    var t = new je;
                    return function(e, i) {
                        return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this
                    }
                }(),
                translateX: function() {
                    var t = new je(1, 0, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateY: function() {
                    var t = new je(0, 1, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateZ: function() {
                    var t = new je(0, 0, 1);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var t = new He;
                    return function(e) {
                        return e.applyMatrix4(t.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var t = new Ve,
                        e = new He,
                        i = new je,
                        n = new je;
                    return function(r, o, a) {
                        r.isVector3 ? i.copy(r) : i.set(r, o, a);
                        var s = this.parent;
                        this.updateWorldMatrix(!0, !1), n.setFromMatrixPosition(this.matrixWorld), this.isCamera ? e.lookAt(n, i, this.up) : e.lookAt(i, n, this.up), this.quaternion.setFromRotationMatrix(e), s && (e.extractRotation(s.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()))
                    }
                }(),
                add: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                        type: "added"
                    }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    var i = this.children.indexOf(t);
                    return -1 !== i && (t.parent = null, t.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(i, 1)), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (var i = 0, n = this.children.length; i < n; i++) {
                        var r = this.children[i].getObjectByProperty(t, e);
                        if (void 0 !== r) return r
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new je), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var t = new je,
                        e = new je;
                    return function(i) {
                        return void 0 === i && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), i = new Ve), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i
                    }
                }(),
                getWorldScale: function() {
                    var t = new je,
                        e = new Ve;
                    return function(i) {
                        return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new je), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i
                    }
                }(),
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new je), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 !== this.visible) {
                        t(this);
                        for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
                    }
                },
                traverseAncestors: function(t) {
                    var e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    var i = this.parent;
                    if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                        for (var n = this.children, r = 0, o = n.length; r < o; r++) n[r].updateWorldMatrix(!1, !0)
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t,
                        i = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, i.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var n = {};

                    function r(e, i) {
                        return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
                        n.geometry = r(t.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var a = o.shapes;
                            if (Array.isArray(a))
                                for (var s = 0, c = a.length; s < c; s++) {
                                    var l = a[s];
                                    r(t.shapes, l)
                                } else r(t.shapes, a)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            var h = [];
                            for (s = 0, c = this.material.length; s < c; s++) h.push(r(t.materials, this.material[s]));
                            n.material = h
                        } else n.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        n.children = [];
                        for (s = 0; s < this.children.length; s++) n.children.push(this.children[s].toJSON(t).object)
                    }
                    if (e) {
                        var u = m(t.geometries),
                            d = m(t.materials),
                            p = m(t.textures),
                            f = m(t.images);
                        a = m(t.shapes);
                        u.length > 0 && (i.geometries = u), d.length > 0 && (i.materials = d), p.length > 0 && (i.textures = p), f.length > 0 && (i.images = f), a.length > 0 && (i.shapes = a)
                    }
                    return i.object = n, i;

                    function m(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (var i = 0; i < t.children.length; i++) {
                            var n = t.children[i];
                            this.add(n.clone())
                        }
                    return this
                }
            });
            var yi = 0;

            function _i() {
                Object.defineProperty(this, "id", {
                    value: yi += 2
                }), this.uuid = Ue.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function xi(t, e, i) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function bi(t, e, i) {
                xi.call(this, new Int8Array(t), e, i)
            }

            function wi(t, e, i) {
                xi.call(this, new Uint8Array(t), e, i)
            }

            function Mi(t, e, i) {
                xi.call(this, new Uint8ClampedArray(t), e, i)
            }

            function Ti(t, e, i) {
                xi.call(this, new Int16Array(t), e, i)
            }

            function Ei(t, e, i) {
                xi.call(this, new Uint16Array(t), e, i)
            }

            function Si(t, e, i) {
                xi.call(this, new Int32Array(t), e, i)
            }

            function Ai(t, e, i) {
                xi.call(this, new Uint32Array(t), e, i)
            }

            function Pi(t, e, i) {
                xi.call(this, new Float32Array(t), e, i)
            }

            function Li(t, e, i) {
                xi.call(this, new Float64Array(t), e, i)
            }

            function Ci() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Ri(t) {
                if (0 === t.length) return -1 / 0;
                for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
                return e
            }
            _i.prototype = Object.assign(Object.create(n.prototype), {
                constructor: _i,
                isGeometry: !0,
                applyMatrix: function(t) {
                    for (var e = (new We).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) {
                        this.vertices[i].applyMatrix4(t)
                    }
                    for (i = 0, n = this.faces.length; i < n; i++) {
                        var r = this.faces[i];
                        r.normal.applyMatrix3(e).normalize();
                        for (var o = 0, a = r.vertexNormals.length; o < a; o++) r.vertexNormals[o].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeScale(e, i, n), this.applyMatrix(t), this
                    }
                }(),
                lookAt: function() {
                    var t = new vi;
                    return function(e) {
                        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                    }
                }(),
                fromBufferGeometry: function(t) {
                    var e = this,
                        i = null !== t.index ? t.index.array : void 0,
                        n = t.attributes,
                        r = n.position.array,
                        o = void 0 !== n.normal ? n.normal.array : void 0,
                        a = void 0 !== n.color ? n.color.array : void 0,
                        s = void 0 !== n.uv ? n.uv.array : void 0,
                        c = void 0 !== n.uv2 ? n.uv2.array : void 0;
                    void 0 !== c && (this.faceVertexUvs[1] = []);
                    for (var l = 0, h = 0; l < r.length; l += 3, h += 2) e.vertices.push((new je).fromArray(r, l)), void 0 !== a && e.colors.push((new ci).fromArray(a, l));

                    function u(t, i, n, r) {
                        var l = void 0 === a ? [] : [e.colors[t].clone(), e.colors[i].clone(), e.colors[n].clone()],
                            h = new pi(t, i, n, void 0 === o ? [] : [(new je).fromArray(o, 3 * t), (new je).fromArray(o, 3 * i), (new je).fromArray(o, 3 * n)], l, r);
                        e.faces.push(h), void 0 !== s && e.faceVertexUvs[0].push([(new Ge).fromArray(s, 2 * t), (new Ge).fromArray(s, 2 * i), (new Ge).fromArray(s, 2 * n)]), void 0 !== c && e.faceVertexUvs[1].push([(new Ge).fromArray(c, 2 * t), (new Ge).fromArray(c, 2 * i), (new Ge).fromArray(c, 2 * n)])
                    }
                    var d = t.groups;
                    if (d.length > 0)
                        for (l = 0; l < d.length; l++)
                            for (var p = d[l], f = p.start, m = (h = f, f + p.count); h < m; h += 3) void 0 !== i ? u(i[h], i[h + 1], i[h + 2], p.materialIndex) : u(h, h + 1, h + 2, p.materialIndex);
                    else if (void 0 !== i)
                        for (l = 0; l < i.length; l += 3) u(i[l], i[l + 1], i[l + 2]);
                    else
                        for (l = 0; l < r.length / 3; l += 3) u(l, l + 1, l + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: function() {
                    var t = new je;
                    return function() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                    }
                }(),
                normalize: function() {
                    this.computeBoundingSphere();
                    var t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        i = 0 === e ? 1 : 1 / e,
                        n = new He;
                    return n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1), this.applyMatrix(n), this
                },
                computeFaceNormals: function() {
                    for (var t = new je, e = new je, i = 0, n = this.faces.length; i < n; i++) {
                        var r = this.faces[i],
                            o = this.vertices[r.a],
                            a = this.vertices[r.b],
                            s = this.vertices[r.c];
                        t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), r.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    var e, i, n, r, o, a;
                    for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, i = this.vertices.length; e < i; e++) a[e] = new je;
                    if (t) {
                        var s, c, l, h = new je,
                            u = new je;
                        for (n = 0, r = this.faces.length; n < r; n++) o = this.faces[n], s = this.vertices[o.a], c = this.vertices[o.b], l = this.vertices[o.c], h.subVectors(l, c), u.subVectors(s, c), h.cross(u), a[o.a].add(h), a[o.b].add(h), a[o.c].add(h)
                    } else
                        for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) a[(o = this.faces[n]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                    for (e = 0, i = this.vertices.length; e < i; e++) a[e].normalize();
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        var d = (o = this.faces[n]).vertexNormals;
                        3 === d.length ? (d[0].copy(a[o.a]), d[1].copy(a[o.b]), d[2].copy(a[o.c])) : (d[0] = a[o.a].clone(), d[1] = a[o.b].clone(), d[2] = a[o.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var t, e, i;
                    for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                        var n = (i = this.faces[t]).vertexNormals;
                        3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var t, e, i, n, r;
                    for (i = 0, n = this.faces.length; i < n; i++)
                        for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), t = 0, e = r.vertexNormals.length; t < e; t++) r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone();
                    var o = new _i;
                    for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                        if (!this.morphNormals[t]) {
                            this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                            var a = this.morphNormals[t].faceNormals,
                                s = this.morphNormals[t].vertexNormals;
                            for (i = 0, n = this.faces.length; i < n; i++) c = new je, l = {
                                a: new je,
                                b: new je,
                                c: new je
                            }, a.push(c), s.push(l)
                        }
                        var c, l, h = this.morphNormals[t];
                        for (o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], c = h.faceNormals[i], l = h.vertexNormals[i], c.copy(r.normal), l.a.copy(r.vertexNormals[0]), l.b.copy(r.vertexNormals[1]), l.c.copy(r.vertexNormals[2])
                    }
                    for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new $e), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new ti), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, i) {
                    if (t && t.isGeometry) {
                        var n, r = this.vertices.length,
                            o = this.vertices,
                            a = t.vertices,
                            s = this.faces,
                            c = t.faces,
                            l = this.faceVertexUvs[0],
                            h = t.faceVertexUvs[0],
                            u = this.colors,
                            d = t.colors;
                        void 0 === i && (i = 0), void 0 !== e && (n = (new We).getNormalMatrix(e));
                        for (var p = 0, f = a.length; p < f; p++) {
                            var m = a[p].clone();
                            void 0 !== e && m.applyMatrix4(e), o.push(m)
                        }
                        for (p = 0, f = d.length; p < f; p++) u.push(d[p].clone());
                        for (p = 0, f = c.length; p < f; p++) {
                            var g, v, y, _ = c[p],
                                x = _.vertexNormals,
                                b = _.vertexColors;
                            (g = new pi(_.a + r, _.b + r, _.c + r)).normal.copy(_.normal), void 0 !== n && g.normal.applyMatrix3(n).normalize();
                            for (var w = 0, M = x.length; w < M; w++) v = x[w].clone(), void 0 !== n && v.applyMatrix3(n).normalize(), g.vertexNormals.push(v);
                            g.color.copy(_.color);
                            for (w = 0, M = b.length; w < M; w++) y = b[w], g.vertexColors.push(y.clone());
                            g.materialIndex = _.materialIndex + i, s.push(g)
                        }
                        for (p = 0, f = h.length; p < f; p++) {
                            var T = h[p],
                                E = [];
                            if (void 0 !== T) {
                                for (w = 0, M = T.length; w < M; w++) E.push(T[w].clone());
                                l.push(E)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
                },
                mergeMesh: function(t) {
                    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                },
                mergeVertices: function() {
                    var t, e, i, n, r, o, a, s, c = {},
                        l = [],
                        h = [],
                        u = Math.pow(10, 4);
                    for (i = 0, n = this.vertices.length; i < n; i++) t = this.vertices[i], void 0 === c[e = Math.round(t.x * u) + "_" + Math.round(t.y * u) + "_" + Math.round(t.z * u)] ? (c[e] = i, l.push(this.vertices[i]), h[i] = l.length - 1) : h[i] = h[c[e]];
                    var d = [];
                    for (i = 0, n = this.faces.length; i < n; i++) {
                        (r = this.faces[i]).a = h[r.a], r.b = h[r.b], r.c = h[r.c], o = [r.a, r.b, r.c];
                        for (var p = 0; p < 3; p++)
                            if (o[p] === o[(p + 1) % 3]) {
                                d.push(i);
                                break
                            }
                    }
                    for (i = d.length - 1; i >= 0; i--) {
                        var f = d[i];
                        for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
                    }
                    var m = this.vertices.length - l.length;
                    return this.vertices = l, m
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (var e = 0, i = t.length; e < i; e++) {
                        var n = t[e];
                        this.vertices.push(new je(n.x, n.y, n.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
                    t.sort(function(t, e) {
                        return t.materialIndex - e.materialIndex
                    });
                    var n, r, o = this.faceVertexUvs[0],
                        a = this.faceVertexUvs[1];
                    o && o.length === e && (n = []), a && a.length === e && (r = []);
                    for (i = 0; i < e; i++) {
                        var s = t[i]._id;
                        n && n.push(o[s]), r && r.push(a[s])
                    }
                    n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t
                    }
                    for (var n = [], r = 0; r < this.vertices.length; r++) {
                        var o = this.vertices[r];
                        n.push(o.x, o.y, o.z)
                    }
                    var a = [],
                        s = [],
                        c = {},
                        l = [],
                        h = {},
                        u = [],
                        d = {};
                    for (r = 0; r < this.faces.length; r++) {
                        var p = this.faces[r],
                            f = void 0 !== this.faceVertexUvs[0][r],
                            m = p.normal.length() > 0,
                            g = p.vertexNormals.length > 0,
                            v = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                            y = p.vertexColors.length > 0,
                            _ = 0;
                        if (_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_ = M(_, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, g), 6, v), 7, y), a.push(_), a.push(p.a, p.b, p.c), a.push(p.materialIndex), f) {
                            var x = this.faceVertexUvs[0][r];
                            a.push(S(x[0]), S(x[1]), S(x[2]))
                        }
                        if (m && a.push(T(p.normal)), g) {
                            var b = p.vertexNormals;
                            a.push(T(b[0]), T(b[1]), T(b[2]))
                        }
                        if (v && a.push(E(p.color)), y) {
                            var w = p.vertexColors;
                            a.push(E(w[0]), E(w[1]), E(w[2]))
                        }
                    }

                    function M(t, e, i) {
                        return i ? t | 1 << e : t & ~(1 << e)
                    }

                    function T(t) {
                        var e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z), c[e])
                    }

                    function E(t) {
                        var e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== h[e] ? h[e] : (h[e] = l.length, l.push(t.getHex()), h[e])
                    }

                    function S(t) {
                        var e = t.x.toString() + t.y.toString();
                        return void 0 !== d[e] ? d[e] : (d[e] = u.length / 2, u.push(t.x, t.y), d[e])
                    }
                    return t.data = {}, t.data.vertices = n, t.data.normals = s, l.length > 0 && (t.data.colors = l), u.length > 0 && (t.data.uvs = [u]), t.data.faces = a, t
                },
                clone: function() {
                    return (new _i).copy(this)
                },
                copy: function(t) {
                    var e, i, n, r, o, a;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var s = t.vertices;
                    for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
                    var c = t.colors;
                    for (e = 0, i = c.length; e < i; e++) this.colors.push(c[e].clone());
                    var l = t.faces;
                    for (e = 0, i = l.length; e < i; e++) this.faces.push(l[e].clone());
                    for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
                        var h = t.faceVertexUvs[e];
                        for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), n = 0, r = h.length; n < r; n++) {
                            var u = h[n],
                                d = [];
                            for (o = 0, a = u.length; o < a; o++) {
                                var p = u[o];
                                d.push(p.clone())
                            }
                            this.faceVertexUvs[e].push(d)
                        }
                    }
                    var f = t.morphTargets;
                    for (e = 0, i = f.length; e < i; e++) {
                        var m = {};
                        if (m.name = f[e].name, void 0 !== f[e].vertices)
                            for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++) m.vertices.push(f[e].vertices[n].clone());
                        if (void 0 !== f[e].normals)
                            for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++) m.normals.push(f[e].normals[n].clone());
                        this.morphTargets.push(m)
                    }
                    var g = t.morphNormals;
                    for (e = 0, i = g.length; e < i; e++) {
                        var v = {};
                        if (void 0 !== g[e].vertexNormals)
                            for (v.vertexNormals = [], n = 0, r = g[e].vertexNormals.length; n < r; n++) {
                                var y = g[e].vertexNormals[n],
                                    _ = {};
                                _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), v.vertexNormals.push(_)
                            }
                        if (void 0 !== g[e].faceNormals)
                            for (v.faceNormals = [], n = 0, r = g[e].faceNormals.length; n < r; n++) v.faceNormals.push(g[e].faceNormals[n].clone());
                        this.morphNormals.push(v)
                    }
                    var x = t.skinWeights;
                    for (e = 0, i = x.length; e < i; e++) this.skinWeights.push(x[e].clone());
                    var b = t.skinIndices;
                    for (e = 0, i = b.length; e < i; e++) this.skinIndices.push(b[e].clone());
                    var w = t.lineDistances;
                    for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
                    var M = t.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var T = t.boundingSphere;
                    return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(xi.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(xi.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, i) {
                    t *= this.itemSize, i *= e.itemSize;
                    for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new ci), e[i++] = o.r, e[i++] = o.g, e[i++] = o.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), o = new Ge), e[i++] = o.x, e[i++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), o = new je), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new Ze), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z, e[i++] = o.w
                    }
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
                },
                setXYZ: function(t, e, i, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
                },
                setXYZW: function(t, e, i, n, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            }), bi.prototype = Object.create(xi.prototype), bi.prototype.constructor = bi, wi.prototype = Object.create(xi.prototype), wi.prototype.constructor = wi, Mi.prototype = Object.create(xi.prototype), Mi.prototype.constructor = Mi, Ti.prototype = Object.create(xi.prototype), Ti.prototype.constructor = Ti, Ei.prototype = Object.create(xi.prototype), Ei.prototype.constructor = Ei, Si.prototype = Object.create(xi.prototype), Si.prototype.constructor = Si, Ai.prototype = Object.create(xi.prototype), Ai.prototype.constructor = Ai, Pi.prototype = Object.create(xi.prototype), Pi.prototype.constructor = Pi, Li.prototype = Object.create(xi.prototype), Li.prototype.constructor = Li, Object.assign(Ci.prototype, {
                computeGroups: function(t) {
                    for (var e, i = [], n = void 0, r = t.faces, o = 0; o < r.length; o++) {
                        var a = r[o];
                        a.materialIndex !== n && (n = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), e = {
                            start: 3 * o,
                            materialIndex: n
                        })
                    }
                    void 0 !== e && (e.count = 3 * o - e.start, i.push(e)), this.groups = i
                },
                fromGeometry: function(t) {
                    var e, i = t.faces,
                        n = t.vertices,
                        r = t.faceVertexUvs,
                        o = r[0] && r[0].length > 0,
                        a = r[1] && r[1].length > 0,
                        s = t.morphTargets,
                        c = s.length;
                    if (c > 0) {
                        e = [];
                        for (var l = 0; l < c; l++) e[l] = {
                            name: s[l].name,
                            data: []
                        };
                        this.morphTargets.position = e
                    }
                    var h, u = t.morphNormals,
                        d = u.length;
                    if (d > 0) {
                        h = [];
                        for (l = 0; l < d; l++) h[l] = {
                            name: u[l].name,
                            data: []
                        };
                        this.morphTargets.normal = h
                    }
                    var p = t.skinIndices,
                        f = t.skinWeights,
                        m = p.length === n.length,
                        g = f.length === n.length;
                    n.length > 0 && 0 === i.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (l = 0; l < i.length; l++) {
                        var v = i[l];
                        this.vertices.push(n[v.a], n[v.b], n[v.c]);
                        var y = v.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var _ = v.normal;
                            this.normals.push(_, _, _)
                        }
                        var x, b = v.vertexColors;
                        if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                        else {
                            var w = v.color;
                            this.colors.push(w, w, w)
                        }
                        if (!0 === o) void 0 !== (x = r[0][l]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new Ge, new Ge, new Ge));
                        if (!0 === a) void 0 !== (x = r[1][l]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new Ge, new Ge, new Ge));
                        for (var M = 0; M < c; M++) {
                            var T = s[M].vertices;
                            e[M].data.push(T[v.a], T[v.b], T[v.c])
                        }
                        for (M = 0; M < d; M++) {
                            var E = u[M].vertexNormals[l];
                            h[M].data.push(E.a, E.b, E.c)
                        }
                        m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                }
            });
            var Oi = 1;

            function Ii() {
                Object.defineProperty(this, "id", {
                    value: Oi += 2
                }), this.uuid = Ue.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            function Di(t, e, i, n, r, o) {
                _i.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: i,
                    widthSegments: n,
                    heightSegments: r,
                    depthSegments: o
                }, this.fromBufferGeometry(new ki(t, e, i, n, r, o)), this.mergeVertices()
            }

            function ki(t, e, i, n, r, o) {
                Ii.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: i,
                    widthSegments: n,
                    heightSegments: r,
                    depthSegments: o
                };
                var a = this;
                t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1;
                var s = [],
                    c = [],
                    l = [],
                    h = [],
                    u = 0,
                    d = 0;

                function p(t, e, i, n, r, o, p, f, m, g, v) {
                    var y, _, x = o / m,
                        b = p / g,
                        w = o / 2,
                        M = p / 2,
                        T = f / 2,
                        E = m + 1,
                        S = g + 1,
                        A = 0,
                        P = 0,
                        L = new je;
                    for (_ = 0; _ < S; _++) {
                        var C = _ * b - M;
                        for (y = 0; y < E; y++) {
                            var R = y * x - w;
                            L[t] = R * n, L[e] = C * r, L[i] = T, c.push(L.x, L.y, L.z), L[t] = 0, L[e] = 0, L[i] = f > 0 ? 1 : -1, l.push(L.x, L.y, L.z), h.push(y / m), h.push(1 - _ / g), A += 1
                        }
                    }
                    for (_ = 0; _ < g; _++)
                        for (y = 0; y < m; y++) {
                            var O = u + y + E * _,
                                I = u + y + E * (_ + 1),
                                D = u + (y + 1) + E * (_ + 1),
                                k = u + (y + 1) + E * _;
                            s.push(O, I, k), s.push(I, D, k), P += 6
                        }
                    a.addGroup(d, P, v), d += P, u += A
                }
                p("z", "y", "x", -1, -1, i, e, t, o = Math.floor(o) || 1, r, 0), p("z", "y", "x", 1, -1, i, e, -t, o, r, 1), p("x", "z", "y", 1, 1, t, i, e, n, o, 2), p("x", "z", "y", 1, -1, t, i, -e, n, o, 3), p("x", "y", "z", 1, -1, t, e, i, n, r, 4), p("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(s), this.addAttribute("position", new Pi(c, 3)), this.addAttribute("normal", new Pi(l, 3)), this.addAttribute("uv", new Pi(h, 2))
            }

            function Ni(t, e, i, n) {
                _i.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: i,
                    heightSegments: n
                }, this.fromBufferGeometry(new Bi(t, e, i, n)), this.mergeVertices()
            }

            function Bi(t, e, i, n) {
                Ii.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: i,
                    heightSegments: n
                };
                var r, o, a = (t = t || 1) / 2,
                    s = (e = e || 1) / 2,
                    c = Math.floor(i) || 1,
                    l = Math.floor(n) || 1,
                    h = c + 1,
                    u = l + 1,
                    d = t / c,
                    p = e / l,
                    f = [],
                    m = [],
                    g = [],
                    v = [];
                for (o = 0; o < u; o++) {
                    var y = o * p - s;
                    for (r = 0; r < h; r++) {
                        var _ = r * d - a;
                        m.push(_, -y, 0), g.push(0, 0, 1), v.push(r / c), v.push(1 - o / l)
                    }
                }
                for (o = 0; o < l; o++)
                    for (r = 0; r < c; r++) {
                        var x = r + h * o,
                            b = r + h * (o + 1),
                            w = r + 1 + h * (o + 1),
                            M = r + 1 + h * o;
                        f.push(x, b, M), f.push(b, w, M)
                    }
                this.setIndex(f), this.addAttribute("position", new Pi(m, 3)), this.addAttribute("normal", new Pi(g, 3)), this.addAttribute("uv", new Pi(v, 2))
            }
            Ii.prototype = Object.assign(Object.create(n.prototype), {
                constructor: Ii,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    Array.isArray(t) ? this.index = new(Ri(t) > 65535 ? Ai : Ei)(t, 1) : this.index = t
                },
                addAttribute: function(t, e) {
                    return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new xi(arguments[1], arguments[2])))
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                removeAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, i) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== i ? i : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix: function(t) {
                    var e = this.attributes.position;
                    void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                    var i = this.attributes.normal;
                    void 0 !== i && ((new We).getNormalMatrix(t).applyToBufferAttribute(i), i.needsUpdate = !0);
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new He;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeTranslation(e, i, n), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new He;
                    return function(e, i, n) {
                        return t.makeScale(e, i, n), this.applyMatrix(t), this
                    }
                }(),
                lookAt: function() {
                    var t = new vi;
                    return function(e) {
                        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                    }
                }(),
                center: function() {
                    var t = new je;
                    return function() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                    }
                }(),
                setFromObject: function(t) {
                    var e = t.geometry;
                    if (t.isPoints || t.isLine) {
                        var i = new Pi(3 * e.vertices.length, 3),
                            n = new Pi(3 * e.colors.length, 3);
                        if (this.addAttribute("position", i.copyVector3sArray(e.vertices)), this.addAttribute("color", n.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            var r = new Pi(e.lineDistances.length, 1);
                            this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                setFromPoints: function(t) {
                    for (var e = [], i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        e.push(r.x, r.y, r.z || 0)
                    }
                    return this.addAttribute("position", new Pi(e, 3)), this
                },
                updateFromObject: function(t) {
                    var e, i = t.geometry;
                    if (t.isMesh) {
                        var n = i.__directGeometry;
                        if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(i);
                        n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i = n
                    }
                    return !0 === i.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(i.vertices), e.needsUpdate = !0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(i.normals), e.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(i.colors), e.needsUpdate = !0), i.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(i.uvs), e.needsUpdate = !0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(i.lineDistances), e.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i.computeGroups(t.geometry), this.groups = i.groups, i.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new Ci).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    var e = new Float32Array(3 * t.vertices.length);
                    if (this.addAttribute("position", new xi(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                        var i = new Float32Array(3 * t.normals.length);
                        this.addAttribute("normal", new xi(i, 3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        var n = new Float32Array(3 * t.colors.length);
                        this.addAttribute("color", new xi(n, 3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        var r = new Float32Array(2 * t.uvs.length);
                        this.addAttribute("uv", new xi(r, 2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        var o = new Float32Array(2 * t.uvs2.length);
                        this.addAttribute("uv2", new xi(o, 2).copyVector2sArray(t.uvs2))
                    }
                    for (var a in this.groups = t.groups, t.morphTargets) {
                        for (var s = [], c = t.morphTargets[a], l = 0, h = c.length; l < h; l++) {
                            var u = c[l],
                                d = new Pi(3 * u.data.length, 3);
                            d.name = u.name, s.push(d.copyVector3sArray(u.data))
                        }
                        this.morphAttributes[a] = s
                    }
                    if (t.skinIndices.length > 0) {
                        var p = new Pi(4 * t.skinIndices.length, 4);
                        this.addAttribute("skinIndex", p.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        var f = new Pi(4 * t.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new $e);
                    var t = this.attributes.position;
                    void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    var t = new $e,
                        e = new je;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new ti);
                        var i = this.attributes.position;
                        if (i) {
                            var n = this.boundingSphere.center;
                            t.setFromBufferAttribute(i), t.getCenter(n);
                            for (var r = 0, o = 0, a = i.count; o < a; o++) e.x = i.getX(o), e.y = i.getY(o), e.z = i.getZ(o), r = Math.max(r, n.distanceToSquared(e));
                            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var t = this.index,
                        e = this.attributes;
                    if (e.position) {
                        var i = e.position.array;
                        if (void 0 === e.normal) this.addAttribute("normal", new xi(new Float32Array(i.length), 3));
                        else
                            for (var n = e.normal.array, r = 0, o = n.length; r < o; r++) n[r] = 0;
                        var a, s, c, l = e.normal.array,
                            h = new je,
                            u = new je,
                            d = new je,
                            p = new je,
                            f = new je;
                        if (t) {
                            var m = t.array;
                            for (r = 0, o = t.count; r < o; r += 3) a = 3 * m[r + 0], s = 3 * m[r + 1], c = 3 * m[r + 2], h.fromArray(i, a), u.fromArray(i, s), d.fromArray(i, c), p.subVectors(d, u), f.subVectors(h, u), p.cross(f), l[a] += p.x, l[a + 1] += p.y, l[a + 2] += p.z, l[s] += p.x, l[s + 1] += p.y, l[s + 2] += p.z, l[c] += p.x, l[c + 1] += p.y, l[c + 2] += p.z
                        } else
                            for (r = 0, o = i.length; r < o; r += 9) h.fromArray(i, r), u.fromArray(i, r + 3), d.fromArray(i, r + 6), p.subVectors(d, u), f.subVectors(h, u), p.cross(f), l[r] = p.x, l[r + 1] = p.y, l[r + 2] = p.z, l[r + 3] = p.x, l[r + 4] = p.y, l[r + 5] = p.z, l[r + 6] = p.x, l[r + 7] = p.y, l[r + 8] = p.z;
                        this.normalizeNormals(), e.normal.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (t && t.isBufferGeometry) {
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        var i = this.attributes;
                        for (var n in i)
                            if (void 0 !== t.attributes[n])
                                for (var r = i[n].array, o = t.attributes[n], a = o.array, s = 0, c = o.itemSize * e; s < a.length; s++, c++) r[c] = a[s];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
                },
                normalizeNormals: function() {
                    var t = new je;
                    return function() {
                        for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z)
                    }
                }(),
                toNonIndexed: function() {
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var t = new Ii,
                        e = this.index.array,
                        i = this.attributes;
                    for (var n in i) {
                        for (var r = i[n], o = r.array, a = r.itemSize, s = new o.constructor(e.length * a), c = 0, l = 0, h = 0, u = e.length; h < u; h++) {
                            c = e[h] * a;
                            for (var d = 0; d < a; d++) s[l++] = o[c++]
                        }
                        t.addAttribute(n, new xi(s, a))
                    }
                    var p = this.groups;
                    for (h = 0, u = p.length; h < u; h++) {
                        var f = p[h];
                        t.addGroup(f.start, f.count, f.materialIndex)
                    }
                    return t
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    var n = this.index;
                    if (null !== n) {
                        var r = Array.prototype.slice.call(n.array);
                        t.data.index = {
                            type: n.array.constructor.name,
                            array: r
                        }
                    }
                    var o = this.attributes;
                    for (var i in o) {
                        var a = o[i];
                        r = Array.prototype.slice.call(a.array);
                        t.data.attributes[i] = {
                            itemSize: a.itemSize,
                            type: a.array.constructor.name,
                            array: r,
                            normalized: a.normalized
                        }
                    }
                    var s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    var c = this.boundingSphere;
                    return null !== c && (t.data.boundingSphere = {
                        center: c.center.toArray(),
                        radius: c.radius
                    }), t
                },
                clone: function() {
                    return (new Ii).copy(this)
                },
                copy: function(t) {
                    var e, i, n;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var r = t.index;
                    null !== r && this.setIndex(r.clone());
                    var o = t.attributes;
                    for (e in o) {
                        var a = o[e];
                        this.addAttribute(e, a.clone())
                    }
                    var s = t.morphAttributes;
                    for (e in s) {
                        var c = [],
                            l = s[e];
                        for (i = 0, n = l.length; i < n; i++) c.push(l[i].clone());
                        this.morphAttributes[e] = c
                    }
                    var h = t.groups;
                    for (i = 0, n = h.length; i < n; i++) {
                        var u = h[i];
                        this.addGroup(u.start, u.count, u.materialIndex)
                    }
                    var d = t.boundingBox;
                    null !== d && (this.boundingBox = d.clone());
                    var p = t.boundingSphere;
                    return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Di.prototype = Object.create(_i.prototype), Di.prototype.constructor = Di, ki.prototype = Object.create(Ii.prototype), ki.prototype.constructor = ki, Ni.prototype = Object.create(_i.prototype), Ni.prototype.constructor = Ni, Bi.prototype = Object.create(Ii.prototype), Bi.prototype.constructor = Bi;
            var Fi = 0;

            function zi() {
                Object.defineProperty(this, "id", {
                    value: Fi++
                }), this.uuid = Ue.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = E, this.side = g, this.flatShading = !1, this.vertexColors = b, this.opacity = 1, this.transparent = !1, this.blendSrc = z, this.blendDst = U, this.blendEquation = C, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Z, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
            }

            function Ui(t) {
                zi.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            function Gi(t, e) {
                this.origin = void 0 !== t ? t : new je, this.direction = void 0 !== e ? e : new je
            }

            function Hi(t, e, i) {
                this.a = void 0 !== t ? t : new je, this.b = void 0 !== e ? e : new je, this.c = void 0 !== i ? i : new je
            }

            function Vi(t) {
                zi.call(this), this.type = "MeshBasicMaterial", this.color = new ci(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function ji(t, e) {
                vi.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Ii, this.material = void 0 !== e ? e : new Vi({
                    color: 16777215 * Math.random()
                }), this.drawMode = Ee, this.updateMorphTargets()
            }

            function Wi(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function Xi(t, e, i, n, r, o, a, s, c, l) {
                t = void 0 !== t ? t : [], e = void 0 !== e ? e : ht, Ye.call(this, t, e, i, n, r, o, a, s, c, l), this.flipY = !1
            }

            function qi(t, e, i, n) {
                Ye.call(this, null), this.image = {
                    data: t,
                    width: e,
                    height: i,
                    depth: n
                }, this.magFilter = xt, this.minFilter = xt, this.generateMipmaps = !1, this.flipY = !1
            }
            zi.prototype = Object.assign(Object.create(n.prototype), {
                constructor: zi,
                isMaterial: !0,
                onBeforeCompile: function() {},
                setValues: function(t) {
                    if (void 0 !== t)
                        for (var e in t) {
                            var i = t[e];
                            if (void 0 !== i)
                                if ("shading" !== e) {
                                    var n = this[e];
                                    void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === _;
                            else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                        }
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    var i = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function n(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            delete n.metadata, e.push(n)
                        }
                        return e
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(t).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== E && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), this.side !== g && (i.side = this.side), this.vertexColors !== b && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), e) {
                        var r = n(t.textures),
                            o = n(t.images);
                        r.length > 0 && (i.textures = r), o.length > 0 && (i.images = o)
                    }
                    return i
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                    var e = t.clippingPlanes,
                        i = null;
                    if (null !== e) {
                        var n = e.length;
                        i = new Array(n);
                        for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
                    }
                    return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Ui.prototype = Object.create(zi.prototype), Ui.prototype.constructor = Ui, Ui.prototype.isShaderMaterial = !0, Ui.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = ri(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
            }, Ui.prototype.toJSON = function(t) {
                var e = zi.prototype.toJSON.call(this, t);
                for (var i in e.uniforms = {}, this.uniforms) {
                    var n = this.uniforms[i].value;
                    n.isTexture ? e.uniforms[i] = {
                        type: "t",
                        value: n.toJSON(t).uuid
                    } : n.isColor ? e.uniforms[i] = {
                        type: "c",
                        value: n.getHex()
                    } : n.isVector2 ? e.uniforms[i] = {
                        type: "v2",
                        value: n.toArray()
                    } : n.isVector3 ? e.uniforms[i] = {
                        type: "v3",
                        value: n.toArray()
                    } : n.isVector4 ? e.uniforms[i] = {
                        type: "v4",
                        value: n.toArray()
                    } : n.isMatrix4 ? e.uniforms[i] = {
                        type: "m4",
                        value: n.toArray()
                    } : e.uniforms[i] = {
                        value: n
                    }
                }
                return Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e
            }, Object.assign(Gi.prototype, {
                set: function(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                },
                at: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new je), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                },
                recast: function() {
                    var t = new je;
                    return function(e) {
                        return this.origin.copy(this.at(e, t)), this
                    }
                }(),
                closestPointToPoint: function(t, e) {
                    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new je), e.subVectors(t, this.origin);
                    var i = e.dot(this.direction);
                    return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin)
                },
                distanceToPoint: function(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                },
                distanceSqToPoint: function() {
                    var t = new je;
                    return function(e) {
                        var i = t.subVectors(e, this.origin).dot(this.direction);
                        return i < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
                    }
                }(),
                distanceSqToSegment: function() {
                    var t = new je,
                        e = new je,
                        i = new je;
                    return function(n, r, o, a) {
                        t.copy(n).add(r).multiplyScalar(.5), e.copy(r).sub(n).normalize(), i.copy(this.origin).sub(t);
                        var s, c, l, h, u = .5 * n.distanceTo(r),
                            d = -this.direction.dot(e),
                            p = i.dot(this.direction),
                            f = -i.dot(e),
                            m = i.lengthSq(),
                            g = Math.abs(1 - d * d);
                        if (g > 0)
                            if (c = d * p - f, h = u * g, (s = d * f - p) >= 0)
                                if (c >= -h)
                                    if (c <= h) {
                                        var v = 1 / g;
                                        l = (s *= v) * (s + d * (c *= v) + 2 * p) + c * (d * s + c + 2 * f) + m
                                    } else c = u, l = -(s = Math.max(0, -(d * c + p))) * s + c * (c + 2 * f) + m;
                        else c = -u, l = -(s = Math.max(0, -(d * c + p))) * s + c * (c + 2 * f) + m;
                        else c <= -h ? l = -(s = Math.max(0, -(-d * u + p))) * s + (c = s > 0 ? -u : Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m : c <= h ? (s = 0, l = (c = Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m) : l = -(s = Math.max(0, -(d * u + p))) * s + (c = s > 0 ? u : Math.min(Math.max(-u, -f), u)) * (c + 2 * f) + m;
                        else c = d > 0 ? -u : u, l = -(s = Math.max(0, -(d * c + p))) * s + c * (c + 2 * f) + m;
                        return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(e).multiplyScalar(c).add(t), l
                    }
                }(),
                intersectSphere: function() {
                    var t = new je;
                    return function(e, i) {
                        t.subVectors(e.center, this.origin);
                        var n = t.dot(this.direction),
                            r = t.dot(t) - n * n,
                            o = e.radius * e.radius;
                        if (r > o) return null;
                        var a = Math.sqrt(o - r),
                            s = n - a,
                            c = n + a;
                        return s < 0 && c < 0 ? null : s < 0 ? this.at(c, i) : this.at(s, i)
                    }
                }(),
                intersectsSphere: function(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                },
                distanceToPlane: function(t) {
                    var e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    var i = -(this.origin.dot(t.normal) + t.constant) / e;
                    return i >= 0 ? i : null
                },
                intersectPlane: function(t, e) {
                    var i = this.distanceToPlane(t);
                    return null === i ? null : this.at(i, e)
                },
                intersectsPlane: function(t) {
                    var e = t.distanceToPoint(this.origin);
                    return 0 === e || t.normal.dot(this.direction) * e < 0
                },
                intersectBox: function(t, e) {
                    var i, n, r, o, a, s, c = 1 / this.direction.x,
                        l = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin;
                    return c >= 0 ? (i = (t.min.x - u.x) * c, n = (t.max.x - u.x) * c) : (i = (t.max.x - u.x) * c, n = (t.min.x - u.x) * c), l >= 0 ? (r = (t.min.y - u.y) * l, o = (t.max.y - u.y) * l) : (r = (t.max.y - u.y) * l, o = (t.min.y - u.y) * l), i > o || r > n ? null : ((r > i || i != i) && (i = r), (o < n || n != n) && (n = o), h >= 0 ? (a = (t.min.z - u.z) * h, s = (t.max.z - u.z) * h) : (a = (t.max.z - u.z) * h, s = (t.min.z - u.z) * h), i > s || a > n ? null : ((a > i || i != i) && (i = a), (s < n || n != n) && (n = s), n < 0 ? null : this.at(i >= 0 ? i : n, e)))
                },
                intersectsBox: function() {
                    var t = new je;
                    return function(e) {
                        return null !== this.intersectBox(e, t)
                    }
                }(),
                intersectTriangle: function() {
                    var t = new je,
                        e = new je,
                        i = new je,
                        n = new je;
                    return function(r, o, a, s, c) {
                        e.subVectors(o, r), i.subVectors(a, r), n.crossVectors(e, i);
                        var l, h = this.direction.dot(n);
                        if (h > 0) {
                            if (s) return null;
                            l = 1
                        } else {
                            if (!(h < 0)) return null;
                            l = -1, h = -h
                        }
                        t.subVectors(this.origin, r);
                        var u = l * this.direction.dot(i.crossVectors(t, i));
                        if (u < 0) return null;
                        var d = l * this.direction.dot(e.cross(t));
                        if (d < 0) return null;
                        if (u + d > h) return null;
                        var p = -l * t.dot(n);
                        return p < 0 ? null : this.at(p / h, c)
                    }
                }(),
                applyMatrix4: function(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                },
                equals: function(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            }), Object.assign(Hi, {
                getNormal: function() {
                    var t = new je;
                    return function(e, i, n, r) {
                        void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new je), r.subVectors(n, i), t.subVectors(e, i), r.cross(t);
                        var o = r.lengthSq();
                        return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0)
                    }
                }(),
                getBarycoord: function() {
                    var t = new je,
                        e = new je,
                        i = new je;
                    return function(n, r, o, a, s) {
                        t.subVectors(a, r), e.subVectors(o, r), i.subVectors(n, r);
                        var c = t.dot(t),
                            l = t.dot(e),
                            h = t.dot(i),
                            u = e.dot(e),
                            d = e.dot(i),
                            p = c * u - l * l;
                        if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s = new je), 0 === p) return s.set(-2, -1, -1);
                        var f = 1 / p,
                            m = (u * h - l * d) * f,
                            g = (c * d - l * h) * f;
                        return s.set(1 - m - g, g, m)
                    }
                }(),
                containsPoint: function() {
                    var t = new je;
                    return function(e, i, n, r) {
                        return Hi.getBarycoord(e, i, n, r, t), t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
                    }
                }(),
                getUV: function() {
                    var t = new je;
                    return function(e, i, n, r, o, a, s, c) {
                        return this.getBarycoord(e, i, n, r, t), c.set(0, 0), c.addScaledVector(o, t.x), c.addScaledVector(a, t.y), c.addScaledVector(s, t.z), c
                    }
                }()
            }), Object.assign(Hi.prototype, {
                set: function(t, e, i) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
                },
                setFromPointsAndIndices: function(t, e, i, n) {
                    return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                },
                getArea: function() {
                    var t = new je,
                        e = new je;
                    return function() {
                        return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                    }
                }(),
                getMidpoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new je), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function(t) {
                    return Hi.getNormal(this.a, this.b, this.c, t)
                },
                getPlane: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new je), t.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function(t, e) {
                    return Hi.getBarycoord(t, this.a, this.b, this.c, e)
                },
                containsPoint: function(t) {
                    return Hi.containsPoint(t, this.a, this.b, this.c)
                },
                getUV: function(t, e, i, n, r) {
                    return Hi.getUV(t, this.a, this.b, this.c, e, i, n, r)
                },
                intersectsBox: function(t) {
                    return t.intersectsTriangle(this)
                },
                closestPointToPoint: function() {
                    var t = new je,
                        e = new je,
                        i = new je,
                        n = new je,
                        r = new je,
                        o = new je;
                    return function(a, s) {
                        void 0 === s && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), s = new je);
                        var c, l, h = this.a,
                            u = this.b,
                            d = this.c;
                        t.subVectors(u, h), e.subVectors(d, h), n.subVectors(a, h);
                        var p = t.dot(n),
                            f = e.dot(n);
                        if (p <= 0 && f <= 0) return s.copy(h);
                        r.subVectors(a, u);
                        var m = t.dot(r),
                            g = e.dot(r);
                        if (m >= 0 && g <= m) return s.copy(u);
                        var v = p * g - m * f;
                        if (v <= 0 && p >= 0 && m <= 0) return c = p / (p - m), s.copy(h).addScaledVector(t, c);
                        o.subVectors(a, d);
                        var y = t.dot(o),
                            _ = e.dot(o);
                        if (_ >= 0 && y <= _) return s.copy(d);
                        var x = y * f - p * _;
                        if (x <= 0 && f >= 0 && _ <= 0) return l = f / (f - _), s.copy(h).addScaledVector(e, l);
                        var b = m * _ - y * g;
                        if (b <= 0 && g - m >= 0 && y - _ >= 0) return i.subVectors(d, u), l = (g - m) / (g - m + (y - _)), s.copy(u).addScaledVector(i, l);
                        var w = 1 / (b + x + v);
                        return c = x * w, l = v * w, s.copy(h).addScaledVector(t, c).addScaledVector(e, l)
                    }
                }(),
                equals: function(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }), Vi.prototype = Object.create(zi.prototype), Vi.prototype.constructor = Vi, Vi.prototype.isMeshBasicMaterial = !0, Vi.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            }, ji.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: ji,
                isMesh: !0,
                setDrawMode: function(t) {
                    this.drawMode = t
                },
                copy: function(t) {
                    return vi.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
                },
                updateMorphTargets: function() {
                    var t, e, i, n = this.geometry;
                    if (n.isBufferGeometry) {
                        var r = n.morphAttributes,
                            o = Object.keys(r);
                        if (o.length > 0) {
                            var a = r[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) i = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                        }
                    } else {
                        var s = n.morphTargets;
                        if (void 0 !== s && s.length > 0)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = s.length; t < e; t++) i = s[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = t
                    }
                },
                raycast: function() {
                    var t = new He,
                        e = new Gi,
                        i = new ti,
                        n = new je,
                        r = new je,
                        o = new je,
                        a = new je,
                        s = new je,
                        c = new je,
                        l = new Ge,
                        h = new Ge,
                        u = new Ge,
                        d = new je,
                        p = new je;

                    function f(t, e, i, n, r, o, a, s) {
                        if (null === (e.side === v ? n.intersectTriangle(a, o, r, !0, s) : n.intersectTriangle(r, o, a, e.side !== y, s))) return null;
                        p.copy(s), p.applyMatrix4(t.matrixWorld);
                        var c = i.ray.origin.distanceTo(p);
                        return c < i.near || c > i.far ? null : {
                            distance: c,
                            point: p.clone(),
                            object: t
                        }
                    }

                    function m(t, e, i, a, s, c, p, m, g) {
                        n.fromBufferAttribute(s, p), r.fromBufferAttribute(s, m), o.fromBufferAttribute(s, g);
                        var v = f(t, e, i, a, n, r, o, d);
                        if (v) {
                            c && (l.fromBufferAttribute(c, p), h.fromBufferAttribute(c, m), u.fromBufferAttribute(c, g), v.uv = Hi.getUV(d, n, r, o, l, h, u, new Ge));
                            var y = new pi(p, m, g);
                            Hi.getNormal(n, r, o, y.normal), v.face = y
                        }
                        return v
                    }
                    return function(p, g) {
                        var v, y = this.geometry,
                            _ = this.material,
                            x = this.matrixWorld;
                        if (void 0 !== _ && (null === y.boundingSphere && y.computeBoundingSphere(), i.copy(y.boundingSphere), i.applyMatrix4(x), !1 !== p.ray.intersectsSphere(i) && (t.getInverse(x), e.copy(p.ray).applyMatrix4(t), null === y.boundingBox || !1 !== e.intersectsBox(y.boundingBox))))
                            if (y.isBufferGeometry) {
                                var b, w, M, T, E, S, A, P, L, C = y.index,
                                    R = y.attributes.position,
                                    O = y.attributes.uv,
                                    I = y.groups,
                                    D = y.drawRange;
                                if (null !== C)
                                    if (Array.isArray(_))
                                        for (T = 0, S = I.length; T < S; T++)
                                            for (L = _[(P = I[T]).materialIndex], E = Math.max(P.start, D.start), A = Math.min(P.start + P.count, D.start + D.count); E < A; E += 3) b = C.getX(E), w = C.getX(E + 1), M = C.getX(E + 2), (v = m(this, L, p, e, R, O, b, w, M)) && (v.faceIndex = Math.floor(E / 3), g.push(v));
                                    else
                                        for (T = Math.max(0, D.start), S = Math.min(C.count, D.start + D.count); T < S; T += 3) b = C.getX(T), w = C.getX(T + 1), M = C.getX(T + 2), (v = m(this, _, p, e, R, O, b, w, M)) && (v.faceIndex = Math.floor(T / 3), g.push(v));
                                else if (void 0 !== R)
                                    if (Array.isArray(_))
                                        for (T = 0, S = I.length; T < S; T++)
                                            for (L = _[(P = I[T]).materialIndex], E = Math.max(P.start, D.start), A = Math.min(P.start + P.count, D.start + D.count); E < A; E += 3)(v = m(this, L, p, e, R, O, b = E, w = E + 1, M = E + 2)) && (v.faceIndex = Math.floor(E / 3), g.push(v));
                                    else
                                        for (T = Math.max(0, D.start), S = Math.min(R.count, D.start + D.count); T < S; T += 3)(v = m(this, _, p, e, R, O, b = T, w = T + 1, M = T + 2)) && (v.faceIndex = Math.floor(T / 3), g.push(v))
                            } else if (y.isGeometry) {
                            var k, N, B, F, z = Array.isArray(_),
                                U = y.vertices,
                                G = y.faces,
                                H = y.faceVertexUvs[0];
                            H.length > 0 && (F = H);
                            for (var V = 0, j = G.length; V < j; V++) {
                                var W = G[V],
                                    X = z ? _[W.materialIndex] : _;
                                if (void 0 !== X) {
                                    if (k = U[W.a], N = U[W.b], B = U[W.c], !0 === X.morphTargets) {
                                        var q = y.morphTargets,
                                            Y = this.morphTargetInfluences;
                                        n.set(0, 0, 0), r.set(0, 0, 0), o.set(0, 0, 0);
                                        for (var Z = 0, J = q.length; Z < J; Z++) {
                                            var K = Y[Z];
                                            if (0 !== K) {
                                                var Q = q[Z].vertices;
                                                n.addScaledVector(a.subVectors(Q[W.a], k), K), r.addScaledVector(s.subVectors(Q[W.b], N), K), o.addScaledVector(c.subVectors(Q[W.c], B), K)
                                            }
                                        }
                                        n.add(k), r.add(N), o.add(B), k = n, N = r, B = o
                                    }
                                    if (v = f(this, X, p, e, k, N, B, d)) {
                                        if (F && F[V]) {
                                            var $ = F[V];
                                            l.copy($[0]), h.copy($[1]), u.copy($[2]), v.uv = Hi.getUV(d, k, N, B, l, h, u, new Ge)
                                        }
                                        v.face = W, v.faceIndex = V, g.push(v)
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Xi.prototype = Object.create(Ye.prototype), Xi.prototype.constructor = Xi, Xi.prototype.isCubeTexture = !0, Object.defineProperty(Xi.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            }), qi.prototype = Object.create(Ye.prototype), qi.prototype.constructor = qi, qi.prototype.isDataTexture3D = !0;
            var Yi = new Ye,
                Zi = new qi,
                Ji = new Xi;

            function Ki() {
                this.seq = [], this.map = {}
            }
            var Qi = [],
                $i = [],
                tn = new Float32Array(16),
                en = new Float32Array(9),
                nn = new Float32Array(4);

            function rn(t, e, i) {
                var n = t[0];
                if (n <= 0 || n > 0) return t;
                var r = e * i,
                    o = Qi[r];
                if (void 0 === o && (o = new Float32Array(r), Qi[r] = o), 0 !== e) {
                    n.toArray(o, 0);
                    for (var a = 1, s = 0; a !== e; ++a) s += i, t[a].toArray(o, s)
                }
                return o
            }

            function on(t, e) {
                if (t.length !== e.length) return !1;
                for (var i = 0, n = t.length; i < n; i++)
                    if (t[i] !== e[i]) return !1;
                return !0
            }

            function an(t, e) {
                for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
            }

            function sn(t, e) {
                var i = $i[e];
                void 0 === i && (i = new Int32Array(e), $i[e] = i);
                for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
                return i
            }

            function cn(t, e) {
                var i = this.cache;
                i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
            }

            function ln(t, e) {
                var i = this.cache;
                i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
            }

            function hn(t, e) {
                var i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y);
                else {
                    if (on(i, e)) return;
                    t.uniform2fv(this.addr, e), an(i, e)
                }
            }

            function un(t, e) {
                var i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z);
                else if (void 0 !== e.r) i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b);
                else {
                    if (on(i, e)) return;
                    t.uniform3fv(this.addr, e), an(i, e)
                }
            }

            function dn(t, e) {
                var i = this.cache;
                if (void 0 !== e.x) i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w);
                else {
                    if (on(i, e)) return;
                    t.uniform4fv(this.addr, e), an(i, e)
                }
            }

            function pn(t, e) {
                var i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (on(i, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), an(i, e)
                } else {
                    if (on(i, n)) return;
                    nn.set(n), t.uniformMatrix2fv(this.addr, !1, nn), an(i, n)
                }
            }

            function fn(t, e) {
                var i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (on(i, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), an(i, e)
                } else {
                    if (on(i, n)) return;
                    en.set(n), t.uniformMatrix3fv(this.addr, !1, en), an(i, n)
                }
            }

            function mn(t, e) {
                var i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (on(i, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), an(i, e)
                } else {
                    if (on(i, n)) return;
                    tn.set(n), t.uniformMatrix4fv(this.addr, !1, tn), an(i, n)
                }
            }

            function gn(t, e, i) {
                var n = this.cache,
                    r = i.allocTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(e || Yi, r)
            }

            function vn(t, e, i) {
                var n = this.cache,
                    r = i.allocTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || Zi, r)
            }

            function yn(t, e, i) {
                var n = this.cache,
                    r = i.allocTextureUnit();
                n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(e || Ji, r)
            }

            function _n(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform2iv(this.addr, e), an(i, e))
            }

            function xn(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform3iv(this.addr, e), an(i, e))
            }

            function bn(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform4iv(this.addr, e), an(i, e))
            }

            function wn(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform1fv(this.addr, e), an(i, e))
            }

            function Mn(t, e) {
                var i = this.cache;
                on(i, e) || (t.uniform1iv(this.addr, e), an(i, e))
            }

            function Tn(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 2);
                on(i, n) || (t.uniform2fv(this.addr, n), this.updateCache(n))
            }

            function En(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 3);
                on(i, n) || (t.uniform3fv(this.addr, n), this.updateCache(n))
            }

            function Sn(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 4);
                on(i, n) || (t.uniform4fv(this.addr, n), this.updateCache(n))
            }

            function An(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 4);
                on(i, n) || (t.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n))
            }

            function Pn(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 9);
                on(i, n) || (t.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n))
            }

            function Ln(t, e) {
                var i = this.cache,
                    n = rn(e, this.size, 16);
                on(i, n) || (t.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n))
            }

            function Cn(t, e, i) {
                var n = this.cache,
                    r = e.length,
                    o = sn(i, r);
                !1 === on(n, o) && (t.uniform1iv(this.addr, o), an(n, o));
                for (var a = 0; a !== r; ++a) i.setTexture2D(e[a] || Yi, o[a])
            }

            function Rn(t, e, i) {
                var n = this.cache,
                    r = e.length,
                    o = sn(i, r);
                !1 === on(n, o) && (t.uniform1iv(this.addr, o), an(n, o));
                for (var a = 0; a !== r; ++a) i.setTextureCube(e[a] || Ji, o[a])
            }

            function On(t, e, i) {
                this.id = t, this.addr = i, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return cn;
                        case 35664:
                            return hn;
                        case 35665:
                            return un;
                        case 35666:
                            return dn;
                        case 35674:
                            return pn;
                        case 35675:
                            return fn;
                        case 35676:
                            return mn;
                        case 35678:
                        case 36198:
                            return gn;
                        case 35679:
                            return vn;
                        case 35680:
                            return yn;
                        case 5124:
                        case 35670:
                            return ln;
                        case 35667:
                        case 35671:
                            return _n;
                        case 35668:
                        case 35672:
                            return xn;
                        case 35669:
                        case 35673:
                            return bn
                    }
                }(e.type)
            }

            function In(t, e, i) {
                this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return wn;
                        case 35664:
                            return Tn;
                        case 35665:
                            return En;
                        case 35666:
                            return Sn;
                        case 35674:
                            return An;
                        case 35675:
                            return Pn;
                        case 35676:
                            return Ln;
                        case 35678:
                            return Cn;
                        case 35680:
                            return Rn;
                        case 5124:
                        case 35670:
                            return Mn;
                        case 35667:
                        case 35671:
                            return _n;
                        case 35668:
                        case 35672:
                            return xn;
                        case 35669:
                        case 35673:
                            return bn
                    }
                }(e.type)
            }

            function Dn(t) {
                this.id = t, Ki.call(this)
            }
            In.prototype.updateCache = function(t) {
                var e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), an(e, t)
            }, Dn.prototype.setValue = function(t, e, i) {
                for (var n = this.seq, r = 0, o = n.length; r !== o; ++r) {
                    var a = n[r];
                    a.setValue(t, e[a.id], i)
                }
            };
            var kn = /([\w\d_]+)(\])?(\[|\.)?/g;

            function Nn(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function Bn(t, e, i) {
                var n = t.name,
                    r = n.length;
                for (kn.lastIndex = 0;;) {
                    var o = kn.exec(n),
                        a = kn.lastIndex,
                        s = o[1],
                        c = "]" === o[2],
                        l = o[3];
                    if (c && (s |= 0), void 0 === l || "[" === l && a + 2 === r) {
                        Nn(i, void 0 === l ? new On(s, t, e) : new In(s, t, e));
                        break
                    }
                    var h = i.map[s];
                    void 0 === h && Nn(i, h = new Dn(s)), i = h
                }
            }

            function Fn(t, e, i) {
                Ki.call(this), this.renderer = i;
                for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
                    var o = t.getActiveUniform(e, r);
                    Bn(o, t.getUniformLocation(e, o.name), this)
                }
            }

            function zn(t, e, i) {
                var n = t.createShader(e);
                return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" : "fragment", t.getShaderInfoLog(n), function(t) {
                    for (var e = t.split("\n"), i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
                    return e.join("\n")
                }(i)), n
            }
            Fn.prototype.setValue = function(t, e, i) {
                var n = this.map[e];
                void 0 !== n && n.setValue(t, i, this.renderer)
            }, Fn.prototype.setOptional = function(t, e, i) {
                var n = e[i];
                void 0 !== n && this.setValue(t, i, n)
            }, Fn.upload = function(t, e, i, n) {
                for (var r = 0, o = e.length; r !== o; ++r) {
                    var a = e[r],
                        s = i[a.id];
                    !1 !== s.needsUpdate && a.setValue(t, s.value, n)
                }
            }, Fn.seqWithValue = function(t, e) {
                for (var i = [], n = 0, r = t.length; n !== r; ++n) {
                    var o = t[n];
                    o.id in e && i.push(o)
                }
                return i
            };
            var Un = 0;

            function Gn(t) {
                switch (t) {
                    case Pe:
                        return ["Linear", "( value )"];
                    case Le:
                        return ["sRGB", "( value )"];
                    case Re:
                        return ["RGBE", "( value )"];
                    case Ie:
                        return ["RGBM", "( value, 7.0 )"];
                    case De:
                        return ["RGBM", "( value, 16.0 )"];
                    case ke:
                        return ["RGBD", "( value, 256.0 )"];
                    case Ce:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + t)
                }
            }

            function Hn(t, e) {
                var i = Gn(e);
                return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
            }

            function Vn(t) {
                return "" !== t
            }

            function jn(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            }

            function Wn(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }

            function Xn(t) {
                return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(t, e) {
                    var i = ni[e];
                    if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
                    return Xn(i)
                })
            }

            function qn(t) {
                return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, i, n) {
                    for (var r = "", o = parseInt(e); o < parseInt(i); o++) r += n.replace(/\[ i \]/g, "[ " + o + " ]");
                    return r
                })
            }

            function Yn(t, e, i, n, r, o, a) {
                var s = t.context,
                    c = n.defines,
                    l = r.vertexShader,
                    h = r.fragmentShader,
                    u = "SHADOWMAP_TYPE_BASIC";
                o.shadowMapType === f ? u = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === m && (u = "SHADOWMAP_TYPE_PCF_SOFT");
                var d = "ENVMAP_TYPE_CUBE",
                    p = "ENVMAP_MODE_REFLECTION",
                    g = "ENVMAP_BLENDING_MULTIPLY";
                if (o.envMap) {
                    switch (n.envMap.mapping) {
                        case ht:
                        case ut:
                            d = "ENVMAP_TYPE_CUBE";
                            break;
                        case mt:
                        case gt:
                            d = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case dt:
                        case pt:
                            d = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case ft:
                            d = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (n.envMap.mapping) {
                        case ut:
                        case pt:
                            p = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (n.combine) {
                        case tt:
                            g = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case et:
                            g = "ENVMAP_BLENDING_MIX";
                            break;
                        case it:
                            g = "ENVMAP_BLENDING_ADD"
                    }
                }
                var v, y, _ = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    x = a.isWebGL2 ? "" : function(t, e, i) {
                        return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Vn).join("\n")
                    }(n.extensions, o, e),
                    b = function(t) {
                        var e = [];
                        for (var i in t) {
                            var n = t[i];
                            !1 !== n && e.push("#define " + i + " " + n)
                        }
                        return e.join("\n")
                    }(c),
                    w = s.createProgram();
                if (n.isRawShaderMaterial ? ((v = [b].filter(Vn).join("\n")).length > 0 && (v += "\n"), (y = [x, b].filter(Vn).join("\n")).length > 0 && (y += "\n")) : (v = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + _, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Vn).join("\n"), y = [x, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + _, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + d : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + g : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + u : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (a.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== nt ? "#define TONE_MAPPING" : "", o.toneMapping !== nt ? ni.tonemapping_pars_fragment : "", o.toneMapping !== nt ? function(t, e) {
                        var i;
                        switch (e) {
                            case rt:
                                i = "Linear";
                                break;
                            case ot:
                                i = "Reinhard";
                                break;
                            case at:
                                i = "Uncharted2";
                                break;
                            case st:
                                i = "OptimizedCineon";
                                break;
                            case ct:
                                i = "ACESFilmic";
                                break;
                            default:
                                throw new Error("unsupported toneMapping: " + e)
                        }
                        return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
                    }("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? ni.encodings_pars_fragment : "", o.mapEncoding ? Hn("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? Hn("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? Hn("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Hn("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? function(t, e) {
                        var i = Gn(e);
                        return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }"
                    }("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Vn).join("\n")), l = Wn(l = jn(l = Xn(l), o), o), h = Wn(h = jn(h = Xn(h), o), o), l = qn(l), h = qn(h), a.isWebGL2 && !n.isRawShaderMaterial) {
                    var M = !1,
                        T = /^\s*#version\s+300\s+es\s*\n/;
                    n.isShaderMaterial && null !== l.match(T) && null !== h.match(T) && (M = !0, l = l.replace(T, ""), h = h.replace(T, "")), v = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v, y = ["#version 300 es\n", "#define varying in", M ? "" : "out highp vec4 pc_fragColor;", M ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y
                }
                var E = y + h,
                    S = zn(s, 35633, v + l),
                    A = zn(s, 35632, E);
                s.attachShader(w, S), s.attachShader(w, A), void 0 !== n.index0AttributeName ? s.bindAttribLocation(w, 0, n.index0AttributeName) : !0 === o.morphTargets && s.bindAttribLocation(w, 0, "position"), s.linkProgram(w);
                var P, L, C = s.getProgramInfoLog(w).trim(),
                    R = s.getShaderInfoLog(S).trim(),
                    O = s.getShaderInfoLog(A).trim(),
                    I = !0,
                    D = !0;
                return !1 === s.getProgramParameter(w, 35714) ? (I = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(w, 35715), "gl.getProgramInfoLog", C, R, O)) : "" !== C ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", C) : "" !== R && "" !== O || (D = !1), D && (this.diagnostics = {
                    runnable: I,
                    material: n,
                    programLog: C,
                    vertexShader: {
                        log: R,
                        prefix: v
                    },
                    fragmentShader: {
                        log: O,
                        prefix: y
                    }
                }), s.deleteShader(S), s.deleteShader(A), this.getUniforms = function() {
                    return void 0 === P && (P = new Fn(s, w, t)), P
                }, this.getAttributes = function() {
                    return void 0 === L && (L = function(t, e) {
                        for (var i = {}, n = t.getProgramParameter(e, 35721), r = 0; r < n; r++) {
                            var o = t.getActiveAttrib(e, r).name;
                            i[o] = t.getAttribLocation(e, o)
                        }
                        return i
                    }(s, w)), L
                }, this.destroy = function() {
                    s.deleteProgram(w), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function() {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.name = r.name, this.id = Un++, this.code = i, this.usedTimes = 1, this.program = w, this.vertexShader = S, this.fragmentShader = A, this
            }

            function Zn(t, e, i) {
                var n = [],
                    r = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

                function a(t, e) {
                    var i;
                    return t ? t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding) : i = Pe, i === Pe && e && (i = Ce), i
                }
                this.getParameters = function(e, n, o, s, c, l, h) {
                    var u = r[e.type],
                        d = h.isSkinnedMesh ? function(t) {
                            var e = t.skeleton.bones;
                            if (i.floatVertexTextures) return 1024;
                            var n = i.maxVertexUniforms,
                                r = Math.floor((n - 20) / 4),
                                o = Math.min(r, e.length);
                            return o < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + o + "."), 0) : o
                        }(h) : 0,
                        p = i.precision;
                    null !== e.precision && (p = i.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", p, "instead.");
                    var f = t.getRenderTarget();
                    return {
                        shaderID: u,
                        precision: p,
                        supportsVertexTextures: i.vertexTextures,
                        outputEncoding: a(f ? f.texture : null, t.gammaOutput),
                        map: !!e.map,
                        mapEncoding: a(e.map, t.gammaInput),
                        matcap: !!e.matcap,
                        matcapEncoding: a(e.matcap, t.gammaInput),
                        envMap: !!e.envMap,
                        envMapMode: e.envMap && e.envMap.mapping,
                        envMapEncoding: a(e.envMap, t.gammaInput),
                        envMapCubeUV: !!e.envMap && (e.envMap.mapping === mt || e.envMap.mapping === gt),
                        lightMap: !!e.lightMap,
                        aoMap: !!e.aoMap,
                        emissiveMap: !!e.emissiveMap,
                        emissiveMapEncoding: a(e.emissiveMap, t.gammaInput),
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        objectSpaceNormalMap: e.normalMapType === ze,
                        displacementMap: !!e.displacementMap,
                        roughnessMap: !!e.roughnessMap,
                        metalnessMap: !!e.metalnessMap,
                        specularMap: !!e.specularMap,
                        alphaMap: !!e.alphaMap,
                        gradientMap: !!e.gradientMap,
                        combine: e.combine,
                        vertexColors: e.vertexColors,
                        fog: !!s,
                        useFog: e.fog,
                        fogExp: s && s.isFogExp2,
                        flatShading: e.flatShading,
                        sizeAttenuation: e.sizeAttenuation,
                        logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                        skinning: e.skinning && d > 0,
                        maxBones: d,
                        useVertexTexture: i.floatVertexTextures,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: t.maxMorphTargets,
                        maxMorphNormals: t.maxMorphNormals,
                        numDirLights: n.directional.length,
                        numPointLights: n.point.length,
                        numSpotLights: n.spot.length,
                        numRectAreaLights: n.rectArea.length,
                        numHemiLights: n.hemi.length,
                        numClippingPlanes: c,
                        numClipIntersection: l,
                        dithering: e.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && h.receiveShadow && o.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: t.toneMapping,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: e.premultipliedAlpha,
                        alphaTest: e.alphaTest,
                        doubleSided: e.side === y,
                        flipSided: e.side === v,
                        depthPacking: void 0 !== e.depthPacking && e.depthPacking
                    }
                }, this.getProgramCode = function(e, i) {
                    var n = [];
                    if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                        for (var r in e.defines) n.push(r), n.push(e.defines[r]);
                    for (var a = 0; a < o.length; a++) n.push(i[o[a]]);
                    return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.push(t.gammaFactor), n.join()
                }, this.acquireProgram = function(r, o, a, s) {
                    for (var c, l = 0, h = n.length; l < h; l++) {
                        var u = n[l];
                        if (u.code === s) {
                            ++(c = u).usedTimes;
                            break
                        }
                    }
                    return void 0 === c && (c = new Yn(t, e, s, r, o, a, i), n.push(c)), c
                }, this.releaseProgram = function(t) {
                    if (0 == --t.usedTimes) {
                        var e = n.indexOf(t);
                        n[e] = n[n.length - 1], n.pop(), t.destroy()
                    }
                }, this.programs = n
            }

            function Jn(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function Kn(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function Qn() {
                var t = [],
                    e = 0,
                    i = [],
                    n = [];

                function r(i, n, r, o, a) {
                    var s = t[e];
                    return void 0 === s ? (s = {
                        id: i.id,
                        object: i,
                        geometry: n,
                        material: r,
                        program: r.program,
                        renderOrder: i.renderOrder,
                        z: o,
                        group: a
                    }, t[e] = s) : (s.id = i.id, s.object = i, s.geometry = n, s.material = r, s.program = r.program, s.renderOrder = i.renderOrder, s.z = o, s.group = a), e++, s
                }
                return {
                    opaque: i,
                    transparent: n,
                    init: function() {
                        e = 0, i.length = 0, n.length = 0
                    },
                    push: function(t, e, o, a, s) {
                        var c = r(t, e, o, a, s);
                        (!0 === o.transparent ? n : i).push(c)
                    },
                    unshift: function(t, e, o, a, s) {
                        var c = r(t, e, o, a, s);
                        (!0 === o.transparent ? n : i).unshift(c)
                    },
                    sort: function() {
                        i.length > 1 && i.sort(Jn), n.length > 1 && n.sort(Kn)
                    }
                }
            }
            var $n = 0;

            function tr() {
                var t = new function() {
                        var t = {};
                        return {
                            get: function(e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                var i;
                                switch (e.type) {
                                    case "DirectionalLight":
                                        i = {
                                            direction: new je,
                                            color: new ci,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ge
                                        };
                                        break;
                                    case "SpotLight":
                                        i = {
                                            position: new je,
                                            direction: new je,
                                            color: new ci,
                                            distance: 0,
                                            coneCos: 0,
                                            penumbraCos: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ge
                                        };
                                        break;
                                    case "PointLight":
                                        i = {
                                            position: new je,
                                            color: new ci,
                                            distance: 0,
                                            decay: 0,
                                            shadow: !1,
                                            shadowBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new Ge,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        };
                                        break;
                                    case "HemisphereLight":
                                        i = {
                                            direction: new je,
                                            skyColor: new ci,
                                            groundColor: new ci
                                        };
                                        break;
                                    case "RectAreaLight":
                                        i = {
                                            color: new ci,
                                            position: new je,
                                            halfWidth: new je,
                                            halfHeight: new je
                                        }
                                }
                                return t[e.id] = i, i
                            }
                        }
                    },
                    e = {
                        id: $n++,
                        hash: {
                            stateID: -1,
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            shadowsLength: -1
                        },
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    },
                    i = new je,
                    n = new He,
                    r = new He;
                return {
                    setup: function(o, a, s) {
                        for (var c = 0, l = 0, h = 0, u = 0, d = 0, p = 0, f = 0, m = 0, g = s.matrixWorldInverse, v = 0, y = o.length; v < y; v++) {
                            var _ = o[v],
                                x = _.color,
                                b = _.intensity,
                                w = _.distance,
                                M = _.shadow && _.shadow.map ? _.shadow.map.texture : null;
                            if (_.isAmbientLight) c += x.r * b, l += x.g * b, h += x.b * b;
                            else if (_.isDirectionalLight) {
                                if ((E = t.get(_)).color.copy(_.color).multiplyScalar(_.intensity), E.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), E.direction.sub(i), E.direction.transformDirection(g), E.shadow = _.castShadow, _.castShadow) {
                                    var T = _.shadow;
                                    E.shadowBias = T.bias, E.shadowRadius = T.radius, E.shadowMapSize = T.mapSize
                                }
                                e.directionalShadowMap[u] = M, e.directionalShadowMatrix[u] = _.shadow.matrix, e.directional[u] = E, u++
                            } else if (_.isSpotLight)(E = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(g), E.color.copy(x).multiplyScalar(b), E.distance = w, E.direction.setFromMatrixPosition(_.matrixWorld), i.setFromMatrixPosition(_.target.matrixWorld), E.direction.sub(i), E.direction.transformDirection(g), E.coneCos = Math.cos(_.angle), E.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)), E.decay = _.decay, E.shadow = _.castShadow, _.castShadow && (T = _.shadow, E.shadowBias = T.bias, E.shadowRadius = T.radius, E.shadowMapSize = T.mapSize), e.spotShadowMap[p] = M, e.spotShadowMatrix[p] = _.shadow.matrix, e.spot[p] = E, p++;
                            else if (_.isRectAreaLight)(E = t.get(_)).color.copy(x).multiplyScalar(b), E.position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(g), r.identity(), n.copy(_.matrixWorld), n.premultiply(g), r.extractRotation(n), E.halfWidth.set(.5 * _.width, 0, 0), E.halfHeight.set(0, .5 * _.height, 0), E.halfWidth.applyMatrix4(r), E.halfHeight.applyMatrix4(r), e.rectArea[f] = E, f++;
                            else if (_.isPointLight)(E = t.get(_)).position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(g), E.color.copy(_.color).multiplyScalar(_.intensity), E.distance = _.distance, E.decay = _.decay, E.shadow = _.castShadow, _.castShadow && (T = _.shadow, E.shadowBias = T.bias, E.shadowRadius = T.radius, E.shadowMapSize = T.mapSize, E.shadowCameraNear = T.camera.near, E.shadowCameraFar = T.camera.far), e.pointShadowMap[d] = M, e.pointShadowMatrix[d] = _.shadow.matrix, e.point[d] = E, d++;
                            else if (_.isHemisphereLight) {
                                var E;
                                (E = t.get(_)).direction.setFromMatrixPosition(_.matrixWorld), E.direction.transformDirection(g), E.direction.normalize(), E.skyColor.copy(_.color).multiplyScalar(b), E.groundColor.copy(_.groundColor).multiplyScalar(b), e.hemi[m] = E, m++
                            }
                        }
                        e.ambient[0] = c, e.ambient[1] = l, e.ambient[2] = h, e.directional.length = u, e.spot.length = p, e.rectArea.length = f, e.point.length = d, e.hemi.length = m, e.hash.stateID = e.id, e.hash.directionalLength = u, e.hash.pointLength = d, e.hash.spotLength = p, e.hash.rectAreaLength = f, e.hash.hemiLength = m, e.hash.shadowsLength = a.length
                    },
                    state: e
                }
            }

            function er() {
                var t = new tr,
                    e = [],
                    i = [];
                return {
                    init: function() {
                        e.length = 0, i.length = 0
                    },
                    state: {
                        lightsArray: e,
                        shadowsArray: i,
                        lights: t
                    },
                    setupLights: function(n) {
                        t.setup(e, i, n)
                    },
                    pushLight: function(t) {
                        e.push(t)
                    },
                    pushShadow: function(t) {
                        i.push(t)
                    }
                }
            }

            function ir(t) {
                zi.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Ne, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function nr(t) {
                zi.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new je, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function rr(t, e, i) {
                for (var n = new ii, r = new He, o = new Ge, a = new Ge(i, i), s = new je, c = new je, l = 1, h = 2, u = 1 + (l | h), d = new Array(u), p = new Array(u), m = {}, _ = {
                        0: v,
                        1: g,
                        2: y
                    }, x = [new je(1, 0, 0), new je(-1, 0, 0), new je(0, 0, 1), new je(0, 0, -1), new je(0, 1, 0), new je(0, -1, 0)], b = [new je(0, 1, 0), new je(0, 1, 0), new je(0, 1, 0), new je(0, 1, 0), new je(0, 0, 1), new je(0, 0, -1)], w = [new Ze, new Ze, new Ze, new Ze, new Ze, new Ze], M = 0; M !== u; ++M) {
                    var T = 0 != (M & l),
                        E = 0 != (M & h),
                        S = new ir({
                            depthPacking: Be,
                            morphTargets: T,
                            skinning: E
                        });
                    d[M] = S;
                    var A = new nr({
                        morphTargets: T,
                        skinning: E
                    });
                    p[M] = A
                }
                var P = this;

                function L(e, i, n, r, o, a) {
                    var s = e.geometry,
                        c = null,
                        u = d,
                        f = e.customDepthMaterial;
                    if (n && (u = p, f = e.customDistanceMaterial), f) c = f;
                    else {
                        var g = !1;
                        i.morphTargets && (s && s.isBufferGeometry ? g = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (g = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                        var v = e.isSkinnedMesh && i.skinning,
                            y = 0;
                        g && (y |= l), v && (y |= h), c = u[y]
                    }
                    if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                        var x = c.uuid,
                            b = i.uuid,
                            w = m[x];
                        void 0 === w && (w = {}, m[x] = w);
                        var M = w[b];
                        void 0 === M && (M = c.clone(), w[b] = M), c = M
                    }
                    return c.visible = i.visible, c.wireframe = i.wireframe, c.side = null != i.shadowSide ? i.shadowSide : _[i.side], c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, n && c.isMeshDistanceMaterial && (c.referencePosition.copy(r), c.nearDistance = o, c.farDistance = a), c
                }

                function C(i, r, o, a) {
                    if (!1 !== i.visible) {
                        if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || n.intersectsObject(i))) {
                            i.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, i.matrixWorld);
                            var s = e.update(i),
                                l = i.material;
                            if (Array.isArray(l))
                                for (var h = s.groups, u = 0, d = h.length; u < d; u++) {
                                    var p = h[u],
                                        f = l[p.materialIndex];
                                    if (f && f.visible) {
                                        var m = L(i, f, a, c, o.near, o.far);
                                        t.renderBufferDirect(o, null, s, m, i, p)
                                    }
                                } else if (l.visible) {
                                    m = L(i, l, a, c, o.near, o.far);
                                    t.renderBufferDirect(o, null, s, m, i, null)
                                }
                        }
                        for (var g = i.children, v = 0, y = g.length; v < y; v++) C(g[v], r, o, a)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = f, this.render = function(e, i, l) {
                    if (!1 !== P.enabled && (!1 !== P.autoUpdate || !1 !== P.needsUpdate) && 0 !== e.length) {
                        t.context;
                        var h, u = t.state;
                        u.disable(3042), u.buffers.color.setClear(1, 1, 1, 1), u.buffers.depth.setTest(!0), u.setScissorTest(!1);
                        for (var d = 0, p = e.length; d < p; d++) {
                            var f = e[d],
                                m = f.shadow,
                                g = f && f.isPointLight;
                            if (void 0 !== m) {
                                var v = m.camera;
                                if (o.copy(m.mapSize), o.min(a), g) {
                                    var y = o.x,
                                        _ = o.y;
                                    w[0].set(2 * y, _, y, _), w[1].set(0, _, y, _), w[2].set(3 * y, _, y, _), w[3].set(y, _, y, _), w[4].set(3 * y, 0, y, _), w[5].set(y, 0, y, _), o.x *= 4, o.y *= 2
                                }
                                if (null === m.map) {
                                    var M = {
                                        minFilter: xt,
                                        magFilter: xt,
                                        format: Ut
                                    };
                                    m.map = new Je(o.x, o.y, M), m.map.texture.name = f.name + ".shadowMap", v.updateProjectionMatrix()
                                }
                                m.isSpotLightShadow && m.update(f);
                                var T = m.map,
                                    E = m.matrix;
                                c.setFromMatrixPosition(f.matrixWorld), v.position.copy(c), g ? (h = 6, E.makeTranslation(-c.x, -c.y, -c.z)) : (h = 1, s.setFromMatrixPosition(f.target.matrixWorld), v.lookAt(s), v.updateMatrixWorld(), E.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), E.multiply(v.projectionMatrix), E.multiply(v.matrixWorldInverse)), t.setRenderTarget(T), t.clear();
                                for (var S = 0; S < h; S++) {
                                    if (g) {
                                        s.copy(v.position), s.add(x[S]), v.up.copy(b[S]), v.lookAt(s), v.updateMatrixWorld();
                                        var A = w[S];
                                        u.viewport(A)
                                    }
                                    r.multiplyMatrices(v.projectionMatrix, v.matrixWorldInverse), n.setFromMatrix(r), C(i, l, v, g)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", f, "has no shadow.")
                        }
                        P.needsUpdate = !1
                    }
                }
            }

            function or(t, e, i, n, r, o, a) {
                var s, c = {};

                function l(t, e) {
                    if (t.width > e || t.height > e) {
                        if ("data" in t) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + t.width + "x" + t.height + ").");
                        var i = e / Math.max(t.width, t.height),
                            n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return n.width = Math.floor(t.width * i), n.height = Math.floor(t.height * i), n.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height), console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + n.width + "x" + n.height), n
                    }
                    return t
                }

                function h(t) {
                    return Ue.isPowerOfTwo(t.width) && Ue.isPowerOfTwo(t.height)
                }

                function u(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== xt && t.minFilter !== Mt
                }

                function d(e, i, r, o) {
                    t.generateMipmap(e), n.get(i).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E
                }

                function p(t, e) {
                    if (!r.isWebGL2) return t;
                    if (6403 === t) {
                        if (5126 === e) return 33326;
                        if (5131 === e) return 33325;
                        if (5121 === e) return 33321
                    }
                    if (6407 === t) {
                        if (5126 === e) return 34837;
                        if (5131 === e) return 34843;
                        if (5121 === e) return 32849
                    }
                    if (6408 === t) {
                        if (5126 === e) return 34836;
                        if (5131 === e) return 34842;
                        if (5121 === e) return 32856
                    }
                    return t
                }

                function f(t) {
                    return t === xt || t === bt || t === wt ? 9728 : 9729
                }

                function m(e) {
                    var i = e.target;
                    i.removeEventListener("dispose", m),
                        function(e) {
                            var i = n.get(e);
                            if (e.image && i.__image__webglTextureCube) t.deleteTexture(i.__image__webglTextureCube);
                            else {
                                if (void 0 === i.__webglInit) return;
                                t.deleteTexture(i.__webglTexture)
                            }
                            n.remove(e)
                        }(i), i.isVideoTexture && delete c[i.id], a.memory.textures--
                }

                function g(e) {
                    var i = e.target;
                    i.removeEventListener("dispose", g),
                        function(e) {
                            var i = n.get(e),
                                r = n.get(e.texture);
                            if (!e) return;
                            void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLRenderTargetCube)
                                for (var o = 0; o < 6; o++) t.deleteFramebuffer(i.__webglFramebuffer[o]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[o]);
                            else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                            n.remove(e.texture), n.remove(e)
                        }(i), a.memory.textures--
                }

                function v(t, e) {
                    var r = n.get(t);
                    if (t.isVideoTexture && function(t) {
                            var e = t.id,
                                i = a.render.frame;
                            c[e] !== i && (c[e] = i, t.update())
                        }(t), t.version > 0 && r.__version !== t.version) {
                        var o = t.image;
                        if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== o.complete) return void _(r, t, e);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture)
                }

                function y(i, a, s) {
                    var c;
                    if (s ? (t.texParameteri(i, 10242, o.convert(a.wrapS)), t.texParameteri(i, 10243, o.convert(a.wrapT)), t.texParameteri(i, 10240, o.convert(a.magFilter)), t.texParameteri(i, 10241, o.convert(a.minFilter))) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), a.wrapS === yt && a.wrapT === yt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, f(a.magFilter)), t.texParameteri(i, 10241, f(a.minFilter)), a.minFilter !== xt && a.minFilter !== Mt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c = e.get("EXT_texture_filter_anisotropic")) {
                        if (a.type === Ot && null === e.get("OES_texture_float_linear")) return;
                        if (a.type === It && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear"))) return;
                        (a.anisotropy > 1 || n.get(a).__currentAnisotropy) && (t.texParameterf(i, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function _(e, n, c) {
                    var f;
                    f = n.isDataTexture3D ? 32879 : 3553, void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", m), e.__webglTexture = t.createTexture(), a.memory.textures++), i.activeTexture(33984 + c), i.bindTexture(f, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment);
                    var g = l(n.image, r.maxTextureSize);
                    (function(t) {
                        return !r.isWebGL2 && (t.wrapS !== yt || t.wrapT !== yt || t.minFilter !== xt && t.minFilter !== Mt)
                    })(n) && !1 === h(g) && (g = function(t) {
                        return t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap ? (void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), s.width = Ue.floorPowerOfTwo(t.width), s.height = Ue.floorPowerOfTwo(t.height), s.getContext("2d").drawImage(t, 0, 0, s.width, s.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + s.width + "x" + s.height), s) : t
                    }(g));
                    var v = h(g),
                        _ = o.convert(n.format),
                        x = o.convert(n.type),
                        b = p(_, x);
                    y(f, n, v);
                    var w, M = n.mipmaps;
                    if (n.isDepthTexture) {
                        if (b = 6402, n.type === Ot) {
                            if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            b = 36012
                        } else r.isWebGL2 && (b = 33189);
                        n.format === jt && 6402 === b && n.type !== Lt && n.type !== Rt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = Lt, x = o.convert(n.type)), n.format === Wt && (b = 34041, n.type !== Bt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = Bt, x = o.convert(n.type))), i.texImage2D(3553, 0, b, g.width, g.height, 0, _, x, null)
                    } else if (n.isDataTexture)
                        if (M.length > 0 && v) {
                            for (var T = 0, E = M.length; T < E; T++) w = M[T], i.texImage2D(3553, T, b, w.width, w.height, 0, _, x, w.data);
                            n.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                        } else i.texImage2D(3553, 0, b, g.width, g.height, 0, _, x, g.data), e.__maxMipLevel = 0;
                    else if (n.isCompressedTexture) {
                        for (T = 0, E = M.length; T < E; T++) w = M[T], n.format !== Ut && n.format !== zt ? i.getCompressedTextureFormats().indexOf(_) > -1 ? i.compressedTexImage2D(3553, T, b, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, T, b, w.width, w.height, 0, _, x, w.data);
                        e.__maxMipLevel = M.length - 1
                    } else if (n.isDataTexture3D) i.texImage3D(32879, 0, b, g.width, g.height, g.depth, 0, _, x, g.data), e.__maxMipLevel = 0;
                    else if (M.length > 0 && v) {
                        for (T = 0, E = M.length; T < E; T++) w = M[T], i.texImage2D(3553, T, b, _, x, w);
                        n.generateMipmaps = !1, e.__maxMipLevel = M.length - 1
                    } else i.texImage2D(3553, 0, b, _, x, g), e.__maxMipLevel = 0;
                    u(n, v) && d(3553, n, g.width, g.height), e.__version = n.version, n.onUpdate && n.onUpdate(n)
                }

                function x(e, r, a, s) {
                    var c = o.convert(r.texture.format),
                        l = o.convert(r.texture.type),
                        h = p(c, l);
                    i.texImage2D(s, 0, h, r.width, r.height, 0, c, l, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, s, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
                }

                function b(e, i) {
                    t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer ? (t.renderbufferStorage(36161, 33189, i.width, i.height), t.framebufferRenderbuffer(36160, 36096, 36161, e)) : i.depthBuffer && i.stencilBuffer ? (t.renderbufferStorage(36161, 34041, i.width, i.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)) : t.renderbufferStorage(36161, 32854, i.width, i.height), t.bindRenderbuffer(36161, null)
                }

                function w(e) {
                    var i = n.get(e),
                        r = !0 === e.isWebGLRenderTargetCube;
                    if (e.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, i) {
                            if (i && i.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), v(i.depthTexture, 0);
                            var r = n.get(i.depthTexture).__webglTexture;
                            if (i.depthTexture.format === jt) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                            else {
                                if (i.depthTexture.format !== Wt) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                            }
                        }(i.__webglFramebuffer, e)
                    } else if (r) {
                        i.__webglDepthbuffer = [];
                        for (var o = 0; o < 6; o++) t.bindFramebuffer(36160, i.__webglFramebuffer[o]), i.__webglDepthbuffer[o] = t.createRenderbuffer(), b(i.__webglDepthbuffer[o], e)
                    } else t.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), b(i.__webglDepthbuffer, e);
                    t.bindFramebuffer(36160, null)
                }
                this.setTexture2D = v, this.setTexture3D = function(t, e) {
                    var r = n.get(t);
                    t.version > 0 && r.__version !== t.version ? _(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = function(e, s) {
                    var c = n.get(e);
                    if (6 === e.image.length)
                        if (e.version > 0 && c.__version !== e.version) {
                            c.__image__webglTextureCube || (e.addEventListener("dispose", m), c.__image__webglTextureCube = t.createTexture(), a.memory.textures++), i.activeTexture(33984 + s), i.bindTexture(34067, c.__image__webglTextureCube), t.pixelStorei(37440, e.flipY);
                            for (var f = e && e.isCompressedTexture, g = e.image[0] && e.image[0].isDataTexture, v = [], _ = 0; _ < 6; _++) v[_] = f || g ? g ? e.image[_].image : e.image[_] : l(e.image[_], r.maxCubemapSize);
                            var x = v[0],
                                b = h(x),
                                w = o.convert(e.format),
                                M = o.convert(e.type),
                                T = p(w, M);
                            for (y(34067, e, b), _ = 0; _ < 6; _++)
                                if (f)
                                    for (var E, S = v[_].mipmaps, A = 0, P = S.length; A < P; A++) E = S[A], e.format !== Ut && e.format !== zt ? i.getCompressedTextureFormats().indexOf(w) > -1 ? i.compressedTexImage2D(34069 + _, A, T, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + _, A, T, E.width, E.height, 0, w, M, E.data);
                                else g ? i.texImage2D(34069 + _, 0, T, v[_].width, v[_].height, 0, w, M, v[_].data) : i.texImage2D(34069 + _, 0, T, w, M, v[_]);
                            c.__maxMipLevel = f ? S.length - 1 : 0, u(e, b) && d(34067, e, x.width, x.height), c.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else i.activeTexture(33984 + s), i.bindTexture(34067, c.__image__webglTextureCube)
                }, this.setTextureCubeDynamic = function(t, e) {
                    i.activeTexture(33984 + e), i.bindTexture(34067, n.get(t).__webglTexture)
                }, this.setupRenderTarget = function(e) {
                    var r = n.get(e),
                        o = n.get(e.texture);
                    e.addEventListener("dispose", g), o.__webglTexture = t.createTexture(), a.memory.textures++;
                    var s = !0 === e.isWebGLRenderTargetCube,
                        c = h(e);
                    if (s) {
                        r.__webglFramebuffer = [];
                        for (var l = 0; l < 6; l++) r.__webglFramebuffer[l] = t.createFramebuffer()
                    } else r.__webglFramebuffer = t.createFramebuffer();
                    if (s) {
                        for (i.bindTexture(34067, o.__webglTexture), y(34067, e.texture, c), l = 0; l < 6; l++) x(r.__webglFramebuffer[l], e, 36064, 34069 + l);
                        u(e.texture, c) && d(34067, e.texture, e.width, e.height), i.bindTexture(34067, null)
                    } else i.bindTexture(3553, o.__webglTexture), y(3553, e.texture, c), x(r.__webglFramebuffer, e, 36064, 3553), u(e.texture, c) && d(3553, e.texture, e.width, e.height), i.bindTexture(3553, null);
                    e.depthBuffer && w(e)
                }, this.updateRenderTargetMipmap = function(t) {
                    var e = t.texture;
                    if (u(e, h(t))) {
                        var r = t.isWebGLRenderTargetCube ? 34067 : 3553,
                            o = n.get(e).__webglTexture;
                        i.bindTexture(r, o), d(r, e, t.width, t.height), i.bindTexture(r, null)
                    }
                }
            }

            function ar(t, e, i) {
                return {
                    convert: function(t) {
                        var n;
                        if (t === vt) return 10497;
                        if (t === yt) return 33071;
                        if (t === _t) return 33648;
                        if (t === xt) return 9728;
                        if (t === bt) return 9984;
                        if (t === wt) return 9986;
                        if (t === Mt) return 9729;
                        if (t === Tt) return 9985;
                        if (t === Et) return 9987;
                        if (t === St) return 5121;
                        if (t === Dt) return 32819;
                        if (t === kt) return 32820;
                        if (t === Nt) return 33635;
                        if (t === At) return 5120;
                        if (t === Pt) return 5122;
                        if (t === Lt) return 5123;
                        if (t === Ct) return 5124;
                        if (t === Rt) return 5125;
                        if (t === Ot) return 5126;
                        if (t === It) {
                            if (i.isWebGL2) return 5131;
                            if (null !== (n = e.get("OES_texture_half_float"))) return n.HALF_FLOAT_OES
                        }
                        if (t === Ft) return 6406;
                        if (t === zt) return 6407;
                        if (t === Ut) return 6408;
                        if (t === Gt) return 6409;
                        if (t === Ht) return 6410;
                        if (t === jt) return 6402;
                        if (t === Wt) return 34041;
                        if (t === Xt) return 6403;
                        if (t === C) return 32774;
                        if (t === R) return 32778;
                        if (t === O) return 32779;
                        if (t === k) return 0;
                        if (t === N) return 1;
                        if (t === B) return 768;
                        if (t === F) return 769;
                        if (t === z) return 770;
                        if (t === U) return 771;
                        if (t === G) return 772;
                        if (t === H) return 773;
                        if (t === V) return 774;
                        if (t === j) return 775;
                        if (t === W) return 776;
                        if ((t === qt || t === Yt || t === Zt || t === Jt) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) {
                            if (t === qt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === Yt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === Zt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === Jt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if ((t === Kt || t === Qt || t === $t || t === te) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) {
                            if (t === Kt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (t === Qt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (t === $t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (t === te) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (t === ee && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                        if ((t === ie || t === ne || t === re || t === oe || t === ae || t === se || t === ce || t === le || t === he || t === ue || t === de || t === pe || t === fe || t === me) && null !== (n = e.get("WEBGL_compressed_texture_astc"))) return t;
                        if (t === I || t === D) {
                            if (i.isWebGL2) {
                                if (t === I) return 32775;
                                if (t === D) return 32776
                            }
                            if (null !== (n = e.get("EXT_blend_minmax"))) {
                                if (t === I) return n.MIN_EXT;
                                if (t === D) return n.MAX_EXT
                            }
                        }
                        if (t === Bt) {
                            if (i.isWebGL2) return 34042;
                            if (null !== (n = e.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
                        }
                        return 0
                    }
                }
            }

            function sr() {
                vi.call(this), this.type = "Group"
            }

            function cr() {
                vi.call(this), this.type = "Camera", this.matrixWorldInverse = new He, this.projectionMatrix = new He, this.projectionMatrixInverse = new He
            }

            function lr(t, e, i, n) {
                cr.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            function hr(t) {
                lr.call(this), this.cameras = t || []
            }
            ir.prototype = Object.create(zi.prototype), ir.prototype.constructor = ir, ir.prototype.isMeshDepthMaterial = !0, ir.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, nr.prototype = Object.create(zi.prototype), nr.prototype.constructor = nr, nr.prototype.isMeshDistanceMaterial = !0, nr.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }, sr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: sr,
                isGroup: !0
            }), cr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: cr,
                isCamera: !0,
                copy: function(t, e) {
                    return vi.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new je), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    vi.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), lr.prototype = Object.assign(Object.create(cr.prototype), {
                constructor: lr,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return cr.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    var e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * Ue.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var t = Math.tan(.5 * Ue.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * Ue.RAD2DEG * Math.atan(Math.tan(.5 * Ue.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, i, n, r, o) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = this.near,
                        e = t * Math.tan(.5 * Ue.DEG2RAD * this.fov) / this.zoom,
                        i = 2 * e,
                        n = this.aspect * i,
                        r = -.5 * n,
                        o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var a = o.fullWidth,
                            s = o.fullHeight;
                        r += o.offsetX * n / a, e -= o.offsetY * i / s, n *= o.width / a, i *= o.height / s
                    }
                    var c = this.filmOffset;
                    0 !== c && (r += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            }), hr.prototype = Object.assign(Object.create(lr.prototype), {
                constructor: hr,
                isArrayCamera: !0
            });
            var ur, dr = new je,
                pr = new je;

            function fr(t, e, i) {
                dr.setFromMatrixPosition(e.matrixWorld), pr.setFromMatrixPosition(i.matrixWorld);
                var n = dr.distanceTo(pr),
                    r = e.projectionMatrix.elements,
                    o = i.projectionMatrix.elements,
                    a = r[14] / (r[10] - 1),
                    s = r[14] / (r[10] + 1),
                    c = (r[9] + 1) / r[5],
                    l = (r[9] - 1) / r[5],
                    h = (r[8] - 1) / r[0],
                    u = (o[8] + 1) / o[0],
                    d = a * h,
                    p = a * u,
                    f = n / (-h + u),
                    m = f * -h;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                var g = a + f,
                    v = s + f,
                    y = d - m,
                    _ = p + (n - m),
                    x = c * s / v * g,
                    b = l * s / v * g;
                t.projectionMatrix.makePerspective(y, _, x, b, g, v)
            }

            function mr(t) {
                var e = this,
                    i = null,
                    n = null,
                    r = null,
                    o = [],
                    a = new He,
                    s = new He,
                    c = 1,
                    l = "stage";
                "undefined" != typeof window && "VRFrameData" in window && (n = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", _, !1));
                var h = new He,
                    u = new Ve,
                    d = new je,
                    p = new lr;
                p.bounds = new Ze(0, 0, .5, 1), p.layers.enable(1);
                var f = new lr;
                f.bounds = new Ze(.5, 0, .5, 1), f.layers.enable(2);
                var m, g, v = new hr([p, f]);

                function y() {
                    return null !== i && !0 === i.isPresenting
                }

                function _() {
                    if (y()) {
                        var n = i.getEyeParameters("left"),
                            r = n.renderWidth * c,
                            o = n.renderHeight * c;
                        g = t.getPixelRatio(), m = t.getSize(), t.setDrawingBufferSize(2 * r, o, 1), w.start()
                    } else e.enabled && t.setDrawingBufferSize(m.width, m.height, g), w.stop()
                }
                v.layers.enable(1), v.layers.enable(2);
                var x = [];

                function b(t) {
                    for (var e = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        if (o && ("Daydream Controller" === o.id || "Gear VR Controller" === o.id || "Oculus Go Controller" === o.id || "OpenVR Gamepad" === o.id || o.id.startsWith("Oculus Touch") || o.id.startsWith("Spatial Controller"))) {
                            if (n === t) return o;
                            n++
                        }
                    }
                }
                this.enabled = !1, this.getController = function(t) {
                    var e = o[t];
                    return void 0 === e && ((e = new sr).matrixAutoUpdate = !1, e.visible = !1, o[t] = e), e
                }, this.getDevice = function() {
                    return i
                }, this.setDevice = function(t) {
                    void 0 !== t && (i = t), w.setContext(t)
                }, this.setFramebufferScaleFactor = function(t) {
                    c = t
                }, this.setFrameOfReferenceType = function(t) {
                    l = t
                }, this.setPoseTarget = function(t) {
                    void 0 !== t && (r = t)
                }, this.getCamera = function(t) {
                    var e = "stage" === l ? 1.6 : 0;
                    if (null === i) return t.position.set(0, e, 0), t;
                    if (i.depthNear = t.near, i.depthFar = t.far, i.getFrameData(n), "stage" === l) {
                        var c = i.stageParameters;
                        c ? a.fromArray(c.sittingToStandingTransform) : a.makeTranslation(0, e, 0)
                    }
                    var m = n.pose,
                        g = null !== r ? r : t;
                    if (g.matrix.copy(a), g.matrix.decompose(g.position, g.quaternion, g.scale), null !== m.orientation && (u.fromArray(m.orientation), g.quaternion.multiply(u)), null !== m.position && (u.setFromRotationMatrix(a), d.fromArray(m.position), d.applyQuaternion(u), g.position.add(d)), g.updateMatrixWorld(), !1 === i.isPresenting) return t;
                    p.near = t.near, f.near = t.near, p.far = t.far, f.far = t.far, p.matrixWorldInverse.fromArray(n.leftViewMatrix), f.matrixWorldInverse.fromArray(n.rightViewMatrix), s.getInverse(a), "stage" === l && (p.matrixWorldInverse.multiply(s), f.matrixWorldInverse.multiply(s));
                    var y = g.parent;
                    null !== y && (h.getInverse(y.matrixWorld), p.matrixWorldInverse.multiply(h), f.matrixWorldInverse.multiply(h)), p.matrixWorld.getInverse(p.matrixWorldInverse), f.matrixWorld.getInverse(f.matrixWorldInverse), p.projectionMatrix.fromArray(n.leftProjectionMatrix), f.projectionMatrix.fromArray(n.rightProjectionMatrix), fr(v, p, f);
                    var _ = i.getLayers();
                    if (_.length) {
                        var w = _[0];
                        null !== w.leftBounds && 4 === w.leftBounds.length && p.bounds.fromArray(w.leftBounds), null !== w.rightBounds && 4 === w.rightBounds.length && f.bounds.fromArray(w.rightBounds)
                    }
                    return function() {
                        for (var t = 0; t < o.length; t++) {
                            var e = o[t],
                                i = b(t);
                            if (void 0 !== i && void 0 !== i.pose) {
                                if (null === i.pose) return;
                                var n = i.pose;
                                !1 === n.hasPosition && e.position.set(.2, -.6, -.05), null !== n.position && e.position.fromArray(n.position), null !== n.orientation && e.quaternion.fromArray(n.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(a), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
                                var r = "Daydream Controller" === i.id ? 0 : 1;
                                x[t] !== i.buttons[r].pressed && (x[t] = i.buttons[r].pressed, !0 === x[t] ? e.dispatchEvent({
                                    type: "selectstart"
                                }) : (e.dispatchEvent({
                                    type: "selectend"
                                }), e.dispatchEvent({
                                    type: "select"
                                })))
                            } else e.visible = !1
                        }
                    }(), v
                }, this.getStandingMatrix = function() {
                    return a
                }, this.isPresenting = y;
                var w = new ui;
                this.setAnimationLoop = function(t) {
                    w.setAnimationLoop(t)
                }, this.submitFrame = function() {
                    y() && i.submitFrame()
                }, this.dispose = function() {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", _)
                }
            }

            function gr(e) {
                console.log("THREE.WebGLRenderer", o);
                var i = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    n = void 0 !== e.context ? e.context : null,
                    r = void 0 !== e.alpha && e.alpha,
                    a = void 0 === e.depth || e.depth,
                    h = void 0 === e.stencil || e.stencil,
                    u = void 0 !== e.antialias && e.antialias,
                    d = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    p = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    f = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    m = null,
                    _ = null;
                this.domElement = i, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = rt, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var x, b, w, M, R, O, I, D, k, N, B, F, z, U, G, H, V, j, W = this,
                    tt = !1,
                    et = null,
                    it = null,
                    nt = null,
                    ot = -1,
                    at = {
                        geometry: null,
                        program: null,
                        wireframe: !1
                    },
                    st = null,
                    ct = null,
                    lt = new Ze,
                    ht = new Ze,
                    ut = null,
                    dt = 0,
                    pt = i.width,
                    ft = i.height,
                    mt = 1,
                    gt = new Ze(0, 0, pt, ft),
                    vt = new Ze(0, 0, pt, ft),
                    yt = !1,
                    _t = new ii,
                    xt = new function() {
                        var t = this,
                            e = null,
                            i = 0,
                            n = !1,
                            r = !1,
                            o = new ei,
                            a = new We,
                            s = {
                                value: null,
                                needsUpdate: !1
                            };

                        function c() {
                            s.value !== e && (s.value = e, s.needsUpdate = i > 0), t.numPlanes = i, t.numIntersection = 0
                        }

                        function l(e, i, n, r) {
                            var c = null !== e ? e.length : 0,
                                l = null;
                            if (0 !== c) {
                                if (l = s.value, !0 !== r || null === l) {
                                    var h = n + 4 * c,
                                        u = i.matrixWorldInverse;
                                    a.getNormalMatrix(u), (null === l || l.length < h) && (l = new Float32Array(h));
                                    for (var d = 0, p = n; d !== c; ++d, p += 4) o.copy(e[d]).applyMatrix4(u, a), o.normal.toArray(l, p), l[p + 3] = o.constant
                                }
                                s.value = l, s.needsUpdate = !0
                            }
                            return t.numPlanes = c, l
                        }
                        this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, r, o) {
                            var a = 0 !== t.length || r || 0 !== i || n;
                            return n = r, e = l(t, o, 0), i = t.length, a
                        }, this.beginShadows = function() {
                            r = !0, l(null)
                        }, this.endShadows = function() {
                            r = !1, c()
                        }, this.setState = function(t, o, a, h, u, d) {
                            if (!n || null === t || 0 === t.length || r && !a) r ? l(null) : c();
                            else {
                                var p = r ? 0 : i,
                                    f = 4 * p,
                                    m = u.clippingState || null;
                                s.value = m, m = l(t, h, f, d);
                                for (var g = 0; g !== f; ++g) m[g] = e[g];
                                u.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += p
                            }
                        }
                    },
                    bt = !1,
                    wt = !1,
                    Mt = new He,
                    Tt = new je;

                function Et() {
                    return null === it ? mt : 1
                }
                try {
                    var At = {
                        alpha: r,
                        depth: a,
                        stencil: h,
                        antialias: u,
                        premultipliedAlpha: d,
                        preserveDrawingBuffer: p,
                        powerPreference: f
                    };
                    if (i.addEventListener("webglcontextlost", Rt, !1), i.addEventListener("webglcontextrestored", Dt, !1), null === (x = n || i.getContext("webgl", At) || i.getContext("experimental-webgl", At))) throw null !== i.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === x.getShaderPrecisionFormat && (x.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    console.error("THREE.WebGLRenderer: " + t.message)
                }

                function Pt() {
                    b = new function(t) {
                        var e = {};
                        return {
                            get: function(i) {
                                if (void 0 !== e[i]) return e[i];
                                var n;
                                switch (i) {
                                    case "WEBGL_depth_texture":
                                        n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                        break;
                                    case "EXT_texture_filter_anisotropic":
                                        n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                        break;
                                    case "WEBGL_compressed_texture_s3tc":
                                        n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                        break;
                                    case "WEBGL_compressed_texture_pvrtc":
                                        n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                        break;
                                    default:
                                        n = t.getExtension(i)
                                }
                                return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n, n
                            }
                        }
                    }(x), (w = new function(t, e, i) {
                        var n;

                        function r(e) {
                            if ("highp" === e) {
                                if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                                e = "mediump"
                            }
                            return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                        }
                        var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                            a = void 0 !== i.precision ? i.precision : "highp",
                            s = r(a);
                        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
                        var c = !0 === i.logarithmicDepthBuffer,
                            l = t.getParameter(34930),
                            h = t.getParameter(35660),
                            u = t.getParameter(3379),
                            d = t.getParameter(34076),
                            p = t.getParameter(34921),
                            f = t.getParameter(36347),
                            m = t.getParameter(36348),
                            g = t.getParameter(36349),
                            v = h > 0,
                            y = o || !!e.get("OES_texture_float");
                        return {
                            isWebGL2: o,
                            getMaxAnisotropy: function() {
                                if (void 0 !== n) return n;
                                var i = e.get("EXT_texture_filter_anisotropic");
                                return n = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                            },
                            getMaxPrecision: r,
                            precision: a,
                            logarithmicDepthBuffer: c,
                            maxTextures: l,
                            maxVertexTextures: h,
                            maxTextureSize: u,
                            maxCubemapSize: d,
                            maxAttributes: p,
                            maxVertexUniforms: f,
                            maxVaryings: m,
                            maxFragmentUniforms: g,
                            vertexTextures: v,
                            floatFragmentTextures: y,
                            floatVertexTextures: v && y
                        }
                    }(x, b, e)).isWebGL2 || (b.get("WEBGL_depth_texture"), b.get("OES_texture_float"), b.get("OES_texture_half_float"), b.get("OES_texture_half_float_linear"), b.get("OES_standard_derivatives"), b.get("OES_element_index_uint"), b.get("ANGLE_instanced_arrays")), b.get("OES_texture_float_linear"), j = new ar(x, b, w), (M = new function(t, e, i, n) {
                        var r = new function() {
                                var e = !1,
                                    i = new Ze,
                                    n = null,
                                    r = new Ze(0, 0, 0, 0);
                                return {
                                    setMask: function(i) {
                                        n === i || e || (t.colorMask(i, i, i, i), n = i)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e, n, o, a, s) {
                                        !0 === s && (e *= a, n *= a, o *= a), i.set(e, n, o, a), !1 === r.equals(i) && (t.clearColor(e, n, o, a), r.copy(i))
                                    },
                                    reset: function() {
                                        e = !1, n = null, r.set(-1, 0, 0, 0)
                                    }
                                }
                            },
                            o = new function() {
                                var e = !1,
                                    i = null,
                                    n = null,
                                    r = null;
                                return {
                                    setTest: function(t) {
                                        t ? ot(2929) : at(2929)
                                    },
                                    setMask: function(n) {
                                        i === n || e || (t.depthMask(n), i = n)
                                    },
                                    setFunc: function(e) {
                                        if (n !== e) {
                                            if (e) switch (e) {
                                                case X:
                                                    t.depthFunc(512);
                                                    break;
                                                case q:
                                                    t.depthFunc(519);
                                                    break;
                                                case Y:
                                                    t.depthFunc(513);
                                                    break;
                                                case Z:
                                                    t.depthFunc(515);
                                                    break;
                                                case J:
                                                    t.depthFunc(514);
                                                    break;
                                                case K:
                                                    t.depthFunc(518);
                                                    break;
                                                case Q:
                                                    t.depthFunc(516);
                                                    break;
                                                case $:
                                                    t.depthFunc(517);
                                                    break;
                                                default:
                                                    t.depthFunc(515)
                                            } else t.depthFunc(515);
                                            n = e
                                        }
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        r !== e && (t.clearDepth(e), r = e)
                                    },
                                    reset: function() {
                                        e = !1, i = null, n = null, r = null
                                    }
                                }
                            },
                            a = new function() {
                                var e = !1,
                                    i = null,
                                    n = null,
                                    r = null,
                                    o = null,
                                    a = null,
                                    s = null,
                                    c = null,
                                    l = null;
                                return {
                                    setTest: function(t) {
                                        t ? ot(2960) : at(2960)
                                    },
                                    setMask: function(n) {
                                        i === n || e || (t.stencilMask(n), i = n)
                                    },
                                    setFunc: function(e, i, a) {
                                        n === e && r === i && o === a || (t.stencilFunc(e, i, a), n = e, r = i, o = a)
                                    },
                                    setOp: function(e, i, n) {
                                        a === e && s === i && c === n || (t.stencilOp(e, i, n), a = e, s = i, c = n)
                                    },
                                    setLocked: function(t) {
                                        e = t
                                    },
                                    setClear: function(e) {
                                        l !== e && (t.clearStencil(e), l = e)
                                    },
                                    reset: function() {
                                        e = !1, i = null, n = null, r = null, o = null, a = null, s = null, c = null, l = null
                                    }
                                }
                            },
                            h = t.getParameter(34921),
                            u = new Uint8Array(h),
                            d = new Uint8Array(h),
                            p = new Uint8Array(h),
                            f = {},
                            m = null,
                            g = null,
                            _ = null,
                            x = null,
                            b = null,
                            w = null,
                            M = null,
                            R = null,
                            O = null,
                            I = null,
                            D = !1,
                            k = null,
                            N = null,
                            B = null,
                            F = null,
                            z = null,
                            U = t.getParameter(35661),
                            G = !1,
                            H = 0,
                            V = t.getParameter(7938); - 1 !== V.indexOf("WebGL") ? (H = parseFloat(/^WebGL\ ([0-9])/.exec(V)[1]), G = H >= 1) : -1 !== V.indexOf("OpenGL ES") && (H = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(V)[1]), G = H >= 2);
                        var j = null,
                            W = {},
                            tt = new Ze,
                            et = new Ze;

                        function it(e, i, n) {
                            var r = new Uint8Array(4),
                                o = t.createTexture();
                            t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                            for (var a = 0; a < n; a++) t.texImage2D(i + a, 0, 6408, 1, 1, 0, 6408, 5121, r);
                            return o
                        }
                        var nt = {};

                        function rt(i, r) {
                            u[i] = 1, 0 === d[i] && (t.enableVertexAttribArray(i), d[i] = 1), p[i] !== r && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), p[i] = r)
                        }

                        function ot(e) {
                            !0 !== f[e] && (t.enable(e), f[e] = !0)
                        }

                        function at(e) {
                            !1 !== f[e] && (t.disable(e), f[e] = !1)
                        }

                        function st(e, n, r, o, a, s, c, l) {
                            if (e !== T) {
                                if (_ || (ot(3042), _ = !0), e === L) a = a || n, s = s || r, c = c || o, n === b && a === R || (t.blendEquationSeparate(i.convert(n), i.convert(a)), b = n, R = a), r === w && o === M && s === O && c === I || (t.blendFuncSeparate(i.convert(r), i.convert(o), i.convert(s), i.convert(c)), w = r, M = o, O = s, I = c), x = e, D = null;
                                else if (e !== x || l !== D) {
                                    if (b === C && R === C || (t.blendEquation(32774), b = C, R = C), l) switch (e) {
                                        case E:
                                            t.blendFuncSeparate(1, 771, 1, 771);
                                            break;
                                        case S:
                                            t.blendFunc(1, 1);
                                            break;
                                        case A:
                                            t.blendFuncSeparate(0, 0, 769, 771);
                                            break;
                                        case P:
                                            t.blendFuncSeparate(0, 768, 0, 770);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    } else switch (e) {
                                        case E:
                                            t.blendFuncSeparate(770, 771, 1, 771);
                                            break;
                                        case S:
                                            t.blendFunc(770, 1);
                                            break;
                                        case A:
                                            t.blendFunc(0, 769);
                                            break;
                                        case P:
                                            t.blendFunc(0, 768);
                                            break;
                                        default:
                                            console.error("THREE.WebGLState: Invalid blending: ", e)
                                    }
                                    w = null, M = null, O = null, I = null, x = e, D = l
                                }
                            } else _ && (at(3042), _ = !1)
                        }

                        function ct(e) {
                            k !== e && (e ? t.frontFace(2304) : t.frontFace(2305), k = e)
                        }

                        function lt(e) {
                            e !== s ? (ot(2884), e !== N && (e === c ? t.cullFace(1029) : e === l ? t.cullFace(1028) : t.cullFace(1032))) : at(2884), N = e
                        }

                        function ht(e, i, n) {
                            e ? (ot(32823), F === i && z === n || (t.polygonOffset(i, n), F = i, z = n)) : at(32823)
                        }

                        function ut(e) {
                            void 0 === e && (e = 33984 + U - 1), j !== e && (t.activeTexture(e), j = e)
                        }
                        return nt[3553] = it(3553, 3553, 1), nt[34067] = it(34067, 34069, 6), r.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), ot(2929), o.setFunc(Z), ct(!1), lt(c), ot(2884), st(T), {
                            buffers: {
                                color: r,
                                depth: o,
                                stencil: a
                            },
                            initAttributes: function() {
                                for (var t = 0, e = u.length; t < e; t++) u[t] = 0
                            },
                            enableAttribute: function(t) {
                                rt(t, 0)
                            },
                            enableAttributeAndDivisor: rt,
                            disableUnusedAttributes: function() {
                                for (var e = 0, i = d.length; e !== i; ++e) d[e] !== u[e] && (t.disableVertexAttribArray(e), d[e] = 0)
                            },
                            enable: ot,
                            disable: at,
                            getCompressedTextureFormats: function() {
                                if (null === m && (m = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                                    for (var i = t.getParameter(34467), n = 0; n < i.length; n++) m.push(i[n]);
                                return m
                            },
                            useProgram: function(e) {
                                return g !== e && (t.useProgram(e), g = e, !0)
                            },
                            setBlending: st,
                            setMaterial: function(t, e) {
                                t.side === y ? at(2884) : ot(2884);
                                var i = t.side === v;
                                e && (i = !i), ct(i), t.blending === E && !1 === t.transparent ? st(T) : st(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), r.setMask(t.colorWrite), ht(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                            },
                            setFlipSided: ct,
                            setCullFace: lt,
                            setLineWidth: function(e) {
                                e !== B && (G && t.lineWidth(e), B = e)
                            },
                            setPolygonOffset: ht,
                            setScissorTest: function(t) {
                                t ? ot(3089) : at(3089)
                            },
                            activeTexture: ut,
                            bindTexture: function(e, i) {
                                null === j && ut();
                                var n = W[j];
                                void 0 === n && (n = {
                                    type: void 0,
                                    texture: void 0
                                }, W[j] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || nt[e]), n.type = e, n.texture = i)
                            },
                            compressedTexImage2D: function() {
                                try {
                                    t.compressedTexImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage2D: function() {
                                try {
                                    t.texImage2D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            texImage3D: function() {
                                try {
                                    t.texImage3D.apply(t, arguments)
                                } catch (t) {
                                    console.error("THREE.WebGLState:", t)
                                }
                            },
                            scissor: function(e) {
                                !1 === tt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), tt.copy(e))
                            },
                            viewport: function(e) {
                                !1 === et.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), et.copy(e))
                            },
                            reset: function() {
                                for (var e = 0; e < d.length; e++) 1 === d[e] && (t.disableVertexAttribArray(e), d[e] = 0);
                                f = {}, m = null, j = null, W = {}, g = null, x = null, k = null, N = null, r.reset(), o.reset(), a.reset()
                            }
                        }
                    }(x, b, j, w)).scissor(ht.copy(vt).multiplyScalar(mt)), M.viewport(lt.copy(gt).multiplyScalar(mt)), R = new function(t) {
                        var e = {
                            frame: 0,
                            calls: 0,
                            triangles: 0,
                            points: 0,
                            lines: 0
                        };
                        return {
                            memory: {
                                geometries: 0,
                                textures: 0
                            },
                            render: e,
                            programs: null,
                            autoReset: !0,
                            reset: function() {
                                e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                            },
                            update: function(t, i, n) {
                                switch (n = n || 1, e.calls++, i) {
                                    case 4:
                                        e.triangles += n * (t / 3);
                                        break;
                                    case 5:
                                    case 6:
                                        e.triangles += n * (t - 2);
                                        break;
                                    case 1:
                                        e.lines += n * (t / 2);
                                        break;
                                    case 3:
                                        e.lines += n * (t - 1);
                                        break;
                                    case 2:
                                        e.lines += n * t;
                                        break;
                                    case 0:
                                        e.points += n * t;
                                        break;
                                    default:
                                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                                }
                            }
                        }
                    }(x), O = new function() {
                        var t = new WeakMap;
                        return {
                            get: function(e) {
                                var i = t.get(e);
                                return void 0 === i && (i = {}, t.set(e, i)), i
                            },
                            remove: function(e) {
                                t.delete(e)
                            },
                            update: function(e, i, n) {
                                t.get(e)[i] = n
                            },
                            dispose: function() {
                                t = new WeakMap
                            }
                        }
                    }, I = new or(x, b, M, O, w, j, R), D = new di(x), k = new function(t, e, i) {
                        var n = {},
                            r = {};

                        function o(t) {
                            var a = t.target,
                                s = n[a.id];
                            for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[c]);
                            a.removeEventListener("dispose", o), delete n[a.id];
                            var l = r[s.id];
                            l && (e.remove(l), delete r[s.id]), i.memory.geometries--
                        }
                        return {
                            get: function(t, e) {
                                var r = n[e.id];
                                return r || (e.addEventListener("dispose", o), e.isBufferGeometry ? r = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Ii).setFromObject(t)), r = e._bufferGeometry), n[e.id] = r, i.memory.geometries++, r)
                            },
                            update: function(t) {
                                var i = t.index,
                                    n = t.attributes;
                                for (var r in null !== i && e.update(i, 34963), n) e.update(n[r], 34962);
                                var o = t.morphAttributes;
                                for (var r in o)
                                    for (var a = o[r], s = 0, c = a.length; s < c; s++) e.update(a[s], 34962)
                            },
                            getWireframeAttribute: function(t) {
                                var i = r[t.id];
                                if (i) return i;
                                var n, o = [],
                                    a = t.index,
                                    s = t.attributes;
                                if (null !== a)
                                    for (var c = 0, l = (n = a.array).length; c < l; c += 3) {
                                        var h = n[c + 0],
                                            u = n[c + 1],
                                            d = n[c + 2];
                                        o.push(h, u, u, d, d, h)
                                    } else
                                        for (c = 0, l = (n = s.position.array).length / 3 - 1; c < l; c += 3) h = c + 0, u = c + 1, d = c + 2, o.push(h, u, u, d, d, h);
                                return i = new(Ri(o) > 65535 ? Ai : Ei)(o, 1), e.update(i, 34963), r[t.id] = i, i
                            }
                        }
                    }(x, D, R), N = new function(t, e) {
                        var i = {};
                        return {
                            update: function(n) {
                                var r = e.render.frame,
                                    o = n.geometry,
                                    a = t.get(n, o);
                                return i[a.id] !== r && (o.isGeometry && a.updateFromObject(n), t.update(a), i[a.id] = r), a
                            },
                            dispose: function() {
                                i = {}
                            }
                        }
                    }(k, R), G = new function(t) {
                        var e = {},
                            i = new Float32Array(8);
                        return {
                            update: function(n, r, o, a) {
                                var s = n.morphTargetInfluences,
                                    c = s.length,
                                    l = e[r.id];
                                if (void 0 === l) {
                                    l = [];
                                    for (var h = 0; h < c; h++) l[h] = [h, 0];
                                    e[r.id] = l
                                }
                                var u = o.morphTargets && r.morphAttributes.position,
                                    d = o.morphNormals && r.morphAttributes.normal;
                                for (h = 0; h < c; h++) 0 !== (p = l[h])[1] && (u && r.removeAttribute("morphTarget" + h), d && r.removeAttribute("morphNormal" + h));
                                for (h = 0; h < c; h++)(p = l[h])[0] = h, p[1] = s[h];
                                for (l.sort(Wi), h = 0; h < 8; h++) {
                                    var p;
                                    if (p = l[h]) {
                                        var f = p[0],
                                            m = p[1];
                                        if (m) {
                                            u && r.addAttribute("morphTarget" + h, u[f]), d && r.addAttribute("morphNormal" + h, d[f]), i[h] = m;
                                            continue
                                        }
                                    }
                                    i[h] = 0
                                }
                                a.getUniforms().setValue(t, "morphTargetInfluences", i)
                            }
                        }
                    }(x), B = new Zn(W, b, w), F = new function() {
                        var t = {};
                        return {
                            get: function(e, i) {
                                var n, r = t[e.id];
                                return void 0 === r ? (n = new Qn, t[e.id] = {}, t[e.id][i.id] = n) : void 0 === (n = r[i.id]) && (n = new Qn, r[i.id] = n), n
                            },
                            dispose: function() {
                                t = {}
                            }
                        }
                    }, z = new function() {
                        var t = {};
                        return {
                            get: function(e, i) {
                                var n;
                                return void 0 === t[e.id] ? (n = new er, t[e.id] = {}, t[e.id][i.id] = n) : void 0 === t[e.id][i.id] ? (n = new er, t[e.id][i.id] = n) : n = t[e.id][i.id], n
                            },
                            dispose: function() {
                                t = {}
                            }
                        }
                    }, U = new function(t, e, i, n) {
                        var r, o, a = new ci(0),
                            s = 0,
                            c = null,
                            l = 0;

                        function h(t, i) {
                            e.buffers.color.setClear(t.r, t.g, t.b, i, n)
                        }
                        return {
                            getClearColor: function() {
                                return a
                            },
                            setClearColor: function(t, e) {
                                a.set(t), h(a, s = void 0 !== e ? e : 1)
                            },
                            getClearAlpha: function() {
                                return s
                            },
                            setClearAlpha: function(t) {
                                h(a, s = t)
                            },
                            render: function(e, n, u, d) {
                                var p = n.background;
                                if (null === p ? (h(a, s), c = null, l = 0) : p && p.isColor && (h(p, 1), d = !0, c = null, l = 0), (t.autoClear || d) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), p && (p.isCubeTexture || p.isWebGLRenderTargetCube)) {
                                    void 0 === o && ((o = new ji(new ki(1, 1, 1), new Ui({
                                        type: "BackgroundCubeMaterial",
                                        uniforms: ri(hi.cube.uniforms),
                                        vertexShader: hi.cube.vertexShader,
                                        fragmentShader: hi.cube.fragmentShader,
                                        side: v,
                                        depthTest: !0,
                                        depthWrite: !1,
                                        fog: !1
                                    }))).geometry.removeAttribute("normal"), o.geometry.removeAttribute("uv"), o.onBeforeRender = function(t, e, i) {
                                        this.matrixWorld.copyPosition(i.matrixWorld)
                                    }, Object.defineProperty(o.material, "map", {
                                        get: function() {
                                            return this.uniforms.tCube.value
                                        }
                                    }), i.update(o));
                                    var f = p.isWebGLRenderTargetCube ? p.texture : p;
                                    o.material.uniforms.tCube.value = f, o.material.uniforms.tFlip.value = p.isWebGLRenderTargetCube ? 1 : -1, c === p && l === f.version || (o.material.needsUpdate = !0, c = p, l = f.version), e.unshift(o, o.geometry, o.material, 0, null)
                                } else p && p.isTexture && (void 0 === r && ((r = new ji(new Bi(2, 2), new Ui({
                                    type: "BackgroundMaterial",
                                    uniforms: ri(hi.background.uniforms),
                                    vertexShader: hi.background.vertexShader,
                                    fragmentShader: hi.background.fragmentShader,
                                    side: g,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                }))).geometry.removeAttribute("normal"), Object.defineProperty(r.material, "map", {
                                    get: function() {
                                        return this.uniforms.t2D.value
                                    }
                                }), i.update(r)), r.material.uniforms.t2D.value = p, !0 === p.matrixAutoUpdate && p.updateMatrix(), r.material.uniforms.uvTransform.value.copy(p.matrix), c === p && l === p.version || (r.material.needsUpdate = !0, c = p, l = p.version), e.unshift(r, r.geometry, r.material, 0, null))
                            }
                        }
                    }(W, M, N, d), H = new function(t, e, i, n) {
                        var r;
                        this.setMode = function(t) {
                            r = t
                        }, this.render = function(e, n) {
                            t.drawArrays(r, e, n), i.update(n, r)
                        }, this.renderInstances = function(o, a, s) {
                            var c;
                            if (n.isWebGL2) c = t;
                            else if (null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            c[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, a, s, o.maxInstancedCount), i.update(s, r, o.maxInstancedCount)
                        }
                    }(x, b, R, w), V = new function(t, e, i, n) {
                        var r, o, a;
                        this.setMode = function(t) {
                            r = t
                        }, this.setIndex = function(t) {
                            o = t.type, a = t.bytesPerElement
                        }, this.render = function(e, n) {
                            t.drawElements(r, n, o, e * a), i.update(n, r)
                        }, this.renderInstances = function(s, c, l) {
                            var h;
                            if (n.isWebGL2) h = t;
                            else if (null === (h = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                            h[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, l, o, c * a, s.maxInstancedCount), i.update(l, r, s.maxInstancedCount)
                        }
                    }(x, b, R, w), R.programs = B.programs, W.context = x, W.capabilities = w, W.extensions = b, W.properties = O, W.renderLists = F, W.state = M, W.info = R
                }
                Pt();
                var Lt = null;
                "undefined" != typeof navigator && (Lt = "xr" in navigator ? new function(e) {
                    var i = e.context,
                        n = null,
                        r = null,
                        o = 1,
                        a = null,
                        s = "stage",
                        c = null,
                        l = [],
                        h = [];

                    function u() {
                        return null !== r && null !== a
                    }
                    var d = new lr;
                    d.layers.enable(1), d.viewport = new Ze;
                    var p = new lr;
                    p.layers.enable(2), p.viewport = new Ze;
                    var f = new hr([d, p]);

                    function m(t) {
                        var e = l[h.indexOf(t.inputSource)];
                        e && e.dispatchEvent({
                            type: t.type
                        })
                    }

                    function g() {
                        e.setFramebuffer(null), _.stop()
                    }

                    function v(t, e) {
                        null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
                    }
                    f.layers.enable(1), f.layers.enable(2), this.enabled = !1, this.getController = function(t) {
                        var e = l[t];
                        return void 0 === e && ((e = new sr).matrixAutoUpdate = !1, e.visible = !1, l[t] = e), e
                    }, this.getDevice = function() {
                        return n
                    }, this.setDevice = function(t) {
                        void 0 !== t && (n = t), t instanceof XRDevice && i.setCompatibleXRDevice(t)
                    }, this.setFramebufferScaleFactor = function(t) {
                        o = t
                    }, this.setFrameOfReferenceType = function(t) {
                        s = t
                    }, this.setSession = function(t) {
                        null !== (r = t) && (r.addEventListener("select", m), r.addEventListener("selectstart", m), r.addEventListener("selectend", m), r.addEventListener("end", g), r.baseLayer = new XRWebGLLayer(r, i, {
                            framebufferScaleFactor: o
                        }), r.requestFrameOfReference(s).then(function(t) {
                            a = t, e.setFramebuffer(r.baseLayer.framebuffer), _.setContext(r), _.start()
                        }), h = r.getInputSources(), r.addEventListener("inputsourceschange", function() {
                            h = r.getInputSources(), console.log(h);
                            for (var t = 0; t < l.length; t++) l[t].userData.inputSource = h[t]
                        }))
                    }, this.getCamera = function(t) {
                        if (u()) {
                            var e = t.parent,
                                i = f.cameras;
                            v(f, e);
                            for (var n = 0; n < i.length; n++) v(i[n], e);
                            t.matrixWorld.copy(f.matrixWorld);
                            for (var r = t.children, o = (n = 0, r.length); n < o; n++) r[n].updateMatrixWorld(!0);
                            return fr(f, d, p), f
                        }
                        return t
                    }, this.isPresenting = u;
                    var y = null,
                        _ = new ui;
                    _.setAnimationLoop(function(t, e) {
                        if (null !== (c = e.getDevicePose(a)))
                            for (var i = r.baseLayer, n = e.views, o = 0; o < n.length; o++) {
                                var s = n[o],
                                    u = i.getViewport(s),
                                    d = c.getViewMatrix(s),
                                    p = f.cameras[o];
                                p.matrix.fromArray(d).getInverse(p.matrix), p.projectionMatrix.fromArray(s.projectionMatrix), p.viewport.set(u.x, u.y, u.width, u.height), 0 === o && f.matrix.copy(p.matrix)
                            }
                        for (o = 0; o < l.length; o++) {
                            var m = l[o],
                                g = h[o];
                            if (g) {
                                var v = e.getInputPose(g, a);
                                if (null !== v) {
                                    "targetRay" in v ? m.matrix.elements = v.targetRay.transformMatrix : "pointerMatrix" in v && (m.matrix.elements = v.pointerMatrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.visible = !0;
                                    continue
                                }
                            }
                            m.visible = !1
                        }
                        y && y(t)
                    }), this.setAnimationLoop = function(t) {
                        y = t
                    }, this.dispose = function() {}, this.getStandingMatrix = function() {
                        return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new t.Matrix4
                    }, this.submitFrame = function() {}
                }(W) : new mr(W)), this.vr = Lt;
                var Ct = new rr(W, N, w.maxTextureSize);

                function Rt(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), tt = !0
                }

                function Dt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), tt = !1, Pt()
                }

                function kt(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", kt),
                        function(t) {
                            Nt(t), O.remove(t)
                        }(e)
                }

                function Nt(t) {
                    var e = O.get(t).program;
                    t.program = void 0, void 0 !== e && B.releaseProgram(e)
                }
                this.shadowMap = Ct, this.getContext = function() {
                    return x
                }, this.getContextAttributes = function() {
                    return x.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var t = b.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    var t = b.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return mt
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (mt = t, this.setSize(pt, ft, !1))
                }, this.getSize = function() {
                    return {
                        width: pt,
                        height: ft
                    }
                }, this.setSize = function(t, e, n) {
                    Lt.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (pt = t, ft = e, i.width = t * mt, i.height = e * mt, !1 !== n && (i.style.width = t + "px", i.style.height = e + "px"), this.setViewport(0, 0, t, e))
                }, this.getDrawingBufferSize = function() {
                    return {
                        width: pt * mt,
                        height: ft * mt
                    }
                }, this.setDrawingBufferSize = function(t, e, n) {
                    pt = t, ft = e, mt = n, i.width = t * n, i.height = e * n, this.setViewport(0, 0, t, e)
                }, this.getCurrentViewport = function() {
                    return lt
                }, this.setViewport = function(t, e, i, n) {
                    gt.set(t, ft - e - n, i, n), M.viewport(lt.copy(gt).multiplyScalar(mt))
                }, this.setScissor = function(t, e, i, n) {
                    vt.set(t, ft - e - n, i, n), M.scissor(ht.copy(vt).multiplyScalar(mt))
                }, this.setScissorTest = function(t) {
                    M.setScissorTest(yt = t)
                }, this.getClearColor = function() {
                    return U.getClearColor()
                }, this.setClearColor = function() {
                    U.setClearColor.apply(U, arguments)
                }, this.getClearAlpha = function() {
                    return U.getClearAlpha()
                }, this.setClearAlpha = function() {
                    U.setClearAlpha.apply(U, arguments)
                }, this.clear = function(t, e, i) {
                    var n = 0;
                    (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), x.clear(n)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    i.removeEventListener("webglcontextlost", Rt, !1), i.removeEventListener("webglcontextrestored", Dt, !1), F.dispose(), z.dispose(), O.dispose(), N.dispose(), Lt.dispose(), Ft.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    M.initAttributes();
                    var i = O.get(t);
                    t.hasPositions && !i.position && (i.position = x.createBuffer()), t.hasNormals && !i.normal && (i.normal = x.createBuffer()), t.hasUvs && !i.uv && (i.uv = x.createBuffer()), t.hasColors && !i.color && (i.color = x.createBuffer());
                    var n = e.getAttributes();
                    t.hasPositions && (x.bindBuffer(34962, i.position), x.bufferData(34962, t.positionArray, 35048), M.enableAttribute(n.position), x.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (x.bindBuffer(34962, i.normal), x.bufferData(34962, t.normalArray, 35048), M.enableAttribute(n.normal), x.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (x.bindBuffer(34962, i.uv), x.bufferData(34962, t.uvArray, 35048), M.enableAttribute(n.uv), x.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (x.bindBuffer(34962, i.color), x.bufferData(34962, t.colorArray, 35048), M.enableAttribute(n.color), x.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), M.disableUnusedAttributes(), x.drawArrays(4, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, i, n, r, o) {
                    var a = r.isMesh && r.normalMatrix.determinant() < 0;
                    M.setMaterial(n, a);
                    var s = Vt(t, e, n, r),
                        c = !1;
                    at.geometry === i.id && at.program === s.id && at.wireframe === (!0 === n.wireframe) || (at.geometry = i.id, at.program = s.id, at.wireframe = !0 === n.wireframe, c = !0), r.morphTargetInfluences && (G.update(r, i, n, s), c = !0);
                    var l, h = i.index,
                        u = i.attributes.position,
                        d = 1;
                    !0 === n.wireframe && (h = k.getWireframeAttribute(i), d = 2);
                    var p = H;
                    null !== h && (l = D.get(h), (p = V).setIndex(l)), c && (! function(t, e, i) {
                        if (i && i.isInstancedBufferGeometry & !w.isWebGL2 && null === b.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        M.initAttributes();
                        var n = i.attributes,
                            r = e.getAttributes(),
                            o = t.defaultAttributeValues;
                        for (var a in r) {
                            var s = r[a];
                            if (s >= 0) {
                                var c = n[a];
                                if (void 0 !== c) {
                                    var l = c.normalized,
                                        h = c.itemSize,
                                        u = D.get(c);
                                    if (void 0 === u) continue;
                                    var d = u.buffer,
                                        p = u.type,
                                        f = u.bytesPerElement;
                                    if (c.isInterleavedBufferAttribute) {
                                        var m = c.data,
                                            g = m.stride,
                                            v = c.offset;
                                        m && m.isInstancedInterleavedBuffer ? (M.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = m.meshPerAttribute * m.count)) : M.enableAttribute(s), x.bindBuffer(34962, d), x.vertexAttribPointer(s, h, p, l, g * f, v * f)
                                    } else c.isInstancedBufferAttribute ? (M.enableAttributeAndDivisor(s, c.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = c.meshPerAttribute * c.count)) : M.enableAttribute(s), x.bindBuffer(34962, d), x.vertexAttribPointer(s, h, p, l, 0, 0)
                                } else if (void 0 !== o) {
                                    var y = o[a];
                                    if (void 0 !== y) switch (y.length) {
                                        case 2:
                                            x.vertexAttrib2fv(s, y);
                                            break;
                                        case 3:
                                            x.vertexAttrib3fv(s, y);
                                            break;
                                        case 4:
                                            x.vertexAttrib4fv(s, y);
                                            break;
                                        default:
                                            x.vertexAttrib1fv(s, y)
                                    }
                                }
                            }
                        }
                        M.disableUnusedAttributes()
                    }(n, s, i), null !== h && x.bindBuffer(34963, l.buffer));
                    var f = 1 / 0;
                    null !== h ? f = h.count : void 0 !== u && (f = u.count);
                    var m = i.drawRange.start * d,
                        g = i.drawRange.count * d,
                        v = null !== o ? o.start * d : 0,
                        y = null !== o ? o.count * d : 1 / 0,
                        _ = Math.max(m, v),
                        T = Math.min(f, m + g, v + y) - 1,
                        E = Math.max(0, T - _ + 1);
                    if (0 !== E) {
                        if (r.isMesh)
                            if (!0 === n.wireframe) M.setLineWidth(n.wireframeLinewidth * Et()), p.setMode(1);
                            else switch (r.drawMode) {
                                case Ee:
                                    p.setMode(4);
                                    break;
                                case Se:
                                    p.setMode(5);
                                    break;
                                case Ae:
                                    p.setMode(6)
                            } else if (r.isLine) {
                                var S = n.linewidth;
                                void 0 === S && (S = 1), M.setLineWidth(S * Et()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
                            } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                        i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && p.renderInstances(i, _, E) : p.render(_, E)
                    }
                }, this.compile = function(t, e) {
                    (_ = z.get(t, e)).init(), t.traverse(function(t) {
                        t.isLight && (_.pushLight(t), t.castShadow && _.pushShadow(t))
                    }), _.setupLights(e), t.traverse(function(e) {
                        if (e.material)
                            if (Array.isArray(e.material))
                                for (var i = 0; i < e.material.length; i++) Ht(e.material[i], t.fog, e);
                            else Ht(e.material, t.fog, e)
                    })
                };
                var Bt = null;
                var Ft = new ui;

                function zt(t, e, i, n) {
                    for (var r = 0, o = t.length; r < o; r++) {
                        var a = t[r],
                            s = a.object,
                            c = a.geometry,
                            l = void 0 === n ? a.material : n,
                            h = a.group;
                        if (i.isArrayCamera) {
                            ct = i;
                            for (var u = i.cameras, d = 0, p = u.length; d < p; d++) {
                                var f = u[d];
                                if (s.layers.test(f.layers)) {
                                    if ("viewport" in f) M.viewport(lt.copy(f.viewport));
                                    else {
                                        var m = f.bounds,
                                            g = m.x * pt,
                                            v = m.y * ft,
                                            y = m.z * pt,
                                            x = m.w * ft;
                                        M.viewport(lt.set(g, v, y, x).multiplyScalar(mt))
                                    }
                                    _.setupLights(f), Gt(s, e, f, c, l, h)
                                }
                            }
                        } else ct = null, Gt(s, e, i, c, l, h)
                    }
                }

                function Gt(t, e, i, n, r, o) {
                    if (t.onBeforeRender(W, e, i, n, r, o), _ = z.get(e, ct || i), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        M.setMaterial(r);
                        var a = Vt(i, e.fog, r, t);
                        at.geometry = null, at.program = null, at.wireframe = !1,
                            function(t, e) {
                                t.render(function(t) {
                                    W.renderBufferImmediate(t, e)
                                })
                            }(t, a)
                    } else W.renderBufferDirect(i, e.fog, n, r, t, o);
                    t.onAfterRender(W, e, i, n, r, o), _ = z.get(e, ct || i)
                }

                function Ht(t, e, i) {
                    var n = O.get(t),
                        r = _.state.lights,
                        o = _.state.shadowsArray,
                        a = n.lightsHash,
                        s = r.state.hash,
                        c = B.getParameters(t, r.state, o, e, xt.numPlanes, xt.numIntersection, i),
                        l = B.getProgramCode(t, c),
                        h = n.program,
                        u = !0;
                    if (void 0 === h) t.addEventListener("dispose", kt);
                    else if (h.code !== l) Nt(t);
                    else if (a.stateID !== s.stateID || a.directionalLength !== s.directionalLength || a.pointLength !== s.pointLength || a.spotLength !== s.spotLength || a.rectAreaLength !== s.rectAreaLength || a.hemiLength !== s.hemiLength || a.shadowsLength !== s.shadowsLength) a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, u = !1;
                    else {
                        if (void 0 !== c.shaderID) return;
                        u = !1
                    }
                    if (u) {
                        if (c.shaderID) {
                            var d = hi[c.shaderID];
                            n.shader = {
                                name: t.type,
                                uniforms: ri(d.uniforms),
                                vertexShader: d.vertexShader,
                                fragmentShader: d.fragmentShader
                            }
                        } else n.shader = {
                            name: t.type,
                            uniforms: t.uniforms,
                            vertexShader: t.vertexShader,
                            fragmentShader: t.fragmentShader
                        };
                        t.onBeforeCompile(n.shader, W), l = B.getProgramCode(t, c), h = B.acquireProgram(t, n.shader, c, l), n.program = h, t.program = h
                    }
                    var p = h.getAttributes();
                    if (t.morphTargets) {
                        t.numSupportedMorphTargets = 0;
                        for (var f = 0; f < W.maxMorphTargets; f++) p["morphTarget" + f] >= 0 && t.numSupportedMorphTargets++
                    }
                    if (t.morphNormals) {
                        t.numSupportedMorphNormals = 0;
                        for (f = 0; f < W.maxMorphNormals; f++) p["morphNormal" + f] >= 0 && t.numSupportedMorphNormals++
                    }
                    var m = n.shader.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = xt.numPlanes, n.numIntersection = xt.numIntersection, m.clippingPlanes = xt.uniform), n.fog = e, void 0 === a && (n.lightsHash = a = {}), a.stateID = s.stateID, a.directionalLength = s.directionalLength, a.pointLength = s.pointLength, a.spotLength = s.spotLength, a.rectAreaLength = s.rectAreaLength, a.hemiLength = s.hemiLength, a.shadowsLength = s.shadowsLength, t.lights && (m.ambientLightColor.value = r.state.ambient, m.directionalLights.value = r.state.directional, m.spotLights.value = r.state.spot, m.rectAreaLights.value = r.state.rectArea, m.pointLights.value = r.state.point, m.hemisphereLights.value = r.state.hemi, m.directionalShadowMap.value = r.state.directionalShadowMap, m.directionalShadowMatrix.value = r.state.directionalShadowMatrix, m.spotShadowMap.value = r.state.spotShadowMap, m.spotShadowMatrix.value = r.state.spotShadowMatrix, m.pointShadowMap.value = r.state.pointShadowMap, m.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    var g = n.program.getUniforms(),
                        v = Fn.seqWithValue(g.seq, m);
                    n.uniformsList = v
                }

                function Vt(t, e, i, n) {
                    dt = 0;
                    var r = O.get(i),
                        o = _.state.lights,
                        a = r.lightsHash,
                        s = o.state.hash;
                    if (bt && (wt || t !== st)) {
                        var c = t === st && i.id === ot;
                        xt.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, c)
                    }!1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : (!i.lights || a.stateID === s.stateID && a.directionalLength === s.directionalLength && a.pointLength === s.pointLength && a.spotLength === s.spotLength && a.rectAreaLength === s.rectAreaLength && a.hemiLength === s.hemiLength && a.shadowsLength === s.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === xt.numPlanes && r.numIntersection === xt.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (Ht(i, e, n), i.needsUpdate = !1);
                    var l = !1,
                        h = !1,
                        u = !1,
                        d = r.program,
                        p = d.getUniforms(),
                        f = r.shader.uniforms;
                    if (M.useProgram(d.program) && (l = !0, h = !0, u = !0), i.id !== ot && (ot = i.id, h = !0), l || st !== t) {
                        if (p.setValue(x, "projectionMatrix", t.projectionMatrix), w.logarithmicDepthBuffer && p.setValue(x, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), st !== t && (st = t, h = !0, u = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                            var m = p.map.cameraPosition;
                            void 0 !== m && m.setValue(x, Tt.setFromMatrixPosition(t.matrixWorld))
                        }(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && p.setValue(x, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (i.skinning) {
                        p.setOptional(x, n, "bindMatrix"), p.setOptional(x, n, "bindMatrixInverse");
                        var g = n.skeleton;
                        if (g) {
                            var y = g.bones;
                            if (w.floatVertexTextures) {
                                if (void 0 === g.boneTexture) {
                                    var b = Math.sqrt(4 * y.length);
                                    b = Ue.ceilPowerOfTwo(b), b = Math.max(b, 4);
                                    var T = new Float32Array(b * b * 4);
                                    T.set(g.boneMatrices);
                                    var E = new Qe(T, b, b, Ut, Ot);
                                    E.needsUpdate = !0, g.boneMatrices = T, g.boneTexture = E, g.boneTextureSize = b
                                }
                                p.setValue(x, "boneTexture", g.boneTexture), p.setValue(x, "boneTextureSize", g.boneTextureSize)
                            } else p.setOptional(x, g, "boneMatrices")
                        }
                    }
                    return h && (p.setValue(x, "toneMappingExposure", W.toneMappingExposure), p.setValue(x, "toneMappingWhitePoint", W.toneMappingWhitePoint), i.lights && function(t, e) {
                        t.ambientLightColor.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
                    }(f, u), e && i.fog && function(t, e) {
                        t.fogColor.value = e.color, e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    }(f, e), i.isMeshBasicMaterial ? jt(f, i) : i.isMeshLambertMaterial ? (jt(f, i), function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(f, i)) : i.isMeshPhongMaterial ? (jt(f, i), i.isMeshToonMaterial ? function(t, e) {
                        Wt(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(f, i) : Wt(f, i)) : i.isMeshStandardMaterial ? (jt(f, i), i.isMeshPhysicalMaterial ? function(t, e) {
                        Xt(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness
                    }(f, i) : Xt(f, i)) : i.isMeshMatcapMaterial ? (jt(f, i), function(t, e) {
                        e.matcap && (t.matcap.value = e.matcap);
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === v && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === v && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(f, i)) : i.isMeshDepthMaterial ? (jt(f, i), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(f, i)) : i.isMeshDistanceMaterial ? (jt(f, i), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                        t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(f, i)) : i.isMeshNormalMaterial ? (jt(f, i), function(t, e) {
                        e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === v && (t.bumpScale.value *= -1));
                        e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === v && t.normalScale.value.negate());
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(f, i)) : i.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity
                    }(f, i), i.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(f, i)) : i.isPointsMaterial ? function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * mt, t.scale.value = .5 * ft, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(f, i) : i.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value = e.color, t.opacity.value = e.opacity, t.rotation.value = e.rotation, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(f, i) : i.isShadowMaterial && (f.color.value = i.color, f.opacity.value = i.opacity), void 0 !== f.ltc_1 && (f.ltc_1.value = li.LTC_1), void 0 !== f.ltc_2 && (f.ltc_2.value = li.LTC_2), Fn.upload(x, r.uniformsList, f, W)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Fn.upload(x, r.uniformsList, f, W), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && p.setValue(x, "center", n.center), p.setValue(x, "modelViewMatrix", n.modelViewMatrix), p.setValue(x, "normalMatrix", n.normalMatrix), p.setValue(x, "modelMatrix", n.matrixWorld), d
                }

                function jt(t, e) {
                    var i;
                    t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = O.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? i = e.map : e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
                }

                function Wt(t, e) {
                    t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === v && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === v && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function Xt(t, e) {
                    t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === v && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === v && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                }
                Ft.setAnimationLoop(function(t) {
                    Lt.isPresenting() || Bt && Bt(t)
                }), "undefined" != typeof window && Ft.setContext(window), this.setAnimationLoop = function(t) {
                    Bt = t, Lt.setAnimationLoop(t), Ft.start()
                }, this.render = function(t, e, i, n) {
                    if (e && e.isCamera) {
                        if (!tt) {
                            at.geometry = null, at.program = null, at.wireframe = !1, ot = -1, st = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), Lt.enabled && (e = Lt.getCamera(e)), (_ = z.get(t, e)).init(), t.onBeforeRender(W, t, e, i), Mt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), _t.setFromMatrix(Mt), wt = this.localClippingEnabled, bt = xt.init(this.clippingPlanes, wt, e), (m = F.get(t, e)).init(),
                                function t(e, i, n) {
                                    if (!1 === e.visible) return;
                                    var r = e.layers.test(i.layers);
                                    if (r)
                                        if (e.isLight) _.pushLight(e), e.castShadow && _.pushShadow(e);
                                        else if (e.isSprite) {
                                        if (!e.frustumCulled || _t.intersectsSprite(e)) {
                                            n && Tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Mt);
                                            var o = N.update(e),
                                                a = e.material;
                                            m.push(e, o, a, Tt.z, null)
                                        }
                                    } else if (e.isImmediateRenderObject) n && Tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Mt), m.push(e, null, e.material, Tt.z, null);
                                    else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || _t.intersectsObject(e))) {
                                        n && Tt.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Mt);
                                        var o = N.update(e),
                                            a = e.material;
                                        if (Array.isArray(a))
                                            for (var s = o.groups, c = 0, l = s.length; c < l; c++) {
                                                var h = s[c],
                                                    u = a[h.materialIndex];
                                                u && u.visible && m.push(e, o, u, Tt.z, h)
                                            } else a.visible && m.push(e, o, a, Tt.z, null)
                                    }
                                    var d = e.children;
                                    for (var c = 0, l = d.length; c < l; c++) t(d[c], i, n)
                                }(t, e, W.sortObjects), !0 === W.sortObjects && m.sort(), bt && xt.beginShadows();
                            var r = _.state.shadowsArray;
                            Ct.render(r, t, e), _.setupLights(e), bt && xt.endShadows(), this.info.autoReset && this.info.reset(), void 0 === i && (i = null), this.setRenderTarget(i), U.render(m, t, e, n);
                            var o = m.opaque,
                                a = m.transparent;
                            if (t.overrideMaterial) {
                                var s = t.overrideMaterial;
                                o.length && zt(o, t, e, s), a.length && zt(a, t, e, s)
                            } else o.length && zt(o, t, e), a.length && zt(a, t, e);
                            i && I.updateRenderTargetMipmap(i), M.buffers.depth.setTest(!0), M.buffers.depth.setMask(!0), M.buffers.color.setMask(!0), M.setPolygonOffset(!1), t.onAfterRender(W, t, e), Lt.enabled && Lt.submitFrame(), m = null, _ = null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.allocTextureUnit = function() {
                    var t = dt;
                    return t >= w.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + w.maxTextures), dt += 1, t
                }, this.setTexture2D = function() {
                    var t = !1;
                    return function(e, i) {
                        e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), I.setTexture2D(e, i)
                    }
                }(), this.setTexture3D = function(t, e) {
                    I.setTexture3D(t, e)
                }, this.setTexture = function() {
                    var t = !1;
                    return function(e, i) {
                        t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), I.setTexture2D(e, i)
                    }
                }(), this.setTextureCube = function() {
                    var t = !1;
                    return function(e, i) {
                        e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? I.setTextureCube(e, i) : I.setTextureCubeDynamic(e, i)
                    }
                }(), this.setFramebuffer = function(t) {
                    et = t
                }, this.getRenderTarget = function() {
                    return it
                }, this.setRenderTarget = function(t) {
                    it = t, t && void 0 === O.get(t).__webglFramebuffer && I.setupRenderTarget(t);
                    var e = et,
                        i = !1;
                    if (t) {
                        var n = O.get(t).__webglFramebuffer;
                        t.isWebGLRenderTargetCube ? (e = n[t.activeCubeFace], i = !0) : e = n, lt.copy(t.viewport), ht.copy(t.scissor), ut = t.scissorTest
                    } else lt.copy(gt).multiplyScalar(mt), ht.copy(vt).multiplyScalar(mt), ut = yt;
                    if (nt !== e && (x.bindFramebuffer(36160, e), nt = e), M.viewport(lt), M.scissor(ht), M.setScissorTest(ut), i) {
                        var r = O.get(t.texture);
                        x.framebufferTexture2D(36160, 36064, 34069 + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
                    }
                }, this.readRenderTargetPixels = function(t, e, i, n, r, o) {
                    if (t && t.isWebGLRenderTarget) {
                        var a = O.get(t).__webglFramebuffer;
                        if (a) {
                            var s = !1;
                            a !== nt && (x.bindFramebuffer(36160, a), s = !0);
                            try {
                                var c = t.texture,
                                    l = c.format,
                                    h = c.type;
                                if (l !== Ut && j.convert(l) !== x.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(h === St || j.convert(h) === x.getParameter(35738) || h === Ot && (w.isWebGL2 || b.get("OES_texture_float") || b.get("WEBGL_color_buffer_float")) || h === It && (w.isWebGL2 ? b.get("EXT_color_buffer_float") : b.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === x.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - r && x.readPixels(e, i, n, r, j.convert(l), j.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                s && x.bindFramebuffer(36160, nt)
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }, this.copyFramebufferToTexture = function(t, e, i) {
                    var n = e.image.width,
                        r = e.image.height,
                        o = j.convert(e.format);
                    this.setTexture2D(e, 0), x.copyTexImage2D(3553, i || 0, o, t.x, t.y, n, r, 0)
                }, this.copyTextureToTexture = function(t, e, i, n) {
                    var r = e.image.width,
                        o = e.image.height,
                        a = j.convert(i.format),
                        s = j.convert(i.type);
                    this.setTexture2D(i, 0), e.isDataTexture ? x.texSubImage2D(3553, n || 0, t.x, t.y, r, o, a, s, e.image.data) : x.texSubImage2D(3553, n || 0, t.x, t.y, a, s, e.image)
                }
            }

            function vr(t, e) {
                this.name = "", this.color = new ci(t), this.density = void 0 !== e ? e : 25e-5
            }

            function yr(t, e, i) {
                this.name = "", this.color = new ci(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
            }

            function _r() {
                vi.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }

            function xr(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function br(t, e, i, n) {
                this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
            }

            function wr(t) {
                zi.call(this), this.type = "SpriteMaterial", this.color = new ci(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t)
            }

            function Mr(t) {
                if (vi.call(this), this.type = "Sprite", void 0 === ur) {
                    ur = new Ii;
                    var e = new xr(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    ur.setIndex([0, 1, 2, 0, 2, 3]), ur.addAttribute("position", new br(e, 3, 0, !1)), ur.addAttribute("uv", new br(e, 2, 3, !1))
                }
                this.geometry = ur, this.material = void 0 !== t ? t : new wr, this.center = new Ge(.5, .5)
            }

            function Tr() {
                vi.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }

            function Er(t, e) {
                t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), ji.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new He, this.bindMatrixInverse = new He
            }

            function Sr(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new He)
                }
            }

            function Ar() {
                vi.call(this), this.type = "Bone"
            }

            function Pr(t) {
                zi.call(this), this.type = "LineBasicMaterial", this.color = new ci(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
            }

            function Lr(t, e, i) {
                1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), vi.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Ii, this.material = void 0 !== e ? e : new Pr({
                    color: 16777215 * Math.random()
                })
            }

            function Cr(t, e) {
                Lr.call(this, t, e), this.type = "LineSegments"
            }

            function Rr(t, e) {
                Lr.call(this, t, e), this.type = "LineLoop"
            }

            function Or(t) {
                zi.call(this), this.type = "PointsMaterial", this.color = new ci(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function Ir(t, e) {
                vi.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Ii, this.material = void 0 !== e ? e : new Or({
                    color: 16777215 * Math.random()
                })
            }

            function Dr(t, e, i, n, r, o, a, s, c) {
                Ye.call(this, t, e, i, n, r, o, a, s, c), this.format = void 0 !== a ? a : zt, this.minFilter = void 0 !== o ? o : Mt, this.magFilter = void 0 !== r ? r : Mt, this.generateMipmaps = !1
            }

            function kr(t, e, i, n, r, o, a, s, c, l, h, u) {
                Ye.call(this, null, o, a, s, c, l, n, r, h, u), this.image = {
                    width: e,
                    height: i
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }

            function Nr(t, e, i, n, r, o, a, s, c) {
                Ye.call(this, t, e, i, n, r, o, a, s, c), this.needsUpdate = !0
            }

            function Br(t, e, i, n, r, o, a, s, c, l) {
                if ((l = void 0 !== l ? l : jt) !== jt && l !== Wt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === i && l === jt && (i = Lt), void 0 === i && l === Wt && (i = Bt), Ye.call(this, null, n, r, o, a, s, l, i, c), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== a ? a : xt, this.minFilter = void 0 !== s ? s : xt, this.flipY = !1, this.generateMipmaps = !1
            }

            function Fr(t) {
                Ii.call(this), this.type = "WireframeGeometry";
                var e, i, n, r, o, a, s, c, l, h, u = [],
                    d = [0, 0],
                    p = {},
                    f = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    var m = t.faces;
                    for (e = 0, n = m.length; e < n; e++) {
                        var g = m[e];
                        for (i = 0; i < 3; i++) s = g[f[i]], c = g[f[(i + 1) % 3]], d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[l = d[0] + "," + d[1]] && (p[l] = {
                            index1: d[0],
                            index2: d[1]
                        })
                    }
                    for (l in p) a = p[l], h = t.vertices[a.index1], u.push(h.x, h.y, h.z), h = t.vertices[a.index2], u.push(h.x, h.y, h.z)
                } else if (t && t.isBufferGeometry) {
                    var v, y, _, x, b, w, M;
                    if (h = new je, null !== t.index) {
                        for (v = t.attributes.position, y = t.index, 0 === (_ = t.groups).length && (_ = [{
                                start: 0,
                                count: y.count,
                                materialIndex: 0
                            }]), r = 0, o = _.length; r < o; ++r)
                            for (e = b = (x = _[r]).start, n = b + x.count; e < n; e += 3)
                                for (i = 0; i < 3; i++) s = y.getX(e + i), c = y.getX(e + (i + 1) % 3), d[0] = Math.min(s, c), d[1] = Math.max(s, c), void 0 === p[l = d[0] + "," + d[1]] && (p[l] = {
                                    index1: d[0],
                                    index2: d[1]
                                });
                        for (l in p) a = p[l], h.fromBufferAttribute(v, a.index1), u.push(h.x, h.y, h.z), h.fromBufferAttribute(v, a.index2), u.push(h.x, h.y, h.z)
                    } else
                        for (e = 0, n = (v = t.attributes.position).count / 3; e < n; e++)
                            for (i = 0; i < 3; i++) w = 3 * e + i, h.fromBufferAttribute(v, w), u.push(h.x, h.y, h.z), M = 3 * e + (i + 1) % 3, h.fromBufferAttribute(v, M), u.push(h.x, h.y, h.z)
                }
                this.addAttribute("position", new Pi(u, 3))
            }

            function zr(t, e, i) {
                _i.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: i
                }, this.fromBufferGeometry(new Ur(t, e, i)), this.mergeVertices()
            }

            function Ur(t, e, i) {
                Ii.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: i
                };
                var n, r, o = [],
                    a = [],
                    s = [],
                    c = [],
                    l = new je,
                    h = new je,
                    u = new je,
                    d = new je,
                    p = new je;
                t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var f = e + 1;
                for (n = 0; n <= i; n++) {
                    var m = n / i;
                    for (r = 0; r <= e; r++) {
                        var g = r / e;
                        t(g, m, h), a.push(h.x, h.y, h.z), g - 1e-5 >= 0 ? (t(g - 1e-5, m, u), d.subVectors(h, u)) : (t(g + 1e-5, m, u), d.subVectors(u, h)), m - 1e-5 >= 0 ? (t(g, m - 1e-5, u), p.subVectors(h, u)) : (t(g, m + 1e-5, u), p.subVectors(u, h)), l.crossVectors(d, p).normalize(), s.push(l.x, l.y, l.z), c.push(g, m)
                    }
                }
                for (n = 0; n < i; n++)
                    for (r = 0; r < e; r++) {
                        var v = n * f + r,
                            y = n * f + r + 1,
                            _ = (n + 1) * f + r + 1,
                            x = (n + 1) * f + r;
                        o.push(v, y, x), o.push(y, _, x)
                    }
                this.setIndex(o), this.addAttribute("position", new Pi(a, 3)), this.addAttribute("normal", new Pi(s, 3)), this.addAttribute("uv", new Pi(c, 2))
            }

            function Gr(t, e, i, n) {
                _i.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: i,
                    detail: n
                }, this.fromBufferGeometry(new Hr(t, e, i, n)), this.mergeVertices()
            }

            function Hr(t, e, i, n) {
                Ii.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: i,
                    detail: n
                }, i = i || 1;
                var r = [],
                    o = [];

                function a(t, e, i, n) {
                    var r, o, a = Math.pow(2, n),
                        c = [];
                    for (r = 0; r <= a; r++) {
                        c[r] = [];
                        var l = t.clone().lerp(i, r / a),
                            h = e.clone().lerp(i, r / a),
                            u = a - r;
                        for (o = 0; o <= u; o++) c[r][o] = 0 === o && r === a ? l : l.clone().lerp(h, o / u)
                    }
                    for (r = 0; r < a; r++)
                        for (o = 0; o < 2 * (a - r) - 1; o++) {
                            var d = Math.floor(o / 2);
                            o % 2 == 0 ? (s(c[r][d + 1]), s(c[r + 1][d]), s(c[r][d])) : (s(c[r][d + 1]), s(c[r + 1][d + 1]), s(c[r + 1][d]))
                        }
                }

                function s(t) {
                    r.push(t.x, t.y, t.z)
                }

                function c(e, i) {
                    var n = 3 * e;
                    i.x = t[n + 0], i.y = t[n + 1], i.z = t[n + 2]
                }

                function l(t, e, i, n) {
                    n < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === i.x && 0 === i.z && (o[e] = n / 2 / Math.PI + .5)
                }

                function h(t) {
                    return Math.atan2(t.z, -t.x)
                }

                function u(t) {
                    return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                }! function(t) {
                    for (var i = new je, n = new je, r = new je, o = 0; o < e.length; o += 3) c(e[o + 0], i), c(e[o + 1], n), c(e[o + 2], r), a(i, n, r, t)
                }(n = n || 0),
                function(t) {
                    for (var e = new je, i = 0; i < r.length; i += 3) e.x = r[i + 0], e.y = r[i + 1], e.z = r[i + 2], e.normalize().multiplyScalar(t), r[i + 0] = e.x, r[i + 1] = e.y, r[i + 2] = e.z
                }(i),
                function() {
                    for (var t = new je, e = 0; e < r.length; e += 3) {
                        t.x = r[e + 0], t.y = r[e + 1], t.z = r[e + 2];
                        var i = h(t) / 2 / Math.PI + .5,
                            n = u(t) / Math.PI + .5;
                        o.push(i, 1 - n)
                    }(function() {
                        for (var t = new je, e = new je, i = new je, n = new je, a = new Ge, s = new Ge, c = new Ge, u = 0, d = 0; u < r.length; u += 9, d += 6) {
                            t.set(r[u + 0], r[u + 1], r[u + 2]), e.set(r[u + 3], r[u + 4], r[u + 5]), i.set(r[u + 6], r[u + 7], r[u + 8]), a.set(o[d + 0], o[d + 1]), s.set(o[d + 2], o[d + 3]), c.set(o[d + 4], o[d + 5]), n.copy(t).add(e).add(i).divideScalar(3);
                            var p = h(n);
                            l(a, d + 0, t, p), l(s, d + 2, e, p), l(c, d + 4, i, p)
                        }
                    })(),
                    function() {
                        for (var t = 0; t < o.length; t += 6) {
                            var e = o[t + 0],
                                i = o[t + 2],
                                n = o[t + 4],
                                r = Math.max(e, i, n),
                                a = Math.min(e, i, n);
                            r > .9 && a < .1 && (e < .2 && (o[t + 0] += 1), i < .2 && (o[t + 2] += 1), n < .2 && (o[t + 4] += 1))
                        }
                    }()
                }(), this.addAttribute("position", new Pi(r, 3)), this.addAttribute("normal", new Pi(r.slice(), 3)), this.addAttribute("uv", new Pi(o, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function Vr(t, e) {
                _i.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new jr(t, e)), this.mergeVertices()
            }

            function jr(t, e) {
                Hr.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Wr(t, e) {
                _i.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Xr(t, e)), this.mergeVertices()
            }

            function Xr(t, e) {
                Hr.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function qr(t, e) {
                _i.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Yr(t, e)), this.mergeVertices()
            }

            function Yr(t, e) {
                var i = (1 + Math.sqrt(5)) / 2,
                    n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1];
                Hr.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Zr(t, e) {
                _i.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Jr(t, e)), this.mergeVertices()
            }

            function Jr(t, e) {
                var i = (1 + Math.sqrt(5)) / 2,
                    n = 1 / i,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n];
                Hr.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Kr(t, e, i, n, r, o) {
                _i.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: i,
                    radialSegments: n,
                    closed: r
                }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
                var a = new Qr(t, e, i, n, r);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
            }

            function Qr(t, e, i, n, r) {
                Ii.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: i,
                    radialSegments: n,
                    closed: r
                }, e = e || 64, i = i || 1, n = n || 8, r = r || !1;
                var o = t.computeFrenetFrames(e, r);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
                var a, s, c = new je,
                    l = new je,
                    h = new Ge,
                    u = new je,
                    d = [],
                    p = [],
                    f = [],
                    m = [];

                function g(r) {
                    u = t.getPointAt(r / e, u);
                    var a = o.normals[r],
                        h = o.binormals[r];
                    for (s = 0; s <= n; s++) {
                        var f = s / n * Math.PI * 2,
                            m = Math.sin(f),
                            g = -Math.cos(f);
                        l.x = g * a.x + m * h.x, l.y = g * a.y + m * h.y, l.z = g * a.z + m * h.z, l.normalize(), p.push(l.x, l.y, l.z), c.x = u.x + i * l.x, c.y = u.y + i * l.y, c.z = u.z + i * l.z, d.push(c.x, c.y, c.z)
                    }
                }! function() {
                    for (a = 0; a < e; a++) g(a);
                    g(!1 === r ? e : 0),
                        function() {
                            for (a = 0; a <= e; a++)
                                for (s = 0; s <= n; s++) h.x = a / e, h.y = s / n, f.push(h.x, h.y)
                        }(),
                        function() {
                            for (s = 1; s <= e; s++)
                                for (a = 1; a <= n; a++) {
                                    var t = (n + 1) * (s - 1) + (a - 1),
                                        i = (n + 1) * s + (a - 1),
                                        r = (n + 1) * s + a,
                                        o = (n + 1) * (s - 1) + a;
                                    m.push(t, i, o), m.push(i, r, o)
                                }
                        }()
                }(), this.setIndex(m), this.addAttribute("position", new Pi(d, 3)), this.addAttribute("normal", new Pi(p, 3)), this.addAttribute("uv", new Pi(f, 2))
            }

            function $r(t, e, i, n, r, o, a) {
                _i.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: i,
                    radialSegments: n,
                    p: r,
                    q: o
                }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new to(t, e, i, n, r, o)), this.mergeVertices()
            }

            function to(t, e, i, n, r, o) {
                Ii.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: i,
                    radialSegments: n,
                    p: r,
                    q: o
                }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, o = o || 3;
                var a, s, c = [],
                    l = [],
                    h = [],
                    u = [],
                    d = new je,
                    p = new je,
                    f = new je,
                    m = new je,
                    g = new je,
                    v = new je,
                    y = new je;
                for (a = 0; a <= i; ++a) {
                    var _ = a / i * r * Math.PI * 2;
                    for (A(_, r, o, t, f), A(_ + .01, r, o, t, m), v.subVectors(m, f), y.addVectors(m, f), g.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), s = 0; s <= n; ++s) {
                        var x = s / n * Math.PI * 2,
                            b = -e * Math.cos(x),
                            w = e * Math.sin(x);
                        d.x = f.x + (b * y.x + w * g.x), d.y = f.y + (b * y.y + w * g.y), d.z = f.z + (b * y.z + w * g.z), l.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), h.push(p.x, p.y, p.z), u.push(a / i), u.push(s / n)
                    }
                }
                for (s = 1; s <= i; s++)
                    for (a = 1; a <= n; a++) {
                        var M = (n + 1) * (s - 1) + (a - 1),
                            T = (n + 1) * s + (a - 1),
                            E = (n + 1) * s + a,
                            S = (n + 1) * (s - 1) + a;
                        c.push(M, T, S), c.push(T, E, S)
                    }

                function A(t, e, i, n, r) {
                    var o = Math.cos(t),
                        a = Math.sin(t),
                        s = i / e * t,
                        c = Math.cos(s);
                    r.x = n * (2 + c) * .5 * o, r.y = n * (2 + c) * a * .5, r.z = n * Math.sin(s) * .5
                }
                this.setIndex(c), this.addAttribute("position", new Pi(l, 3)), this.addAttribute("normal", new Pi(h, 3)), this.addAttribute("uv", new Pi(u, 2))
            }

            function eo(t, e, i, n, r) {
                _i.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: r
                }, this.fromBufferGeometry(new io(t, e, i, n, r)), this.mergeVertices()
            }

            function io(t, e, i, n, r) {
                Ii.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: r
                }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
                var o, a, s = [],
                    c = [],
                    l = [],
                    h = [],
                    u = new je,
                    d = new je,
                    p = new je;
                for (o = 0; o <= i; o++)
                    for (a = 0; a <= n; a++) {
                        var f = a / n * r,
                            m = o / i * Math.PI * 2;
                        d.x = (t + e * Math.cos(m)) * Math.cos(f), d.y = (t + e * Math.cos(m)) * Math.sin(f), d.z = e * Math.sin(m), c.push(d.x, d.y, d.z), u.x = t * Math.cos(f), u.y = t * Math.sin(f), p.subVectors(d, u).normalize(), l.push(p.x, p.y, p.z), h.push(a / n), h.push(o / i)
                    }
                for (o = 1; o <= i; o++)
                    for (a = 1; a <= n; a++) {
                        var g = (n + 1) * o + a - 1,
                            v = (n + 1) * (o - 1) + a - 1,
                            y = (n + 1) * (o - 1) + a,
                            _ = (n + 1) * o + a;
                        s.push(g, v, _), s.push(v, y, _)
                    }
                this.setIndex(s), this.addAttribute("position", new Pi(c, 3)), this.addAttribute("normal", new Pi(l, 3)), this.addAttribute("uv", new Pi(h, 2))
            }
            vr.prototype.isFogExp2 = !0, vr.prototype.clone = function() {
                return new vr(this.color, this.density)
            }, vr.prototype.toJSON = function() {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }, yr.prototype.isFog = !0, yr.prototype.clone = function() {
                return new yr(this.color, this.near, this.far)
            }, yr.prototype.toJSON = function() {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }, _r.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: _r,
                copy: function(t, e) {
                    return vi.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                },
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                }
            }), Object.defineProperty(xr.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(xr.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, i) {
                    t *= this.stride, i *= e.stride;
                    for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                }
            }), Object.defineProperties(br.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            }), Object.assign(br.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
                },
                setXYZ: function(t, e, i, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
                },
                setXYZW: function(t, e, i, n, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
                }
            }), wr.prototype = Object.create(zi.prototype), wr.prototype.constructor = wr, wr.prototype.isSpriteMaterial = !0, wr.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            }, Mr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Mr,
                isSprite: !0,
                raycast: function() {
                    var t = new je,
                        e = new je,
                        i = new je,
                        n = new Ge,
                        r = new Ge,
                        o = new He,
                        a = new je,
                        s = new je,
                        c = new je,
                        l = new Ge,
                        h = new Ge,
                        u = new Ge;

                    function d(t, e, i, a, s, c) {
                        n.subVectors(t, i).addScalar(.5).multiply(a), void 0 !== s ? (r.x = c * n.x - s * n.y, r.y = s * n.x + c * n.y) : r.copy(n), t.copy(e), t.x += r.x, t.y += r.y, t.applyMatrix4(o)
                    }
                    return function(n, r) {
                        e.setFromMatrixScale(this.matrixWorld), o.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), i.setFromMatrixPosition(this.modelViewMatrix);
                        var p, f, m = this.material.rotation;
                        0 !== m && (f = Math.cos(m), p = Math.sin(m));
                        var g = this.center;
                        d(a.set(-.5, -.5, 0), i, g, e, p, f), d(s.set(.5, -.5, 0), i, g, e, p, f), d(c.set(.5, .5, 0), i, g, e, p, f), l.set(0, 0), h.set(1, 0), u.set(1, 1);
                        var v = n.ray.intersectTriangle(a, s, c, !1, t);
                        if (null !== v || (d(s.set(-.5, .5, 0), i, g, e, p, f), h.set(0, 1), null !== (v = n.ray.intersectTriangle(a, c, s, !1, t)))) {
                            var y = n.ray.origin.distanceTo(t);
                            y < n.near || y > n.far || r.push({
                                distance: y,
                                point: t.clone(),
                                uv: Hi.getUV(t, a, s, c, l, h, u, new Ge),
                                face: null,
                                object: this
                            })
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function(t) {
                    return vi.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
                }
            }), Tr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Tr,
                copy: function(t) {
                    vi.prototype.copy.call(this, t, !1);
                    for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
                        var r = e[i];
                        this.addLevel(r.object.clone(), r.distance)
                    }
                    return this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
                    i.splice(n, 0, {
                        distance: e,
                        object: t
                    }), this.add(t)
                },
                getObjectForDistance: function(t) {
                    for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++);
                    return e[i - 1].object
                },
                raycast: function() {
                    var t = new je;
                    return function(e, i) {
                        t.setFromMatrixPosition(this.matrixWorld);
                        var n = e.ray.origin.distanceTo(t);
                        this.getObjectForDistance(n).raycast(e, i)
                    }
                }(),
                update: function() {
                    var t = new je,
                        e = new je;
                    return function(i) {
                        var n = this.levels;
                        if (n.length > 1) {
                            t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                            var r = t.distanceTo(e);
                            n[0].object.visible = !0;
                            for (var o = 1, a = n.length; o < a && r >= n[o].distance; o++) n[o - 1].object.visible = !1, n[o].object.visible = !0;
                            for (; o < a; o++) n[o].object.visible = !1
                        }
                    }
                }(),
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    e.object.levels = [];
                    for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                        var o = i[n];
                        e.object.levels.push({
                            object: o.object.uuid,
                            distance: o.distance
                        })
                    }
                    return e
                }
            }), Er.prototype = Object.assign(Object.create(ji.prototype), {
                constructor: Er,
                isSkinnedMesh: !0,
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    for (var t = new Ze, e = this.geometry.attributes.skinWeight, i = 0, n = e.count; i < n; i++) {
                        t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
                        var r = 1 / t.manhattanLength();
                        r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
                    }
                },
                updateMatrixWorld: function(t) {
                    ji.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Object.assign(Sr.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var i = new He;
                        this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
                    }
                },
                pose: function() {
                    var t, e, i;
                    for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                    for (e = 0, i = this.bones.length; e < i; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                },
                update: function() {
                    var t = new He,
                        e = new He;
                    return function() {
                        for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = i.length; a < s; a++) {
                            var c = i[a] ? i[a].matrixWorld : e;
                            t.multiplyMatrices(c, n[a]), t.toArray(r, 16 * a)
                        }
                        void 0 !== o && (o.needsUpdate = !0)
                    }
                }(),
                clone: function() {
                    return new Sr(this.bones, this.boneInverses)
                },
                getBoneByName: function(t) {
                    for (var e = 0, i = this.bones.length; e < i; e++) {
                        var n = this.bones[e];
                        if (n.name === t) return n
                    }
                }
            }), Ar.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Ar,
                isBone: !0
            }), Pr.prototype = Object.create(zi.prototype), Pr.prototype.constructor = Pr, Pr.prototype.isLineBasicMaterial = !0, Pr.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
            }, Lr.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Lr,
                isLine: !0,
                computeLineDistances: function() {
                    var t = new je,
                        e = new je;
                    return function() {
                        var i = this.geometry;
                        if (i.isBufferGeometry)
                            if (null === i.index) {
                                for (var n = i.attributes.position, r = [0], o = 1, a = n.count; o < a; o++) t.fromBufferAttribute(n, o - 1), e.fromBufferAttribute(n, o), r[o] = r[o - 1], r[o] += t.distanceTo(e);
                                i.addAttribute("lineDistance", new Pi(r, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (i.isGeometry) {
                            var s = i.vertices;
                            (r = i.lineDistances)[0] = 0;
                            for (o = 1, a = s.length; o < a; o++) r[o] = r[o - 1], r[o] += s[o - 1].distanceTo(s[o])
                        }
                        return this
                    }
                }(),
                raycast: function() {
                    var t = new He,
                        e = new Gi,
                        i = new ti;
                    return function(n, r) {
                        var o = n.linePrecision,
                            a = this.geometry,
                            s = this.matrixWorld;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(s), i.radius += o, !1 !== n.ray.intersectsSphere(i)) {
                            t.getInverse(s), e.copy(n.ray).applyMatrix4(t);
                            var c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                l = c * c,
                                h = new je,
                                u = new je,
                                d = new je,
                                p = new je,
                                f = this && this.isLineSegments ? 2 : 1;
                            if (a.isBufferGeometry) {
                                var m = a.index,
                                    g = a.attributes.position.array;
                                if (null !== m)
                                    for (var v = m.array, y = 0, _ = v.length - 1; y < _; y += f) {
                                        var x = v[y],
                                            b = v[y + 1];
                                        if (h.fromArray(g, 3 * x), u.fromArray(g, 3 * b), !(e.distanceSqToSegment(h, u, p, d) > l)) p.applyMatrix4(this.matrixWorld), (T = n.ray.origin.distanceTo(p)) < n.near || T > n.far || r.push({
                                            distance: T,
                                            point: d.clone().applyMatrix4(this.matrixWorld),
                                            index: y,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    } else
                                        for (y = 0, _ = g.length / 3 - 1; y < _; y += f) {
                                            if (h.fromArray(g, 3 * y), u.fromArray(g, 3 * y + 3), !(e.distanceSqToSegment(h, u, p, d) > l)) p.applyMatrix4(this.matrixWorld), (T = n.ray.origin.distanceTo(p)) < n.near || T > n.far || r.push({
                                                distance: T,
                                                point: d.clone().applyMatrix4(this.matrixWorld),
                                                index: y,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                            } else if (a.isGeometry) {
                                var w = a.vertices,
                                    M = w.length;
                                for (y = 0; y < M - 1; y += f) {
                                    var T;
                                    if (!(e.distanceSqToSegment(w[y], w[y + 1], p, d) > l)) p.applyMatrix4(this.matrixWorld), (T = n.ray.origin.distanceTo(p)) < n.near || T > n.far || r.push({
                                        distance: T,
                                        point: d.clone().applyMatrix4(this.matrixWorld),
                                        index: y,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                        }
                    }
                }(),
                copy: function(t) {
                    return vi.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), Cr.prototype = Object.assign(Object.create(Lr.prototype), {
                constructor: Cr,
                isLineSegments: !0,
                computeLineDistances: function() {
                    var t = new je,
                        e = new je;
                    return function() {
                        var i = this.geometry;
                        if (i.isBufferGeometry)
                            if (null === i.index) {
                                for (var n = i.attributes.position, r = [], o = 0, a = n.count; o < a; o += 2) t.fromBufferAttribute(n, o), e.fromBufferAttribute(n, o + 1), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e);
                                i.addAttribute("lineDistance", new Pi(r, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (i.isGeometry) {
                            var s = i.vertices;
                            for (r = i.lineDistances, o = 0, a = s.length; o < a; o += 2) t.copy(s[o]), e.copy(s[o + 1]), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e)
                        }
                        return this
                    }
                }()
            }), Rr.prototype = Object.assign(Object.create(Lr.prototype), {
                constructor: Rr,
                isLineLoop: !0
            }), Or.prototype = Object.create(zi.prototype), Or.prototype.constructor = Or, Or.prototype.isPointsMaterial = !0, Or.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
            }, Ir.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Ir,
                isPoints: !0,
                raycast: function() {
                    var t = new He,
                        e = new Gi,
                        i = new ti;
                    return function(n, r) {
                        var o = this,
                            a = this.geometry,
                            s = this.matrixWorld,
                            c = n.params.Points.threshold;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), i.copy(a.boundingSphere), i.applyMatrix4(s), i.radius += c, !1 !== n.ray.intersectsSphere(i)) {
                            t.getInverse(s), e.copy(n.ray).applyMatrix4(t);
                            var l = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                h = l * l,
                                u = new je,
                                d = new je;
                            if (a.isBufferGeometry) {
                                var p = a.index,
                                    f = a.attributes.position.array;
                                if (null !== p)
                                    for (var m = p.array, g = 0, v = m.length; g < v; g++) {
                                        var y = m[g];
                                        u.fromArray(f, 3 * y), b(u, y)
                                    } else {
                                        g = 0;
                                        for (var _ = f.length / 3; g < _; g++) u.fromArray(f, 3 * g), b(u, g)
                                    }
                            } else {
                                var x = a.vertices;
                                for (g = 0, _ = x.length; g < _; g++) b(x[g], g)
                            }
                        }

                        function b(t, i) {
                            var a = e.distanceSqToPoint(t);
                            if (a < h) {
                                e.closestPointToPoint(t, d), d.applyMatrix4(s);
                                var c = n.ray.origin.distanceTo(d);
                                if (c < n.near || c > n.far) return;
                                r.push({
                                    distance: c,
                                    distanceToRay: Math.sqrt(a),
                                    point: d.clone(),
                                    index: i,
                                    face: null,
                                    object: o
                                })
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Dr.prototype = Object.assign(Object.create(Ye.prototype), {
                constructor: Dr,
                isVideoTexture: !0,
                update: function() {
                    var t = this.image;
                    t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), kr.prototype = Object.create(Ye.prototype), kr.prototype.constructor = kr, kr.prototype.isCompressedTexture = !0, Nr.prototype = Object.create(Ye.prototype), Nr.prototype.constructor = Nr, Nr.prototype.isCanvasTexture = !0, Br.prototype = Object.create(Ye.prototype), Br.prototype.constructor = Br, Br.prototype.isDepthTexture = !0, Fr.prototype = Object.create(Ii.prototype), Fr.prototype.constructor = Fr, zr.prototype = Object.create(_i.prototype), zr.prototype.constructor = zr, Ur.prototype = Object.create(Ii.prototype), Ur.prototype.constructor = Ur, Gr.prototype = Object.create(_i.prototype), Gr.prototype.constructor = Gr, Hr.prototype = Object.create(Ii.prototype), Hr.prototype.constructor = Hr, Vr.prototype = Object.create(_i.prototype), Vr.prototype.constructor = Vr, jr.prototype = Object.create(Hr.prototype), jr.prototype.constructor = jr, Wr.prototype = Object.create(_i.prototype), Wr.prototype.constructor = Wr, Xr.prototype = Object.create(Hr.prototype), Xr.prototype.constructor = Xr, qr.prototype = Object.create(_i.prototype), qr.prototype.constructor = qr, Yr.prototype = Object.create(Hr.prototype), Yr.prototype.constructor = Yr, Zr.prototype = Object.create(_i.prototype), Zr.prototype.constructor = Zr, Jr.prototype = Object.create(Hr.prototype), Jr.prototype.constructor = Jr, Kr.prototype = Object.create(_i.prototype), Kr.prototype.constructor = Kr, Qr.prototype = Object.create(Ii.prototype), Qr.prototype.constructor = Qr, $r.prototype = Object.create(_i.prototype), $r.prototype.constructor = $r, to.prototype = Object.create(Ii.prototype), to.prototype.constructor = to, eo.prototype = Object.create(_i.prototype), eo.prototype.constructor = eo, io.prototype = Object.create(Ii.prototype), io.prototype.constructor = io;
            var no = function(t, e, i) {
                i = i || 2;
                var n, r, o, a, s, c, l, h = e && e.length,
                    u = h ? e[0] * i : t.length,
                    d = ro(t, 0, u, i, !0),
                    p = [];
                if (!d) return p;
                if (h && (d = function(t, e, i, n) {
                        var r, o, a, s, c, l = [];
                        for (r = 0, o = e.length; r < o; r++) a = e[r] * n, s = r < o - 1 ? e[r + 1] * n : t.length, (c = ro(t, a, s, n, !1)) === c.next && (c.steiner = !0), l.push(mo(c));
                        for (l.sort(uo), r = 0; r < l.length; r++) po(l[r], i), i = oo(i, i.next);
                        return i
                    }(t, e, d, i)), t.length > 80 * i) {
                    n = o = t[0], r = a = t[1];
                    for (var f = i; f < u; f += i) s = t[f], c = t[f + 1], s < n && (n = s), c < r && (r = c), s > o && (o = s), c > a && (a = c);
                    l = 0 !== (l = Math.max(o - n, a - r)) ? 1 / l : 0
                }
                return ao(d, p, i, n, r, l), p
            };

            function ro(t, e, i, n, r) {
                var o, a;
                if (r === function(t, e, i, n) {
                        for (var r = 0, o = e, a = i - n; o < i; o += n) r += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                        return r
                    }(t, e, i, n) > 0)
                    for (o = e; o < i; o += n) a = Mo(o, t[o], t[o + 1], a);
                else
                    for (o = i - n; o >= e; o -= n) a = Mo(o, t[o], t[o + 1], a);
                return a && _o(a, a.next) && (To(a), a = a.next), a
            }

            function oo(t, e) {
                if (!t) return t;
                e || (e = t);
                var i, n = t;
                do {
                    if (i = !1, n.steiner || !_o(n, n.next) && 0 !== yo(n.prev, n, n.next)) n = n.next;
                    else {
                        if (To(n), (n = e = n.prev) === n.next) break;
                        i = !0
                    }
                } while (i || n !== e);
                return e
            }

            function ao(t, e, i, n, r, o, a) {
                if (t) {
                    !a && o && function(t, e, i, n) {
                        var r = t;
                        do {
                            null === r.z && (r.z = fo(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(t) {
                                var e, i, n, r, o, a, s, c, l = 1;
                                do {
                                    for (i = t, t = null, o = null, a = 0; i;) {
                                        for (a++, n = i, s = 0, e = 0; e < l && (s++, n = n.nextZ); e++);
                                        for (c = l; s > 0 || c > 0 && n;) 0 !== s && (0 === c || !n || i.z <= n.z) ? (r = i, i = i.nextZ, s--) : (r = n, n = n.nextZ, c--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                                        i = n
                                    }
                                    o.nextZ = null, l *= 2
                                } while (a > 1)
                            }(r)
                    }(t, n, r, o);
                    for (var s, c, l = t; t.prev !== t.next;)
                        if (s = t.prev, c = t.next, o ? co(t, n, r, o) : so(t)) e.push(s.i / i), e.push(t.i / i), e.push(c.i / i), To(t), t = c.next, l = c.next;
                        else if ((t = c) === l) {
                        a ? 1 === a ? ao(t = lo(t, e, i), e, i, n, r, o, 2) : 2 === a && ho(t, e, i, n, r, o) : ao(oo(t), e, i, n, r, o, 1);
                        break
                    }
                }
            }

            function so(t) {
                var e = t.prev,
                    i = t,
                    n = t.next;
                if (yo(e, i, n) >= 0) return !1;
                for (var r = t.next.next; r !== t.prev;) {
                    if (go(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && yo(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function co(t, e, i, n) {
                var r = t.prev,
                    o = t,
                    a = t.next;
                if (yo(r, o, a) >= 0) return !1;
                for (var s = r.x < o.x ? r.x < a.x ? r.x : a.x : o.x < a.x ? o.x : a.x, c = r.y < o.y ? r.y < a.y ? r.y : a.y : o.y < a.y ? o.y : a.y, l = r.x > o.x ? r.x > a.x ? r.x : a.x : o.x > a.x ? o.x : a.x, h = r.y > o.y ? r.y > a.y ? r.y : a.y : o.y > a.y ? o.y : a.y, u = fo(s, c, e, i, n), d = fo(l, h, e, i, n), p = t.nextZ; p && p.z <= d;) {
                    if (p !== t.prev && p !== t.next && go(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && yo(p.prev, p, p.next) >= 0) return !1;
                    p = p.nextZ
                }
                for (p = t.prevZ; p && p.z >= u;) {
                    if (p !== t.prev && p !== t.next && go(r.x, r.y, o.x, o.y, a.x, a.y, p.x, p.y) && yo(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                return !0
            }

            function lo(t, e, i) {
                var n = t;
                do {
                    var r = n.prev,
                        o = n.next.next;
                    !_o(r, o) && xo(r, n, n.next, o) && bo(r, o) && bo(o, r) && (e.push(r.i / i), e.push(n.i / i), e.push(o.i / i), To(n), To(n.next), n = t = o), n = n.next
                } while (n !== t);
                return n
            }

            function ho(t, e, i, n, r, o) {
                var a = t;
                do {
                    for (var s = a.next.next; s !== a.prev;) {
                        if (a.i !== s.i && vo(a, s)) {
                            var c = wo(a, s);
                            return a = oo(a, a.next), c = oo(c, c.next), ao(a, e, i, n, r, o), void ao(c, e, i, n, r, o)
                        }
                        s = s.next
                    }
                    a = a.next
                } while (a !== t)
            }

            function uo(t, e) {
                return t.x - e.x
            }

            function po(t, e) {
                if (e = function(t, e) {
                        var i, n = e,
                            r = t.x,
                            o = t.y,
                            a = -1 / 0;
                        do {
                            if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
                                var s = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (s <= r && s > a) {
                                    if (a = s, s === r) {
                                        if (o === n.y) return n;
                                        if (o === n.next.y) return n.next
                                    }
                                    i = n.x < n.next.x ? n : n.next
                                }
                            }
                            n = n.next
                        } while (n !== e);
                        if (!i) return null;
                        if (r === a) return i.prev;
                        var c, l = i,
                            h = i.x,
                            u = i.y,
                            d = 1 / 0;
                        n = i.next;
                        for (; n !== l;) r >= n.x && n.x >= h && r !== n.x && go(o < u ? r : a, o, h, u, o < u ? a : r, o, n.x, n.y) && ((c = Math.abs(o - n.y) / (r - n.x)) < d || c === d && n.x > i.x) && bo(n, t) && (i = n, d = c), n = n.next;
                        return i
                    }(t, e)) {
                    var i = wo(e, t);
                    oo(i, i.next)
                }
            }

            function fo(t, e, i, n, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function mo(t) {
                var e = t,
                    i = t;
                do {
                    e.x < i.x && (i = e), e = e.next
                } while (e !== t);
                return i
            }

            function go(t, e, i, n, r, o, a, s) {
                return (r - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (n - s) - (i - a) * (e - s) >= 0 && (i - a) * (o - s) - (r - a) * (n - s) >= 0
            }

            function vo(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                    var i = t;
                    do {
                        if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && xo(i, i.next, t, e)) return !0;
                        i = i.next
                    } while (i !== t);
                    return !1
                }(t, e) && bo(t, e) && bo(e, t) && function(t, e) {
                    var i = t,
                        n = !1,
                        r = (t.x + e.x) / 2,
                        o = (t.y + e.y) / 2;
                    do {
                        i.y > o != i.next.y > o && i.next.y !== i.y && r < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
                    } while (i !== t);
                    return n
                }(t, e)
            }

            function yo(t, e, i) {
                return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
            }

            function _o(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function xo(t, e, i, n) {
                return !!(_o(t, e) && _o(i, n) || _o(t, n) && _o(i, e)) || yo(t, e, i) > 0 != yo(t, e, n) > 0 && yo(i, n, t) > 0 != yo(i, n, e) > 0
            }

            function bo(t, e) {
                return yo(t.prev, t, t.next) < 0 ? yo(t, e, t.next) >= 0 && yo(t, t.prev, e) >= 0 : yo(t, e, t.prev) < 0 || yo(t, t.next, e) < 0
            }

            function wo(t, e) {
                var i = new Eo(t.i, t.x, t.y),
                    n = new Eo(e.i, e.x, e.y),
                    r = t.next,
                    o = e.prev;
                return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
            }

            function Mo(t, e, i, n) {
                var r = new Eo(t, e, i);
                return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
            }

            function To(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function Eo(t, e, i) {
                this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var So = {
                area: function(t) {
                    for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
                    return .5 * i
                },
                isClockWise: function(t) {
                    return So.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    var i = [],
                        n = [],
                        r = [];
                    Ao(t), Po(i, t);
                    var o = t.length;
                    e.forEach(Ao);
                    for (var a = 0; a < e.length; a++) n.push(o), o += e[a].length, Po(i, e[a]);
                    var s = no(i, n);
                    for (a = 0; a < s.length; a += 3) r.push(s.slice(a, a + 3));
                    return r
                }
            };

            function Ao(t) {
                var e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function Po(t, e) {
                for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
            }

            function Lo(t, e) {
                _i.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, this.fromBufferGeometry(new Co(t, e)), this.mergeVertices()
            }

            function Co(t, e) {
                Ii.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: t,
                    options: e
                };
                for (var i = this, n = [], r = [], o = 0, a = (t = Array.isArray(t) ? t : [t]).length; o < a; o++) {
                    s(t[o])
                }

                function s(t) {
                    var o = [],
                        a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        s = void 0 !== e.steps ? e.steps : 1,
                        c = void 0 !== e.depth ? e.depth : 100,
                        l = void 0 === e.bevelEnabled || e.bevelEnabled,
                        h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                        u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                        d = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                        p = e.extrudePath,
                        f = void 0 !== e.UVGenerator ? e.UVGenerator : Ro;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
                    var m, g, v, y, _, x, b, w, M = !1;
                    p && (m = p.getSpacedPoints(s), M = !0, l = !1, g = p.computeFrenetFrames(s, !1), v = new je, y = new je, _ = new je), l || (d = 0, h = 0, u = 0);
                    var T = t.extractPoints(a),
                        E = T.shape,
                        S = T.holes;
                    if (!So.isClockWise(E))
                        for (E = E.reverse(), b = 0, w = S.length; b < w; b++) x = S[b], So.isClockWise(x) && (S[b] = x.reverse());
                    var A = So.triangulateShape(E, S),
                        P = E;
                    for (b = 0, w = S.length; b < w; b++) x = S[b], E = E.concat(x);

                    function L(t, e, i) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
                    }
                    var C, R, O, I, D, k, N = E.length,
                        B = A.length;

                    function F(t, e, i) {
                        var n, r, o, a = t.x - e.x,
                            s = t.y - e.y,
                            c = i.x - t.x,
                            l = i.y - t.y,
                            h = a * a + s * s,
                            u = a * l - s * c;
                        if (Math.abs(u) > Number.EPSILON) {
                            var d = Math.sqrt(h),
                                p = Math.sqrt(c * c + l * l),
                                f = e.x - s / d,
                                m = e.y + a / d,
                                g = ((i.x - l / p - f) * l - (i.y + c / p - m) * c) / (a * l - s * c),
                                v = (n = f + a * g - t.x) * n + (r = m + s * g - t.y) * r;
                            if (v <= 2) return new Ge(n, r);
                            o = Math.sqrt(v / 2)
                        } else {
                            var y = !1;
                            a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(l) && (y = !0), y ? (n = -s, r = a, o = Math.sqrt(h)) : (n = a, r = s, o = Math.sqrt(h / 2))
                        }
                        return new Ge(n / o, r / o)
                    }
                    for (var z = [], U = 0, G = P.length, H = G - 1, V = U + 1; U < G; U++, H++, V++) H === G && (H = 0), V === G && (V = 0), z[U] = F(P[U], P[H], P[V]);
                    var j, W, X = [],
                        q = z.concat();
                    for (b = 0, w = S.length; b < w; b++) {
                        for (x = S[b], j = [], U = 0, H = (G = x.length) - 1, V = U + 1; U < G; U++, H++, V++) H === G && (H = 0), V === G && (V = 0), j[U] = F(x[U], x[H], x[V]);
                        X.push(j), q = q.concat(j)
                    }
                    for (C = 0; C < d; C++) {
                        for (O = C / d, I = h * Math.cos(O * Math.PI / 2), R = u * Math.sin(O * Math.PI / 2), U = 0, G = P.length; U < G; U++) Z((D = L(P[U], z[U], R)).x, D.y, -I);
                        for (b = 0, w = S.length; b < w; b++)
                            for (x = S[b], j = X[b], U = 0, G = x.length; U < G; U++) Z((D = L(x[U], j[U], R)).x, D.y, -I)
                    }
                    for (R = u, U = 0; U < N; U++) D = l ? L(E[U], q[U], R) : E[U], M ? (y.copy(g.normals[0]).multiplyScalar(D.x), v.copy(g.binormals[0]).multiplyScalar(D.y), _.copy(m[0]).add(y).add(v), Z(_.x, _.y, _.z)) : Z(D.x, D.y, 0);
                    for (W = 1; W <= s; W++)
                        for (U = 0; U < N; U++) D = l ? L(E[U], q[U], R) : E[U], M ? (y.copy(g.normals[W]).multiplyScalar(D.x), v.copy(g.binormals[W]).multiplyScalar(D.y), _.copy(m[W]).add(y).add(v), Z(_.x, _.y, _.z)) : Z(D.x, D.y, c / s * W);
                    for (C = d - 1; C >= 0; C--) {
                        for (O = C / d, I = h * Math.cos(O * Math.PI / 2), R = u * Math.sin(O * Math.PI / 2), U = 0, G = P.length; U < G; U++) Z((D = L(P[U], z[U], R)).x, D.y, c + I);
                        for (b = 0, w = S.length; b < w; b++)
                            for (x = S[b], j = X[b], U = 0, G = x.length; U < G; U++) D = L(x[U], j[U], R), M ? Z(D.x, D.y + m[s - 1].y, m[s - 1].x + I) : Z(D.x, D.y, c + I)
                    }

                    function Y(t, e) {
                        var i, n;
                        for (U = t.length; --U >= 0;) {
                            i = U, (n = U - 1) < 0 && (n = t.length - 1);
                            var r = 0,
                                o = s + 2 * d;
                            for (r = 0; r < o; r++) {
                                var a = N * r,
                                    c = N * (r + 1);
                                K(e + i + a, e + n + a, e + n + c, e + i + c)
                            }
                        }
                    }

                    function Z(t, e, i) {
                        o.push(t), o.push(e), o.push(i)
                    }

                    function J(t, e, r) {
                        Q(t), Q(e), Q(r);
                        var o = n.length / 3,
                            a = f.generateTopUV(i, n, o - 3, o - 2, o - 1);
                        $(a[0]), $(a[1]), $(a[2])
                    }

                    function K(t, e, r, o) {
                        Q(t), Q(e), Q(o), Q(e), Q(r), Q(o);
                        var a = n.length / 3,
                            s = f.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                        $(s[0]), $(s[1]), $(s[3]), $(s[1]), $(s[2]), $(s[3])
                    }

                    function Q(t) {
                        n.push(o[3 * t + 0]), n.push(o[3 * t + 1]), n.push(o[3 * t + 2])
                    }

                    function $(t) {
                        r.push(t.x), r.push(t.y)
                    }! function() {
                        var t = n.length / 3;
                        if (l) {
                            var e = 0,
                                r = N * e;
                            for (U = 0; U < B; U++) J((k = A[U])[2] + r, k[1] + r, k[0] + r);
                            for (r = N * (e = s + 2 * d), U = 0; U < B; U++) J((k = A[U])[0] + r, k[1] + r, k[2] + r)
                        } else {
                            for (U = 0; U < B; U++) J((k = A[U])[2], k[1], k[0]);
                            for (U = 0; U < B; U++) J((k = A[U])[0] + N * s, k[1] + N * s, k[2] + N * s)
                        }
                        i.addGroup(t, n.length / 3 - t, 0)
                    }(),
                    function() {
                        var t = n.length / 3,
                            e = 0;
                        for (Y(P, e), e += P.length, b = 0, w = S.length; b < w; b++) Y(x = S[b], e), e += x.length;
                        i.addGroup(t, n.length / 3 - t, 1)
                    }()
                }
                this.addAttribute("position", new Pi(n, 3)), this.addAttribute("uv", new Pi(r, 2)), this.computeVertexNormals()
            }
            Lo.prototype = Object.create(_i.prototype), Lo.prototype.constructor = Lo, Lo.prototype.toJSON = function() {
                var t = _i.prototype.toJSON.call(this);
                return Oo(this.parameters.shapes, this.parameters.options, t)
            }, Co.prototype = Object.create(Ii.prototype), Co.prototype.constructor = Co, Co.prototype.toJSON = function() {
                var t = Ii.prototype.toJSON.call(this);
                return Oo(this.parameters.shapes, this.parameters.options, t)
            };
            var Ro = {
                generateTopUV: function(t, e, i, n, r) {
                    var o = e[3 * i],
                        a = e[3 * i + 1],
                        s = e[3 * n],
                        c = e[3 * n + 1],
                        l = e[3 * r],
                        h = e[3 * r + 1];
                    return [new Ge(o, a), new Ge(s, c), new Ge(l, h)]
                },
                generateSideWallUV: function(t, e, i, n, r, o) {
                    var a = e[3 * i],
                        s = e[3 * i + 1],
                        c = e[3 * i + 2],
                        l = e[3 * n],
                        h = e[3 * n + 1],
                        u = e[3 * n + 2],
                        d = e[3 * r],
                        p = e[3 * r + 1],
                        f = e[3 * r + 2],
                        m = e[3 * o],
                        g = e[3 * o + 1],
                        v = e[3 * o + 2];
                    return Math.abs(s - h) < .01 ? [new Ge(a, 1 - c), new Ge(l, 1 - u), new Ge(d, 1 - f), new Ge(m, 1 - v)] : [new Ge(s, 1 - c), new Ge(h, 1 - u), new Ge(p, 1 - f), new Ge(g, 1 - v)]
                }
            };

            function Oo(t, e, i) {
                if (i.shapes = [], Array.isArray(t))
                    for (var n = 0, r = t.length; n < r; n++) {
                        var o = t[n];
                        i.shapes.push(o.uuid)
                    } else i.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
            }

            function Io(t, e) {
                _i.call(this), this.type = "TextGeometry", this.parameters = {
                    text: t,
                    parameters: e
                }, this.fromBufferGeometry(new Do(t, e)), this.mergeVertices()
            }

            function Do(t, e) {
                var i = (e = e || {}).font;
                if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new _i;
                var n = i.generateShapes(t, e.size);
                e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Co.call(this, n, e), this.type = "TextBufferGeometry"
            }

            function ko(t, e, i, n, r, o, a) {
                _i.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: a
                }, this.fromBufferGeometry(new No(t, e, i, n, r, o, a)), this.mergeVertices()
            }

            function No(t, e, i, n, r, o, a) {
                Ii.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: a
                }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var s, c, l = (o = void 0 !== o ? o : 0) + (a = void 0 !== a ? a : Math.PI),
                    h = 0,
                    u = [],
                    d = new je,
                    p = new je,
                    f = [],
                    m = [],
                    g = [],
                    v = [];
                for (c = 0; c <= i; c++) {
                    var y = [],
                        _ = c / i;
                    for (s = 0; s <= e; s++) {
                        var x = s / e;
                        d.x = -t * Math.cos(n + x * r) * Math.sin(o + _ * a), d.y = t * Math.cos(o + _ * a), d.z = t * Math.sin(n + x * r) * Math.sin(o + _ * a), m.push(d.x, d.y, d.z), p.set(d.x, d.y, d.z).normalize(), g.push(p.x, p.y, p.z), v.push(x, 1 - _), y.push(h++)
                    }
                    u.push(y)
                }
                for (c = 0; c < i; c++)
                    for (s = 0; s < e; s++) {
                        var b = u[c][s + 1],
                            w = u[c][s],
                            M = u[c + 1][s],
                            T = u[c + 1][s + 1];
                        (0 !== c || o > 0) && f.push(b, w, T), (c !== i - 1 || l < Math.PI) && f.push(w, M, T)
                    }
                this.setIndex(f), this.addAttribute("position", new Pi(m, 3)), this.addAttribute("normal", new Pi(g, 3)), this.addAttribute("uv", new Pi(v, 2))
            }

            function Bo(t, e, i, n, r, o) {
                _i.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: r,
                    thetaLength: o
                }, this.fromBufferGeometry(new Fo(t, e, i, n, r, o)), this.mergeVertices()
            }

            function Fo(t, e, i, n, r, o) {
                Ii.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: r,
                    thetaLength: o
                }, t = t || .5, e = e || 1, r = void 0 !== r ? r : 0, o = void 0 !== o ? o : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
                var a, s, c, l = [],
                    h = [],
                    u = [],
                    d = [],
                    p = t,
                    f = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1),
                    m = new je,
                    g = new Ge;
                for (s = 0; s <= n; s++) {
                    for (c = 0; c <= i; c++) a = r + c / i * o, m.x = p * Math.cos(a), m.y = p * Math.sin(a), h.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / e + 1) / 2, g.y = (m.y / e + 1) / 2, d.push(g.x, g.y);
                    p += f
                }
                for (s = 0; s < n; s++) {
                    var v = s * (i + 1);
                    for (c = 0; c < i; c++) {
                        var y = a = c + v,
                            _ = a + i + 1,
                            x = a + i + 2,
                            b = a + 1;
                        l.push(y, _, b), l.push(_, x, b)
                    }
                }
                this.setIndex(l), this.addAttribute("position", new Pi(h, 3)), this.addAttribute("normal", new Pi(u, 3)), this.addAttribute("uv", new Pi(d, 2))
            }

            function zo(t, e, i, n) {
                _i.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: i,
                    phiLength: n
                }, this.fromBufferGeometry(new Uo(t, e, i, n)), this.mergeVertices()
            }

            function Uo(t, e, i, n) {
                Ii.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: i,
                    phiLength: n
                }, e = Math.floor(e) || 12, i = i || 0, n = n || 2 * Math.PI, n = Ue.clamp(n, 0, 2 * Math.PI);
                var r, o, a, s = [],
                    c = [],
                    l = [],
                    h = 1 / e,
                    u = new je,
                    d = new Ge;
                for (o = 0; o <= e; o++) {
                    var p = i + o * h * n,
                        f = Math.sin(p),
                        m = Math.cos(p);
                    for (a = 0; a <= t.length - 1; a++) u.x = t[a].x * f, u.y = t[a].y, u.z = t[a].x * m, c.push(u.x, u.y, u.z), d.x = o / e, d.y = a / (t.length - 1), l.push(d.x, d.y)
                }
                for (o = 0; o < e; o++)
                    for (a = 0; a < t.length - 1; a++) {
                        var g = r = a + o * t.length,
                            v = r + t.length,
                            y = r + t.length + 1,
                            _ = r + 1;
                        s.push(g, v, _), s.push(v, y, _)
                    }
                if (this.setIndex(s), this.addAttribute("position", new Pi(c, 3)), this.addAttribute("uv", new Pi(l, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
                    var x = this.attributes.normal.array,
                        b = new je,
                        w = new je,
                        M = new je;
                    for (r = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3) b.x = x[a + 0], b.y = x[a + 1], b.z = x[a + 2], w.x = x[r + a + 0], w.y = x[r + a + 1], w.z = x[r + a + 2], M.addVectors(b, w).normalize(), x[a + 0] = x[r + a + 0] = M.x, x[a + 1] = x[r + a + 1] = M.y, x[a + 2] = x[r + a + 2] = M.z
                }
            }

            function Go(t, e) {
                _i.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, this.fromBufferGeometry(new Ho(t, e)), this.mergeVertices()
            }

            function Ho(t, e) {
                Ii.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, e = e || 12;
                var i = [],
                    n = [],
                    r = [],
                    o = [],
                    a = 0,
                    s = 0;
                if (!1 === Array.isArray(t)) l(t);
                else
                    for (var c = 0; c < t.length; c++) l(t[c]), this.addGroup(a, s, c), a += s, s = 0;

                function l(t) {
                    var a, c, l, h = n.length / 3,
                        u = t.extractPoints(e),
                        d = u.shape,
                        p = u.holes;
                    if (!1 === So.isClockWise(d))
                        for (d = d.reverse(), a = 0, c = p.length; a < c; a++) l = p[a], !0 === So.isClockWise(l) && (p[a] = l.reverse());
                    var f = So.triangulateShape(d, p);
                    for (a = 0, c = p.length; a < c; a++) l = p[a], d = d.concat(l);
                    for (a = 0, c = d.length; a < c; a++) {
                        var m = d[a];
                        n.push(m.x, m.y, 0), r.push(0, 0, 1), o.push(m.x, m.y)
                    }
                    for (a = 0, c = f.length; a < c; a++) {
                        var g = f[a],
                            v = g[0] + h,
                            y = g[1] + h,
                            _ = g[2] + h;
                        i.push(v, y, _), s += 3
                    }
                }
                this.setIndex(i), this.addAttribute("position", new Pi(n, 3)), this.addAttribute("normal", new Pi(r, 3)), this.addAttribute("uv", new Pi(o, 2))
            }

            function Vo(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (var i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        e.shapes.push(r.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }

            function jo(t, e) {
                Ii.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: e
                }, e = void 0 !== e ? e : 1;
                var i, n, r, o, a = [],
                    s = Math.cos(Ue.DEG2RAD * e),
                    c = [0, 0],
                    l = {},
                    h = ["a", "b", "c"];
                t.isBufferGeometry ? (o = new _i).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var u = o.vertices, d = o.faces, p = 0, f = d.length; p < f; p++)
                    for (var m = d[p], g = 0; g < 3; g++) i = m[h[g]], n = m[h[(g + 1) % 3]], c[0] = Math.min(i, n), c[1] = Math.max(i, n), void 0 === l[r = c[0] + "," + c[1]] ? l[r] = {
                        index1: c[0],
                        index2: c[1],
                        face1: p,
                        face2: void 0
                    } : l[r].face2 = p;
                for (r in l) {
                    var v = l[r];
                    if (void 0 === v.face2 || d[v.face1].normal.dot(d[v.face2].normal) <= s) {
                        var y = u[v.index1];
                        a.push(y.x, y.y, y.z), y = u[v.index2], a.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new Pi(a, 3))
            }

            function Wo(t, e, i, n, r, o, a, s) {
                _i.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: i,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                }, this.fromBufferGeometry(new Xo(t, e, i, n, r, o, a, s)), this.mergeVertices()
            }

            function Xo(t, e, i, n, r, o, a, s) {
                Ii.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: i,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                };
                var c = this;
                t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, i = i || 1, n = Math.floor(n) || 8, r = Math.floor(r) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
                var l = [],
                    h = [],
                    u = [],
                    d = [],
                    p = 0,
                    f = [],
                    m = i / 2,
                    g = 0;

                function v(i) {
                    var r, o, f, v = new Ge,
                        y = new je,
                        _ = 0,
                        x = !0 === i ? t : e,
                        b = !0 === i ? 1 : -1;
                    for (o = p, r = 1; r <= n; r++) h.push(0, m * b, 0), u.push(0, b, 0), d.push(.5, .5), p++;
                    for (f = p, r = 0; r <= n; r++) {
                        var w = r / n * s + a,
                            M = Math.cos(w),
                            T = Math.sin(w);
                        y.x = x * T, y.y = m * b, y.z = x * M, h.push(y.x, y.y, y.z), u.push(0, b, 0), v.x = .5 * M + .5, v.y = .5 * T * b + .5, d.push(v.x, v.y), p++
                    }
                    for (r = 0; r < n; r++) {
                        var E = o + r,
                            S = f + r;
                        !0 === i ? l.push(S, S + 1, E) : l.push(S + 1, S, E), _ += 3
                    }
                    c.addGroup(g, _, !0 === i ? 1 : 2), g += _
                }! function() {
                    var o, v, y = new je,
                        _ = new je,
                        x = 0,
                        b = (e - t) / i;
                    for (v = 0; v <= r; v++) {
                        var w = [],
                            M = v / r,
                            T = M * (e - t) + t;
                        for (o = 0; o <= n; o++) {
                            var E = o / n,
                                S = E * s + a,
                                A = Math.sin(S),
                                P = Math.cos(S);
                            _.x = T * A, _.y = -M * i + m, _.z = T * P, h.push(_.x, _.y, _.z), y.set(A, b, P).normalize(), u.push(y.x, y.y, y.z), d.push(E, 1 - M), w.push(p++)
                        }
                        f.push(w)
                    }
                    for (o = 0; o < n; o++)
                        for (v = 0; v < r; v++) {
                            var L = f[v][o],
                                C = f[v + 1][o],
                                R = f[v + 1][o + 1],
                                O = f[v][o + 1];
                            l.push(L, C, O), l.push(C, R, O), x += 6
                        }
                    c.addGroup(g, x, 0), g += x
                }(), !1 === o && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(l), this.addAttribute("position", new Pi(h, 3)), this.addAttribute("normal", new Pi(u, 3)), this.addAttribute("uv", new Pi(d, 2))
            }

            function qo(t, e, i, n, r, o, a) {
                Wo.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: i,
                    heightSegments: n,
                    openEnded: r,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function Yo(t, e, i, n, r, o, a) {
                Xo.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: i,
                    heightSegments: n,
                    openEnded: r,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function Zo(t, e, i, n) {
                _i.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: i,
                    thetaLength: n
                }, this.fromBufferGeometry(new Jo(t, e, i, n)), this.mergeVertices()
            }

            function Jo(t, e, i, n) {
                Ii.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: i,
                    thetaLength: n
                }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
                var r, o, a = [],
                    s = [],
                    c = [],
                    l = [],
                    h = new je,
                    u = new Ge;
                for (s.push(0, 0, 0), c.push(0, 0, 1), l.push(.5, .5), o = 0, r = 3; o <= e; o++, r += 3) {
                    var d = i + o / e * n;
                    h.x = t * Math.cos(d), h.y = t * Math.sin(d), s.push(h.x, h.y, h.z), c.push(0, 0, 1), u.x = (s[r] / t + 1) / 2, u.y = (s[r + 1] / t + 1) / 2, l.push(u.x, u.y)
                }
                for (r = 1; r <= e; r++) a.push(r, r + 1, 0);
                this.setIndex(a), this.addAttribute("position", new Pi(s, 3)), this.addAttribute("normal", new Pi(c, 3)), this.addAttribute("uv", new Pi(l, 2))
            }
            Io.prototype = Object.create(_i.prototype), Io.prototype.constructor = Io, Do.prototype = Object.create(Co.prototype), Do.prototype.constructor = Do, ko.prototype = Object.create(_i.prototype), ko.prototype.constructor = ko, No.prototype = Object.create(Ii.prototype), No.prototype.constructor = No, Bo.prototype = Object.create(_i.prototype), Bo.prototype.constructor = Bo, Fo.prototype = Object.create(Ii.prototype), Fo.prototype.constructor = Fo, zo.prototype = Object.create(_i.prototype), zo.prototype.constructor = zo, Uo.prototype = Object.create(Ii.prototype), Uo.prototype.constructor = Uo, Go.prototype = Object.create(_i.prototype), Go.prototype.constructor = Go, Go.prototype.toJSON = function() {
                var t = _i.prototype.toJSON.call(this);
                return Vo(this.parameters.shapes, t)
            }, Ho.prototype = Object.create(Ii.prototype), Ho.prototype.constructor = Ho, Ho.prototype.toJSON = function() {
                var t = Ii.prototype.toJSON.call(this);
                return Vo(this.parameters.shapes, t)
            }, jo.prototype = Object.create(Ii.prototype), jo.prototype.constructor = jo, Wo.prototype = Object.create(_i.prototype), Wo.prototype.constructor = Wo, Xo.prototype = Object.create(Ii.prototype), Xo.prototype.constructor = Xo, qo.prototype = Object.create(Wo.prototype), qo.prototype.constructor = qo, Yo.prototype = Object.create(Xo.prototype), Yo.prototype.constructor = Yo, Zo.prototype = Object.create(_i.prototype), Zo.prototype.constructor = Zo, Jo.prototype = Object.create(Ii.prototype), Jo.prototype.constructor = Jo;
            var Ko = Object.freeze({
                WireframeGeometry: Fr,
                ParametricGeometry: zr,
                ParametricBufferGeometry: Ur,
                TetrahedronGeometry: Vr,
                TetrahedronBufferGeometry: jr,
                OctahedronGeometry: Wr,
                OctahedronBufferGeometry: Xr,
                IcosahedronGeometry: qr,
                IcosahedronBufferGeometry: Yr,
                DodecahedronGeometry: Zr,
                DodecahedronBufferGeometry: Jr,
                PolyhedronGeometry: Gr,
                PolyhedronBufferGeometry: Hr,
                TubeGeometry: Kr,
                TubeBufferGeometry: Qr,
                TorusKnotGeometry: $r,
                TorusKnotBufferGeometry: to,
                TorusGeometry: eo,
                TorusBufferGeometry: io,
                TextGeometry: Io,
                TextBufferGeometry: Do,
                SphereGeometry: ko,
                SphereBufferGeometry: No,
                RingGeometry: Bo,
                RingBufferGeometry: Fo,
                PlaneGeometry: Ni,
                PlaneBufferGeometry: Bi,
                LatheGeometry: zo,
                LatheBufferGeometry: Uo,
                ShapeGeometry: Go,
                ShapeBufferGeometry: Ho,
                ExtrudeGeometry: Lo,
                ExtrudeBufferGeometry: Co,
                EdgesGeometry: jo,
                ConeGeometry: qo,
                ConeBufferGeometry: Yo,
                CylinderGeometry: Wo,
                CylinderBufferGeometry: Xo,
                CircleGeometry: Zo,
                CircleBufferGeometry: Jo,
                BoxGeometry: Di,
                BoxBufferGeometry: ki
            });

            function Qo(t) {
                zi.call(this), this.type = "ShadowMaterial", this.color = new ci(0), this.transparent = !0, this.setValues(t)
            }

            function $o(t) {
                Ui.call(this, t), this.type = "RawShaderMaterial"
            }

            function ta(t) {
                zi.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new ci(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ci(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function ea(t) {
                ta.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
            }

            function ia(t) {
                zi.call(this), this.type = "MeshPhongMaterial", this.color = new ci(16777215), this.specular = new ci(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ci(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function na(t) {
                ia.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
            }

            function ra(t) {
                zi.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function oa(t) {
                zi.call(this), this.type = "MeshLambertMaterial", this.color = new ci(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ci(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function aa(t) {
                zi.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new ci(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fe, this.normalScale = new Ge(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t)
            }

            function sa(t) {
                Pr.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            Qo.prototype = Object.create(zi.prototype), Qo.prototype.constructor = Qo, Qo.prototype.isShadowMaterial = !0, Qo.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this
            }, $o.prototype = Object.create(Ui.prototype), $o.prototype.constructor = $o, $o.prototype.isRawShaderMaterial = !0, ta.prototype = Object.create(zi.prototype), ta.prototype.constructor = ta, ta.prototype.isMeshStandardMaterial = !0, ta.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, ea.prototype = Object.create(ta.prototype), ea.prototype.constructor = ea, ea.prototype.isMeshPhysicalMaterial = !0, ea.prototype.copy = function(t) {
                return ta.prototype.copy.call(this, t), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
            }, ia.prototype = Object.create(zi.prototype), ia.prototype.constructor = ia, ia.prototype.isMeshPhongMaterial = !0, ia.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, na.prototype = Object.create(ia.prototype), na.prototype.constructor = na, na.prototype.isMeshToonMaterial = !0, na.prototype.copy = function(t) {
                return ia.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
            }, ra.prototype = Object.create(zi.prototype), ra.prototype.constructor = ra, ra.prototype.isMeshNormalMaterial = !0, ra.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, oa.prototype = Object.create(zi.prototype), oa.prototype.constructor = oa, oa.prototype.isMeshLambertMaterial = !0, oa.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, aa.prototype = Object.create(zi.prototype), aa.prototype.constructor = aa, aa.prototype.isMeshMatcapMaterial = !0, aa.prototype.copy = function(t) {
                return zi.prototype.copy.call(this, t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, sa.prototype = Object.create(Pr.prototype), sa.prototype.constructor = sa, sa.prototype.isLineDashedMaterial = !0, sa.prototype.copy = function(t) {
                return Pr.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var ca = Object.freeze({
                    ShadowMaterial: Qo,
                    SpriteMaterial: wr,
                    RawShaderMaterial: $o,
                    ShaderMaterial: Ui,
                    PointsMaterial: Or,
                    MeshPhysicalMaterial: ea,
                    MeshStandardMaterial: ta,
                    MeshPhongMaterial: ia,
                    MeshToonMaterial: na,
                    MeshNormalMaterial: ra,
                    MeshLambertMaterial: oa,
                    MeshDepthMaterial: ir,
                    MeshDistanceMaterial: nr,
                    MeshBasicMaterial: Vi,
                    MeshMatcapMaterial: aa,
                    LineDashedMaterial: sa,
                    LineBasicMaterial: Pr,
                    Material: zi
                }),
                la = {
                    arraySlice: function(t, e, i) {
                        return la.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
                    },
                    convertArray: function(t, e, i) {
                        return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    },
                    isTypedArray: function(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    },
                    getKeyframeOrder: function(t) {
                        for (var e = t.length, i = new Array(e), n = 0; n !== e; ++n) i[n] = n;
                        return i.sort(function(e, i) {
                            return t[e] - t[i]
                        }), i
                    },
                    sortedArray: function(t, e, i) {
                        for (var n = t.length, r = new t.constructor(n), o = 0, a = 0; a !== n; ++o)
                            for (var s = i[o] * e, c = 0; c !== e; ++c) r[a++] = t[s + c];
                        return r
                    },
                    flattenJSON: function(t, e, i, n) {
                        for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[n];) o = t[r++];
                        if (void 0 !== o) {
                            var a = o[n];
                            if (void 0 !== a)
                                if (Array.isArray(a))
                                    do {
                                        void 0 !== (a = o[n]) && (e.push(o.time), i.push.apply(i, a)), o = t[r++]
                                    } while (void 0 !== o);
                                else if (void 0 !== a.toArray)
                                do {
                                    void 0 !== (a = o[n]) && (e.push(o.time), a.toArray(i, i.length)), o = t[r++]
                                } while (void 0 !== o);
                            else
                                do {
                                    void 0 !== (a = o[n]) && (e.push(o.time), i.push(a)), o = t[r++]
                                } while (void 0 !== o)
                        }
                    }
                };

            function ha(t, e, i, n) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
            }

            function ua(t, e, i, n) {
                ha.call(this, t, e, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function da(t, e, i, n) {
                ha.call(this, t, e, i, n)
            }

            function pa(t, e, i, n) {
                ha.call(this, t, e, i, n)
            }

            function fa(t, e, i, n) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = la.convertArray(e, this.TimeBufferType), this.values = la.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
            }

            function ma(t, e, i) {
                fa.call(this, t, e, i)
            }

            function ga(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function va(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function ya(t, e, i, n) {
                ha.call(this, t, e, i, n)
            }

            function _a(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function xa(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function ba(t, e, i, n) {
                fa.call(this, t, e, i, n)
            }

            function wa(t, e, i) {
                this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = Ue.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function Ma(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var e = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return va;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return ba;
                        case "color":
                            return ga;
                        case "quaternion":
                            return _a;
                        case "bool":
                        case "boolean":
                            return ma;
                        case "string":
                            return xa
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    var i = [],
                        n = [];
                    la.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            Object.assign(ha.prototype, {
                    evaluate: function(t) {
                        var e = this.parameterPositions,
                            i = this._cachedIndex,
                            n = e[i],
                            r = e[i - 1];
                        t: {
                            e: {
                                var o;i: {
                                    n: if (!(t < n)) {
                                        for (var a = i + 2;;) {
                                            if (void 0 === n) {
                                                if (t < r) break n;
                                                return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, t, r)
                                            }
                                            if (i === a) break;
                                            if (r = n, t < (n = e[++i])) break e
                                        }
                                        o = e.length;
                                        break i
                                    }if (t >= r) break t;
                                    var s = e[1];t < s && (i = 2, r = s);
                                    for (a = i - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                        if (i === a) break;
                                        if (n = r, t >= (r = e[--i - 1])) break e
                                    }
                                    o = i,
                                    i = 0
                                }
                                for (; i < o;) {
                                    var c = i + o >>> 1;
                                    t < e[c] ? o = c : i = c + 1
                                }
                                if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                                if (void 0 === n) return i = e.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, t)
                            }
                            this._cachedIndex = i,
                            this.intervalChanged_(i, r, n)
                        }
                        return this.interpolate_(i, r, t, n)
                    },
                    settings: null,
                    DefaultSettings_: {},
                    getSettings_: function() {
                        return this.settings || this.DefaultSettings_
                    },
                    copySampleValue_: function(t) {
                        for (var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = t * n, o = 0; o !== n; ++o) e[o] = i[r + o];
                        return e
                    },
                    interpolate_: function() {
                        throw new Error("call to abstract method")
                    },
                    intervalChanged_: function() {}
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign(ha.prototype, {
                    beforeStart_: ha.prototype.copySampleValue_,
                    afterEnd_: ha.prototype.copySampleValue_
                }), ua.prototype = Object.assign(Object.create(ha.prototype), {
                    constructor: ua,
                    DefaultSettings_: {
                        endingStart: we,
                        endingEnd: we
                    },
                    intervalChanged_: function(t, e, i) {
                        var n = this.parameterPositions,
                            r = t - 2,
                            o = t + 1,
                            a = n[r],
                            s = n[o];
                        if (void 0 === a) switch (this.getSettings_().endingStart) {
                            case Me:
                                r = t, a = 2 * e - i;
                                break;
                            case Te:
                                a = e + n[r = n.length - 2] - n[r + 1];
                                break;
                            default:
                                r = t, a = i
                        }
                        if (void 0 === s) switch (this.getSettings_().endingEnd) {
                            case Me:
                                o = t, s = 2 * i - e;
                                break;
                            case Te:
                                o = 1, s = i + n[1] - n[0];
                                break;
                            default:
                                o = t - 1, s = e
                        }
                        var c = .5 * (i - e),
                            l = this.valueSize;
                        this._weightPrev = c / (e - a), this._weightNext = c / (s - i), this._offsetPrev = r * l, this._offsetNext = o * l
                    },
                    interpolate_: function(t, e, i, n) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (i - e) / (n - e), f = p * p, m = f * p, g = -u * m + 2 * u * f - u * p, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, _ = d * m - d * f, x = 0; x !== a; ++x) r[x] = g * o[l + x] + v * o[c + x] + y * o[s + x] + _ * o[h + x];
                        return r
                    }
                }), da.prototype = Object.assign(Object.create(ha.prototype), {
                    constructor: da,
                    interpolate_: function(t, e, i, n) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, l = (i - e) / (n - e), h = 1 - l, u = 0; u !== a; ++u) r[u] = o[c + u] * h + o[s + u] * l;
                        return r
                    }
                }), pa.prototype = Object.assign(Object.create(ha.prototype), {
                    constructor: pa,
                    interpolate_: function(t) {
                        return this.copySampleValue_(t - 1)
                    }
                }), Object.assign(fa, {
                    toJSON: function(t) {
                        var e, i = t.constructor;
                        if (void 0 !== i.toJSON) e = i.toJSON(t);
                        else {
                            e = {
                                name: t.name,
                                times: la.convertArray(t.times, Array),
                                values: la.convertArray(t.values, Array)
                            };
                            var n = t.getInterpolation();
                            n !== t.DefaultInterpolation && (e.interpolation = n)
                        }
                        return e.type = t.ValueTypeName, e
                    }
                }), Object.assign(fa.prototype, {
                    constructor: fa,
                    TimeBufferType: Float32Array,
                    ValueBufferType: Float32Array,
                    DefaultInterpolation: xe,
                    InterpolantFactoryMethodDiscrete: function(t) {
                        return new pa(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodLinear: function(t) {
                        return new da(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: function(t) {
                        return new ua(this.times, this.values, this.getValueSize(), t)
                    },
                    setInterpolation: function(t) {
                        var e;
                        switch (t) {
                            case _e:
                                e = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case xe:
                                e = this.InterpolantFactoryMethodLinear;
                                break;
                            case be:
                                e = this.InterpolantFactoryMethodSmooth
                        }
                        if (void 0 === e) {
                            var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                            if (void 0 === this.createInterpolant) {
                                if (t === this.DefaultInterpolation) throw new Error(i);
                                this.setInterpolation(this.DefaultInterpolation)
                            }
                            return console.warn("THREE.KeyframeTrack:", i), this
                        }
                        return this.createInterpolant = e, this
                    },
                    getInterpolation: function() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return _e;
                            case this.InterpolantFactoryMethodLinear:
                                return xe;
                            case this.InterpolantFactoryMethodSmooth:
                                return be
                        }
                    },
                    getValueSize: function() {
                        return this.values.length / this.times.length
                    },
                    shift: function(t) {
                        if (0 !== t)
                            for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
                        return this
                    },
                    scale: function(t) {
                        if (1 !== t)
                            for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                        return this
                    },
                    trim: function(t, e) {
                        for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < t;) ++r;
                        for (; - 1 !== o && i[o] > e;) --o;
                        if (++o, 0 !== r || o !== n) {
                            r >= o && (r = (o = Math.max(o, 1)) - 1);
                            var a = this.getValueSize();
                            this.times = la.arraySlice(i, r, o), this.values = la.arraySlice(this.values, r * a, o * a)
                        }
                        return this
                    },
                    validate: function() {
                        var t = !0,
                            e = this.getValueSize();
                        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                        var i = this.times,
                            n = this.values,
                            r = i.length;
                        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                        for (var o = null, a = 0; a !== r; a++) {
                            var s = i[a];
                            if ("number" == typeof s && isNaN(s)) {
                                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1;
                                break
                            }
                            if (null !== o && o > s) {
                                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1;
                                break
                            }
                            o = s
                        }
                        if (void 0 !== n && la.isTypedArray(n)) {
                            a = 0;
                            for (var c = n.length; a !== c; ++a) {
                                var l = n[a];
                                if (isNaN(l)) {
                                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), t = !1;
                                    break
                                }
                            }
                        }
                        return t
                    },
                    optimize: function() {
                        for (var t = this.times, e = this.values, i = this.getValueSize(), n = this.getInterpolation() === be, r = 1, o = t.length - 1, a = 1; a < o; ++a) {
                            var s = !1,
                                c = t[a];
                            if (c !== t[a + 1] && (1 !== a || c !== c[0]))
                                if (n) s = !0;
                                else
                                    for (var l = a * i, h = l - i, u = l + i, d = 0; d !== i; ++d) {
                                        var p = e[l + d];
                                        if (p !== e[h + d] || p !== e[u + d]) {
                                            s = !0;
                                            break
                                        }
                                    }
                            if (s) {
                                if (a !== r) {
                                    t[r] = t[a];
                                    var f = a * i,
                                        m = r * i;
                                    for (d = 0; d !== i; ++d) e[m + d] = e[f + d]
                                }++r
                            }
                        }
                        if (o > 0) {
                            t[r] = t[o];
                            for (f = o * i, m = r * i, d = 0; d !== i; ++d) e[m + d] = e[f + d];
                            ++r
                        }
                        return r !== t.length && (this.times = la.arraySlice(t, 0, r), this.values = la.arraySlice(e, 0, r * i)), this
                    }
                }), ma.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: ma,
                    ValueTypeName: "bool",
                    ValueBufferType: Array,
                    DefaultInterpolation: _e,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), ga.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: ga,
                    ValueTypeName: "color"
                }), va.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: va,
                    ValueTypeName: "number"
                }), ya.prototype = Object.assign(Object.create(ha.prototype), {
                    constructor: ya,
                    interpolate_: function(t, e, i, n) {
                        for (var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = (i - e) / (n - e), l = s + a; s !== l; s += 4) Ve.slerpFlat(r, 0, o, s - a, o, s, c);
                        return r
                    }
                }), _a.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: _a,
                    ValueTypeName: "quaternion",
                    DefaultInterpolation: xe,
                    InterpolantFactoryMethodLinear: function(t) {
                        return new ya(this.times, this.values, this.getValueSize(), t)
                    },
                    InterpolantFactoryMethodSmooth: void 0
                }), xa.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: xa,
                    ValueTypeName: "string",
                    ValueBufferType: Array,
                    DefaultInterpolation: _e,
                    InterpolantFactoryMethodLinear: void 0,
                    InterpolantFactoryMethodSmooth: void 0
                }), ba.prototype = Object.assign(Object.create(fa.prototype), {
                    constructor: ba,
                    ValueTypeName: "vector"
                }), Object.assign(wa, {
                    parse: function(t) {
                        for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, o = i.length; r !== o; ++r) e.push(Ma(i[r]).scale(n));
                        return new wa(t.name, t.duration, e)
                    },
                    toJSON: function(t) {
                        for (var e = [], i = t.tracks, n = {
                                name: t.name,
                                duration: t.duration,
                                tracks: e,
                                uuid: t.uuid
                            }, r = 0, o = i.length; r !== o; ++r) e.push(fa.toJSON(i[r]));
                        return n
                    },
                    CreateFromMorphTargetSequence: function(t, e, i, n) {
                        for (var r = e.length, o = [], a = 0; a < r; a++) {
                            var s = [],
                                c = [];
                            s.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
                            var l = la.getKeyframeOrder(s);
                            s = la.sortedArray(s, 1, l), c = la.sortedArray(c, 1, l), n || 0 !== s[0] || (s.push(r), c.push(c[0])), o.push(new va(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(1 / i))
                        }
                        return new wa(t, -1, o)
                    },
                    findByName: function(t, e) {
                        var i = t;
                        if (!Array.isArray(t)) {
                            var n = t;
                            i = n.geometry && n.geometry.animations || n.animations
                        }
                        for (var r = 0; r < i.length; r++)
                            if (i[r].name === e) return i[r];
                        return null
                    },
                    CreateClipsFromMorphTargetSequences: function(t, e, i) {
                        for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                            var s = t[o],
                                c = s.name.match(r);
                            if (c && c.length > 1) {
                                var l = n[u = c[1]];
                                l || (n[u] = l = []), l.push(s)
                            }
                        }
                        var h = [];
                        for (var u in n) h.push(wa.CreateFromMorphTargetSequence(u, n[u], e, i));
                        return h
                    },
                    parseAnimation: function(t, e) {
                        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        for (var i = function(t, e, i, n, r) {
                                if (0 !== i.length) {
                                    var o = [],
                                        a = [];
                                    la.flattenJSON(i, o, a, n), 0 !== o.length && r.push(new t(e, o, a))
                                }
                            }, n = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                            var l = s[c].keys;
                            if (l && 0 !== l.length)
                                if (l[0].morphTargets) {
                                    for (var h = {}, u = 0; u < l.length; u++)
                                        if (l[u].morphTargets)
                                            for (var d = 0; d < l[u].morphTargets.length; d++) h[l[u].morphTargets[d]] = -1;
                                    for (var p in h) {
                                        var f = [],
                                            m = [];
                                        for (d = 0; d !== l[u].morphTargets.length; ++d) {
                                            var g = l[u];
                                            f.push(g.time), m.push(g.morphTarget === p ? 1 : 0)
                                        }
                                        n.push(new va(".morphTargetInfluence[" + p + "]", f, m))
                                    }
                                    o = h.length * (a || 1)
                                } else {
                                    var v = ".bones[" + e[c].name + "]";
                                    i(ba, v + ".position", l, "pos", n), i(_a, v + ".quaternion", l, "rot", n), i(ba, v + ".scale", l, "scl", n)
                                }
                        }
                        return 0 === n.length ? null : new wa(r, o, n)
                    }
                }), Object.assign(wa.prototype, {
                    resetDuration: function() {
                        for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
                            var n = this.tracks[e];
                            t = Math.max(t, n.times[n.times.length - 1])
                        }
                        return this.duration = t, this
                    },
                    trim: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                        return this
                    },
                    validate: function() {
                        for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                        return t
                    },
                    optimize: function() {
                        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                        return this
                    }
                });
            var Ta = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function Ea(t, e, i) {
                var n = this,
                    r = !1,
                    o = 0,
                    a = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function(t) {
                    a++, !1 === r && void 0 !== n.onStart && n.onStart(t, o, a), r = !0
                }, this.itemEnd = function(t) {
                    o++, void 0 !== n.onProgress && n.onProgress(t, o, a), o === a && (r = !1, void 0 !== n.onLoad && n.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== n.onError && n.onError(t)
                }, this.resolveURL = function(t) {
                    return s ? s(t) : t
                }, this.setURLModifier = function(t) {
                    return s = t, this
                }
            }
            var Sa = new Ea,
                Aa = {};

            function Pa(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function La(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Ca(t) {
                this.manager = void 0 !== t ? t : Sa, this._parser = null
            }

            function Ra(t) {
                this.manager = void 0 !== t ? t : Sa, this._parser = null
            }

            function Oa(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Ia(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Da(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function ka() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function Na(t, e, i, n, r, o, a, s) {
                ka.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
            }

            function Ba(t, e, i, n, r, o) {
                Na.call(this, t, e, i, i, n, r, o), this.type = "ArcCurve"
            }

            function Fa() {
                var t = 0,
                    e = 0,
                    i = 0,
                    n = 0;

                function r(r, o, a, s) {
                    t = r, e = a, i = -3 * r + 3 * o - 2 * a - s, n = 2 * r - 2 * o + a + s
                }
                return {
                    initCatmullRom: function(t, e, i, n, o) {
                        r(e, i, o * (i - t), o * (n - e))
                    },
                    initNonuniformCatmullRom: function(t, e, i, n, o, a, s) {
                        var c = (e - t) / o - (i - t) / (o + a) + (i - e) / a,
                            l = (i - e) / a - (n - e) / (a + s) + (n - i) / s;
                        r(e, i, c *= a, l *= a)
                    },
                    calc: function(r) {
                        var o = r * r;
                        return t + e * r + i * o + n * (o * r)
                    }
                }
            }
            Object.assign(Pa.prototype, {
                load: function(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Ta.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    if (void 0 === Aa[t]) {
                        var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (a) {
                            var s = a[1],
                                c = !!a[2],
                                l = a[3];
                            l = decodeURIComponent(l), c && (l = atob(l));
                            try {
                                var h, u = (this.responseType || "").toLowerCase();
                                switch (u) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var d = new Uint8Array(l.length), p = 0; p < l.length; p++) d[p] = l.charCodeAt(p);
                                        h = "blob" === u ? new Blob([d.buffer], {
                                            type: s
                                        }) : d.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        h = f.parseFromString(l, s);
                                        break;
                                    case "json":
                                        h = JSON.parse(l);
                                        break;
                                    default:
                                        h = l
                                }
                                setTimeout(function() {
                                    e && e(h), r.manager.itemEnd(t)
                                }, 0)
                            } catch (e) {
                                setTimeout(function() {
                                    n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                                }, 0)
                            }
                        } else {
                            Aa[t] = [], Aa[t].push({
                                onLoad: e,
                                onProgress: i,
                                onError: n
                            });
                            var m = new XMLHttpRequest;
                            for (var g in m.open("GET", t, !0), m.addEventListener("load", function(e) {
                                    var i = this.response;
                                    Ta.add(t, i);
                                    var n = Aa[t];
                                    if (delete Aa[t], 200 === this.status || 0 === this.status) {
                                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                        for (var o = 0, a = n.length; o < a; o++) {
                                            (s = n[o]).onLoad && s.onLoad(i)
                                        }
                                        r.manager.itemEnd(t)
                                    } else {
                                        for (o = 0, a = n.length; o < a; o++) {
                                            var s;
                                            (s = n[o]).onError && s.onError(e)
                                        }
                                        r.manager.itemError(t), r.manager.itemEnd(t)
                                    }
                                }, !1), m.addEventListener("progress", function(e) {
                                    for (var i = Aa[t], n = 0, r = i.length; n < r; n++) {
                                        var o = i[n];
                                        o.onProgress && o.onProgress(e)
                                    }
                                }, !1), m.addEventListener("error", function(e) {
                                    var i = Aa[t];
                                    delete Aa[t];
                                    for (var n = 0, o = i.length; n < o; n++) {
                                        var a = i[n];
                                        a.onError && a.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }, !1), m.addEventListener("abort", function(e) {
                                    var i = Aa[t];
                                    delete Aa[t];
                                    for (var n = 0, o = i.length; n < o; n++) {
                                        var a = i[n];
                                        a.onError && a.onError(e)
                                    }
                                    r.manager.itemError(t), r.manager.itemEnd(t)
                                }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
                            m.send(null)
                        }
                        return r.manager.itemStart(t), m
                    }
                    Aa[t].push({
                        onLoad: e,
                        onProgress: i,
                        onError: n
                    })
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            }), Object.assign(La.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Pa(r.manager);
                    o.setPath(r.path), o.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, i, n)
                },
                parse: function(t, e) {
                    for (var i = [], n = 0; n < t.length; n++) {
                        var r = wa.parse(t[n]);
                        i.push(r)
                    }
                    e(i)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Ca.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = [],
                        a = new kr;
                    a.image = o;
                    var s = new Pa(this.manager);

                    function c(c) {
                        s.load(t[c], function(t) {
                            var i = r._parser(t, !0);
                            o[c] = {
                                width: i.width,
                                height: i.height,
                                format: i.format,
                                mipmaps: i.mipmaps
                            }, 6 === (l += 1) && (1 === i.mipmapCount && (a.minFilter = Mt), a.format = i.format, a.needsUpdate = !0, e && e(a))
                        }, i, n)
                    }
                    if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                        for (var l = 0, h = 0, u = t.length; h < u; ++h) c(h);
                    else s.load(t, function(t) {
                        var i = r._parser(t, !0);
                        if (i.isCubemap)
                            for (var n = i.mipmaps.length / i.mipmapCount, s = 0; s < n; s++) {
                                o[s] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < i.mipmapCount; c++) o[s].mipmaps.push(i.mipmaps[s * i.mipmapCount + c]), o[s].format = i.format, o[s].width = i.width, o[s].height = i.height
                            } else a.image.width = i.width, a.image.height = i.height, a.mipmaps = i.mipmaps;
                        1 === i.mipmapCount && (a.minFilter = Mt), a.format = i.format, a.needsUpdate = !0, e && e(a)
                    }, i, n);
                    return a
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Ra.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Qe,
                        a = new Pa(this.manager);
                    return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(t, function(t) {
                        var i = r._parser(t);
                        i && (void 0 !== i.image ? o.image = i.image : void 0 !== i.data && (o.image.width = i.width, o.image.height = i.height, o.image.data = i.data), o.wrapS = void 0 !== i.wrapS ? i.wrapS : yt, o.wrapT = void 0 !== i.wrapT ? i.wrapT : yt, o.magFilter = void 0 !== i.magFilter ? i.magFilter : Mt, o.minFilter = void 0 !== i.minFilter ? i.minFilter : Et, o.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (o.format = i.format), void 0 !== i.type && (o.type = i.type), void 0 !== i.mipmaps && (o.mipmaps = i.mipmaps), 1 === i.mipmapCount && (o.minFilter = Mt), o.needsUpdate = !0, e && e(o, i))
                    }, i, n), o
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Oa.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Ta.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), Ta.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }

                    function c(e) {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }
                    return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(t), a.src = t, a
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Ia.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, i, n) {
                    var r = new Xi,
                        o = new Oa(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    var a = 0;

                    function s(i) {
                        o.load(t[i], function(t) {
                            r.images[i] = t, 6 === ++a && (r.needsUpdate = !0, e && e(r))
                        }, void 0, n)
                    }
                    for (var c = 0; c < t.length; ++c) s(c);
                    return r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Da.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, i, n) {
                    var r = new Ye,
                        o = new Oa(this.manager);
                    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(i) {
                        r.image = i;
                        var n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        r.format = n ? zt : Ut, r.needsUpdate = !0, void 0 !== e && e(r)
                    }, i, n), r
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(ka.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    var i = this.getUtoTmapping(t);
                    return this.getPoint(i, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                    return e
                },
                getLength: function() {
                    var t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var e, i, n = [],
                        r = this.getPoint(0),
                        o = 0;
                    for (n.push(0), i = 1; i <= t; i++) o += (e = this.getPoint(i / t)).distanceTo(r), n.push(o), r = e;
                    return this.cacheArcLengths = n, n
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    var i, n = this.getLengths(),
                        r = 0,
                        o = n.length;
                    i = e || t * n[o - 1];
                    for (var a, s = 0, c = o - 1; s <= c;)
                        if ((a = n[r = Math.floor(s + (c - s) / 2)] - i) < 0) s = r + 1;
                        else {
                            if (!(a > 0)) {
                                c = r;
                                break
                            }
                            c = r - 1
                        }
                    if (n[r = c] === i) return r / (o - 1);
                    var l = n[r];
                    return (r + (i - l) / (n[r + 1] - l)) / (o - 1)
                },
                getTangent: function(t) {
                    var e = t - 1e-4,
                        i = t + 1e-4;
                    e < 0 && (e = 0), i > 1 && (i = 1);
                    var n = this.getPoint(e);
                    return this.getPoint(i).clone().sub(n).normalize()
                },
                getTangentAt: function(t) {
                    var e = this.getUtoTmapping(t);
                    return this.getTangent(e)
                },
                computeFrenetFrames: function(t, e) {
                    var i, n, r, o = new je,
                        a = [],
                        s = [],
                        c = [],
                        l = new je,
                        h = new He;
                    for (i = 0; i <= t; i++) n = i / t, a[i] = this.getTangentAt(n), a[i].normalize();
                    s[0] = new je, c[0] = new je;
                    var u = Number.MAX_VALUE,
                        d = Math.abs(a[0].x),
                        p = Math.abs(a[0].y),
                        f = Math.abs(a[0].z);
                    for (d <= u && (u = d, o.set(1, 0, 0)), p <= u && (u = p, o.set(0, 1, 0)), f <= u && o.set(0, 0, 1), l.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], l), c[0].crossVectors(a[0], s[0]), i = 1; i <= t; i++) s[i] = s[i - 1].clone(), c[i] = c[i - 1].clone(), l.crossVectors(a[i - 1], a[i]), l.length() > Number.EPSILON && (l.normalize(), r = Math.acos(Ue.clamp(a[i - 1].dot(a[i]), -1, 1)), s[i].applyMatrix4(h.makeRotationAxis(l, r))), c[i].crossVectors(a[i], s[i]);
                    if (!0 === e)
                        for (r = Math.acos(Ue.clamp(s[0].dot(s[t]), -1, 1)), r /= t, a[0].dot(l.crossVectors(s[0], s[t])) > 0 && (r = -r), i = 1; i <= t; i++) s[i].applyMatrix4(h.makeRotationAxis(a[i], r * i)), c[i].crossVectors(a[i], s[i]);
                    return {
                        tangents: a,
                        normals: s,
                        binormals: c
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), Na.prototype = Object.create(ka.prototype), Na.prototype.constructor = Na, Na.prototype.isEllipseCurve = !0, Na.prototype.getPoint = function(t, e) {
                for (var i = e || new Ge, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; r < 0;) r += n;
                for (; r > n;) r -= n;
                r < Number.EPSILON && (r = o ? 0 : n), !0 !== this.aClockwise || o || (r === n ? r = -n : r -= n);
                var a = this.aStartAngle + t * r,
                    s = this.aX + this.xRadius * Math.cos(a),
                    c = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    var l = Math.cos(this.aRotation),
                        h = Math.sin(this.aRotation),
                        u = s - this.aX,
                        d = c - this.aY;
                    s = u * l - d * h + this.aX, c = u * h + d * l + this.aY
                }
                return i.set(s, c)
            }, Na.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Na.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, Na.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, Ba.prototype = Object.create(Na.prototype), Ba.prototype.constructor = Ba, Ba.prototype.isArcCurve = !0;
            var za = new je,
                Ua = new Fa,
                Ga = new Fa,
                Ha = new Fa;

            function Va(t, e, i, n) {
                ka.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || .5
            }

            function ja(t, e, i, n, r) {
                var o = .5 * (n - e),
                    a = .5 * (r - i),
                    s = t * t;
                return (2 * i - 2 * n + o + a) * (t * s) + (-3 * i + 3 * n - 2 * o - a) * s + o * t + i
            }

            function Wa(t, e, i, n) {
                return function(t, e) {
                    var i = 1 - t;
                    return i * i * e
                }(t, e) + function(t, e) {
                    return 2 * (1 - t) * t * e
                }(t, i) + function(t, e) {
                    return t * t * e
                }(t, n)
            }

            function Xa(t, e, i, n, r) {
                return function(t, e) {
                    var i = 1 - t;
                    return i * i * i * e
                }(t, e) + function(t, e) {
                    var i = 1 - t;
                    return 3 * i * i * t * e
                }(t, i) + function(t, e) {
                    return 3 * (1 - t) * t * t * e
                }(t, n) + function(t, e) {
                    return t * t * t * e
                }(t, r)
            }

            function qa(t, e, i, n) {
                ka.call(this), this.type = "CubicBezierCurve", this.v0 = t || new Ge, this.v1 = e || new Ge, this.v2 = i || new Ge, this.v3 = n || new Ge
            }

            function Ya(t, e, i, n) {
                ka.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new je, this.v1 = e || new je, this.v2 = i || new je, this.v3 = n || new je
            }

            function Za(t, e) {
                ka.call(this), this.type = "LineCurve", this.v1 = t || new Ge, this.v2 = e || new Ge
            }

            function Ja(t, e) {
                ka.call(this), this.type = "LineCurve3", this.v1 = t || new je, this.v2 = e || new je
            }

            function Ka(t, e, i) {
                ka.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new Ge, this.v1 = e || new Ge, this.v2 = i || new Ge
            }

            function Qa(t, e, i) {
                ka.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new je, this.v1 = e || new je, this.v2 = i || new je
            }

            function $a(t) {
                ka.call(this), this.type = "SplineCurve", this.points = t || []
            }
            Va.prototype = Object.create(ka.prototype), Va.prototype.constructor = Va, Va.prototype.isCatmullRomCurve3 = !0, Va.prototype.getPoint = function(t, e) {
                var i, n, r, o, a = e || new je,
                    s = this.points,
                    c = s.length,
                    l = (c - (this.closed ? 0 : 1)) * t,
                    h = Math.floor(l),
                    u = l - h;
                if (this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / c) + 1) * c : 0 === u && h === c - 1 && (h = c - 2, u = 1), this.closed || h > 0 ? i = s[(h - 1) % c] : (za.subVectors(s[0], s[1]).add(s[0]), i = za), n = s[h % c], r = s[(h + 1) % c], this.closed || h + 2 < c ? o = s[(h + 2) % c] : (za.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), o = za), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var d = "chordal" === this.curveType ? .5 : .25,
                        p = Math.pow(i.distanceToSquared(n), d),
                        f = Math.pow(n.distanceToSquared(r), d),
                        m = Math.pow(r.distanceToSquared(o), d);
                    f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), Ua.initNonuniformCatmullRom(i.x, n.x, r.x, o.x, p, f, m), Ga.initNonuniformCatmullRom(i.y, n.y, r.y, o.y, p, f, m), Ha.initNonuniformCatmullRom(i.z, n.z, r.z, o.z, p, f, m)
                } else "catmullrom" === this.curveType && (Ua.initCatmullRom(i.x, n.x, r.x, o.x, this.tension), Ga.initCatmullRom(i.y, n.y, r.y, o.y, this.tension), Ha.initCatmullRom(i.z, n.z, r.z, o.z, this.tension));
                return a.set(Ua.calc(u), Ga.calc(u), Ha.calc(u)), a
            }, Va.prototype.copy = function(t) {
                ka.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push(n.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, Va.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, i = this.points.length; e < i; e++) {
                    var n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, Va.prototype.fromJSON = function(t) {
                ka.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push((new je).fromArray(n))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, qa.prototype = Object.create(ka.prototype), qa.prototype.constructor = qa, qa.prototype.isCubicBezierCurve = !0, qa.prototype.getPoint = function(t, e) {
                var i = e || new Ge,
                    n = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return i.set(Xa(t, n.x, r.x, o.x, a.x), Xa(t, n.y, r.y, o.y, a.y)), i
            }, qa.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, qa.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, qa.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, Ya.prototype = Object.create(ka.prototype), Ya.prototype.constructor = Ya, Ya.prototype.isCubicBezierCurve3 = !0, Ya.prototype.getPoint = function(t, e) {
                var i = e || new je,
                    n = this.v0,
                    r = this.v1,
                    o = this.v2,
                    a = this.v3;
                return i.set(Xa(t, n.x, r.x, o.x, a.x), Xa(t, n.y, r.y, o.y, a.y), Xa(t, n.z, r.z, o.z, a.z)), i
            }, Ya.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, Ya.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, Ya.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, Za.prototype = Object.create(ka.prototype), Za.prototype.constructor = Za, Za.prototype.isLineCurve = !0, Za.prototype.getPoint = function(t, e) {
                var i = e || new Ge;
                return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
            }, Za.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, Za.prototype.getTangent = function() {
                return this.v2.clone().sub(this.v1).normalize()
            }, Za.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Za.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Za.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Ja.prototype = Object.create(ka.prototype), Ja.prototype.constructor = Ja, Ja.prototype.isLineCurve3 = !0, Ja.prototype.getPoint = function(t, e) {
                var i = e || new je;
                return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i
            }, Ja.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, Ja.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Ja.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Ja.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Ka.prototype = Object.create(ka.prototype), Ka.prototype.constructor = Ka, Ka.prototype.isQuadraticBezierCurve = !0, Ka.prototype.getPoint = function(t, e) {
                var i = e || new Ge,
                    n = this.v0,
                    r = this.v1,
                    o = this.v2;
                return i.set(Wa(t, n.x, r.x, o.x), Wa(t, n.y, r.y, o.y)), i
            }, Ka.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Ka.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Ka.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Qa.prototype = Object.create(ka.prototype), Qa.prototype.constructor = Qa, Qa.prototype.isQuadraticBezierCurve3 = !0, Qa.prototype.getPoint = function(t, e) {
                var i = e || new je,
                    n = this.v0,
                    r = this.v1,
                    o = this.v2;
                return i.set(Wa(t, n.x, r.x, o.x), Wa(t, n.y, r.y, o.y), Wa(t, n.z, r.z, o.z)), i
            }, Qa.prototype.copy = function(t) {
                return ka.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Qa.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Qa.prototype.fromJSON = function(t) {
                return ka.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, $a.prototype = Object.create(ka.prototype), $a.prototype.constructor = $a, $a.prototype.isSplineCurve = !0, $a.prototype.getPoint = function(t, e) {
                var i = e || new Ge,
                    n = this.points,
                    r = (n.length - 1) * t,
                    o = Math.floor(r),
                    a = r - o,
                    s = n[0 === o ? o : o - 1],
                    c = n[o],
                    l = n[o > n.length - 2 ? n.length - 1 : o + 1],
                    h = n[o > n.length - 3 ? n.length - 1 : o + 2];
                return i.set(ja(a, s.x, c.x, l.x, h.x), ja(a, s.y, c.y, l.y, h.y)), i
            }, $a.prototype.copy = function(t) {
                ka.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push(n.clone())
                }
                return this
            }, $a.prototype.toJSON = function() {
                var t = ka.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, i = this.points.length; e < i; e++) {
                    var n = this.points[e];
                    t.points.push(n.toArray())
                }
                return t
            }, $a.prototype.fromJSON = function(t) {
                ka.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, i = t.points.length; e < i; e++) {
                    var n = t.points[e];
                    this.points.push((new Ge).fromArray(n))
                }
                return this
            };
            var ts = Object.freeze({
                ArcCurve: Ba,
                CatmullRomCurve3: Va,
                CubicBezierCurve: qa,
                CubicBezierCurve3: Ya,
                EllipseCurve: Na,
                LineCurve: Za,
                LineCurve3: Ja,
                QuadraticBezierCurve: Ka,
                QuadraticBezierCurve3: Qa,
                SplineCurve: $a
            });

            function es() {
                ka.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function is(t) {
                es.call(this), this.type = "Path", this.currentPoint = new Ge, t && this.setFromPoints(t)
            }

            function ns(t) {
                is.call(this, t), this.uuid = Ue.generateUUID(), this.type = "Shape", this.holes = []
            }

            function rs(t, e) {
                vi.call(this), this.type = "Light", this.color = new ci(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
            }

            function os(t, e, i) {
                rs.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(vi.DefaultUp), this.updateMatrix(), this.groundColor = new ci(e)
            }

            function as(t) {
                this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new Ge(512, 512), this.map = null, this.matrix = new He
            }

            function ss() {
                as.call(this, new lr(50, 1, .5, 500))
            }

            function cs(t, e, i, n, r, o) {
                rs.call(this, t, e), this.type = "SpotLight", this.position.copy(vi.DefaultUp), this.updateMatrix(), this.target = new vi, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new ss
            }

            function ls(t, e, i, n) {
                rs.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new as(new lr(90, 1, .5, 500))
            }

            function hs(t, e, i, n, r, o) {
                cr.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
            }

            function us() {
                as.call(this, new hs(-5, 5, 5, -5, .5, 500))
            }

            function ds(t, e) {
                rs.call(this, t, e), this.type = "DirectionalLight", this.position.copy(vi.DefaultUp), this.updateMatrix(), this.target = new vi, this.shadow = new us
            }

            function ps(t, e) {
                rs.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
            }

            function fs(t, e, i, n) {
                rs.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
            }

            function ms(t) {
                this.manager = void 0 !== t ? t : Sa, this.textures = {}
            }
            es.prototype = Object.assign(Object.create(ka.prototype), {
                constructor: es,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    var t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new Za(e, t))
                },
                getPoint: function(t) {
                    for (var e = t * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) {
                        if (i[n] >= e) {
                            var r = i[n] - e,
                                o = this.curves[n],
                                a = o.getLength(),
                                s = 0 === a ? 0 : 1 - r / a;
                            return o.getPointAt(s)
                        }
                        n++
                    }
                    return null
                },
                getLength: function() {
                    var t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
                        for (var o = r[n], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), c = 0; c < s.length; c++) {
                            var l = s[c];
                            e && e.equals(l) || (i.push(l), e = l)
                        }
                    return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
                },
                copy: function(t) {
                    ka.prototype.copy.call(this, t), this.curves = [];
                    for (var e = 0, i = t.curves.length; e < i; e++) {
                        var n = t.curves[e];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    var t = ka.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (var e = 0, i = this.curves.length; e < i; e++) {
                        var n = this.curves[e];
                        t.curves.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    ka.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (var e = 0, i = t.curves.length; e < i; e++) {
                        var n = t.curves[e];
                        this.curves.push((new ts[n.type]).fromJSON(n))
                    }
                    return this
                }
            }), is.prototype = Object.assign(Object.create(es.prototype), {
                constructor: is,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
                },
                moveTo: function(t, e) {
                    this.currentPoint.set(t, e)
                },
                lineTo: function(t, e) {
                    var i = new Za(this.currentPoint.clone(), new Ge(t, e));
                    this.curves.push(i), this.currentPoint.set(t, e)
                },
                quadraticCurveTo: function(t, e, i, n) {
                    var r = new Ka(this.currentPoint.clone(), new Ge(t, e), new Ge(i, n));
                    this.curves.push(r), this.currentPoint.set(i, n)
                },
                bezierCurveTo: function(t, e, i, n, r, o) {
                    var a = new qa(this.currentPoint.clone(), new Ge(t, e), new Ge(i, n), new Ge(r, o));
                    this.curves.push(a), this.currentPoint.set(r, o)
                },
                splineThru: function(t) {
                    var e = new $a([this.currentPoint.clone()].concat(t));
                    this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
                },
                arc: function(t, e, i, n, r, o) {
                    var a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(t + a, e + s, i, n, r, o)
                },
                absarc: function(t, e, i, n, r, o) {
                    this.absellipse(t, e, i, i, n, r, o)
                },
                ellipse: function(t, e, i, n, r, o, a, s) {
                    var c = this.currentPoint.x,
                        l = this.currentPoint.y;
                    this.absellipse(t + c, e + l, i, n, r, o, a, s)
                },
                absellipse: function(t, e, i, n, r, o, a, s) {
                    var c = new Na(t, e, i, n, r, o, a, s);
                    if (this.curves.length > 0) {
                        var l = c.getPoint(0);
                        l.equals(this.currentPoint) || this.lineTo(l.x, l.y)
                    }
                    this.curves.push(c);
                    var h = c.getPoint(1);
                    this.currentPoint.copy(h)
                },
                copy: function(t) {
                    return es.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    var t = es.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return es.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), ns.prototype = Object.assign(Object.create(is.prototype), {
                constructor: ns,
                getPointsHoles: function(t) {
                    for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    is.prototype.copy.call(this, t), this.holes = [];
                    for (var e = 0, i = t.holes.length; e < i; e++) {
                        var n = t.holes[e];
                        this.holes.push(n.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var t = is.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (var e = 0, i = this.holes.length; e < i; e++) {
                        var n = this.holes[e];
                        t.holes.push(n.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    is.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (var e = 0, i = t.holes.length; e < i; e++) {
                        var n = t.holes[e];
                        this.holes.push((new is).fromJSON(n))
                    }
                    return this
                }
            }), rs.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: rs,
                isLight: !0,
                copy: function(t) {
                    return vi.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), os.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: os,
                isHemisphereLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(as.prototype, {
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), ss.prototype = Object.assign(Object.create(as.prototype), {
                constructor: ss,
                isSpotLightShadow: !0,
                update: function(t) {
                    var e = this.camera,
                        i = 2 * Ue.RAD2DEG * t.angle,
                        n = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    i === e.fov && n === e.aspect && r === e.far || (e.fov = i, e.aspect = n, e.far = r, e.updateProjectionMatrix())
                }
            }), cs.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: cs,
                isSpotLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), ls.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: ls,
                isPointLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), hs.prototype = Object.assign(Object.create(cr.prototype), {
                constructor: hs,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return cr.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, i, n, r, o) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        i = (this.right + this.left) / 2,
                        n = (this.top + this.bottom) / 2,
                        r = i - t,
                        o = i + t,
                        a = n + e,
                        s = n - e;
                    if (null !== this.view && this.view.enabled) {
                        var c = this.zoom / (this.view.width / this.view.fullWidth),
                            l = this.zoom / (this.view.height / this.view.fullHeight),
                            h = (this.right - this.left) / this.view.width,
                            u = (this.top - this.bottom) / this.view.height;
                        o = (r += h * (this.view.offsetX / c)) + h * (this.view.width / c), s = (a -= u * (this.view.offsetY / l)) - u * (this.view.height / l)
                    }
                    this.projectionMatrix.makeOrthographic(r, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = vi.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), us.prototype = Object.assign(Object.create(as.prototype), {
                constructor: us
            }), ds.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: ds,
                isDirectionalLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), ps.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: ps,
                isAmbientLight: !0
            }), fs.prototype = Object.assign(Object.create(rs.prototype), {
                constructor: fs,
                isRectAreaLight: !0,
                copy: function(t) {
                    return rs.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    var e = rs.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            }), Object.assign(ms.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Pa(r.manager);
                    o.setPath(r.path), o.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, i, n)
                },
                parse: function(t) {
                    var e = this.textures;

                    function i(t) {
                        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                    }
                    var n = new ca[t.type];
                    if (void 0 !== t.uuid && (n.uuid = t.uuid), void 0 !== t.name && (n.name = t.name), void 0 !== t.color && n.color.setHex(t.color), void 0 !== t.roughness && (n.roughness = t.roughness), void 0 !== t.metalness && (n.metalness = t.metalness), void 0 !== t.emissive && n.emissive.setHex(t.emissive), void 0 !== t.specular && n.specular.setHex(t.specular), void 0 !== t.shininess && (n.shininess = t.shininess), void 0 !== t.clearCoat && (n.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (n.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors), void 0 !== t.fog && (n.fog = t.fog), void 0 !== t.flatShading && (n.flatShading = t.flatShading), void 0 !== t.blending && (n.blending = t.blending), void 0 !== t.combine && (n.combine = t.combine), void 0 !== t.side && (n.side = t.side), void 0 !== t.opacity && (n.opacity = t.opacity), void 0 !== t.transparent && (n.transparent = t.transparent), void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest), void 0 !== t.depthTest && (n.depthTest = t.depthTest), void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite), void 0 !== t.wireframe && (n.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (n.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (n.rotation = t.rotation), 1 !== t.linewidth && (n.linewidth = t.linewidth), void 0 !== t.dashSize && (n.dashSize = t.dashSize), void 0 !== t.gapSize && (n.gapSize = t.gapSize), void 0 !== t.scale && (n.scale = t.scale), void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (n.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (n.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (n.skinning = t.skinning), void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets), void 0 !== t.dithering && (n.dithering = t.dithering), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.uniforms)
                        for (var r in t.uniforms) {
                            var o = t.uniforms[r];
                            switch (n.uniforms[r] = {}, o.type) {
                                case "t":
                                    n.uniforms[r].value = i(o.value);
                                    break;
                                case "c":
                                    n.uniforms[r].value = (new ci).setHex(o.value);
                                    break;
                                case "v2":
                                    n.uniforms[r].value = (new Ge).fromArray(o.value);
                                    break;
                                case "v3":
                                    n.uniforms[r].value = (new je).fromArray(o.value);
                                    break;
                                case "v4":
                                    n.uniforms[r].value = (new Ze).fromArray(o.value);
                                    break;
                                case "m4":
                                    n.uniforms[r].value = (new He).fromArray(o.value);
                                    break;
                                default:
                                    n.uniforms[r].value = o.value
                            }
                        }
                    if (void 0 !== t.defines && (n.defines = t.defines), void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader), void 0 !== t.shading && (n.flatShading = 1 === t.shading), void 0 !== t.size && (n.size = t.size), void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (n.map = i(t.map)), void 0 !== t.alphaMap && (n.alphaMap = i(t.alphaMap), n.transparent = !0), void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)), void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale), void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)), void 0 !== t.normalMapType && (n.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                        var a = t.normalScale;
                        !1 === Array.isArray(a) && (a = [a, a]), n.normalScale = (new Ge).fromArray(a)
                    }
                    return void 0 !== t.displacementMap && (n.displacementMap = i(t.displacementMap)), void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)), void 0 !== t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)), void 0 !== t.emissiveMap && (n.emissiveMap = i(t.emissiveMap)), void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)), void 0 !== t.envMap && (n.envMap = i(t.envMap)), void 0 !== t.envMapIntensity && (n.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity), void 0 !== t.lightMap && (n.lightMap = i(t.lightMap)), void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)), void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (n.gradientMap = i(t.gradientMap)), n
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setTextures: function(t) {
                    return this.textures = t, this
                }
            });
            var gs = {
                decodeText: function(t) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                    for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
                    return decodeURIComponent(escape(e))
                },
                extractUrlBase: function(t) {
                    var e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1)
                }
            };

            function vs(t) {
                this.manager = void 0 !== t ? t : Sa
            }
            Object.assign(vs.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Pa(r.manager);
                    o.setPath(r.path), o.load(t, function(t) {
                        e(r.parse(JSON.parse(t)))
                    }, i, n)
                },
                parse: function(t) {
                    var e = new Ii,
                        i = t.data.index;
                    if (void 0 !== i) {
                        var n = new ys[i.type](i.array);
                        e.setIndex(new xi(n, 1))
                    }
                    var r = t.data.attributes;
                    for (var o in r) {
                        var a = r[o];
                        n = new ys[a.type](a.array);
                        e.addAttribute(o, new xi(n, a.itemSize, a.normalized))
                    }
                    var s = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== s)
                        for (var c = 0, l = s.length; c !== l; ++c) {
                            var h = s[c];
                            e.addGroup(h.start, h.count, h.materialIndex)
                        }
                    var u = t.data.boundingSphere;
                    if (void 0 !== u) {
                        var d = new je;
                        void 0 !== u.center && d.fromArray(u.center), e.boundingSphere = new ti(d, u.radius)
                    }
                    return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            });
            var ys = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function _s(t) {
                this.manager = void 0 !== t ? t : Sa, this.resourcePath = ""
            }
            Object.assign(_s.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, i, n) {
                    var r = this,
                        o = void 0 === this.path ? gs.extractUrlBase(t) : this.path;
                    this.resourcePath = this.resourcePath || o;
                    var a = new Pa(r.manager);
                    a.setPath(this.path), a.load(t, function(i) {
                        var o = null;
                        try {
                            o = JSON.parse(i)
                        } catch (e) {
                            return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                        }
                        var a = o.metadata;
                        void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                    }, i, n)
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                parse: function(t, e) {
                    var i = this.parseShape(t.shapes),
                        n = this.parseGeometries(t.geometries, i),
                        r = this.parseImages(t.images, function() {
                            void 0 !== e && e(s)
                        }),
                        o = this.parseTextures(t.textures, r),
                        a = this.parseMaterials(t.materials, o),
                        s = this.parseObject(t.object, n, a);
                    return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
                },
                parseShape: function(t) {
                    var e = {};
                    if (void 0 !== t)
                        for (var i = 0, n = t.length; i < n; i++) {
                            var r = (new ns).fromJSON(t[i]);
                            e[r.uuid] = r
                        }
                    return e
                },
                parseGeometries: function(e, i) {
                    var n = {};
                    if (void 0 !== e)
                        for (var r = new vs, o = 0, a = e.length; o < a; o++) {
                            var s, c = e[o];
                            switch (c.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new Ko[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new Ko[c.type](c.width, c.height, c.depth, c.widthSegments, c.heightSegments, c.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new Ko[c.type](c.radiusTop, c.radiusBottom, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.height, c.radialSegments, c.heightSegments, c.openEnded, c.thetaStart, c.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.widthSegments, c.heightSegments, c.phiStart, c.phiLength, c.thetaStart, c.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new Ko[c.type](c.innerRadius, c.outerRadius, c.thetaSegments, c.phiSegments, c.thetaStart, c.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.tube, c.radialSegments, c.tubularSegments, c.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new Ko[c.type](c.radius, c.tube, c.tubularSegments, c.radialSegments, c.p, c.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new Ko[c.type](c.points, c.segments, c.phiStart, c.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new Ko[c.type](c.vertices, c.indices, c.radius, c.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var l = [], h = 0, u = c.shapes.length; h < u; h++) {
                                        var d = i[c.shapes[h]];
                                        l.push(d)
                                    }
                                    s = new Ko[c.type](l, c.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (l = [], h = 0, u = c.shapes.length; h < u; h++) {
                                        d = i[c.shapes[h]];
                                        l.push(d)
                                    }
                                    var p = c.options.extrudePath;
                                    void 0 !== p && (c.options.extrudePath = (new ts[p.type]).fromJSON(p)), s = new Ko[c.type](l, c.options);
                                    break;
                                case "BufferGeometry":
                                    s = r.parse(c);
                                    break;
                                case "Geometry":
                                    if ("THREE" in window && "LegacyJSONLoader" in t) s = (new t.LegacyJSONLoader).parse(c, this.resourcePath).geometry;
                                    else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"');
                                    continue
                            }
                            s.uuid = c.uuid, void 0 !== c.name && (s.name = c.name), !0 === s.isBufferGeometry && void 0 !== c.userData && (s.userData = c.userData), n[c.uuid] = s
                        }
                    return n
                },
                parseMaterials: function(t, e) {
                    var i = {},
                        n = {};
                    if (void 0 !== t) {
                        var r = new ms;
                        r.setTextures(e);
                        for (var o = 0, a = t.length; o < a; o++) {
                            var s = t[o];
                            if ("MultiMaterial" === s.type) {
                                for (var c = [], l = 0; l < s.materials.length; l++) {
                                    var h = s.materials[l];
                                    void 0 === i[h.uuid] && (i[h.uuid] = r.parse(h)), c.push(i[h.uuid])
                                }
                                n[s.uuid] = c
                            } else n[s.uuid] = r.parse(s), i[s.uuid] = n[s.uuid]
                        }
                    }
                    return n
                },
                parseAnimations: function(t) {
                    for (var e = [], i = 0; i < t.length; i++) {
                        var n = t[i],
                            r = wa.parse(n);
                        void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
                    }
                    return e
                },
                parseImages: function(t, e) {
                    var i = this,
                        n = {};

                    function r(t) {
                        return i.manager.itemStart(t), o.load(t, function() {
                            i.manager.itemEnd(t)
                        }, void 0, function() {
                            i.manager.itemError(t), i.manager.itemEnd(t)
                        })
                    }
                    if (void 0 !== t && t.length > 0) {
                        var o = new Oa(new Ea(e));
                        o.setCrossOrigin(this.crossOrigin);
                        for (var a = 0, s = t.length; a < s; a++) {
                            var c = t[a],
                                l = c.url;
                            if (Array.isArray(l)) {
                                n[c.uuid] = [];
                                for (var h = 0, u = l.length; h < u; h++) {
                                    var d = l[h],
                                        p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : i.resourcePath + d;
                                    n[c.uuid].push(r(p))
                                }
                            } else {
                                p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i.resourcePath + c.url;
                                n[c.uuid] = r(p)
                            }
                        }
                    }
                    return n
                },
                parseTextures: function(t, e) {
                    function i(t, e) {
                        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                    }
                    var n = {};
                    if (void 0 !== t)
                        for (var r = 0, o = t.length; r < o; r++) {
                            var a, s = t[r];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(e[s.image]) ? new Xi(e[s.image]) : new Ye(e[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = i(s.mapping, bs)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = i(s.wrap[0], ws), a.wrapT = i(s.wrap[1], ws)), void 0 !== s.format && (a.format = s.format), void 0 !== s.minFilter && (a.minFilter = i(s.minFilter, Ms)), void 0 !== s.magFilter && (a.magFilter = i(s.magFilter, Ms)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), n[s.uuid] = a
                        }
                    return n
                },
                parseObject: function(t, e, i) {
                    var n;

                    function r(t) {
                        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                    }

                    function o(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], n = 0, r = t.length; n < r; n++) {
                                    var o = t[n];
                                    void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(i[o])
                                }
                                return e
                            }
                            return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t), i[t]
                        }
                    }
                    switch (t.type) {
                        case "Scene":
                            n = new _r, void 0 !== t.background && Number.isInteger(t.background) && (n.background = new ci(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? n.fog = new yr(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (n.fog = new vr(t.fog.color, t.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            n = new lr(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (n.focus = t.focus), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.filmGauge && (n.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (n.filmOffset = t.filmOffset), void 0 !== t.view && (n.view = Object.assign({}, t.view));
                            break;
                        case "OrthographicCamera":
                            n = new hs(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (n.zoom = t.zoom), void 0 !== t.view && (n.view = Object.assign({}, t.view));
                            break;
                        case "AmbientLight":
                            n = new ps(t.color, t.intensity);
                            break;
                        case "DirectionalLight":
                            n = new ds(t.color, t.intensity);
                            break;
                        case "PointLight":
                            n = new ls(t.color, t.intensity, t.distance, t.decay);
                            break;
                        case "RectAreaLight":
                            n = new fs(t.color, t.intensity, t.width, t.height);
                            break;
                        case "SpotLight":
                            n = new cs(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                            break;
                        case "HemisphereLight":
                            n = new os(t.color, t.groundColor, t.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var a = r(t.geometry),
                                s = o(t.material);
                            n = a.bones && a.bones.length > 0 ? new Er(a, s) : new ji(a, s);
                            break;
                        case "LOD":
                            n = new Tr;
                            break;
                        case "Line":
                            n = new Lr(r(t.geometry), o(t.material), t.mode);
                            break;
                        case "LineLoop":
                            n = new Rr(r(t.geometry), o(t.material));
                            break;
                        case "LineSegments":
                            n = new Cr(r(t.geometry), o(t.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            n = new Ir(r(t.geometry), o(t.material));
                            break;
                        case "Sprite":
                            n = new Mr(o(t.material));
                            break;
                        case "Group":
                            n = new sr;
                            break;
                        default:
                            n = new vi
                    }
                    if (n.uuid = t.uuid, void 0 !== t.name && (n.name = t.name), void 0 !== t.matrix ? (n.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (n.matrixAutoUpdate = t.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== t.position && n.position.fromArray(t.position), void 0 !== t.rotation && n.rotation.fromArray(t.rotation), void 0 !== t.quaternion && n.quaternion.fromArray(t.quaternion), void 0 !== t.scale && n.scale.fromArray(t.scale)), void 0 !== t.castShadow && (n.castShadow = t.castShadow), void 0 !== t.receiveShadow && (n.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (n.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (n.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && n.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (n.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (n.visible = t.visible), void 0 !== t.frustumCulled && (n.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (n.renderOrder = t.renderOrder), void 0 !== t.userData && (n.userData = t.userData), void 0 !== t.layers && (n.layers.mask = t.layers), void 0 !== t.children)
                        for (var c = t.children, l = 0; l < c.length; l++) n.add(this.parseObject(c[l], e, i));
                    if ("LOD" === t.type)
                        for (var h = t.levels, u = 0; u < h.length; u++) {
                            var d = h[u],
                                p = n.getObjectByProperty("uuid", d.object);
                            void 0 !== p && n.addLevel(p, d.distance)
                        }
                    return n
                }
            });
            var xs, bs = {
                    UVMapping: lt,
                    CubeReflectionMapping: ht,
                    CubeRefractionMapping: ut,
                    EquirectangularReflectionMapping: dt,
                    EquirectangularRefractionMapping: pt,
                    SphericalReflectionMapping: ft,
                    CubeUVReflectionMapping: mt,
                    CubeUVRefractionMapping: gt
                },
                ws = {
                    RepeatWrapping: vt,
                    ClampToEdgeWrapping: yt,
                    MirroredRepeatWrapping: _t
                },
                Ms = {
                    NearestFilter: xt,
                    NearestMipMapNearestFilter: bt,
                    NearestMipMapLinearFilter: wt,
                    LinearFilter: Mt,
                    LinearMipMapNearestFilter: Tt,
                    LinearMipMapLinearFilter: Et
                };

            function Ts(t) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : Sa, this.options = void 0
            }

            function Es() {
                this.type = "ShapePath", this.color = new ci, this.subPaths = [], this.currentPath = null
            }

            function Ss(t) {
                this.type = "Font", this.data = t
            }

            function As(t, e, i, n, r) {
                var o = r.glyphs[t] || r.glyphs["?"];
                if (o) {
                    var a, s, c, l, h, u, d, p, f = new Es;
                    if (o.o)
                        for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), g = 0, v = m.length; g < v;) {
                            switch (m[g++]) {
                                case "m":
                                    a = m[g++] * e + i, s = m[g++] * e + n, f.moveTo(a, s);
                                    break;
                                case "l":
                                    a = m[g++] * e + i, s = m[g++] * e + n, f.lineTo(a, s);
                                    break;
                                case "q":
                                    c = m[g++] * e + i, l = m[g++] * e + n, h = m[g++] * e + i, u = m[g++] * e + n, f.quadraticCurveTo(h, u, c, l);
                                    break;
                                case "b":
                                    c = m[g++] * e + i, l = m[g++] * e + n, h = m[g++] * e + i, u = m[g++] * e + n, d = m[g++] * e + i, p = m[g++] * e + n, f.bezierCurveTo(h, u, d, p, c, l)
                            }
                        }
                    return {
                        offsetX: o.ha * e,
                        path: f
                    }
                }
            }

            function Ps(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Ls() {}
            Ts.prototype = {
                constructor: Ts,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var r = this,
                        o = Ta.get(t);
                    if (void 0 !== o) return r.manager.itemStart(t), setTimeout(function() {
                        e && e(o), r.manager.itemEnd(t)
                    }, 0), o;
                    fetch(t).then(function(t) {
                        return t.blob()
                    }).then(function(t) {
                        return createImageBitmap(t, r.options)
                    }).then(function(i) {
                        Ta.add(t, i), e && e(i), r.manager.itemEnd(t)
                    }).catch(function(e) {
                        n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    })
                },
                setCrossOrigin: function() {
                    return this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }, Object.assign(Es.prototype, {
                moveTo: function(t, e) {
                    this.currentPath = new is, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
                },
                lineTo: function(t, e) {
                    this.currentPath.lineTo(t, e)
                },
                quadraticCurveTo: function(t, e, i, n) {
                    this.currentPath.quadraticCurveTo(t, e, i, n)
                },
                bezierCurveTo: function(t, e, i, n, r, o) {
                    this.currentPath.bezierCurveTo(t, e, i, n, r, o)
                },
                splineThru: function(t) {
                    this.currentPath.splineThru(t)
                },
                toShapes: function(t, e) {
                    function i(t) {
                        for (var e = [], i = 0, n = t.length; i < n; i++) {
                            var r = t[i],
                                o = new ns;
                            o.curves = r.curves, e.push(o)
                        }
                        return e
                    }

                    function n(t, e) {
                        for (var i = e.length, n = !1, r = i - 1, o = 0; o < i; r = o++) {
                            var a = e[r],
                                s = e[o],
                                c = s.x - a.x,
                                l = s.y - a.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (a = e[o], c = -c, s = e[r], l = -l), t.y < a.y || t.y > s.y) continue;
                                if (t.y === a.y) {
                                    if (t.x === a.x) return !0
                                } else {
                                    var h = l * (t.x - a.x) - c * (t.y - a.y);
                                    if (0 === h) return !0;
                                    if (h < 0) continue;
                                    n = !n
                                }
                            } else {
                                if (t.y !== a.y) continue;
                                if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                            }
                        }
                        return n
                    }
                    var r = So.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === e) return i(o);
                    var a, s, c, l = [];
                    if (1 === o.length) return s = o[0], (c = new ns).curves = s.curves, l.push(c), l;
                    var h = !r(o[0].getPoints());
                    h = t ? !h : h;
                    var u, d, p = [],
                        f = [],
                        m = [],
                        g = 0;
                    f[g] = void 0, m[g] = [];
                    for (var v = 0, y = o.length; v < y; v++) a = r(u = (s = o[v]).getPoints()), (a = t ? !a : a) ? (!h && f[g] && g++, f[g] = {
                        s: new ns,
                        p: u
                    }, f[g].s.curves = s.curves, h && g++, m[g] = []) : m[g].push({
                        h: s,
                        p: u[0]
                    });
                    if (!f[0]) return i(o);
                    if (f.length > 1) {
                        for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) p[b] = [];
                        for (b = 0, w = f.length; b < w; b++)
                            for (var M = m[b], T = 0; T < M.length; T++) {
                                for (var E = M[T], S = !0, A = 0; A < f.length; A++) n(E.p, f[A].p) && (b !== A && x.push({
                                    froms: b,
                                    tos: A,
                                    hole: T
                                }), S ? (S = !1, p[A].push(E)) : _ = !0);
                                S && p[b].push(E)
                            }
                        x.length > 0 && (_ || (m = p))
                    }
                    v = 0;
                    for (var P = f.length; v < P; v++) {
                        c = f[v].s, l.push(c);
                        for (var L = 0, C = (d = m[v]).length; L < C; L++) c.holes.push(d[L].h)
                    }
                    return l
                }
            }), Object.assign(Ss.prototype, {
                isFont: !0,
                generateShapes: function(t, e) {
                    void 0 === e && (e = 100);
                    for (var i = [], n = function(t, e, i) {
                            for (var n = Array.from ? Array.from(t) : String(t).split(""), r = e / i.resolution, o = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, a = [], s = 0, c = 0, l = 0; l < n.length; l++) {
                                var h = n[l];
                                if ("\n" === h) s = 0, c -= o;
                                else {
                                    var u = As(h, r, s, c, i);
                                    s += u.offsetX, a.push(u.path)
                                }
                            }
                            return a
                        }(t, e, this.data), r = 0, o = n.length; r < o; r++) Array.prototype.push.apply(i, n[r].toShapes());
                    return i
                }
            }), Object.assign(Ps.prototype, {
                load: function(t, e, i, n) {
                    var r = this,
                        o = new Pa(this.manager);
                    o.setPath(this.path), o.load(t, function(t) {
                        var i;
                        try {
                            i = JSON.parse(t)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var n = r.parse(i);
                        e && e(n)
                    }, i, n)
                },
                parse: function(t) {
                    return new Ss(t)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Ls.Handlers = {
                handlers: [],
                add: function(t, e) {
                    this.handlers.push(t, e)
                },
                get: function(t) {
                    for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                        var r = e[i],
                            o = e[i + 1];
                        if (r.test(t)) return o
                    }
                    return null
                }
            }, Object.assign(Ls.prototype, {
                crossOrigin: "anonymous",
                onLoadStart: function() {},
                onLoadProgress: function() {},
                onLoadComplete: function() {},
                initMaterials: function(t, e, i) {
                    for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
                    return n
                },
                createMaterial: function() {
                    var t = {
                            NoBlending: T,
                            NormalBlending: E,
                            AdditiveBlending: S,
                            SubtractiveBlending: A,
                            MultiplyBlending: P,
                            CustomBlending: L
                        },
                        e = new ci,
                        i = new Da,
                        n = new ms;
                    return function(r, o, a) {
                        var s = {};

                        function c(t, e, n, r, c) {
                            var l, h = o + t,
                                u = Ls.Handlers.get(h);
                            null !== u ? l = u.load(h) : (i.setCrossOrigin(a), l = i.load(h)), void 0 !== e && (l.repeat.fromArray(e), 1 !== e[0] && (l.wrapS = vt), 1 !== e[1] && (l.wrapT = vt)), void 0 !== n && l.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (l.wrapS = vt), "mirror" === r[0] && (l.wrapS = _t), "repeat" === r[1] && (l.wrapT = vt), "mirror" === r[1] && (l.wrapT = _t)), void 0 !== c && (l.anisotropy = c);
                            var d = Ue.generateUUID();
                            return s[d] = l, d
                        }
                        var l = {
                            uuid: Ue.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                        for (var h in r) {
                            var u = r[h];
                            switch (h) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    l.name = u;
                                    break;
                                case "blending":
                                    l.blending = t[u];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", h, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    l.color = e.fromArray(u).getHex();
                                    break;
                                case "colorSpecular":
                                    l.specular = e.fromArray(u).getHex();
                                    break;
                                case "colorEmissive":
                                    l.emissive = e.fromArray(u).getHex();
                                    break;
                                case "specularCoef":
                                    l.shininess = u;
                                    break;
                                case "shading":
                                    "basic" === u.toLowerCase() && (l.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (l.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (l.type = "MeshStandardMaterial");
                                    break;
                                case "mapDiffuse":
                                    l.map = c(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapEmissive":
                                    l.emissiveMap = c(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                                    break;
                                case "mapEmissiveRepeat":
                                case "mapEmissiveOffset":
                                case "mapEmissiveWrap":
                                case "mapEmissiveAnisotropy":
                                    break;
                                case "mapLight":
                                    l.lightMap = c(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    l.aoMap = c(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    l.bumpMap = c(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    l.bumpScale = u;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    l.normalMap = c(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    l.normalScale = u;
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    l.specularMap = c(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapMetalness":
                                    l.metalnessMap = c(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                                    break;
                                case "mapMetalnessRepeat":
                                case "mapMetalnessOffset":
                                case "mapMetalnessWrap":
                                case "mapMetalnessAnisotropy":
                                    break;
                                case "mapRoughness":
                                    l.roughnessMap = c(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                                    break;
                                case "mapRoughnessRepeat":
                                case "mapRoughnessOffset":
                                case "mapRoughnessWrap":
                                case "mapRoughnessAnisotropy":
                                    break;
                                case "mapAlpha":
                                    l.alphaMap = c(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    l.side = v;
                                    break;
                                case "doubleSided":
                                    l.side = y;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), l.opacity = u;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    l[h] = u;
                                    break;
                                case "vertexColors":
                                    !0 === u && (l.vertexColors = M), "face" === u && (l.vertexColors = w);
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", h, u)
                            }
                        }
                        return "MeshBasicMaterial" === l.type && delete l.emissive, "MeshPhongMaterial" !== l.type && delete l.specular, l.opacity < 1 && (l.transparent = !0), n.setTextures(s), n.parse(l)
                    }
                }()
            });
            var Cs = {
                getContext: function() {
                    return void 0 === xs && (xs = new(window.AudioContext || window.webkitAudioContext)), xs
                },
                setContext: function(t) {
                    xs = t
                }
            };

            function Rs(t) {
                this.manager = void 0 !== t ? t : Sa
            }

            function Os() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new lr, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new lr, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }

            function Is(t, e, i, n) {
                vi.call(this), this.type = "CubeCamera";
                var r = new lr(90, 1, t, e);
                r.up.set(0, -1, 0), r.lookAt(new je(1, 0, 0)), this.add(r);
                var o = new lr(90, 1, t, e);
                o.up.set(0, -1, 0), o.lookAt(new je(-1, 0, 0)), this.add(o);
                var a = new lr(90, 1, t, e);
                a.up.set(0, 0, 1), a.lookAt(new je(0, 1, 0)), this.add(a);
                var s = new lr(90, 1, t, e);
                s.up.set(0, 0, -1), s.lookAt(new je(0, -1, 0)), this.add(s);
                var c = new lr(90, 1, t, e);
                c.up.set(0, -1, 0), c.lookAt(new je(0, 0, 1)), this.add(c);
                var l = new lr(90, 1, t, e);
                l.up.set(0, -1, 0), l.lookAt(new je(0, 0, -1)), this.add(l), n = n || {
                    format: zt,
                    magFilter: Mt,
                    minFilter: Mt
                }, this.renderTarget = new Ke(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    var i = this.renderTarget,
                        n = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, i.activeCubeFace = 0, t.render(e, r, i), i.activeCubeFace = 1, t.render(e, o, i), i.activeCubeFace = 2, t.render(e, a, i), i.activeCubeFace = 3, t.render(e, s, i), i.activeCubeFace = 4, t.render(e, c, i), i.texture.generateMipmaps = n, i.activeCubeFace = 5, t.render(e, l, i), t.setRenderTarget(null)
                }, this.clear = function(t, e, i, n) {
                    for (var r = this.renderTarget, o = 0; o < 6; o++) r.activeCubeFace = o, t.setRenderTarget(r), t.clear(e, i, n);
                    t.setRenderTarget(null)
                }
            }

            function Ds(t) {
                this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }

            function ks() {
                vi.call(this), this.type = "AudioListener", this.context = Cs.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
            }

            function Ns(t) {
                vi.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }

            function Bs(t) {
                Ns.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }

            function Fs(t, e) {
                this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }

            function zs(t, e, i) {
                this.binding = t, this.valueSize = i;
                var n, r = Float64Array;
                switch (e) {
                    case "quaternion":
                        n = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        r = Array, n = this._select;
                        break;
                    default:
                        n = this._lerp
                }
                this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }
            Object.assign(Rs.prototype, {
                load: function(t, e, i, n) {
                    var r = new Pa(this.manager);
                    r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function(t) {
                        var i = t.slice(0);
                        Cs.getContext().decodeAudioData(i, function(t) {
                            e(t)
                        })
                    }, i, n)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(Os.prototype, {
                update: function() {
                    var t, e, i, n, r, o, a, s, c = new He,
                        l = new He;
                    return function(h) {
                        if (t !== this || e !== h.focus || i !== h.fov || n !== h.aspect * this.aspect || r !== h.near || o !== h.far || a !== h.zoom || s !== this.eyeSep) {
                            t = this, e = h.focus, i = h.fov, n = h.aspect * this.aspect, r = h.near, o = h.far, a = h.zoom;
                            var u, d, p = h.projectionMatrix.clone(),
                                f = (s = this.eyeSep / 2) * r / e,
                                m = r * Math.tan(Ue.DEG2RAD * i * .5) / a;
                            l.elements[12] = -s, c.elements[12] = s, u = -m * n + f, d = m * n + f, p.elements[0] = 2 * r / (d - u), p.elements[8] = (d + u) / (d - u), this.cameraL.projectionMatrix.copy(p), u = -m * n - f, d = m * n - f, p.elements[0] = 2 * r / (d - u), p.elements[8] = (d + u) / (d - u), this.cameraR.projectionMatrix.copy(p)
                        }
                        this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(l), this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(c)
                    }
                }()
            }), Is.prototype = Object.create(vi.prototype), Is.prototype.constructor = Is, Object.assign(Ds.prototype, {
                start: function() {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var e = ("undefined" == typeof performance ? Date : performance).now();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            }), ks.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: ks,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(t) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                },
                updateMatrixWorld: function() {
                    var t = new je,
                        e = new Ve,
                        i = new je,
                        n = new je,
                        r = new Ds;
                    return function(o) {
                        vi.prototype.updateMatrixWorld.call(this, o);
                        var a = this.context.listener,
                            s = this.up;
                        if (this.timeDelta = r.getDelta(), this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), a.positionX) {
                            var c = this.context.currentTime + this.timeDelta;
                            a.positionX.linearRampToValueAtTime(t.x, c), a.positionY.linearRampToValueAtTime(t.y, c), a.positionZ.linearRampToValueAtTime(t.z, c), a.forwardX.linearRampToValueAtTime(n.x, c), a.forwardY.linearRampToValueAtTime(n.y, c), a.forwardZ.linearRampToValueAtTime(n.z, c), a.upX.linearRampToValueAtTime(s.x, c), a.upY.linearRampToValueAtTime(s.y, c), a.upZ.linearRampToValueAtTime(s.z, c)
                        } else a.setPosition(t.x, t.y, t.z), a.setOrientation(n.x, n.y, n.z, s.x, s.y, s.z)
                    }
                }()
            }), Ns.prototype = Object.assign(Object.create(vi.prototype), {
                constructor: Ns,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                },
                setMediaElementSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                },
                setBuffer: function(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function() {
                    if (!0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) {
                            var t = this.context.createBufferSource();
                            return t.buffer = this.buffer, t.detune.value = this.detune, t.loop = this.loop, t.onended = this.onEnded.bind(this), t.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.connect()
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    } else console.warn("THREE.Audio: Audio is already playing.")
                },
                pause: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function() {
                    if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(t) {
                    return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
                },
                setDetune: function(t) {
                    return this.detune = t, !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                },
                getDetune: function() {
                    return this.detune
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(t) {
                    return this.setFilters(t ? [t] : [])
                },
                setPlaybackRate: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = !1
                },
                getLoop: function() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }), Bs.prototype = Object.assign(Object.create(Ns.prototype), {
                constructor: Bs,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(t) {
                    return this.panner.refDistance = t, this
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(t) {
                    return this.panner.rolloffFactor = t, this
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(t) {
                    return this.panner.distanceModel = t, this
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(t) {
                    return this.panner.maxDistance = t, this
                },
                setDirectionalCone: function(t, e, i) {
                    return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this
                },
                updateMatrixWorld: function() {
                    var t = new je,
                        e = new Ve,
                        i = new je,
                        n = new je;
                    return function(r) {
                        vi.prototype.updateMatrixWorld.call(this, r);
                        var o = this.panner;
                        if (this.matrixWorld.decompose(t, e, i), n.set(0, 0, 1).applyQuaternion(e), o.positionX) {
                            var a = this.context.currentTime + this.listener.timeDelta;
                            o.positionX.linearRampToValueAtTime(t.x, a), o.positionY.linearRampToValueAtTime(t.y, a), o.positionZ.linearRampToValueAtTime(t.z, a), o.orientationX.linearRampToValueAtTime(n.x, a), o.orientationY.linearRampToValueAtTime(n.y, a), o.orientationZ.linearRampToValueAtTime(n.z, a)
                        } else o.setPosition(t.x, t.y, t.z), o.setOrientation(n.x, n.y, n.z)
                    }
                }()
            }), Object.assign(Fs.prototype, {
                getFrequencyData: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function() {
                    for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
                    return t / e.length
                }
            }), Object.assign(zs.prototype, {
                accumulate: function(t, e) {
                    var i = this.buffer,
                        n = this.valueSize,
                        r = t * n + n,
                        o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== n; ++a) i[r + a] = i[a];
                        o = e
                    } else {
                        var s = e / (o += e);
                        this._mixBufferRegion(i, r, 0, s, n)
                    }
                    this.cumulativeWeight = o
                },
                apply: function(t) {
                    var e = this.valueSize,
                        i = this.buffer,
                        n = t * e + e,
                        r = this.cumulativeWeight,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, r < 1) {
                        var a = 3 * e;
                        this._mixBufferRegion(i, n, a, 1 - r, e)
                    }
                    for (var s = e, c = e + e; s !== c; ++s)
                        if (i[s] !== i[s + e]) {
                            o.setValue(i, n);
                            break
                        }
                },
                saveOriginalState: function() {
                    var t = this.binding,
                        e = this.buffer,
                        i = this.valueSize,
                        n = 3 * i;
                    t.getValue(e, n);
                    for (var r = i, o = n; r !== o; ++r) e[r] = e[n + r % i];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _select: function(t, e, i, n, r) {
                    if (n >= .5)
                        for (var o = 0; o !== r; ++o) t[e + o] = t[i + o]
                },
                _slerp: function(t, e, i, n) {
                    Ve.slerpFlat(t, e, t, e, t, i, n)
                },
                _lerp: function(t, e, i, n, r) {
                    for (var o = 1 - n, a = 0; a !== r; ++a) {
                        var s = e + a;
                        t[s] = t[s] * o + t[i + a] * n
                    }
                }
            });
            var Us, Gs;

            function Hs(t, e, i) {
                var n = i || Vs.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, n)
            }

            function Vs(t, e, i) {
                this.path = e, this.parsedPath = i || Vs.parseTrackName(e), this.node = Vs.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }

            function js() {
                this.uuid = Ue.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var t = {};
                this._indicesByUUID = t;
                for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var n = this;
                this.stats = {
                    objects: {
                        get total() {
                            return n._objects.length
                        },
                        get inUse() {
                            return this.total - n.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return n._bindings.length
                    }
                }
            }

            function Ws(t, e, i) {
                this._mixer = t, this._clip = e, this._localRoot = i || null;
                for (var n = e.tracks, r = n.length, o = new Array(r), a = {
                        endingStart: we,
                        endingEnd: we
                    }, s = 0; s !== r; ++s) {
                    var c = n[s].createInterpolant(null);
                    o[s] = c, c.settings = a
                }
                this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ve, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function Xs(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function qs(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }

            function Ys() {
                Ii.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function Zs(t, e, i) {
                xr.call(this, t, e), this.meshPerAttribute = i || 1
            }

            function Js(t, e, i, n) {
                "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), xi.call(this, t, e, i), this.meshPerAttribute = n || 1
            }

            function Ks(t, e, i, n) {
                this.ray = new Gi(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function Qs(t, e) {
                return t.distance - e.distance
            }

            function $s(t, e, i, n) {
                if (!1 !== t.visible && (t.raycast(e, i), !0 === n))
                    for (var r = t.children, o = 0, a = r.length; o < a; o++) $s(r[o], e, i, !0)
            }

            function tc(t, e, i) {
                return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
            }

            function ec(t, e, i) {
                return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
            }

            function ic(t, e) {
                this.min = void 0 !== t ? t : new Ge(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new Ge(-1 / 0, -1 / 0)
            }

            function nc(t, e) {
                this.start = void 0 !== t ? t : new je, this.end = void 0 !== e ? e : new je
            }

            function rc(t) {
                vi.call(this), this.material = t, this.render = function() {}
            }

            function oc(t, e, i, n) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== i ? i : 16711680,
                    o = void 0 !== n ? n : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
                var c = new Ii,
                    l = new Pi(2 * a * 3, 3);
                c.addAttribute("position", l), Cr.call(this, c, new Pr({
                    color: r,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function ac(t, e) {
                vi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                for (var i = new Ii, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, o = 1; r < 32; r++, o++) {
                    var a = r / 32 * Math.PI * 2,
                        s = o / 32 * Math.PI * 2;
                    n.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
                }
                i.addAttribute("position", new Pi(n, 3));
                var c = new Pr({
                    fog: !1
                });
                this.cone = new Cr(i, c), this.add(this.cone), this.update()
            }

            function sc(t) {
                for (var e = function t(e) {
                        var i = [];
                        e && e.isBone && i.push(e);
                        for (var n = 0; n < e.children.length; n++) i.push.apply(i, t(e.children[n]));
                        return i
                    }(t), i = new Ii, n = [], r = [], o = new ci(0, 0, 1), a = new ci(0, 1, 0), s = 0; s < e.length; s++) {
                    var c = e[s];
                    c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b))
                }
                i.addAttribute("position", new Pi(n, 3)), i.addAttribute("color", new Pi(r, 3));
                var l = new Pr({
                    vertexColors: M,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                Cr.call(this, i, l), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }

            function cc(t, e, i) {
                this.light = t, this.light.updateMatrixWorld(), this.color = i;
                var n = new No(e, 4, 2),
                    r = new Vi({
                        wireframe: !0,
                        fog: !1
                    });
                ji.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function lc(t, e) {
                vi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                var i = new Pr({
                        fog: !1
                    }),
                    n = new Ii;
                n.addAttribute("position", new xi(new Float32Array(15), 3)), this.line = new Lr(n, i), this.add(this.line), this.update()
            }

            function hc(t, e, i) {
                vi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
                var n = new Xr(e);
                n.rotateY(.5 * Math.PI), this.material = new Vi({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = M);
                var r = n.getAttribute("position"),
                    o = new Float32Array(3 * r.count);
                n.addAttribute("color", new xi(o, 3)), this.add(new ji(n, this.material)), this.update()
            }

            function uc(t, e, i, n) {
                t = t || 10, e = e || 10, i = new ci(void 0 !== i ? i : 4473924), n = new ci(void 0 !== n ? n : 8947848);
                for (var r = e / 2, o = t / e, a = t / 2, s = [], c = [], l = 0, h = 0, u = -a; l <= e; l++, u += o) {
                    s.push(-a, 0, u, a, 0, u), s.push(u, 0, -a, u, 0, a);
                    var d = l === r ? i : n;
                    d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3, d.toArray(c, h), h += 3
                }
                var p = new Ii;
                p.addAttribute("position", new Pi(s, 3)), p.addAttribute("color", new Pi(c, 3));
                var f = new Pr({
                    vertexColors: M
                });
                Cr.call(this, p, f)
            }

            function dc(t, e, i, n, r, o) {
                t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new ci(void 0 !== r ? r : 4473924), o = new ci(void 0 !== o ? o : 8947848);
                var a, s, c, l, h, u, d, p = [],
                    f = [];
                for (l = 0; l <= e; l++) c = l / e * (2 * Math.PI), a = Math.sin(c) * t, s = Math.cos(c) * t, p.push(0, 0, 0), p.push(a, 0, s), d = 1 & l ? r : o, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
                for (l = 0; l <= i; l++)
                    for (d = 1 & l ? r : o, u = t - t / i * l, h = 0; h < n; h++) c = h / n * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, p.push(a, 0, s), f.push(d.r, d.g, d.b), c = (h + 1) / n * (2 * Math.PI), a = Math.sin(c) * u, s = Math.cos(c) * u, p.push(a, 0, s), f.push(d.r, d.g, d.b);
                var m = new Ii;
                m.addAttribute("position", new Pi(p, 3)), m.addAttribute("color", new Pi(f, 3));
                var g = new Pr({
                    vertexColors: M
                });
                Cr.call(this, m, g)
            }

            function pc(t, e, i, n) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var r = void 0 !== i ? i : 16776960,
                    o = void 0 !== n ? n : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var c = new Ii,
                    l = new Pi(2 * a * 3, 3);
                c.addAttribute("position", l), Cr.call(this, c, new Pr({
                    color: r,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function fc(t, e, i) {
                vi.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1);
                var n = new Ii;
                n.addAttribute("position", new Pi([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                var r = new Pr({
                    fog: !1
                });
                this.lightPlane = new Lr(n, r), this.add(this.lightPlane), (n = new Ii).addAttribute("position", new Pi([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Lr(n, r), this.add(this.targetLine), this.update()
            }

            function mc(t) {
                var e = new Ii,
                    i = new Pr({
                        color: 16777215,
                        vertexColors: w
                    }),
                    n = [],
                    r = [],
                    o = {},
                    a = new ci(16755200),
                    s = new ci(16711680),
                    c = new ci(43775),
                    l = new ci(16777215),
                    h = new ci(3355443);

                function u(t, e, i) {
                    d(t, i), d(e, i)
                }

                function d(t, e) {
                    n.push(0, 0, 0), r.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(n.length / 3 - 1)
                }
                u("n1", "n2", a), u("n2", "n4", a), u("n4", "n3", a), u("n3", "n1", a), u("f1", "f2", a), u("f2", "f4", a), u("f4", "f3", a), u("f3", "f1", a), u("n1", "f1", a), u("n2", "f2", a), u("n3", "f3", a), u("n4", "f4", a), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", c), u("u2", "u3", c), u("u3", "u1", c), u("c", "t", l), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.addAttribute("position", new Pi(n, 3)), e.addAttribute("color", new Pi(r, 3)), Cr.call(this, e, i), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
            }

            function gc(t, e) {
                this.object = t, void 0 === e && (e = 16776960);
                var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    n = new Float32Array(24),
                    r = new Ii;
                r.setIndex(new xi(i, 1)), r.addAttribute("position", new xi(n, 3)), Cr.call(this, r, new Pr({
                    color: e
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function vc(t, e) {
                this.type = "Box3Helper", this.box = t;
                var i = void 0 !== e ? e : 16776960,
                    n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Ii;
                r.setIndex(new xi(n, 1)), r.addAttribute("position", new Pi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Cr.call(this, r, new Pr({
                    color: i
                })), this.geometry.computeBoundingSphere()
            }

            function yc(t, e, i) {
                this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
                var n = void 0 !== i ? i : 16776960,
                    r = new Ii;
                r.addAttribute("position", new Pi([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), Lr.call(this, r, new Pr({
                    color: n
                }));
                var o = new Ii;
                o.addAttribute("position", new Pi([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new ji(o, new Vi({
                    color: n,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }

            function _c(e, i, n, r, o, a) {
                vi.call(this), void 0 === e && (e = new t.Vector3(0, 0, 1)), void 0 === i && (i = new t.Vector3(0, 0, 0)), void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === o && (o = .2 * n), void 0 === a && (a = .2 * o), void 0 === Us && ((Us = new Ii).addAttribute("position", new Pi([0, 0, 0, 0, 1, 0], 3)), (Gs = new Xo(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(i), this.line = new Lr(Us, new Pr({
                    color: r
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ji(Gs, new Vi({
                    color: r
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, o, a)
            }

            function xc(t) {
                var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    i = new Ii;
                i.addAttribute("position", new Pi(e, 3)), i.addAttribute("color", new Pi([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var n = new Pr({
                    vertexColors: M
                });
                Cr.call(this, i, n)
            }

            function bc(t, e, i, n, r, o, a) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new pi(t, e, i, r, o, a)
            }
            Object.assign(Hs.prototype, {
                    getValue: function(t, e) {
                        this.bind();
                        var i = this._targetGroup.nCachedObjects_,
                            n = this._bindings[i];
                        void 0 !== n && n.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
                    },
                    bind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
                    },
                    unbind: function() {
                        for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
                    }
                }), Object.assign(Vs, {
                    Composite: Hs,
                    create: function(t, e, i) {
                        return t && t.isAnimationObjectGroup ? new Vs.Composite(t, e, i) : new Vs(t, e, i)
                    },
                    sanitizeNodeName: function() {
                        var t = new RegExp("[\\[\\]\\.:\\/]", "g");
                        return function(e) {
                            return e.replace(/\s/g, "_").replace(t, "")
                        }
                    }(),
                    parseTrackName: function() {
                        var t = "[^\\[\\]\\.:\\/]",
                            e = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                            i = /((?:WC+[\/:])*)/.source.replace("WC", t),
                            n = /(WCOD+)?/.source.replace("WCOD", e),
                            r = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t),
                            o = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t),
                            a = new RegExp("^" + i + n + r + o + "$"),
                            s = ["material", "materials", "bones"];
                        return function(t) {
                            var e = a.exec(t);
                            if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                            var i = {
                                    nodeName: e[2],
                                    objectName: e[3],
                                    objectIndex: e[4],
                                    propertyName: e[5],
                                    propertyIndex: e[6]
                                },
                                n = i.nodeName && i.nodeName.lastIndexOf(".");
                            if (void 0 !== n && -1 !== n) {
                                var r = i.nodeName.substring(n + 1); - 1 !== s.indexOf(r) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r)
                            }
                            if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                            return i
                        }
                    }(),
                    findNode: function(t, e) {
                        if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                        if (t.skeleton) {
                            var i = t.skeleton.getBoneByName(e);
                            if (void 0 !== i) return i
                        }
                        if (t.children) {
                            var n = function(t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        if (r.name === e || r.uuid === e) return r;
                                        var o = n(r.children);
                                        if (o) return o
                                    }
                                    return null
                                },
                                r = n(t.children);
                            if (r) return r
                        }
                        return null
                    }
                }), Object.assign(Vs.prototype, {
                    _getValue_unavailable: function() {},
                    _setValue_unavailable: function() {},
                    BindingType: {
                        Direct: 0,
                        EntireArray: 1,
                        ArrayElement: 2,
                        HasFromToArray: 3
                    },
                    Versioning: {
                        None: 0,
                        NeedsUpdate: 1,
                        MatrixWorldNeedsUpdate: 2
                    },
                    GetterByBindingType: [function(t, e) {
                        t[e] = this.node[this.propertyName]
                    }, function(t, e) {
                        for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
                    }, function(t, e) {
                        t[e] = this.resolvedProperty[this.propertyIndex]
                    }, function(t, e) {
                        this.resolvedProperty.toArray(t, e)
                    }],
                    SetterByBindingTypeAndVersioning: [
                        [function(t, e) {
                            this.targetObject[this.propertyName] = t[e]
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
                        }, function(t, e) {
                            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                            this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e]
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                        }],
                        [function(t, e) {
                            this.resolvedProperty.fromArray(t, e)
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                        }, function(t, e) {
                            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                        }]
                    ],
                    getValue: function(t, e) {
                        this.bind(), this.getValue(t, e)
                    },
                    setValue: function(t, e) {
                        this.bind(), this.setValue(t, e)
                    },
                    bind: function() {
                        var t = this.node,
                            e = this.parsedPath,
                            i = e.objectName,
                            n = e.propertyName,
                            r = e.propertyIndex;
                        if (t || (t = Vs.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                            if (i) {
                                var o = e.objectIndex;
                                switch (i) {
                                    case "materials":
                                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                        t = t.material.materials;
                                        break;
                                    case "bones":
                                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                        t = t.skeleton.bones;
                                        for (var a = 0; a < t.length; a++)
                                            if (t[a].name === o) {
                                                o = a;
                                                break
                                            }
                                        break;
                                    default:
                                        if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                        t = t[i]
                                }
                                if (void 0 !== o) {
                                    if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                    t = t[o]
                                }
                            }
                            var s = t[n];
                            if (void 0 !== s) {
                                var c = this.Versioning.None;
                                this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                                var l = this.BindingType.Direct;
                                if (void 0 !== r) {
                                    if ("morphTargetInfluences" === n) {
                                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                        if (t.geometry.isBufferGeometry) {
                                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                            for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                                if (t.geometry.morphAttributes.position[a].name === r) {
                                                    r = a;
                                                    break
                                                }
                                        } else {
                                            if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                            for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                                if (t.geometry.morphTargets[a].name === r) {
                                                    r = a;
                                                    break
                                                }
                                        }
                                    }
                                    l = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (l = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                                this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][c]
                            } else {
                                var h = e.nodeName;
                                console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + n + " but it wasn't found.", t)
                            }
                        } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                    },
                    unbind: function() {
                        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                }),
                //!\ DECLARE ALIAS AFTER assign prototype !
                Object.assign(Vs.prototype, {
                    _getValue_unbound: Vs.prototype.getValue,
                    _setValue_unbound: Vs.prototype.setValue
                }), Object.assign(js.prototype, {
                    isAnimationObjectGroup: !0,
                    add: function() {
                        for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, l = 0, h = arguments.length; l !== h; ++l) {
                            var u = arguments[l],
                                d = u.uuid,
                                p = n[d];
                            if (void 0 === p) {
                                p = e++, n[d] = p, t.push(u);
                                for (var f = 0, m = s; f !== m; ++f) a[f].push(new Vs(u, r[f], o[f]))
                            } else if (p < i) {
                                c = t[p];
                                var g = --i,
                                    v = t[g];
                                n[v.uuid] = p, t[p] = v, n[d] = g, t[g] = u;
                                for (f = 0, m = s; f !== m; ++f) {
                                    var y = a[f],
                                        _ = y[g],
                                        x = y[p];
                                    y[p] = _, void 0 === x && (x = new Vs(u, r[f], o[f])), y[g] = x
                                }
                            } else t[p] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                        }
                        this.nCachedObjects_ = i
                    },
                    remove: function() {
                        for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, a = arguments.length; o !== a; ++o) {
                            var s = arguments[o],
                                c = s.uuid,
                                l = i[c];
                            if (void 0 !== l && l >= e) {
                                var h = e++,
                                    u = t[h];
                                i[u.uuid] = l, t[l] = u, i[c] = h, t[h] = s;
                                for (var d = 0, p = r; d !== p; ++d) {
                                    var f = n[d],
                                        m = f[h],
                                        g = f[l];
                                    f[l] = m, f[h] = g
                                }
                            }
                        }
                        this.nCachedObjects_ = e
                    },
                    uncache: function() {
                        for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) {
                            var c = arguments[a].uuid,
                                l = n[c];
                            if (void 0 !== l)
                                if (delete n[c], l < i) {
                                    var h = --i,
                                        u = t[h],
                                        d = t[v = --e];
                                    n[u.uuid] = l, t[l] = u, n[d.uuid] = h, t[h] = d, t.pop();
                                    for (var p = 0, f = o; p !== f; ++p) {
                                        var m = (y = r[p])[h],
                                            g = y[v];
                                        y[l] = m, y[h] = g, y.pop()
                                    }
                                } else {
                                    var v;
                                    n[(d = t[v = --e]).uuid] = l, t[l] = d, t.pop();
                                    for (p = 0, f = o; p !== f; ++p) {
                                        var y;
                                        (y = r[p])[l] = y[v], y.pop()
                                    }
                                }
                        }
                        this.nCachedObjects_ = i
                    },
                    subscribe_: function(t, e) {
                        var i = this._bindingsIndicesByPath,
                            n = i[t],
                            r = this._bindings;
                        if (void 0 !== n) return r[n];
                        var o = this._paths,
                            a = this._parsedPaths,
                            s = this._objects,
                            c = s.length,
                            l = this.nCachedObjects_,
                            h = new Array(c);
                        n = r.length, i[t] = n, o.push(t), a.push(e), r.push(h);
                        for (var u = l, d = s.length; u !== d; ++u) {
                            var p = s[u];
                            h[u] = new Vs(p, t, e)
                        }
                        return h
                    },
                    unsubscribe_: function(t) {
                        var e = this._bindingsIndicesByPath,
                            i = e[t];
                        if (void 0 !== i) {
                            var n = this._paths,
                                r = this._parsedPaths,
                                o = this._bindings,
                                a = o.length - 1,
                                s = o[a];
                            e[t[a]] = i, o[i] = s, o.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop()
                        }
                    }
                }), Object.assign(Ws.prototype, {
                    play: function() {
                        return this._mixer._activateAction(this), this
                    },
                    stop: function() {
                        return this._mixer._deactivateAction(this), this.reset()
                    },
                    reset: function() {
                        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                    },
                    isRunning: function() {
                        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                    },
                    isScheduled: function() {
                        return this._mixer._isActiveAction(this)
                    },
                    startAt: function(t) {
                        return this._startTime = t, this
                    },
                    setLoop: function(t, e) {
                        return this.loop = t, this.repetitions = e, this
                    },
                    setEffectiveWeight: function(t) {
                        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                    },
                    getEffectiveWeight: function() {
                        return this._effectiveWeight
                    },
                    fadeIn: function(t) {
                        return this._scheduleFading(t, 0, 1)
                    },
                    fadeOut: function(t) {
                        return this._scheduleFading(t, 1, 0)
                    },
                    crossFadeFrom: function(t, e, i) {
                        if (t.fadeOut(e), this.fadeIn(e), i) {
                            var n = this._clip.duration,
                                r = t._clip.duration,
                                o = r / n,
                                a = n / r;
                            t.warp(1, o, e), this.warp(a, 1, e)
                        }
                        return this
                    },
                    crossFadeTo: function(t, e, i) {
                        return t.crossFadeFrom(this, e, i)
                    },
                    stopFading: function() {
                        var t = this._weightInterpolant;
                        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    setEffectiveTimeScale: function(t) {
                        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                    },
                    getEffectiveTimeScale: function() {
                        return this._effectiveTimeScale
                    },
                    setDuration: function(t) {
                        return this.timeScale = this._clip.duration / t, this.stopWarping()
                    },
                    syncWith: function(t) {
                        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                    },
                    halt: function(t) {
                        return this.warp(this._effectiveTimeScale, 0, t)
                    },
                    warp: function(t, e, i) {
                        var n = this._mixer,
                            r = n.time,
                            o = this._timeScaleInterpolant,
                            a = this.timeScale;
                        null === o && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
                        var s = o.parameterPositions,
                            c = o.sampleValues;
                        return s[0] = r, s[1] = r + i, c[0] = t / a, c[1] = e / a, this
                    },
                    stopWarping: function() {
                        var t = this._timeScaleInterpolant;
                        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                    },
                    getMixer: function() {
                        return this._mixer
                    },
                    getClip: function() {
                        return this._clip
                    },
                    getRoot: function() {
                        return this._localRoot || this._mixer._root
                    },
                    _update: function(t, e, i, n) {
                        if (this.enabled) {
                            var r = this._startTime;
                            if (null !== r) {
                                var o = (t - r) * i;
                                if (o < 0 || 0 === i) return;
                                this._startTime = null, e = i * o
                            }
                            e *= this._updateTimeScale(t);
                            var a = this._updateTime(e),
                                s = this._updateWeight(t);
                            if (s > 0)
                                for (var c = this._interpolants, l = this._propertyBindings, h = 0, u = c.length; h !== u; ++h) c[h].evaluate(a), l[h].accumulate(n, s)
                        } else this._updateWeight(t)
                    },
                    _updateWeight: function(t) {
                        var e = 0;
                        if (this.enabled) {
                            e = this.weight;
                            var i = this._weightInterpolant;
                            if (null !== i) {
                                var n = i.evaluate(t)[0];
                                e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                            }
                        }
                        return this._effectiveWeight = e, e
                    },
                    _updateTimeScale: function(t) {
                        var e = 0;
                        if (!this.paused) {
                            e = this.timeScale;
                            var i = this._timeScaleInterpolant;
                            if (null !== i) e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                        }
                        return this._effectiveTimeScale = e, e
                    },
                    _updateTime: function(t) {
                        var e = this.time + t,
                            i = this._clip.duration,
                            n = this.loop,
                            r = this._loopCount,
                            o = n === ye;
                        if (0 === t) return -1 === r ? e : o && 1 == (1 & r) ? i - e : e;
                        if (n === ge) {
                            -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                            t: {
                                if (e >= i) e = i;
                                else {
                                    if (!(e < 0)) break t;
                                    e = 0
                                }
                                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                                this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= i || e < 0) {
                                var a = Math.floor(e / i);
                                e -= i * a, r += Math.abs(a);
                                var s = this.repetitions - r;
                                if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? i : 0, this._mixer.dispatchEvent({
                                    type: "finished",
                                    action: this,
                                    direction: t > 0 ? 1 : -1
                                });
                                else {
                                    if (1 === s) {
                                        var c = t < 0;
                                        this._setEndings(c, !c, o)
                                    } else this._setEndings(!1, !1, o);
                                    this._loopCount = r, this._mixer.dispatchEvent({
                                        type: "loop",
                                        action: this,
                                        loopDelta: a
                                    })
                                }
                            }
                            if (o && 1 == (1 & r)) return this.time = e, i - e
                        }
                        return this.time = e, e
                    },
                    _setEndings: function(t, e, i) {
                        var n = this._interpolantSettings;
                        i ? (n.endingStart = Me, n.endingEnd = Me) : (n.endingStart = t ? this.zeroSlopeAtStart ? Me : we : Te, n.endingEnd = e ? this.zeroSlopeAtEnd ? Me : we : Te)
                    },
                    _scheduleFading: function(t, e, i) {
                        var n = this._mixer,
                            r = n.time,
                            o = this._weightInterpolant;
                        null === o && (o = n._lendControlInterpolant(), this._weightInterpolant = o);
                        var a = o.parameterPositions,
                            s = o.sampleValues;
                        return a[0] = r, s[0] = e, a[1] = r + t, s[1] = i, this
                    }
                }), Xs.prototype = Object.assign(Object.create(n.prototype), {
                    constructor: Xs,
                    _bindAction: function(t, e) {
                        var i = t._localRoot || this._root,
                            n = t._clip.tracks,
                            r = n.length,
                            o = t._propertyBindings,
                            a = t._interpolants,
                            s = i.uuid,
                            c = this._bindingsByRootAndName,
                            l = c[s];
                        void 0 === l && (l = {}, c[s] = l);
                        for (var h = 0; h !== r; ++h) {
                            var u = n[h],
                                d = u.name,
                                p = l[d];
                            if (void 0 !== p) o[h] = p;
                            else {
                                if (void 0 !== (p = o[h])) {
                                    null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                                    continue
                                }
                                var f = e && e._propertyBindings[h].binding.parsedPath;
                                ++(p = new zs(Vs.create(i, d, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), o[h] = p
                            }
                            a[h].resultBuffer = p.buffer
                        }
                    },
                    _activateAction: function(t) {
                        if (!this._isActiveAction(t)) {
                            if (null === t._cacheIndex) {
                                var e = (t._localRoot || this._root).uuid,
                                    i = t._clip.uuid,
                                    n = this._actionsByClip[i];
                                this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                            }
                            for (var r = t._propertyBindings, o = 0, a = r.length; o !== a; ++o) {
                                var s = r[o];
                                0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                            }
                            this._lendAction(t)
                        }
                    },
                    _deactivateAction: function(t) {
                        if (this._isActiveAction(t)) {
                            for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                                var r = e[i];
                                0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                            }
                            this._takeBackAction(t)
                        }
                    },
                    _initMemoryManager: function() {
                        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                        var t = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return t._actions.length
                                },
                                get inUse() {
                                    return t._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return t._bindings.length
                                },
                                get inUse() {
                                    return t._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return t._controlInterpolants.length
                                },
                                get inUse() {
                                    return t._nActiveControlInterpolants
                                }
                            }
                        }
                    },
                    _isActiveAction: function(t) {
                        var e = t._cacheIndex;
                        return null !== e && e < this._nActiveActions
                    },
                    _addInactiveAction: function(t, e, i) {
                        var n = this._actions,
                            r = this._actionsByClip,
                            o = r[e];
                        if (void 0 === o) o = {
                            knownActions: [t],
                            actionByRoot: {}
                        }, t._byClipCacheIndex = 0, r[e] = o;
                        else {
                            var a = o.knownActions;
                            t._byClipCacheIndex = a.length, a.push(t)
                        }
                        t._cacheIndex = n.length, n.push(t), o.actionByRoot[i] = t
                    },
                    _removeInactiveAction: function(t) {
                        var e = this._actions,
                            i = e[e.length - 1],
                            n = t._cacheIndex;
                        i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null;
                        var r = t._clip.uuid,
                            o = this._actionsByClip,
                            a = o[r],
                            s = a.knownActions,
                            c = s[s.length - 1],
                            l = t._byClipCacheIndex;
                        c._byClipCacheIndex = l, s[l] = c, s.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete o[r], this._removeInactiveBindingsForAction(t)
                    },
                    _removeInactiveBindingsForAction: function(t) {
                        for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                            var r = e[i];
                            0 == --r.referenceCount && this._removeInactiveBinding(r)
                        }
                    },
                    _lendAction: function(t) {
                        var e = this._actions,
                            i = t._cacheIndex,
                            n = this._nActiveActions++,
                            r = e[n];
                        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                    },
                    _takeBackAction: function(t) {
                        var e = this._actions,
                            i = t._cacheIndex,
                            n = --this._nActiveActions,
                            r = e[n];
                        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                    },
                    _addInactiveBinding: function(t, e, i) {
                        var n = this._bindingsByRootAndName,
                            r = n[e],
                            o = this._bindings;
                        void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = o.length, o.push(t)
                    },
                    _removeInactiveBinding: function(t) {
                        var e = this._bindings,
                            i = t.binding,
                            n = i.rootNode.uuid,
                            r = i.path,
                            o = this._bindingsByRootAndName,
                            a = o[n],
                            s = e[e.length - 1],
                            c = t._cacheIndex;
                        s._cacheIndex = c, e[c] = s, e.pop(), delete a[r];
                        t: {
                            for (var l in a) break t;delete o[n]
                        }
                    },
                    _lendBinding: function(t) {
                        var e = this._bindings,
                            i = t._cacheIndex,
                            n = this._nActiveBindings++,
                            r = e[n];
                        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                    },
                    _takeBackBinding: function(t) {
                        var e = this._bindings,
                            i = t._cacheIndex,
                            n = --this._nActiveBindings,
                            r = e[n];
                        t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
                    },
                    _lendControlInterpolant: function() {
                        var t = this._controlInterpolants,
                            e = this._nActiveControlInterpolants++,
                            i = t[e];
                        return void 0 === i && ((i = new da(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = i), i
                    },
                    _takeBackControlInterpolant: function(t) {
                        var e = this._controlInterpolants,
                            i = t.__cacheIndex,
                            n = --this._nActiveControlInterpolants,
                            r = e[n];
                        t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
                    },
                    _controlInterpolantsResultBuffer: new Float32Array(1),
                    clipAction: function(t, e) {
                        var i = e || this._root,
                            n = i.uuid,
                            r = "string" == typeof t ? wa.findByName(i, t) : t,
                            o = null !== r ? r.uuid : t,
                            a = this._actionsByClip[o],
                            s = null;
                        if (void 0 !== a) {
                            var c = a.actionByRoot[n];
                            if (void 0 !== c) return c;
                            s = a.knownActions[0], null === r && (r = s._clip)
                        }
                        if (null === r) return null;
                        var l = new Ws(this, r, e);
                        return this._bindAction(l, s), this._addInactiveAction(l, o, n), l
                    },
                    existingAction: function(t, e) {
                        var i = e || this._root,
                            n = i.uuid,
                            r = "string" == typeof t ? wa.findByName(i, t) : t,
                            o = r ? r.uuid : t,
                            a = this._actionsByClip[o];
                        return void 0 !== a && a.actionByRoot[n] || null
                    },
                    stopAllAction: function() {
                        var t = this._actions,
                            e = this._nActiveActions,
                            i = this._bindings,
                            n = this._nActiveBindings;
                        this._nActiveActions = 0, this._nActiveBindings = 0;
                        for (var r = 0; r !== e; ++r) t[r].reset();
                        for (r = 0; r !== n; ++r) i[r].useCount = 0;
                        return this
                    },
                    update: function(t) {
                        t *= this.timeScale;
                        for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== i; ++a) {
                            e[a]._update(n, t, r, o)
                        }
                        var s = this._bindings,
                            c = this._nActiveBindings;
                        for (a = 0; a !== c; ++a) s[a].apply(o);
                        return this
                    },
                    getRoot: function() {
                        return this._root
                    },
                    uncacheClip: function(t) {
                        var e = this._actions,
                            i = t.uuid,
                            n = this._actionsByClip,
                            r = n[i];
                        if (void 0 !== r) {
                            for (var o = r.knownActions, a = 0, s = o.length; a !== s; ++a) {
                                var c = o[a];
                                this._deactivateAction(c);
                                var l = c._cacheIndex,
                                    h = e[e.length - 1];
                                c._cacheIndex = null, c._byClipCacheIndex = null, h._cacheIndex = l, e[l] = h, e.pop(), this._removeInactiveBindingsForAction(c)
                            }
                            delete n[i]
                        }
                    },
                    uncacheRoot: function(t) {
                        var e = t.uuid,
                            i = this._actionsByClip;
                        for (var n in i) {
                            var r = i[n].actionByRoot[e];
                            void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
                        }
                        var o = this._bindingsByRootAndName[e];
                        if (void 0 !== o)
                            for (var a in o) {
                                var s = o[a];
                                s.restoreOriginalState(), this._removeInactiveBinding(s)
                            }
                    },
                    uncacheAction: function(t, e) {
                        var i = this.existingAction(t, e);
                        null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                    }
                }), qs.prototype.clone = function() {
                    return new qs(void 0 === this.value.clone ? this.value : this.value.clone())
                }, Ys.prototype = Object.assign(Object.create(Ii.prototype), {
                    constructor: Ys,
                    isInstancedBufferGeometry: !0,
                    copy: function(t) {
                        return Ii.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    }
                }), Zs.prototype = Object.assign(Object.create(xr.prototype), {
                    constructor: Zs,
                    isInstancedInterleavedBuffer: !0,
                    copy: function(t) {
                        return xr.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                }), Js.prototype = Object.assign(Object.create(xi.prototype), {
                    constructor: Js,
                    isInstancedBufferAttribute: !0,
                    copy: function(t) {
                        return xi.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                    }
                }), Object.assign(Ks.prototype, {
                    linePrecision: 1,
                    set: function(t, e) {
                        this.ray.set(t, e)
                    },
                    setFromCamera: function(t, e) {
                        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                    },
                    intersectObject: function(t, e, i) {
                        var n = i || [];
                        return $s(t, this, n, e), n.sort(Qs), n
                    },
                    intersectObjects: function(t, e, i) {
                        var n = i || [];
                        if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
                        for (var r = 0, o = t.length; r < o; r++) $s(t[r], this, n, e);
                        return n.sort(Qs), n
                    }
                }), Object.assign(tc.prototype, {
                    set: function(t, e, i) {
                        return this.radius = t, this.phi = e, this.theta = i, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                    },
                    makeSafe: function() {
                        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, i) {
                        return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, i), this.phi = Math.acos(Ue.clamp(e / this.radius, -1, 1))), this
                    }
                }), Object.assign(ec.prototype, {
                    set: function(t, e, i) {
                        return this.radius = t, this.theta = e, this.y = i, this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                    },
                    setFromVector3: function(t) {
                        return this.setFromCartesianCoords(t.x, t.y, t.z)
                    },
                    setFromCartesianCoords: function(t, e, i) {
                        return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this
                    }
                }), Object.assign(ic.prototype, {
                    set: function(t, e) {
                        return this.min.copy(t), this.max.copy(e), this
                    },
                    setFromPoints: function(t) {
                        this.makeEmpty();
                        for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                        return this
                    },
                    setFromCenterAndSize: function() {
                        var t = new Ge;
                        return function(e, i) {
                            var n = t.copy(i).multiplyScalar(.5);
                            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                        }
                    }(),
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.min.copy(t.min), this.max.copy(t.max), this
                    },
                    makeEmpty: function() {
                        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                    },
                    isEmpty: function() {
                        return this.max.x < this.min.x || this.max.y < this.min.y
                    },
                    getCenter: function(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new Ge), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                    },
                    getSize: function(t) {
                        return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new Ge), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                    },
                    expandByPoint: function(t) {
                        return this.min.min(t), this.max.max(t), this
                    },
                    expandByVector: function(t) {
                        return this.min.sub(t), this.max.add(t), this
                    },
                    expandByScalar: function(t) {
                        return this.min.addScalar(-t), this.max.addScalar(t), this
                    },
                    containsPoint: function(t) {
                        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                    },
                    containsBox: function(t) {
                        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                    },
                    getParameter: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new Ge), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                    },
                    intersectsBox: function(t) {
                        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                    },
                    clampPoint: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new Ge), e.copy(t).clamp(this.min, this.max)
                    },
                    distanceToPoint: function() {
                        var t = new Ge;
                        return function(e) {
                            return t.copy(e).clamp(this.min, this.max).sub(e).length()
                        }
                    }(),
                    intersect: function(t) {
                        return this.min.max(t.min), this.max.min(t.max), this
                    },
                    union: function(t) {
                        return this.min.min(t.min), this.max.max(t.max), this
                    },
                    translate: function(t) {
                        return this.min.add(t), this.max.add(t), this
                    },
                    equals: function(t) {
                        return t.min.equals(this.min) && t.max.equals(this.max)
                    }
                }), Object.assign(nc.prototype, {
                    set: function(t, e) {
                        return this.start.copy(t), this.end.copy(e), this
                    },
                    clone: function() {
                        return (new this.constructor).copy(this)
                    },
                    copy: function(t) {
                        return this.start.copy(t.start), this.end.copy(t.end), this
                    },
                    getCenter: function(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new je), t.addVectors(this.start, this.end).multiplyScalar(.5)
                    },
                    delta: function(t) {
                        return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new je), t.subVectors(this.end, this.start)
                    },
                    distanceSq: function() {
                        return this.start.distanceToSquared(this.end)
                    },
                    distance: function() {
                        return this.start.distanceTo(this.end)
                    },
                    at: function(t, e) {
                        return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new je), this.delta(e).multiplyScalar(t).add(this.start)
                    },
                    closestPointToPointParameter: function() {
                        var t = new je,
                            e = new je;
                        return function(i, n) {
                            t.subVectors(i, this.start), e.subVectors(this.end, this.start);
                            var r = e.dot(e),
                                o = e.dot(t) / r;
                            return n && (o = Ue.clamp(o, 0, 1)), o
                        }
                    }(),
                    closestPointToPoint: function(t, e, i) {
                        var n = this.closestPointToPointParameter(t, e);
                        return void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new je), this.delta(i).multiplyScalar(n).add(this.start)
                    },
                    applyMatrix4: function(t) {
                        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                    },
                    equals: function(t) {
                        return t.start.equals(this.start) && t.end.equals(this.end)
                    }
                }), rc.prototype = Object.create(vi.prototype), rc.prototype.constructor = rc, rc.prototype.isImmediateRenderObject = !0, oc.prototype = Object.create(Cr.prototype), oc.prototype.constructor = oc, oc.prototype.update = function() {
                    var t = new je,
                        e = new je,
                        i = new We;
                    return function() {
                        var n = ["a", "b", "c"];
                        this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                        var r = this.object.matrixWorld,
                            o = this.geometry.attributes.position,
                            a = this.object.geometry;
                        if (a && a.isGeometry)
                            for (var s = a.vertices, c = a.faces, l = 0, h = 0, u = c.length; h < u; h++)
                                for (var d = c[h], p = 0, f = d.vertexNormals.length; p < f; p++) {
                                    var m = s[d[n[p]]],
                                        g = d.vertexNormals[p];
                                    t.copy(m).applyMatrix4(r), e.copy(g).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(l, t.x, t.y, t.z), l += 1, o.setXYZ(l, e.x, e.y, e.z), l += 1
                                } else if (a && a.isBufferGeometry) {
                                    var v = a.attributes.position,
                                        y = a.attributes.normal;
                                    for (l = 0, p = 0, f = v.count; p < f; p++) t.set(v.getX(p), v.getY(p), v.getZ(p)).applyMatrix4(r), e.set(y.getX(p), y.getY(p), y.getZ(p)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(l, t.x, t.y, t.z), l += 1, o.setXYZ(l, e.x, e.y, e.z), l += 1
                                }
                        o.needsUpdate = !0
                    }
                }(), ac.prototype = Object.create(vi.prototype), ac.prototype.constructor = ac, ac.prototype.dispose = function() {
                    this.cone.geometry.dispose(), this.cone.material.dispose()
                }, ac.prototype.update = function() {
                    var t = new je;
                    return function() {
                        this.light.updateMatrixWorld();
                        var e = this.light.distance ? this.light.distance : 1e3,
                            i = e * Math.tan(this.light.angle);
                        this.cone.scale.set(i, i, e), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                    }
                }(), sc.prototype = Object.create(Cr.prototype), sc.prototype.constructor = sc, sc.prototype.updateMatrixWorld = function() {
                    var t = new je,
                        e = new He,
                        i = new He;
                    return function(n) {
                        var r = this.bones,
                            o = this.geometry,
                            a = o.getAttribute("position");
                        i.getInverse(this.root.matrixWorld);
                        for (var s = 0, c = 0; s < r.length; s++) {
                            var l = r[s];
                            l.parent && l.parent.isBone && (e.multiplyMatrices(i, l.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(i, l.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c + 1, t.x, t.y, t.z), c += 2)
                        }
                        o.getAttribute("position").needsUpdate = !0, vi.prototype.updateMatrixWorld.call(this, n)
                    }
                }(), cc.prototype = Object.create(ji.prototype), cc.prototype.constructor = cc, cc.prototype.dispose = function() {
                    this.geometry.dispose(), this.material.dispose()
                }, cc.prototype.update = function() {
                    void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
                }, lc.prototype = Object.create(vi.prototype), lc.prototype.constructor = lc, lc.prototype.dispose = function() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }, lc.prototype.update = function() {
                    var t = .5 * this.light.width,
                        e = .5 * this.light.height,
                        i = this.line.geometry.attributes.position,
                        n = i.array;
                    n[0] = t, n[1] = -e, n[2] = 0, n[3] = t, n[4] = e, n[5] = 0, n[6] = -t, n[7] = e, n[8] = 0, n[9] = -t, n[10] = -e, n[11] = 0, n[12] = t, n[13] = -e, n[14] = 0, i.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
                }, hc.prototype = Object.create(vi.prototype), hc.prototype.constructor = hc, hc.prototype.dispose = function() {
                    this.children[0].geometry.dispose(), this.children[0].material.dispose()
                }, hc.prototype.update = function() {
                    var t = new je,
                        e = new ci,
                        i = new ci;
                    return function() {
                        var n = this.children[0];
                        if (void 0 !== this.color) this.material.color.set(this.color);
                        else {
                            var r = n.geometry.getAttribute("color");
                            e.copy(this.light.color), i.copy(this.light.groundColor);
                            for (var o = 0, a = r.count; o < a; o++) {
                                var s = o < a / 2 ? e : i;
                                r.setXYZ(o, s.r, s.g, s.b)
                            }
                            r.needsUpdate = !0
                        }
                        n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }(), uc.prototype = Object.create(Cr.prototype), uc.prototype.constructor = uc, dc.prototype = Object.create(Cr.prototype), dc.prototype.constructor = dc, pc.prototype = Object.create(Cr.prototype), pc.prototype.constructor = pc, pc.prototype.update = function() {
                    var t = new je,
                        e = new je,
                        i = new We;
                    return function() {
                        this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                        for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, c = 0, l = 0, h = s.length; l < h; l++) {
                            var u = s[l],
                                d = u.normal;
                            t.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(n), e.copy(d).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(c, t.x, t.y, t.z), c += 1, r.setXYZ(c, e.x, e.y, e.z), c += 1
                        }
                        r.needsUpdate = !0
                    }
                }(), fc.prototype = Object.create(vi.prototype), fc.prototype.constructor = fc, fc.prototype.dispose = function() {
                    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
                }, fc.prototype.update = function() {
                    var t = new je,
                        e = new je,
                        i = new je;
                    return function() {
                        t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(e), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(e), this.targetLine.scale.z = i.length()
                    }
                }(), mc.prototype = Object.create(Cr.prototype), mc.prototype.constructor = mc, mc.prototype.update = function() {
                    var t, e, i = new je,
                        n = new cr;

                    function r(r, o, a, s) {
                        i.set(o, a, s).unproject(n);
                        var c = e[r];
                        if (void 0 !== c)
                            for (var l = t.getAttribute("position"), h = 0, u = c.length; h < u; h++) l.setXYZ(c[h], i.x, i.y, i.z)
                    }
                    return function() {
                        t = this.geometry, e = this.pointMap;
                        n.projectionMatrix.copy(this.camera.projectionMatrix), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                    }
                }(), gc.prototype = Object.create(Cr.prototype), gc.prototype.constructor = gc, gc.prototype.update = function() {
                    var t = new $e;
                    return function(e) {
                        if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                            var i = t.min,
                                n = t.max,
                                r = this.geometry.attributes.position,
                                o = r.array;
                            o[0] = n.x, o[1] = n.y, o[2] = n.z, o[3] = i.x, o[4] = n.y, o[5] = n.z, o[6] = i.x, o[7] = i.y, o[8] = n.z, o[9] = n.x, o[10] = i.y, o[11] = n.z, o[12] = n.x, o[13] = n.y, o[14] = i.z, o[15] = i.x, o[16] = n.y, o[17] = i.z, o[18] = i.x, o[19] = i.y, o[20] = i.z, o[21] = n.x, o[22] = i.y, o[23] = i.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                        }
                    }
                }(), gc.prototype.setFromObject = function(t) {
                    return this.object = t, this.update(), this
                }, gc.prototype.copy = function(t) {
                    return Cr.prototype.copy.call(this, t), this.object = t.object, this
                }, gc.prototype.clone = function() {
                    return (new this.constructor).copy(this)
                }, vc.prototype = Object.create(Cr.prototype), vc.prototype.constructor = vc, vc.prototype.updateMatrixWorld = function(t) {
                    var e = this.box;
                    e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), vi.prototype.updateMatrixWorld.call(this, t))
                }, yc.prototype = Object.create(Lr.prototype), yc.prototype.constructor = yc, yc.prototype.updateMatrixWorld = function(t) {
                    var e = -this.plane.constant;
                    Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? v : g, this.lookAt(this.plane.normal), vi.prototype.updateMatrixWorld.call(this, t)
                }, _c.prototype = Object.create(vi.prototype), _c.prototype.constructor = _c, _c.prototype.setDirection = function() {
                    var t, e = new je;
                    return function(i) {
                        i.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : i.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(), t = Math.acos(i.y), this.quaternion.setFromAxisAngle(e, t))
                    }
                }(), _c.prototype.setLength = function(t, e, i) {
                    void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
                }, _c.prototype.setColor = function(t) {
                    this.line.material.color.copy(t), this.cone.material.color.copy(t)
                }, _c.prototype.copy = function(t) {
                    return vi.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
                }, _c.prototype.clone = function() {
                    return (new this.constructor).copy(this)
                }, xc.prototype = Object.create(Cr.prototype), xc.prototype.constructor = xc;
            var wc = 0,
                Mc = 1;

            function Tc(t) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
            }

            function Ec(t) {
                return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                    return t.slice()
                }, t
            }

            function Sc(t, e) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ir(t, e)
            }

            function Ac(t) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Mr(t)
            }

            function Pc(t, e) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ir(t, e)
            }

            function Lc(t) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Or(t)
            }

            function Cc(t) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Or(t)
            }

            function Rc(t) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Or(t)
            }

            function Oc(t, e, i) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new je(t, e, i)
            }

            function Ic(t, e) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new xi(t, e).setDynamic(!0)
            }

            function Dc(t, e) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new bi(t, e)
            }

            function kc(t, e) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new wi(t, e)
            }

            function Nc(t, e) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Mi(t, e)
            }

            function Bc(t, e) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ti(t, e)
            }

            function Fc(t, e) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Ei(t, e)
            }

            function zc(t, e) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Si(t, e)
            }

            function Uc(t, e) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Ai(t, e)
            }

            function Gc(t, e) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Pi(t, e)
            }

            function Hc(t, e) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Li(t, e)
            }

            function Vc(t) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Va.call(this, t), this.type = "catmullrom", this.closed = !0
            }

            function jc(t) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Va.call(this, t), this.type = "catmullrom"
            }

            function Wc(t) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Va.call(this, t), this.type = "catmullrom"
            }

            function Xc(t) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new xc(t)
            }

            function qc(t, e) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new gc(t, e)
            }

            function Yc(t, e) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Cr(new jo(t.geometry), new Pr({
                    color: void 0 !== e ? e : 16777215
                }))
            }

            function Zc(t, e) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Cr(new Fr(t.geometry), new Pr({
                    color: void 0 !== e ? e : 16777215
                }))
            }

            function Jc(t) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Pa(t)
            }

            function Kc(t) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ra(t)
            }
            ka.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(ka.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Object.assign(es.prototype, {
                createPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var e = new _i, i = 0, n = t.length; i < n; i++) {
                        var r = t[i];
                        e.vertices.push(new je(r.x, r.y, r.z || 0))
                    }
                    return e
                }
            }), Object.assign(is.prototype, {
                fromPoints: function(t) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }
            }), Vc.prototype = Object.create(Va.prototype), jc.prototype = Object.create(Va.prototype), Wc.prototype = Object.create(Va.prototype), Object.assign(Wc.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), uc.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, sc.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(Ls.prototype, {
                extractUrlBase: function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), gs.extractUrlBase(t)
                }
            }), Object.assign(_s.prototype, {
                setTexturePath: function(t) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
                }
            }), Object.assign(ic.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign($e.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), nc.prototype.center = function(t) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Object.assign(Ue, {
                random16: function() {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Ue.floorPowerOfTwo(t)
                },
                nextPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Ue.ceilPowerOfTwo(t)
                }
            }), Object.assign(We.prototype, {
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(He.prototype, {
                extractPosition: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                getPosition: function() {
                    var t;
                    return function() {
                        return void 0 === t && (t = new je), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
                    }
                }(),
                setRotationFromQuaternion: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector4: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                },
                crossVector: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(t, e, i, n, r, o) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, o)
                }
            }), ei.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, Ve.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, Object.assign(Gi.prototype, {
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }
            }), Object.assign(Hi.prototype, {
                area: function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function(t, e) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                },
                midpoint: function(t) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                },
                normal: function(t) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                },
                plane: function(t) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                }
            }), Object.assign(Hi, {
                barycoordFromPoint: function(t, e, i, n, r) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Hi.getBarycoord(t, e, i, n, r)
                },
                normal: function(t, e, i, n) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Hi.getNormal(t, e, i, n)
                }
            }), Object.assign(ns.prototype, {
                extractAllPoints: function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                },
                extrude: function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Lo(this, t)
                },
                makeGeometry: function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Go(this, t)
                }
            }), Object.assign(Ge.prototype, {
                fromAttribute: function(t, e, i) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(je.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                },
                applyProjection: function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                },
                fromAttribute: function(t, e, i) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Ze.prototype, {
                fromAttribute: function(t, e, i) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(_i.prototype, {
                computeTangents: function() {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            }), Object.assign(vi.prototype, {
                getChildByName: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                },
                getWorldRotation: function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            }), Object.defineProperties(vi.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(Tr.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(Sr.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Er.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(ka.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                }
            }), lr.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(rs.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(xi.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                copyIndicesArray: function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }
            }), Object.assign(Ii.prototype, {
                addIndex: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                },
                addDrawCall: function(t, e, i) {
                    void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(Ii.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.assign(Co.prototype, {
                getArrays: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.defineProperties(qs.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(zi.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new ci
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === _
                    }
                }
            }), Object.defineProperties(ia.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(Ui.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), Object.assign(gr.prototype, {
                clearTarget: function(t, e, i, n) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n)
                },
                animate: function(t) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                },
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }
            }), Object.defineProperties(gr.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(rr.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(Je.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), Object.defineProperties(mr.prototype, {
                standing: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                },
                userHeight: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .userHeight has been removed.")
                    }
                }
            }), Ns.prototype.load = function(t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var e = this;
                return (new Rs).load(t, function(t) {
                    e.setBuffer(t)
                }), this
            }, Fs.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, Is.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            };
            var Qc = {
                merge: function(t, e, i) {
                    var n;
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), n = e.matrix, e = e.geometry), t.merge(e, n, i)
                },
                center: function(t) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
                }
            };

            function $c() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(t, e) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
                }, this.unprojectVector = function(t, e) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
                }, this.pickingRay = function() {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }

            function tl() {
                console.error("THREE.CanvasRenderer has been removed")
            }

            function el() {
                console.error("THREE.JSONLoader has been removed.")
            }
            Xe.crossOrigin = void 0, Xe.loadTexture = function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new Da;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, i, void 0, n);
                return e && (o.mapping = e), o
            }, Xe.loadTextureCube = function(t, e, i, n) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new Ia;
                r.setCrossOrigin(this.crossOrigin);
                var o = r.load(t, i, void 0, n);
                return e && (o.mapping = e), o
            }, Xe.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, Xe.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            var il = {
                createMultiMaterialObject: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };

            function nl() {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }
        }.call(this, i(1))
}, function(t, e, i) {
    "use strict";
    var n = i(0);
    /*!
     * VERSION: 2.0.2
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     **/
    n.e._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function() {
        var t = function(t) {
                var e, i = [],
                    n = t.length;
                for (e = 0; e !== n; i.push(t[e++]));
                return i
            },
            e = function(t, e, i) {
                var n, r, o = t.cycle;
                for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                delete t.cycle
            },
            i = function(t, e, r) {
                n.f.call(this, t, e, r), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = i.prototype.render
            },
            r = n.f._internals,
            o = r.isSelector,
            a = r.isArray,
            s = i.prototype = n.f.to({}, .1, {}),
            c = [];
        i.version = "2.0.2", s.constructor = i, s.kill()._gc = !1, i.killTweensOf = i.killDelayedCallsTo = n.f.killTweensOf, i.getTweensOf = n.f.getTweensOf, i.lagSmoothing = n.f.lagSmoothing, i.ticker = n.f.ticker, i.render = n.f.render, s.invalidate = function() {
            return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), n.f.prototype.invalidate.call(this)
        }, s.updateTo = function(t, e) {
            var i, r = this.ratio,
                o = this.vars.immediateRender || t.immediateRender;
            for (i in e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), t) this.vars[i] = t[i];
            if (this._initted || o)
                if (e) this._initted = !1, o && this.render(0, !0, !0);
                else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n.f._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                var a = this._totalTime;
                this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
            } else if (this._initted = !1, this._init(), this._time > 0 || o)
                for (var s, c = 1 / (1 - r), l = this._firstPT; l;) s = l.s + l.c, l.c *= c, l.s = s - l.c, l = l._next;
            return this
        }, s.render = function(t, e, i) {
            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
            var o, a, s, c, l, h, u, d, p, f = this._dirty ? this.totalDuration() : this._totalDuration,
                m = this._time,
                g = this._totalTime,
                v = this._cycle,
                y = this._duration,
                _ = this._rawPrevTime;
            if (t >= f - 1e-7 && t >= 0 ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (o = !0, a = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (_ < 0 || t <= 0 && t >= -1e-7 || 1e-10 === _ && "isPause" !== this.data) && _ !== t && (i = !0, _ > 1e-10 && (a = "onReverseComplete")), this._rawPrevTime = d = !e || t || _ === t ? t : 1e-10)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== g || 0 === y && _ > 0) && (a = "onReverseComplete", o = this._reversed), t < 0 && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || i) && (_ >= 0 && (i = !0), this._rawPrevTime = d = !e || t || _ === t ? t : 1e-10)), this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (c = y + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && g <= t && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 != (1 & this._cycle) && (this._time = y - this._time, (p = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== p || this._initted ? this._yoyoEase = p = !0 === p ? this._ease : p instanceof n.b ? p : n.b.map[p] : (p = this.vars.ease, this._yoyoEase = p = p ? p instanceof n.b ? p : "function" == typeof p ? new n.b(p, this.vars.easeParams) : n.b.map[p] || n.f.defaultEase : n.f.defaultEase)), this.ratio = p ? 1 - p.getRatio((y - this._time) / y) : 0)), this._time > y ? this._time = y : this._time < 0 && (this._time = 0)), this._easeType && !p ? (l = this._time / y, h = this._easeType, u = this._easePower, (1 === h || 3 === h && l >= .5) && (l = 1 - l), 3 === h && (l *= 2), 1 === u ? l *= l : 2 === u ? l *= l * l : 3 === u ? l *= l * l * l : 4 === u && (l *= l * l * l * l), 1 === h ? this.ratio = 1 - l : 2 === h ? this.ratio = l : this._time / y < .5 ? this.ratio = l / 2 : this.ratio = 1 - l / 2) : p || (this.ratio = this._ease.getRatio(this._time / y))), m !== this._time || i || v !== this._cycle) {
                if (!this._initted) {
                    if (this._init(), !this._initted || this._gc) return;
                    if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = m, this._totalTime = g, this._rawPrevTime = _, this._cycle = v, r.lazyTweens.push(this), void(this._lazy = [t, e]);
                    !this._time || o || p ? o && this._ease._calcEnd && !p && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / y)
                }
                for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== m && t >= 0 && (this._active = !0), 0 === g && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : a || (a = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== y || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, !0, i), e || (this._totalTime !== g || a) && this._callback("onUpdate")), this._cycle !== v && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), a && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, i), o && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[a] && this._callback(a), 0 === y && 1e-10 === this._rawPrevTime && 1e-10 !== d && (this._rawPrevTime = 0)))
            } else g !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
        }, i.to = function(t, e, n) {
            return new i(t, e, n)
        }, i.from = function(t, e, n) {
            return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new i(t, e, n)
        }, i.fromTo = function(t, e, n, r) {
            return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, new i(t, e, r)
        }, i.staggerTo = i.allTo = function(r, s, l, h, u, d, p) {
            h = h || 0;
            var f, m, g, v, y = 0,
                _ = [],
                x = function() {
                    l.onComplete && l.onComplete.apply(l.onCompleteScope || this, arguments), u.apply(p || l.callbackScope || this, d || c)
                },
                b = l.cycle,
                w = l.startAt && l.startAt.cycle;
            for (a(r) || ("string" == typeof r && (r = n.f.selector(r) || r), o(r) && (r = t(r))), r = r || [], h < 0 && ((r = t(r)).reverse(), h *= -1), f = r.length - 1, g = 0; g <= f; g++) {
                for (v in m = {}, l) m[v] = l[v];
                if (b && (e(m, r, g), null != m.duration && (s = m.duration, delete m.duration)), w) {
                    for (v in w = m.startAt = {}, l.startAt) w[v] = l.startAt[v];
                    e(m.startAt, r, g)
                }
                m.delay = y + (m.delay || 0), g === f && u && (m.onComplete = x), _[g] = new i(r[g], s, m), y += h
            }
            return _
        }, i.staggerFrom = i.allFrom = function(t, e, n, r, o, a, s) {
            return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, i.staggerTo(t, e, n, r, o, a, s)
        }, i.staggerFromTo = i.allFromTo = function(t, e, n, r, o, a, s, c) {
            return r.startAt = n, r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender, i.staggerTo(t, e, r, o, a, s, c)
        }, i.delayedCall = function(t, e, n, r, o) {
            return new i(e, 0, {
                delay: t,
                onComplete: e,
                onCompleteParams: n,
                callbackScope: r,
                onReverseComplete: e,
                onReverseCompleteParams: n,
                immediateRender: !1,
                useFrames: o,
                overwrite: 0
            })
        }, i.set = function(t, e) {
            return new i(t, 0, e)
        }, i.isTweening = function(t) {
            return n.f.getTweensOf(t, !0).length > 0
        };
        var l = function(t, e) {
                for (var i = [], r = 0, o = t._first; o;) o instanceof n.f ? i[r++] = o : (e && (i[r++] = o), r = (i = i.concat(l(o, e))).length), o = o._next;
                return i
            },
            h = i.getAllTweens = function(t) {
                return l(n.a._rootTimeline, t).concat(l(n.a._rootFramesTimeline, t))
            };
        i.killAll = function(t, e, i, r) {
            null == e && (e = !0), null == i && (i = !0);
            var o, a, s, c = h(0 != r),
                l = c.length,
                u = e && i && r;
            for (s = 0; s < l; s++) a = c[s], (u || a instanceof n.c || (o = a.target === a.vars.onComplete) && i || e && !o) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
        }, i.killChildTweensOf = function(e, s) {
            if (null != e) {
                var c, l, h, u, d, p = r.tweenLookup;
                if ("string" == typeof e && (e = n.f.selector(e) || e), o(e) && (e = t(e)), a(e))
                    for (u = e.length; --u > -1;) i.killChildTweensOf(e[u], s);
                else {
                    for (h in c = [], p)
                        for (l = p[h].target.parentNode; l;) l === e && (c = c.concat(p[h].tweens)), l = l.parentNode;
                    for (d = c.length, u = 0; u < d; u++) s && c[u].totalTime(c[u].totalDuration()), c[u]._enabled(!1, !1)
                }
            }
        };
        var u = function(t, e, i, r) {
            e = !1 !== e, i = !1 !== i;
            for (var o, a, s = h(r = !1 !== r), c = e && i && r, l = s.length; --l > -1;) a = s[l], (c || a instanceof n.c || (o = a.target === a.vars.onComplete) && i || e && !o) && a.paused(t)
        };
        return i.pauseAll = function(t, e, i) {
            u(!0, t, e, i)
        }, i.resumeAll = function(t, e, i) {
            u(!1, t, e, i)
        }, i.globalTimeScale = function(t) {
            var e = n.a._rootTimeline,
                i = n.f.ticker.time;
            return arguments.length ? (t = t || 1e-10, e._startTime = i - (i - e._startTime) * e._timeScale / t, e = n.a._rootFramesTimeline, i = n.f.ticker.frame, e._startTime = i - (i - e._startTime) * e._timeScale / t, e._timeScale = n.a._rootTimeline._timeScale = t, t) : e._timeScale
        }, s.progress = function(t, e) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
        }, s.totalProgress = function(t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
        }, s.time = function(t, e) {
            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
        }, s.duration = function(t) {
            return arguments.length ? n.a.prototype.duration.call(this, t) : this._duration
        }, s.totalDuration = function(t) {
            return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
        }, s.repeat = function(t) {
            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
        }, s.repeatDelay = function(t) {
            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
        }, s.yoyo = function(t) {
            return arguments.length ? (this._yoyo = t, this) : this._yoyo
        }, i
    }, !0);
    var r = n.g.TweenMax;
    /*!
     * VERSION: 2.0.2
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    n.e._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function() {
        var t, e, i, r, o = function() {
                n.d.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = o.prototype.setRatio
            },
            a = n.e._gsDefine.globals,
            s = {},
            c = o.prototype = new n.d("css");
        c.constructor = o, o.version = "2.0.2", o.API = 2, o.defaultTransformPerspective = 0, o.defaultSkewType = "compensated", o.defaultSmoothOrigin = !0, c = "px", o.suffixMap = {
            top: c,
            right: c,
            bottom: c,
            left: c,
            width: c,
            height: c,
            fontSize: c,
            padding: c,
            margin: c,
            perspective: c,
            lineHeight: ""
        };
        var l, h, u, d, p, f, m, g, v = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
            y = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
            _ = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
            x = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
            b = /(?:\d|\-|\+|=|#|\.)*/g,
            w = /opacity *= *([^)]*)/i,
            M = /opacity:([^;]*)/i,
            T = /alpha\(opacity *=.+?\)/i,
            E = /^(rgb|hsl)/,
            S = /([A-Z])/g,
            A = /-([a-z])/gi,
            P = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
            L = function(t, e) {
                return e.toUpperCase()
            },
            C = /(?:Left|Right|Width)/i,
            R = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
            O = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
            I = /,(?=[^\)]*(?:\(|$))/gi,
            D = /[\s,\(]/i,
            k = Math.PI / 180,
            N = 180 / Math.PI,
            B = {},
            F = {
                style: {}
            },
            z = n.e.document || {
                createElement: function() {
                    return F
                }
            },
            U = function(t, e) {
                return z.createElementNS ? z.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : z.createElement(t)
            },
            G = U("div"),
            H = U("img"),
            V = o._internals = {
                _specialProps: s
            },
            j = (n.e.navigator || {}).userAgent || "",
            W = function() {
                var t = j.indexOf("Android"),
                    e = U("a");
                return u = -1 !== j.indexOf("Safari") && -1 === j.indexOf("Chrome") && (-1 === t || parseFloat(j.substr(t + 8, 2)) > 3), p = u && parseFloat(j.substr(j.indexOf("Version/") + 8, 2)) < 6, d = -1 !== j.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(j) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(j)) && (f = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
            }(),
            X = function(t) {
                return w.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
            },
            q = function(t) {
                n.e.console && console.log(t)
            },
            Y = "",
            Z = "",
            J = function(t, e) {
                var i, n, r = (e = e || G).style;
                if (void 0 !== r[t]) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === r[i[n] + t];);
                return n >= 0 ? (Y = "-" + (Z = 3 === n ? "ms" : i[n]).toLowerCase() + "-", Z + t) : null
            },
            K = ("undefined" != typeof window ? window : z.defaultView || {
                getComputedStyle: function() {}
            }).getComputedStyle,
            Q = o.getStyle = function(t, e, i, n, r) {
                var o;
                return W || "opacity" !== e ? (!n && t.style[e] ? o = t.style[e] : (i = i || K(t)) ? o = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(S, "-$1").toLowerCase()) : t.currentStyle && (o = t.currentStyle[e]), null == r || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : r) : X(t)
            },
            $ = V.convertToPixels = function(t, e, i, r, a) {
                if ("px" === r || !r && "lineHeight" !== e) return i;
                if ("auto" === r || !i) return 0;
                var s, c, l, h = C.test(e),
                    u = t,
                    d = G.style,
                    p = i < 0,
                    f = 1 === i;
                if (p && (i = -i), f && (i *= 100), "lineHeight" !== e || r)
                    if ("%" === r && -1 !== e.indexOf("border")) s = i / 100 * (h ? t.clientWidth : t.clientHeight);
                    else {
                        if (d.cssText = "border:0 solid red;position:" + Q(t, "position") + ";line-height:0;", "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[h ? "borderLeftWidth" : "borderTopWidth"] = i + r;
                        else {
                            if (u = t.parentNode || z.body, -1 !== Q(u, "display").indexOf("flex") && (d.position = "absolute"), c = u._gsCache, l = n.f.ticker.frame, c && h && c.time === l) return c.width * i / 100;
                            d[h ? "width" : "height"] = i + r
                        }
                        u.appendChild(G), s = parseFloat(G[h ? "offsetWidth" : "offsetHeight"]), u.removeChild(G), h && "%" === r && !1 !== o.cacheWidths && ((c = u._gsCache = u._gsCache || {}).time = l, c.width = s / i * 100), 0 !== s || a || (s = $(t, e, i, r, !0))
                    }
                else c = K(t).lineHeight, t.style.lineHeight = i, s = parseFloat(K(t).lineHeight), t.style.lineHeight = c;
                return f && (s /= 100), p ? -s : s
            },
            tt = V.calculateOffset = function(t, e, i) {
                if ("absolute" !== Q(t, "position", i)) return 0;
                var n = "left" === e ? "Left" : "Top",
                    r = Q(t, "margin" + n, i);
                return t["offset" + n] - ($(t, e, parseFloat(r), r.replace(b, "")) || 0)
            },
            et = function(t, e) {
                var i, n, r, o = {};
                if (e = e || K(t, null))
                    if (i = e.length)
                        for (; --i > -1;) - 1 !== (r = e[i]).indexOf("-transform") && Pt !== r || (o[r.replace(A, L)] = e.getPropertyValue(r));
                    else
                        for (i in e) - 1 !== i.indexOf("Transform") && At !== i || (o[i] = e[i]);
                else if (e = t.currentStyle || t.style)
                    for (i in e) "string" == typeof i && void 0 === o[i] && (o[i.replace(A, L)] = e[i]);
                return W || (o.opacity = X(t)), n = Gt(t, e, !1), o.rotation = n.rotation, o.skewX = n.skewX, o.scaleX = n.scaleX, o.scaleY = n.scaleY, o.x = n.x, o.y = n.y, Ct && (o.z = n.z, o.rotationX = n.rotationX, o.rotationY = n.rotationY, o.scaleZ = n.scaleZ), o.filters && delete o.filters, o
            },
            it = function(t, e, i, n, r) {
                var o, a, s, c = {},
                    l = t.style;
                for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (o = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" != typeof o && "string" != typeof o || (c[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof e[a] || "" === e[a].replace(x, "") ? o : 0 : tt(t, a), void 0 !== l[a] && (s = new vt(l, a, l[a], s))));
                if (n)
                    for (a in n) "className" !== a && (c[a] = n[a]);
                return {
                    difs: c,
                    firstMPT: s
                }
            },
            nt = {
                width: ["Left", "Right"],
                height: ["Top", "Bottom"]
            },
            rt = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
            ot = function(t, e, i) {
                if ("svg" === (t.nodeName + "").toLowerCase()) return (i || K(t))[e] || 0;
                if (t.getCTM && Ft(t)) return t.getBBox()[e] || 0;
                var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                    r = nt[e],
                    o = r.length;
                for (i = i || K(t, null); --o > -1;) n -= parseFloat(Q(t, "padding" + r[o], i, !0)) || 0, n -= parseFloat(Q(t, "border" + r[o] + "Width", i, !0)) || 0;
                return n
            },
            at = function(t, e) {
                if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                null != t && "" !== t || (t = "0 0");
                var i, n = t.split(" "),
                    r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : n[0],
                    o = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : n[1];
                if (n.length > 3 && !e) {
                    for (n = t.split(", ").join(",").split(","), t = [], i = 0; i < n.length; i++) t.push(at(n[i]));
                    return t.join(",")
                }
                return null == o ? o = "center" === r ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t = r + " " + o + (n.length > 2 ? " " + n[2] : ""), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== o.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === o.charAt(1), e.ox = parseFloat(r.replace(x, "")), e.oy = parseFloat(o.replace(x, "")), e.v = t), e || t
            },
            st = function(t, e) {
                return "function" == typeof t && (t = t(g, m)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
            },
            ct = function(t, e) {
                "function" == typeof t && (t = t(g, m));
                var i = "string" == typeof t && "=" === t.charAt(1);
                return "string" == typeof t && "v" === t.charAt(t.length - 2) && (t = (i ? t.substr(0, 2) : 0) + window["inner" + ("vh" === t.substr(-2) ? "Height" : "Width")] * (parseFloat(i ? t.substr(2) : t) / 100)), null == t ? e : i ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
            },
            lt = function(t, e, i, n) {
                var r, o, a, s, c;
                return "function" == typeof t && (t = t(g, m)), null == t ? s = e : "number" == typeof t ? s = t : (r = 360, o = t.split("_"), a = ((c = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === t.indexOf("rad") ? 1 : N) - (c ? 0 : e), o.length && (n && (n[i] = e + a), -1 !== t.indexOf("short") && (a %= r) !== a % (r / 2) && (a = a < 0 ? a + r : a - r), -1 !== t.indexOf("_cw") && a < 0 ? a = (a + 9999999999 * r) % r - (a / r | 0) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (a / r | 0) * r)), s = e + a), s < 1e-6 && s > -1e-6 && (s = 0), s
            },
            ht = {
                aqua: [0, 255, 255],
                lime: [0, 255, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, 255],
                navy: [0, 0, 128],
                white: [255, 255, 255],
                fuchsia: [255, 0, 255],
                olive: [128, 128, 0],
                yellow: [255, 255, 0],
                orange: [255, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [255, 0, 0],
                pink: [255, 192, 203],
                cyan: [0, 255, 255],
                transparent: [255, 255, 255, 0]
            },
            ut = function(t, e, i) {
                return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
            },
            dt = o.parseColor = function(t, e) {
                var i, n, r, o, a, s, c, l, h, u, d;
                if (t)
                    if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                    else {
                        if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ht[t]) i = ht[t];
                        else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (n = t.charAt(1)) + n + (r = t.charAt(2)) + r + (o = t.charAt(3)) + o), i = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                        else if ("hsl" === t.substr(0, 3))
                            if (i = d = t.match(v), e) {
                                if (-1 !== t.indexOf("=")) return t.match(y)
                            } else a = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, n = 2 * (c = Number(i[2]) / 100) - (r = c <= .5 ? c * (s + 1) : c + s - c * s), i.length > 3 && (i[3] = Number(i[3])), i[0] = ut(a + 1 / 3, n, r), i[1] = ut(a, n, r), i[2] = ut(a - 1 / 3, n, r);
                        else i = t.match(v) || ht.transparent;
                        i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                    }
                else i = ht.black;
                return e && !d && (n = i[0] / 255, r = i[1] / 255, o = i[2] / 255, c = ((l = Math.max(n, r, o)) + (h = Math.min(n, r, o))) / 2, l === h ? a = s = 0 : (u = l - h, s = c > .5 ? u / (2 - l - h) : u / (l + h), a = l === n ? (r - o) / u + (r < o ? 6 : 0) : l === r ? (o - n) / u + 2 : (n - r) / u + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * c + .5 | 0), i
            },
            pt = function(t, e) {
                var i, n, r, o = t.match(ft) || [],
                    a = 0,
                    s = "";
                if (!o.length) return t;
                for (i = 0; i < o.length; i++) n = o[i], a += (r = t.substr(a, t.indexOf(n, a) - a)).length + n.length, 3 === (n = dt(n, e)).length && n.push(1), s += r + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                return s + t.substr(a)
            },
            ft = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (c in ht) ft += "|" + c + "\\b";
        ft = new RegExp(ft + ")", "gi"), o.colorStringFilter = function(t) {
            var e, i = t[0] + " " + t[1];
            ft.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = pt(t[0], e), t[1] = pt(t[1], e)), ft.lastIndex = 0
        }, n.f.defaultStringFilter || (n.f.defaultStringFilter = o.colorStringFilter);
        var mt = function(t, e, i, n) {
                if (null == t) return function(t) {
                    return t
                };
                var r, o = e ? (t.match(ft) || [""])[0] : "",
                    a = t.split(o).join("").match(_) || [],
                    s = t.substr(0, t.indexOf(a[0])),
                    c = ")" === t.charAt(t.length - 1) ? ")" : "",
                    l = -1 !== t.indexOf(" ") ? " " : ",",
                    h = a.length,
                    u = h > 0 ? a[0].replace(v, "") : "";
                return h ? r = e ? function(t) {
                    var e, d, p, f;
                    if ("number" == typeof t) t += u;
                    else if (n && I.test(t)) {
                        for (f = t.replace(I, "|").split("|"), p = 0; p < f.length; p++) f[p] = r(f[p]);
                        return f.join(",")
                    }
                    if (e = (t.match(ft) || [o])[0], p = (d = t.split(e).join("").match(_) || []).length, h > p--)
                        for (; ++p < h;) d[p] = i ? d[(p - 1) / 2 | 0] : a[p];
                    return s + d.join(l) + l + e + c + (-1 !== t.indexOf("inset") ? " inset" : "")
                } : function(t) {
                    var e, o, d;
                    if ("number" == typeof t) t += u;
                    else if (n && I.test(t)) {
                        for (o = t.replace(I, "|").split("|"), d = 0; d < o.length; d++) o[d] = r(o[d]);
                        return o.join(",")
                    }
                    if (d = (e = t.match(_) || []).length, h > d--)
                        for (; ++d < h;) e[d] = i ? e[(d - 1) / 2 | 0] : a[d];
                    return s + e.join(l) + c
                } : function(t) {
                    return t
                }
            },
            gt = function(t) {
                return t = t.split(","),
                    function(e, i, n, r, o, a, s) {
                        var c, l = (i + "").split(" ");
                        for (s = {}, c = 0; c < 4; c++) s[t[c]] = l[c] = l[c] || l[(c - 1) / 2 >> 0];
                        return r.parse(e, s, o, a)
                    }
            },
            vt = (V._setPluginRatio = function(t) {
                this.plugin.setRatio(t);
                for (var e, i, n, r, o, a = this.data, s = a.proxy, c = a.firstMPT; c;) e = s[c.v], c.r ? e = c.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), c.t[c.p] = e, c = c._next;
                if (a.autoRotate && (a.autoRotate.rotation = a.mod ? a.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === t || 0 === t)
                    for (c = a.firstMPT, o = 1 === t ? "e" : "b"; c;) {
                        if ((i = c.t).type) {
                            if (1 === i.type) {
                                for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                i[o] = r
                            }
                        } else i[o] = i.s + i.xs0;
                        c = c._next
                    }
            }, function(t, e, i, n, r) {
                this.t = t, this.p = e, this.v = i, this.r = r, n && (n._prev = this, this._next = n)
            }),
            yt = (V._parseToProxy = function(t, e, i, n, r, o) {
                var a, s, c, l, h, u = n,
                    d = {},
                    p = {},
                    f = i._transform,
                    m = B;
                for (i._transform = null, B = e, n = h = i.parse(t, e, n, r), B = m, o && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) {
                    if (n.type <= 1 && (p[s = n.p] = n.s + n.c, d[s] = n.s, o || (l = new vt(n, "s", s, l, n.r), n.c = 0), 1 === n.type))
                        for (a = n.l; --a > 0;) c = "xn" + a, p[s = n.p + "_" + c] = n.data[c], d[s] = n[c], o || (l = new vt(n, c, s, l, n.rxp[c]));
                    n = n._next
                }
                return {
                    proxy: d,
                    end: p,
                    firstMPT: l,
                    pt: h
                }
            }, V.CSSPropTween = function(e, i, n, o, a, s, c, l, h, u, d) {
                this.t = e, this.p = i, this.s = n, this.c = o, this.n = c || i, e instanceof yt || r.push(this.n), this.r = l ? "function" == typeof l ? l : Math.round : l, this.type = s || 0, h && (this.pr = h, t = !0), this.b = void 0 === u ? n : u, this.e = void 0 === d ? n + o : d, a && (this._next = a, a._prev = this)
            }),
            _t = function(t, e, i, n, r, o) {
                var a = new yt(t, e, i, n - i, r, -1, o);
                return a.b = i, a.e = a.xs0 = n, a
            },
            xt = o.parseComplex = function(t, e, i, n, r, a, s, c, h, u) {
                i = i || a || "", "function" == typeof n && (n = n(g, m)), s = new yt(t, e, 0, 0, s, u ? 2 : 1, null, !1, c, i, n), n += "", r && ft.test(n + i) && (n = [i, n], o.colorStringFilter(n), i = n[0], n = n[1]);
                var d, p, f, _, x, b, w, M, T, E, S, A, P, L = i.split(", ").join(",").split(" "),
                    C = n.split(", ").join(",").split(" "),
                    R = L.length,
                    O = !1 !== l;
                for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (-1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (L = L.join(" ").replace(I, ", ").split(" "), C = C.join(" ").replace(I, ", ").split(" ")) : (L = L.join(" ").split(",").join(", ").split(" "), C = C.join(" ").split(",").join(", ").split(" ")), R = L.length), R !== C.length && (R = (L = (a || "").split(" ")).length), s.plugin = h, s.setRatio = u, ft.lastIndex = 0, d = 0; d < R; d++)
                    if (_ = L[d], x = C[d] + "", (M = parseFloat(_)) || 0 === M) s.appendXtra("", M, st(x, M), x.replace(y, ""), !(!O || -1 === x.indexOf("px")) && Math.round, !0);
                    else if (r && ft.test(_)) A = ")" + ((A = x.indexOf(")") + 1) ? x.substr(A) : ""), P = -1 !== x.indexOf("hsl") && W, E = x, _ = dt(_, P), x = dt(x, P), (T = _.length + x.length > 6) && !W && 0 === x[3] ? (s["xs" + s.l] += s.l ? " transparent" : "transparent", s.e = s.e.split(C[d]).join("transparent")) : (W || (T = !1), P ? s.appendXtra(E.substr(0, E.indexOf("hsl")) + (T ? "hsla(" : "hsl("), _[0], st(x[0], _[0]), ",", !1, !0).appendXtra("", _[1], st(x[1], _[1]), "%,", !1).appendXtra("", _[2], st(x[2], _[2]), T ? "%," : "%" + A, !1) : s.appendXtra(E.substr(0, E.indexOf("rgb")) + (T ? "rgba(" : "rgb("), _[0], x[0] - _[0], ",", Math.round, !0).appendXtra("", _[1], x[1] - _[1], ",", Math.round).appendXtra("", _[2], x[2] - _[2], T ? "," : A, Math.round), T && (_ = _.length < 4 ? 1 : _[3], s.appendXtra("", _, (x.length < 4 ? 1 : x[3]) - _, A, !1))), ft.lastIndex = 0;
                else if (b = _.match(v)) {
                    if (!(w = x.match(y)) || w.length !== b.length) return s;
                    for (f = 0, p = 0; p < b.length; p++) S = b[p], E = _.indexOf(S, f), s.appendXtra(_.substr(f, E - f), Number(S), st(w[p], S), "", !(!O || "px" !== _.substr(E + S.length, 2)) && Math.round, 0 === p), f = E + S.length;
                    s["xs" + s.l] += _.substr(f)
                } else s["xs" + s.l] += s.l || s["xs" + s.l] ? " " + x : x;
                if (-1 !== n.indexOf("=") && s.data) {
                    for (A = s.xs0 + s.data.s, d = 1; d < s.l; d++) A += s["xs" + d] + s.data["xn" + d];
                    s.e = A + s["xs" + d]
                }
                return s.l || (s.type = -1, s.xs0 = s.e), s.xfirst || s
            },
            bt = 9;
        for ((c = yt.prototype).l = c.pr = 0; --bt > 0;) c["xn" + bt] = 0, c["xs" + bt] = "";
        c.xs0 = "", c._next = c._prev = c.xfirst = c.data = c.plugin = c.setRatio = c.rxp = null, c.appendXtra = function(t, e, i, n, r, o) {
            var a = this,
                s = a.l;
            return a["xs" + s] += o && (s || a["xs" + s]) ? " " + t : t || "", i || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = n || "", s > 0 ? (a.data["xn" + s] = e + i, a.rxp["xn" + s] = r, a["xn" + s] = e, a.plugin || (a.xfirst = new yt(a, "xn" + s, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                s: e + i
            }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + s] += e + (n || ""), a)
        };
        var wt = function(t, e) {
                e = e || {}, this.p = e.prefix && J(t) || t, s[t] = s[this.p] = this, this.format = e.formatter || mt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
            },
            Mt = V._registerComplexSpecialProp = function(t, e, i) {
                "object" != typeof e && (e = {
                    parser: i
                });
                var n, r = t.split(","),
                    o = e.defaultValue;
                for (i = i || [o], n = 0; n < r.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || o, new wt(r[n], e)
            },
            Tt = V._registerPluginProp = function(t) {
                if (!s[t]) {
                    var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                    Mt(t, {
                        parser: function(t, i, n, r, o, c, l) {
                            var h = a.com.greensock.plugins[e];
                            return h ? (h._cssRegister(), s[n].parse(t, i, n, r, o, c, l)) : (q("Error: " + e + " js file not loaded."), o)
                        }
                    })
                }
            };
        (c = wt.prototype).parseComplex = function(t, e, i, n, r, o) {
            var a, s, c, l, h, u, d = this.keyword;
            if (this.multi && (I.test(i) || I.test(e) ? (s = e.replace(I, "|").split("|"), c = i.replace(I, "|").split("|")) : d && (s = [e], c = [i])), c) {
                for (l = c.length > s.length ? c.length : s.length, a = 0; a < l; a++) e = s[a] = s[a] || this.dflt, i = c[a] = c[a] || this.dflt, d && (h = e.indexOf(d)) !== (u = i.indexOf(d)) && (-1 === u ? s[a] = s[a].split(d).join("") : -1 === h && (s[a] += " " + d));
                e = s.join(", "), i = c.join(", ")
            }
            return xt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, o)
        }, c.parse = function(t, e, n, r, o, a, s) {
            return this.parseComplex(t.style, this.format(Q(t, this.p, i, !1, this.dflt)), this.format(e), o, a)
        }, o.registerSpecialProp = function(t, e, i) {
            Mt(t, {
                parser: function(t, n, r, o, a, s, c) {
                    var l = new yt(t, r, 0, 0, a, 2, r, !1, i);
                    return l.plugin = s, l.setRatio = e(t, n, o._tween, r), l
                },
                priority: i
            })
        }, o.useSVGTransformAttr = !0;
        var Et, St = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
            At = J("transform"),
            Pt = Y + "transform",
            Lt = J("transformOrigin"),
            Ct = null !== J("perspective"),
            Rt = V.Transform = function() {
                this.perspective = parseFloat(o.defaultTransformPerspective) || 0, this.force3D = !(!1 === o.defaultForce3D || !Ct) && (o.defaultForce3D || "auto")
            },
            Ot = n.e.SVGElement,
            It = function(t, e, i) {
                var n, r = z.createElementNS("http://www.w3.org/2000/svg", t),
                    o = /([a-z])([A-Z])/g;
                for (n in i) r.setAttributeNS(null, n.replace(o, "$1-$2").toLowerCase(), i[n]);
                return e.appendChild(r), r
            },
            Dt = z.documentElement || {},
            kt = function() {
                var t, e, i, r = f || /Android/i.test(j) && !n.e.chrome;
                return z.createElementNS && !r && (t = It("svg", Dt), i = (e = It("rect", t, {
                    width: 100,
                    height: 50,
                    x: 100
                })).getBoundingClientRect().width, e.style[Lt] = "50% 50%", e.style[At] = "scaleX(0.5)", r = i === e.getBoundingClientRect().width && !(d && Ct), Dt.removeChild(t)), r
            }(),
            Nt = function(t, e, i, n, r, a) {
                var s, c, l, h, u, d, p, f, m, g, v, y, _, x, b = t._gsTransform,
                    w = Ut(t, !0);
                b && (_ = b.xOrigin, x = b.yOrigin), (!n || (s = n.split(" ")).length < 2) && (0 === (p = t.getBBox()).x && 0 === p.y && p.width + p.height === 0 && (p = {
                    x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                    y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                    width: 0,
                    height: 0
                }), s = [(-1 !== (e = at(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * p.width : parseFloat(e[0])) + p.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * p.height : parseFloat(e[1])) + p.y]), i.xOrigin = h = parseFloat(s[0]), i.yOrigin = u = parseFloat(s[1]), n && w !== zt && (d = w[0], p = w[1], f = w[2], m = w[3], g = w[4], v = w[5], (y = d * m - p * f) && (c = h * (m / y) + u * (-f / y) + (f * v - m * g) / y, l = h * (-p / y) + u * (d / y) - (d * v - p * g) / y, h = i.xOrigin = s[0] = c, u = i.yOrigin = s[1] = l)), b && (a && (i.xOffset = b.xOffset, i.yOffset = b.yOffset, b = i), r || !1 !== r && !1 !== o.defaultSmoothOrigin ? (c = h - _, l = u - x, b.xOffset += c * w[0] + l * w[2] - c, b.yOffset += c * w[1] + l * w[3] - l) : b.xOffset = b.yOffset = 0), a || t.setAttribute("data-svg-origin", s.join(" "))
            },
            Bt = function(t) {
                var e, i = U("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    n = this.parentNode,
                    r = this.nextSibling,
                    o = this.style.cssText;
                if (Dt.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                    e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Bt
                } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox());
                return r ? n.insertBefore(this, r) : n.appendChild(this), Dt.removeChild(i), this.style.cssText = o, e
            },
            Ft = function(t) {
                return !(!Ot || !t.getCTM || t.parentNode && !t.ownerSVGElement || ! function(t) {
                    try {
                        return t.getBBox()
                    } catch (e) {
                        return Bt.call(t, !0)
                    }
                }(t))
            },
            zt = [1, 0, 0, 1, 0, 0],
            Ut = function(t, e) {
                var i, n, r, o, a, s, c = t._gsTransform || new Rt,
                    l = t.style;
                if (At ? n = Q(t, Pt, null, !0) : t.currentStyle && (n = (n = t.currentStyle.filter.match(R)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), c.x || 0, c.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, !At || !(s = !K(t) || "none" === K(t).display) && t.parentNode || (s && (o = l.display, l.display = "block"), t.parentNode || (a = 1, Dt.appendChild(t)), i = !(n = Q(t, Pt, null, !0)) || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, o ? l.display = o : s && Wt(l, "display"), a && Dt.removeChild(t)), (c.svg || t.getCTM && Ft(t)) && (i && -1 !== (l[At] + "").indexOf("matrix") && (n = l[At], i = 0), r = t.getAttribute("transform"), i && r && (n = "matrix(" + (r = t.transform.baseVal.consolidate().matrix).a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", i = 0)), i) return zt;
                for (r = (n || "").match(v) || [], bt = r.length; --bt > -1;) o = Number(r[bt]), r[bt] = (a = o - (o |= 0)) ? (1e5 * a + (a < 0 ? -.5 : .5) | 0) / 1e5 + o : o;
                return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
            },
            Gt = V.getTransform = function(t, e, i, r) {
                if (t._gsTransform && i && !r) return t._gsTransform;
                var a, s, c, l, h, u, d = i && t._gsTransform || new Rt,
                    p = d.scaleX < 0,
                    f = Ct && (parseFloat(Q(t, Lt, e, !1, "0 0 0").split(" ")[2]) || d.zOrigin) || 0,
                    m = parseFloat(o.defaultTransformPerspective) || 0;
                if (d.svg = !(!t.getCTM || !Ft(t)), d.svg && (Nt(t, Q(t, Lt, e, !1, "50% 50%") + "", d, t.getAttribute("data-svg-origin")), Et = o.useSVGTransformAttr || kt), (a = Ut(t)) !== zt) {
                    if (16 === a.length) {
                        var g, v, y, _, x, b = a[0],
                            w = a[1],
                            M = a[2],
                            T = a[3],
                            E = a[4],
                            S = a[5],
                            A = a[6],
                            P = a[7],
                            L = a[8],
                            C = a[9],
                            R = a[10],
                            O = a[12],
                            I = a[13],
                            D = a[14],
                            k = a[11],
                            B = Math.atan2(A, R);
                        d.zOrigin && (O = L * (D = -d.zOrigin) - a[12], I = C * D - a[13], D = R * D + d.zOrigin - a[14]), d.rotationX = B * N, B && (g = E * (_ = Math.cos(-B)) + L * (x = Math.sin(-B)), v = S * _ + C * x, y = A * _ + R * x, L = E * -x + L * _, C = S * -x + C * _, R = A * -x + R * _, k = P * -x + k * _, E = g, S = v, A = y), B = Math.atan2(-M, R), d.rotationY = B * N, B && (v = w * (_ = Math.cos(-B)) - C * (x = Math.sin(-B)), y = M * _ - R * x, C = w * x + C * _, R = M * x + R * _, k = T * x + k * _, b = g = b * _ - L * x, w = v, M = y), B = Math.atan2(w, b), d.rotation = B * N, B && (g = b * (_ = Math.cos(B)) + w * (x = Math.sin(B)), v = E * _ + S * x, y = L * _ + C * x, w = w * _ - b * x, S = S * _ - E * x, C = C * _ - L * x, b = g, E = v, L = y), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), B = Math.atan2(E, S), d.scaleX = (1e5 * Math.sqrt(b * b + w * w + M * M) + .5 | 0) / 1e5, d.scaleY = (1e5 * Math.sqrt(S * S + A * A) + .5 | 0) / 1e5, d.scaleZ = (1e5 * Math.sqrt(L * L + C * C + R * R) + .5 | 0) / 1e5, b /= d.scaleX, E /= d.scaleY, w /= d.scaleX, S /= d.scaleY, Math.abs(B) > 2e-5 ? (d.skewX = B * N, E = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(B))) : d.skewX = 0, d.perspective = k ? 1 / (k < 0 ? -k : k) : 0, d.x = O, d.y = I, d.z = D, d.svg && (d.x -= d.xOrigin - (d.xOrigin * b - d.yOrigin * E), d.y -= d.yOrigin - (d.yOrigin * w - d.xOrigin * S))
                    } else if (!Ct || r || !a.length || d.x !== a[4] || d.y !== a[5] || !d.rotationX && !d.rotationY) {
                        var F = a.length >= 6,
                            z = F ? a[0] : 1,
                            U = a[1] || 0,
                            G = a[2] || 0,
                            H = F ? a[3] : 1;
                        d.x = a[4] || 0, d.y = a[5] || 0, c = Math.sqrt(z * z + U * U), l = Math.sqrt(H * H + G * G), h = z || U ? Math.atan2(U, z) * N : d.rotation || 0, u = G || H ? Math.atan2(G, H) * N + h : d.skewX || 0, d.scaleX = c, d.scaleY = l, d.rotation = h, d.skewX = u, Ct && (d.rotationX = d.rotationY = d.z = 0, d.perspective = m, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * z + d.yOrigin * G), d.y -= d.yOrigin - (d.xOrigin * U + d.yOrigin * H))
                    }
                    for (s in Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (p ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = f, d) d[s] < 2e-5 && d[s] > -2e-5 && (d[s] = 0)
                }
                return i && (t._gsTransform = d, d.svg && (Et && t.style[At] ? n.f.delayedCall(.001, function() {
                    Wt(t.style, At)
                }) : !Et && t.getAttribute("transform") && n.f.delayedCall(.001, function() {
                    t.removeAttribute("transform")
                }))), d
            },
            Ht = function(t) {
                var e, i, n = this.data,
                    r = -n.rotation * k,
                    o = r + n.skewX * k,
                    a = (Math.cos(r) * n.scaleX * 1e5 | 0) / 1e5,
                    s = (Math.sin(r) * n.scaleX * 1e5 | 0) / 1e5,
                    c = (Math.sin(o) * -n.scaleY * 1e5 | 0) / 1e5,
                    l = (Math.cos(o) * n.scaleY * 1e5 | 0) / 1e5,
                    h = this.t.style,
                    u = this.t.currentStyle;
                if (u) {
                    i = s, s = -c, c = -i, e = u.filter, h.filter = "";
                    var d, p, m = this.t.offsetWidth,
                        g = this.t.offsetHeight,
                        v = "absolute" !== u.position,
                        y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + s + ", M21=" + c + ", M22=" + l,
                        _ = n.x + m * n.xPercent / 100,
                        x = n.y + g * n.yPercent / 100;
                    if (null != n.ox && (_ += (d = (n.oxp ? m * n.ox * .01 : n.ox) - m / 2) - (d * a + (p = (n.oyp ? g * n.oy * .01 : n.oy) - g / 2) * s), x += p - (d * c + p * l)), y += v ? ", Dx=" + ((d = m / 2) - (d * a + (p = g / 2) * s) + _) + ", Dy=" + (p - (d * c + p * l) + x) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? h.filter = e.replace(O, y) : h.filter = y + " " + e, 0 !== t && 1 !== t || 1 === a && 0 === s && 0 === c && 1 === l && (v && -1 === y.indexOf("Dx=0, Dy=0") || w.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && h.removeAttribute("filter")), !v) {
                        var M, T, E, S = f < 8 ? 1 : -1;
                        for (d = n.ieOffsetX || 0, p = n.ieOffsetY || 0, n.ieOffsetX = Math.round((m - ((a < 0 ? -a : a) * m + (s < 0 ? -s : s) * g)) / 2 + _), n.ieOffsetY = Math.round((g - ((l < 0 ? -l : l) * g + (c < 0 ? -c : c) * m)) / 2 + x), bt = 0; bt < 4; bt++) E = (i = -1 !== (M = u[T = rt[bt]]).indexOf("px") ? parseFloat(M) : $(this.t, T, parseFloat(M), M.replace(b, "")) || 0) !== n[T] ? bt < 2 ? -n.ieOffsetX : -n.ieOffsetY : bt < 2 ? d - n.ieOffsetX : p - n.ieOffsetY, h[T] = (n[T] = Math.round(i - E * (0 === bt || 2 === bt ? 1 : S))) + "px"
                    }
                }
            },
            Vt = V.set3DTransformRatio = V.setTransformRatio = function(t) {
                var e, i, n, r, o, a, s, c, l, h, u, p, f, m, g, v, y, _, x, b, w, M = this.data,
                    T = this.t.style,
                    E = M.rotation,
                    S = M.rotationX,
                    A = M.rotationY,
                    P = M.scaleX,
                    L = M.scaleY,
                    C = M.scaleZ,
                    R = M.x,
                    O = M.y,
                    I = M.z,
                    D = M.svg,
                    N = M.perspective,
                    B = M.force3D,
                    F = M.skewY,
                    z = M.skewX;
                if (F && (z += F, E += F), !((1 !== t && 0 !== t || "auto" !== B || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && B || I || N || A || S || 1 !== C) || Et && D || !Ct) E || z || D ? (E *= k, b = z * k, w = 1e5, i = Math.cos(E) * P, o = Math.sin(E) * P, n = Math.sin(E - b) * -L, a = Math.cos(E - b) * L, b && "simple" === M.skewType && (e = Math.tan(b - F * k), n *= e = Math.sqrt(1 + e * e), a *= e, F && (e = Math.tan(F * k), i *= e = Math.sqrt(1 + e * e), o *= e)), D && (R += M.xOrigin - (M.xOrigin * i + M.yOrigin * n) + M.xOffset, O += M.yOrigin - (M.xOrigin * o + M.yOrigin * a) + M.yOffset, Et && (M.xPercent || M.yPercent) && (g = this.t.getBBox(), R += .01 * M.xPercent * g.width, O += .01 * M.yPercent * g.height), R < (g = 1e-6) && R > -g && (R = 0), O < g && O > -g && (O = 0)), x = (i * w | 0) / w + "," + (o * w | 0) / w + "," + (n * w | 0) / w + "," + (a * w | 0) / w + "," + R + "," + O + ")", D && Et ? this.t.setAttribute("transform", "matrix(" + x) : T[At] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + x) : T[At] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix(" : "matrix(") + P + ",0,0," + L + "," + R + "," + O + ")";
                else {
                    if (d && (P < (g = 1e-4) && P > -g && (P = C = 2e-5), L < g && L > -g && (L = C = 2e-5), !N || M.z || M.rotationX || M.rotationY || (N = 0)), E || z) E *= k, v = i = Math.cos(E), y = o = Math.sin(E), z && (E -= z * k, v = Math.cos(E), y = Math.sin(E), "simple" === M.skewType && (e = Math.tan((z - F) * k), v *= e = Math.sqrt(1 + e * e), y *= e, M.skewY && (e = Math.tan(F * k), i *= e = Math.sqrt(1 + e * e), o *= e))), n = -y, a = v;
                    else {
                        if (!(A || S || 1 !== C || N || D)) return void(T[At] = (M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) translate3d(" : "translate3d(") + R + "px," + O + "px," + I + "px)" + (1 !== P || 1 !== L ? " scale(" + P + "," + L + ")" : ""));
                        i = a = 1, n = o = 0
                    }
                    h = 1, r = s = c = l = u = p = 0, f = N ? -1 / N : 0, m = M.zOrigin, g = 1e-6, ",", "0", (E = A * k) && (v = Math.cos(E), c = -(y = Math.sin(E)), u = f * -y, r = i * y, s = o * y, h = v, f *= v, i *= v, o *= v), (E = S * k) && (e = n * (v = Math.cos(E)) + r * (y = Math.sin(E)), _ = a * v + s * y, l = h * y, p = f * y, r = n * -y + r * v, s = a * -y + s * v, h *= v, f *= v, n = e, a = _), 1 !== C && (r *= C, s *= C, h *= C, f *= C), 1 !== L && (n *= L, a *= L, l *= L, p *= L), 1 !== P && (i *= P, o *= P, c *= P, u *= P), (m || D) && (m && (R += r * -m, O += s * -m, I += h * -m + m), D && (R += M.xOrigin - (M.xOrigin * i + M.yOrigin * n) + M.xOffset, O += M.yOrigin - (M.xOrigin * o + M.yOrigin * a) + M.yOffset), R < g && R > -g && (R = "0"), O < g && O > -g && (O = "0"), I < g && I > -g && (I = 0)), x = M.xPercent || M.yPercent ? "translate(" + M.xPercent + "%," + M.yPercent + "%) matrix3d(" : "matrix3d(", x += (i < g && i > -g ? "0" : i) + "," + (o < g && o > -g ? "0" : o) + "," + (c < g && c > -g ? "0" : c), x += "," + (u < g && u > -g ? "0" : u) + "," + (n < g && n > -g ? "0" : n) + "," + (a < g && a > -g ? "0" : a), S || A || 1 !== C ? (x += "," + (l < g && l > -g ? "0" : l) + "," + (p < g && p > -g ? "0" : p) + "," + (r < g && r > -g ? "0" : r), x += "," + (s < g && s > -g ? "0" : s) + "," + (h < g && h > -g ? "0" : h) + "," + (f < g && f > -g ? "0" : f) + ",") : x += ",0,0,0,0,1,0,", x += R + "," + O + "," + I + "," + (N ? 1 + -I / N : 1) + ")", T[At] = x
                }
            };
        (c = Rt.prototype).x = c.y = c.z = c.skewX = c.skewY = c.rotation = c.rotationX = c.rotationY = c.zOrigin = c.xPercent = c.yPercent = c.xOffset = c.yOffset = 0, c.scaleX = c.scaleY = c.scaleZ = 1, Mt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
            parser: function(t, e, n, r, a, s, c) {
                if (r._lastParsedTransform === c) return a;
                r._lastParsedTransform = c;
                var l, h = c.scale && "function" == typeof c.scale ? c.scale : 0;
                "function" == typeof c[n] && (l = c[n], c[n] = e), h && (c.scale = h(g, t));
                var u, d, p, f, v, y, _, x, b, w = t._gsTransform,
                    M = t.style,
                    T = St.length,
                    E = c,
                    S = {},
                    A = Gt(t, i, !0, E.parseTransform),
                    P = E.transform && ("function" == typeof E.transform ? E.transform(g, m) : E.transform);
                if (A.skewType = E.skewType || A.skewType || o.defaultSkewType, r._transform = A, "rotationZ" in E && (E.rotation = E.rotationZ), P && "string" == typeof P && At)(d = G.style)[At] = P, d.display = "block", d.position = "absolute", -1 !== P.indexOf("%") && (d.width = Q(t, "width"), d.height = Q(t, "height")), z.body.appendChild(G), u = Gt(G, null, !1), "simple" === A.skewType && (u.scaleY *= Math.cos(u.skewX * k)), A.svg && (y = A.xOrigin, _ = A.yOrigin, u.x -= A.xOffset, u.y -= A.yOffset, (E.transformOrigin || E.svgOrigin) && (P = {}, Nt(t, at(E.transformOrigin), P, E.svgOrigin, E.smoothOrigin, !0), y = P.xOrigin, _ = P.yOrigin, u.x -= P.xOffset - A.xOffset, u.y -= P.yOffset - A.yOffset), (y || _) && (x = Ut(G, !0), u.x -= y - (y * x[0] + _ * x[2]), u.y -= _ - (y * x[1] + _ * x[3]))), z.body.removeChild(G), u.perspective || (u.perspective = A.perspective), null != E.xPercent && (u.xPercent = ct(E.xPercent, A.xPercent)), null != E.yPercent && (u.yPercent = ct(E.yPercent, A.yPercent));
                else if ("object" == typeof E) {
                    if (u = {
                            scaleX: ct(null != E.scaleX ? E.scaleX : E.scale, A.scaleX),
                            scaleY: ct(null != E.scaleY ? E.scaleY : E.scale, A.scaleY),
                            scaleZ: ct(E.scaleZ, A.scaleZ),
                            x: ct(E.x, A.x),
                            y: ct(E.y, A.y),
                            z: ct(E.z, A.z),
                            xPercent: ct(E.xPercent, A.xPercent),
                            yPercent: ct(E.yPercent, A.yPercent),
                            perspective: ct(E.transformPerspective, A.perspective)
                        }, null != (v = E.directionalRotation))
                        if ("object" == typeof v)
                            for (d in v) E[d] = v[d];
                        else E.rotation = v;
                    "string" == typeof E.x && -1 !== E.x.indexOf("%") && (u.x = 0, u.xPercent = ct(E.x, A.xPercent)), "string" == typeof E.y && -1 !== E.y.indexOf("%") && (u.y = 0, u.yPercent = ct(E.y, A.yPercent)), u.rotation = lt("rotation" in E ? E.rotation : "shortRotation" in E ? E.shortRotation + "_short" : A.rotation, A.rotation, "rotation", S), Ct && (u.rotationX = lt("rotationX" in E ? E.rotationX : "shortRotationX" in E ? E.shortRotationX + "_short" : A.rotationX || 0, A.rotationX, "rotationX", S), u.rotationY = lt("rotationY" in E ? E.rotationY : "shortRotationY" in E ? E.shortRotationY + "_short" : A.rotationY || 0, A.rotationY, "rotationY", S)), u.skewX = lt(E.skewX, A.skewX), u.skewY = lt(E.skewY, A.skewY)
                }
                for (Ct && null != E.force3D && (A.force3D = E.force3D, f = !0), (p = A.force3D || A.z || A.rotationX || A.rotationY || u.z || u.rotationX || u.rotationY || u.perspective) || null == E.scale || (u.scaleZ = 1); --T > -1;)((P = u[b = St[T]] - A[b]) > 1e-6 || P < -1e-6 || null != E[b] || null != B[b]) && (f = !0, a = new yt(A, b, A[b], P, a), b in S && (a.e = S[b]), a.xs0 = 0, a.plugin = s, r._overwriteProps.push(a.n));
                return P = E.transformOrigin, A.svg && (P || E.svgOrigin) && (y = A.xOffset, _ = A.yOffset, Nt(t, at(P), u, E.svgOrigin, E.smoothOrigin), a = _t(A, "xOrigin", (w ? A : u).xOrigin, u.xOrigin, a, "transformOrigin"), a = _t(A, "yOrigin", (w ? A : u).yOrigin, u.yOrigin, a, "transformOrigin"), y === A.xOffset && _ === A.yOffset || (a = _t(A, "xOffset", w ? y : A.xOffset, A.xOffset, a, "transformOrigin"), a = _t(A, "yOffset", w ? _ : A.yOffset, A.yOffset, a, "transformOrigin")), P = "0px 0px"), (P || Ct && p && A.zOrigin) && (At ? (f = !0, b = Lt, P = (P || Q(t, b, i, !1, "50% 50%")) + "", (a = new yt(M, b, 0, 0, a, -1, "transformOrigin")).b = M[b], a.plugin = s, Ct ? (d = A.zOrigin, P = P.split(" "), A.zOrigin = (P.length > 2 && (0 === d || "0px" !== P[2]) ? parseFloat(P[2]) : d) || 0, a.xs0 = a.e = P[0] + " " + (P[1] || "50%") + " 0px", (a = new yt(A, "zOrigin", 0, 0, a, -1, a.n)).b = d, a.xs0 = a.e = A.zOrigin) : a.xs0 = a.e = P) : at(P + "", A)), f && (r._transformType = A.svg && Et || !p && 3 !== this._transformType ? 2 : 3), l && (c[n] = l), h && (c.scale = h), a
            },
            prefix: !0
        }), Mt("boxShadow", {
            defaultValue: "0px 0px 0px 0px #999",
            prefix: !0,
            color: !0,
            multi: !0,
            keyword: "inset"
        }), Mt("borderRadius", {
            defaultValue: "0px",
            parser: function(t, n, r, o, a, s) {
                n = this.format(n);
                var c, l, h, u, d, p, f, m, g, v, y, _, x, b, w, M, T = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                    E = t.style;
                for (g = parseFloat(t.offsetWidth), v = parseFloat(t.offsetHeight), c = n.split(" "), l = 0; l < T.length; l++) this.p.indexOf("border") && (T[l] = J(T[l])), -1 !== (d = u = Q(t, T[l], i, !1, "0px")).indexOf(" ") && (d = (u = d.split(" "))[0], u = u[1]), p = h = c[l], f = parseFloat(d), _ = d.substr((f + "").length), (x = "=" === p.charAt(1)) ? (m = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), m *= parseFloat(p), y = p.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(p), y = p.substr((m + "").length)), "" === y && (y = e[r] || _), y !== _ && (b = $(t, "borderLeft", f, _), w = $(t, "borderTop", f, _), "%" === y ? (d = b / g * 100 + "%", u = w / v * 100 + "%") : "em" === y ? (d = b / (M = $(t, "borderLeft", 1, "em")) + "em", u = w / M + "em") : (d = b + "px", u = w + "px"), x && (p = parseFloat(d) + m + y, h = parseFloat(u) + m + y)), a = xt(E, T[l], d + " " + u, p + " " + h, !1, "0px", a);
                return a
            },
            prefix: !0,
            formatter: mt("0px 0px 0px 0px", !1, !0)
        }), Mt("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
            defaultValue: "0px",
            parser: function(t, e, n, r, o, a) {
                return xt(t.style, n, this.format(Q(t, n, i, !1, "0px 0px")), this.format(e), !1, "0px", o)
            },
            prefix: !0,
            formatter: mt("0px 0px", !1, !0)
        }), Mt("backgroundPosition", {
            defaultValue: "0 0",
            parser: function(t, e, n, r, o, a) {
                var s, c, l, h, u, d, p = "background-position",
                    m = i || K(t, null),
                    g = this.format((m ? f ? m.getPropertyValue(p + "-x") + " " + m.getPropertyValue(p + "-y") : m.getPropertyValue(p) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                    v = this.format(e);
                if (-1 !== g.indexOf("%") != (-1 !== v.indexOf("%")) && v.split(",").length < 2 && (d = Q(t, "backgroundImage").replace(P, "")) && "none" !== d) {
                    for (s = g.split(" "), c = v.split(" "), H.setAttribute("src", d), l = 2; --l > -1;)(h = -1 !== (g = s[l]).indexOf("%")) !== (-1 !== c[l].indexOf("%")) && (u = 0 === l ? t.offsetWidth - H.width : t.offsetHeight - H.height, s[l] = h ? parseFloat(g) / 100 * u + "px" : parseFloat(g) / u * 100 + "%");
                    g = s.join(" ")
                }
                return this.parseComplex(t.style, g, v, o, a)
            },
            formatter: at
        }), Mt("backgroundSize", {
            defaultValue: "0 0",
            formatter: function(t) {
                return "co" === (t += "").substr(0, 2) ? t : at(-1 === t.indexOf(" ") ? t + " " + t : t)
            }
        }), Mt("perspective", {
            defaultValue: "0px",
            prefix: !0
        }), Mt("perspectiveOrigin", {
            defaultValue: "50% 50%",
            prefix: !0
        }), Mt("transformStyle", {
            prefix: !0
        }), Mt("backfaceVisibility", {
            prefix: !0
        }), Mt("userSelect", {
            prefix: !0
        }), Mt("margin", {
            parser: gt("marginTop,marginRight,marginBottom,marginLeft")
        }), Mt("padding", {
            parser: gt("paddingTop,paddingRight,paddingBottom,paddingLeft")
        }), Mt("clip", {
            defaultValue: "rect(0px,0px,0px,0px)",
            parser: function(t, e, n, r, o, a) {
                var s, c, l;
                return f < 9 ? (c = t.currentStyle, l = f < 8 ? " " : ",", s = "rect(" + c.clipTop + l + c.clipRight + l + c.clipBottom + l + c.clipLeft + ")", e = this.format(e).split(",").join(l)) : (s = this.format(Q(t, this.p, i, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, s, e, o, a)
            }
        }), Mt("textShadow", {
            defaultValue: "0px 0px 0px #999",
            color: !0,
            multi: !0
        }), Mt("autoRound,strictUnits", {
            parser: function(t, e, i, n, r) {
                return r
            }
        }), Mt("border", {
            defaultValue: "0px solid #000",
            parser: function(t, e, n, r, o, a) {
                var s = Q(t, "borderTopWidth", i, !1, "0px"),
                    c = this.format(e).split(" "),
                    l = c[0].replace(b, "");
                return "px" !== l && (s = parseFloat(s) / $(t, "borderTopWidth", 1, l) + l), this.parseComplex(t.style, this.format(s + " " + Q(t, "borderTopStyle", i, !1, "solid") + " " + Q(t, "borderTopColor", i, !1, "#000")), c.join(" "), o, a)
            },
            color: !0,
            formatter: function(t) {
                var e = t.split(" ");
                return e[0] + " " + (e[1] || "solid") + " " + (t.match(ft) || ["#000"])[0]
            }
        }), Mt("borderWidth", {
            parser: gt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
        }), Mt("float,cssFloat,styleFloat", {
            parser: function(t, e, i, n, r, o) {
                var a = t.style,
                    s = "cssFloat" in a ? "cssFloat" : "styleFloat";
                return new yt(a, s, 0, 0, r, -1, i, !1, 0, a[s], e)
            }
        });
        var jt = function(t) {
            var e, i = this.t,
                n = i.filter || Q(this.data, "filter") || "",
                r = this.s + this.c * t | 0;
            100 === r && (-1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), e = !Q(this.data, "filter")) : (i.filter = n.replace(T, ""), e = !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(w, "opacity=" + r))
        };
        Mt("opacity,alpha,autoAlpha", {
            defaultValue: "1",
            parser: function(t, e, n, r, o, a) {
                var s = parseFloat(Q(t, "opacity", i, !1, "1")),
                    c = t.style,
                    l = "autoAlpha" === n;
                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s), l && 1 === s && "hidden" === Q(t, "visibility", i) && 0 !== e && (s = 0), W ? o = new yt(c, "opacity", s, e - s, o) : ((o = new yt(c, "opacity", 100 * s, 100 * (e - s), o)).xn1 = l ? 1 : 0, c.zoom = 1, o.type = 2, o.b = "alpha(opacity=" + o.s + ")", o.e = "alpha(opacity=" + (o.s + o.c) + ")", o.data = t, o.plugin = a, o.setRatio = jt), l && ((o = new yt(c, "visibility", 0, 0, o, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", r._overwriteProps.push(o.n), r._overwriteProps.push(n)), o
            }
        });
        var Wt = function(t, e) {
                e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(S, "-$1").toLowerCase())) : t.removeAttribute(e))
            },
            Xt = function(t) {
                if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                    this.t.setAttribute("class", 0 === t ? this.b : this.e);
                    for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Wt(i, e.p), e = e._next;
                    1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
            };
        Mt("className", {
            parser: function(e, n, r, o, a, s, c) {
                var l, h, u, d, p, f = e.getAttribute("class") || "",
                    m = e.style.cssText;
                if ((a = o._classNamePT = new yt(e, r, 0, 0, a, 2)).setRatio = Xt, a.pr = -11, t = !0, a.b = f, h = et(e, i), u = e._gsClassPT) {
                    for (d = {}, p = u.data; p;) d[p.p] = 1, p = p._next;
                    u.setRatio(1)
                }
                return e._gsClassPT = a, a.e = "=" !== n.charAt(1) ? n : f.replace(new RegExp("(?:\\s|^)" + n.substr(2) + "(?![\\w-])"), "") + ("+" === n.charAt(0) ? " " + n.substr(2) : ""), e.setAttribute("class", a.e), l = it(e, h, et(e), c, d), e.setAttribute("class", f), a.data = l.firstMPT, e.style.cssText = m, a = a.xfirst = o.parse(e, l.difs, a, s)
            }
        });
        var qt = function(t) {
            if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                var e, i, n, r, o, a = this.t.style,
                    c = s.transform.parse;
                if ("all" === this.e) a.cssText = "", r = !0;
                else
                    for (n = (e = this.e.split(" ").join("").split(",")).length; --n > -1;) i = e[n], s[i] && (s[i].parse === c ? r = !0 : i = "transformOrigin" === i ? Lt : s[i].p), Wt(a, i);
                r && (Wt(a, At), (o = this.t._gsTransform) && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
            }
        };
        for (Mt("clearProps", {
                parser: function(e, i, n, r, o) {
                    return (o = new yt(e, n, 0, 0, o, 2)).setRatio = qt, o.e = i, o.pr = -10, o.data = r._tween, t = !0, o
                }
            }), c = "bezier,throwProps,physicsProps,physics2D".split(","), bt = c.length; bt--;) Tt(c[bt]);
        (c = o.prototype)._firstPT = c._lastParsedTransform = c._transform = null, c._onInitTween = function(n, a, c, d) {
            if (!n.nodeType) return !1;
            this._target = m = n, this._tween = c, this._vars = a, g = d, l = a.autoRound, t = !1, e = a.suffixMap || o.suffixMap, i = K(n, ""), r = this._overwriteProps;
            var f, v, y, _, x, b, w, T, E, S = n.style;
            if (h && "" === S.zIndex && ("auto" !== (f = Q(n, "zIndex", i)) && "" !== f || this._addLazySet(S, "zIndex", 0)), "string" == typeof a && (_ = S.cssText, f = et(n, i), S.cssText = _ + ";" + a, f = it(n, f, et(n)).difs, !W && M.test(a) && (f.opacity = parseFloat(RegExp.$1)), a = f, S.cssText = _), a.className ? this._firstPT = v = s.className.parse(n, a.className, "className", this, null, null, a) : this._firstPT = v = this.parse(n, a, null), this._transformType) {
                for (E = 3 === this._transformType, At ? u && (h = !0, "" === S.zIndex && ("auto" !== (w = Q(n, "zIndex", i)) && "" !== w || this._addLazySet(S, "zIndex", 0)), p && this._addLazySet(S, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (E ? "visible" : "hidden"))) : S.zoom = 1, y = v; y && y._next;) y = y._next;
                T = new yt(n, "transform", 0, 0, null, 2), this._linkCSSP(T, null, y), T.setRatio = At ? Vt : Ht, T.data = this._transform || Gt(n, i, !0), T.tween = c, T.pr = -1, r.pop()
            }
            if (t) {
                for (; v;) {
                    for (b = v._next, y = _; y && y.pr > v.pr;) y = y._next;
                    (v._prev = y ? y._prev : x) ? v._prev._next = v: _ = v, (v._next = y) ? y._prev = v : x = v, v = b
                }
                this._firstPT = _
            }
            return !0
        }, c.parse = function(t, n, r, o) {
            var a, c, h, u, d, p, f, v, y, _, x = t.style;
            for (a in n) {
                if ("function" == typeof(p = n[a]) && (p = p(g, m)), c = s[a]) r = c.parse(t, p, a, this, r, o, n);
                else {
                    if ("--" === a.substr(0, 2)) {
                        this._tween._propLookup[a] = this._addTween.call(this._tween, t.style, "setProperty", K(t).getPropertyValue(a) + "", p + "", a, !1, a);
                        continue
                    }
                    d = Q(t, a, i) + "", y = "string" == typeof p, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || y && E.test(p) ? (y || (p = ((p = dt(p)).length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), r = xt(x, a, d, p, !0, "transparent", r, 0, o)) : y && D.test(p) ? r = xt(x, a, d, p, !0, null, r, 0, o) : (f = (h = parseFloat(d)) || 0 === h ? d.substr((h + "").length) : "", "" !== d && "auto" !== d || ("width" === a || "height" === a ? (h = ot(t, a, i), f = "px") : "left" === a || "top" === a ? (h = tt(t, a, i), f = "px") : (h = "opacity" !== a ? 0 : 1, f = "")), (_ = y && "=" === p.charAt(1)) ? (u = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), u *= parseFloat(p), v = p.replace(b, "")) : (u = parseFloat(p), v = y ? p.replace(b, "") : ""), "" === v && (v = a in e ? e[a] : f), p = u || 0 === u ? (_ ? u + h : u) + v : n[a], f !== v && ("" === v && "lineHeight" !== a || (u || 0 === u) && h && (h = $(t, a, h, f), "%" === v ? (h /= $(t, a, 100, "%") / 100, !0 !== n.strictUnits && (d = h + "%")) : "em" === v || "rem" === v || "vw" === v || "vh" === v ? h /= $(t, a, 1, v) : "px" !== v && (u = $(t, a, u, v), v = "px"), _ && (u || 0 === u) && (p = u + h + v))), _ && (u += h), !h && 0 !== h || !u && 0 !== u ? void 0 !== x[a] && (p || p + "" != "NaN" && null != p) ? (r = new yt(x, a, u || h || 0, 0, r, -1, a, !1, 0, d, p)).xs0 = "none" !== p || "display" !== a && -1 === a.indexOf("Style") ? p : d : q("invalid " + a + " tween value: " + n[a]) : (r = new yt(x, a, h, u - h, r, 0, a, !1 !== l && ("px" === v || "zIndex" === a), 0, d, p)).xs0 = v)
                }
                o && r && !r.plugin && (r.plugin = o)
            }
            return r
        }, c.setRatio = function(t) {
            var e, i, n, r = this._firstPT;
            if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                    for (; r;) {
                        if (e = r.c * t + r.s, r.r ? e = r.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), r.type)
                            if (1 === r.type)
                                if (2 === (n = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                                else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                        else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                        else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                        else {
                            for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                            r.t[r.p] = i
                        } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                        else r.t[r.p] = e + r.xs0;
                        r = r._next
                    } else
                        for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
                else
                    for (; r;) {
                        if (2 !== r.type)
                            if (r.r && -1 !== r.type)
                                if (e = r.r(r.s + r.c), r.type) {
                                    if (1 === r.type) {
                                        for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                        r.t[r.p] = i
                                    }
                                } else r.t[r.p] = e + r.xs0;
                        else r.t[r.p] = r.e;
                        else r.setRatio(t);
                        r = r._next
                    }
        }, c._enableTransforms = function(t) {
            this._transform = this._transform || Gt(this._target, i, !0), this._transformType = this._transform.svg && Et || !t && 3 !== this._transformType ? 2 : 3
        };
        var Yt = function(t) {
            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
        };
        c._addLazySet = function(t, e, i) {
            var n = this._firstPT = new yt(t, e, 0, 0, this._firstPT, 2);
            n.e = i, n.setRatio = Yt, n.data = this
        }, c._linkCSSP = function(t, e, i, n) {
            return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
        }, c._mod = function(t) {
            for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next
        }, c._kill = function(t) {
            var e, i, r, o = t;
            if (t.autoAlpha || t.alpha) {
                for (i in o = {}, t) o[i] = t[i];
                o.opacity = 1, o.autoAlpha && (o.visibility = 1)
            }
            for (t.className && (e = this._classNamePT) && ((r = e.xfirst) && r._prev ? this._linkCSSP(r._prev, e._next, r._prev._prev) : r === this._firstPT && (this._firstPT = e._next), e._next && this._linkCSSP(e._next, e._next._next, r._prev), this._classNamePT = null), e = this._firstPT; e;) e.plugin && e.plugin !== i && e.plugin._kill && (e.plugin._kill(t), i = e.plugin), e = e._next;
            return n.d.prototype._kill.call(this, o)
        };
        var Zt = function(t, e, i) {
            var n, r, o, a;
            if (t.slice)
                for (r = t.length; --r > -1;) Zt(t[r], e, i);
            else
                for (r = (n = t.childNodes).length; --r > -1;) a = (o = n[r]).type, o.style && (e.push(et(o)), i && i.push(o)), 1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || Zt(o, e, i)
        };
        return o.cascadeTo = function(t, e, i) {
            var r, o, a, s, c = n.f.to(t, e, i),
                l = [c],
                h = [],
                u = [],
                d = [],
                p = n.f._internals.reservedProps;
            for (t = c._targets || c.target, Zt(t, h, d), c.render(e, !0, !0), Zt(t, u), c.render(0, !0, !0), c._enabled(!0), r = d.length; --r > -1;)
                if ((o = it(d[r], h[r], u[r])).firstMPT) {
                    for (a in o = o.difs, i) p[a] && (o[a] = i[a]);
                    for (a in s = {}, o) s[a] = h[r][a];
                    l.push(n.f.fromTo(d[r], e, s, o))
                }
            return l
        }, n.d.activate([o]), o
    }, !0);
    var o = n.g.CSSPlugin,
        a = n.e._gsDefine.plugin({
            propName: "attr",
            API: 2,
            version: "0.6.1",
            init: function(t, e, i, n) {
                var r, o;
                if ("function" != typeof t.setAttribute) return !1;
                for (r in e) "function" == typeof(o = e[r]) && (o = o(n, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", o + "", r, !1, r), this._overwriteProps.push(r);
                return !0
            }
        }),
        s = n.e._gsDefine.plugin({
            propName: "roundProps",
            version: "1.7.0",
            priority: -1,
            API: 2,
            init: function(t, e, i) {
                return this._tween = i, !0
            }
        }),
        c = function(t) {
            var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
            return function(i) {
                return (Math.round(i / t) * t * e | 0) / e
            }
        },
        l = function(t, e) {
            for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next
        },
        h = s.prototype;
    /*!
     * VERSION: 0.6.1
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    h._onInitAllProps = function() {
        var t, e, i, n, r = this._tween,
            o = r.vars.roundProps,
            a = {},
            s = r._propLookup.roundProps;
        if ("object" != typeof o || o.push)
            for ("string" == typeof o && (o = o.split(",")), i = o.length; --i > -1;) a[o[i]] = Math.round;
        else
            for (n in o) a[n] = c(o[n]);
        for (n in a)
            for (t = r._firstPT; t;) e = t._next, t.pg ? t.t._mod(a) : t.n === n && (2 === t.f && t.t ? l(t.t._firstPT, a[n]) : (this._add(t.t, n, t.s, t.c, a[n]), e && (e._prev = t._prev), t._prev ? t._prev._next = e : r._firstPT === t && (r._firstPT = e), t._next = t._prev = null, r._propLookup[n] = s)), t = e;
        return !1
    }, h._add = function(t, e, i, n, r) {
        this._addTween(t, e, i, i + n, e, r || Math.round), this._overwriteProps.push(e)
    };
    /*!
     * VERSION: 0.3.1
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     **/
    var u = n.e._gsDefine.plugin({
        propName: "directionalRotation",
        version: "0.3.1",
        API: 2,
        init: function(t, e, i, n) {
            "object" != typeof e && (e = {
                rotation: e
            }), this.finals = {};
            var r, o, a, s, c, l, h = !0 === e.useRadians ? 2 * Math.PI : 360;
            for (r in e) "useRadians" !== r && ("function" == typeof(s = e[r]) && (s = s(n, t)), o = (l = (s + "").split("_"))[0], a = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), c = (s = this.finals[r] = "string" == typeof o && "=" === o.charAt(1) ? a + parseInt(o.charAt(0) + "1", 10) * Number(o.substr(2)) : Number(o) || 0) - a, l.length && (-1 !== (o = l.join("_")).indexOf("short") && (c %= h) !== c % (h / 2) && (c = c < 0 ? c + h : c - h), -1 !== o.indexOf("_cw") && c < 0 ? c = (c + 9999999999 * h) % h - (c / h | 0) * h : -1 !== o.indexOf("ccw") && c > 0 && (c = (c - 9999999999 * h) % h - (c / h | 0) * h)), (c > 1e-6 || c < -1e-6) && (this._addTween(t, r, a, a + c, r), this._overwriteProps.push(r)));
            return !0
        },
        set: function(t) {
            var e;
            if (1 !== t) this._super.setRatio.call(this, t);
            else
                for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
        }
    });
    u._autoCSS = !0,
        /*!
         * VERSION: 2.0.2
         * DATE: 2018-08-27
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         * 
         * @author: Jack Doyle, jack@greensock.com
         */
        n.e._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function() {
            var t = function(t) {
                    n.c.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                    var e, i, r = this.vars;
                    for (i in r) e = r[i], o(e) && -1 !== e.join("").indexOf("{self}") && (r[i] = this._swapSelfInParams(e));
                    o(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                },
                e = n.f._internals,
                i = t._internals = {},
                r = e.isSelector,
                o = e.isArray,
                a = e.lazyTweens,
                s = e.lazyRender,
                c = n.e._gsDefine.globals,
                l = function(t) {
                    var e, i = {};
                    for (e in t) i[e] = t[e];
                    return i
                },
                h = function(t, e, i) {
                    var n, r, o = t.cycle;
                    for (n in o) r = o[n], t[n] = "function" == typeof r ? r(i, e[i]) : r[i % r.length];
                    delete t.cycle
                },
                u = i.pauseCallback = function() {},
                d = function(t) {
                    var e, i = [],
                        n = t.length;
                    for (e = 0; e !== n; i.push(t[e++]));
                    return i
                },
                p = t.prototype = new n.c;
            return t.version = "2.0.2", p.constructor = t, p.kill()._gc = p._forcingPlayhead = p._hasPause = !1, p.to = function(t, e, i, r) {
                var o = i.repeat && c.TweenMax || n.f;
                return e ? this.add(new o(t, e, i), r) : this.set(t, i, r)
            }, p.from = function(t, e, i, r) {
                return this.add((i.repeat && c.TweenMax || n.f).from(t, e, i), r)
            }, p.fromTo = function(t, e, i, r, o) {
                var a = r.repeat && c.TweenMax || n.f;
                return e ? this.add(a.fromTo(t, e, i, r), o) : this.set(t, r, o)
            }, p.staggerTo = function(e, i, o, a, s, c, u, p) {
                var f, m, g = new t({
                        onComplete: c,
                        onCompleteParams: u,
                        callbackScope: p,
                        smoothChildTiming: this.smoothChildTiming
                    }),
                    v = o.cycle;
                for ("string" == typeof e && (e = n.f.selector(e) || e), r(e = e || []) && (e = d(e)), (a = a || 0) < 0 && ((e = d(e)).reverse(), a *= -1), m = 0; m < e.length; m++)(f = l(o)).startAt && (f.startAt = l(f.startAt), f.startAt.cycle && h(f.startAt, e, m)), v && (h(f, e, m), null != f.duration && (i = f.duration, delete f.duration)), g.to(e[m], i, f, m * a);
                return this.add(g, s)
            }, p.staggerFrom = function(t, e, i, n, r, o, a, s) {
                return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, n, r, o, a, s)
            }, p.staggerFromTo = function(t, e, i, n, r, o, a, s, c) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, n, r, o, a, s, c)
            }, p.call = function(t, e, i, r) {
                return this.add(n.f.delayedCall(0, t, e, i), r)
            }, p.set = function(t, e, i) {
                return i = this._parseTimeOrLabel(i, 0, !0), null == e.immediateRender && (e.immediateRender = i === this._time && !this._paused), this.add(new n.f(t, 0, e), i)
            }, t.exportRoot = function(e, i) {
                null == (e = e || {}).smoothChildTiming && (e.smoothChildTiming = !0);
                var r, o, a, s, c = new t(e),
                    l = c._timeline;
                for (null == i && (i = !0), l._remove(c, !0), c._startTime = 0, c._rawPrevTime = c._time = c._totalTime = l._time, a = l._first; a;) s = a._next, i && a instanceof n.f && a.target === a.vars.onComplete || ((o = a._startTime - a._delay) < 0 && (r = 1), c.add(a, o)), a = s;
                return l.add(c, 0), r && c.totalDuration(), c
            }, p.add = function(e, i, r, a) {
                var s, c, l, h, u, d;
                if ("number" != typeof i && (i = this._parseTimeOrLabel(i, 0, !0, e)), !(e instanceof n.a)) {
                    if (e instanceof Array || e && e.push && o(e)) {
                        for (r = r || "normal", a = a || 0, s = i, c = e.length, l = 0; l < c; l++) o(h = e[l]) && (h = new t({
                            tweens: h
                        })), this.add(h, s), "string" != typeof h && "function" != typeof h && ("sequence" === r ? s = h._startTime + h.totalDuration() / h._timeScale : "start" === r && (h._startTime -= h.delay())), s += a;
                        return this._uncache(!0)
                    }
                    if ("string" == typeof e) return this.addLabel(e, i);
                    if ("function" != typeof e) throw "Cannot add " + e + " into the timeline; it is not a tween, timeline, function, or string.";
                    e = n.f.delayedCall(0, e)
                }
                if (n.c.prototype.add.call(this, e, i), e._time && (s = Math.max(0, Math.min(e.totalDuration(), (this.rawTime() - e._startTime) * e._timeScale)), Math.abs(s - e._totalTime) > 1e-5 && e.render(s, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                    for (d = (u = this).rawTime() > e._startTime; u._timeline;) d && u._timeline.smoothChildTiming ? u.totalTime(u._totalTime, !0) : u._gc && u._enabled(!0, !1), u = u._timeline;
                return this
            }, p.remove = function(t) {
                if (t instanceof n.a) {
                    this._remove(t, !1);
                    var e = t._timeline = t.vars.useFrames ? n.a._rootFramesTimeline : n.a._rootTimeline;
                    return t._startTime = (t._paused ? t._pauseTime : e._time) - (t._reversed ? t.totalDuration() - t._totalTime : t._totalTime) / t._timeScale, this
                }
                if (t instanceof Array || t && t.push && o(t)) {
                    for (var i = t.length; --i > -1;) this.remove(t[i]);
                    return this
                }
                return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
            }, p._remove = function(t, e) {
                return n.c.prototype._remove.call(this, t, e), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
            }, p.append = function(t, e) {
                return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
            }, p.insert = p.insertMultiple = function(t, e, i, n) {
                return this.add(t, e || 0, i, n)
            }, p.appendMultiple = function(t, e, i, n) {
                return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
            }, p.addLabel = function(t, e) {
                return this._labels[t] = this._parseTimeOrLabel(e), this
            }, p.addPause = function(t, e, i, r) {
                var o = n.f.delayedCall(0, u, i, r || this);
                return o.vars.onComplete = o.vars.onReverseComplete = e, o.data = "isPause", this._hasPause = !0, this.add(o, t)
            }, p.removeLabel = function(t) {
                return delete this._labels[t], this
            }, p.getLabelTime = function(t) {
                return null != this._labels[t] ? this._labels[t] : -1
            }, p._parseTimeOrLabel = function(t, e, i, r) {
                var a, s;
                if (r instanceof n.a && r.timeline === this) this.remove(r);
                else if (r && (r instanceof Array || r.push && o(r)))
                    for (s = r.length; --s > -1;) r[s] instanceof n.a && r[s].timeline === this && this.remove(r[s]);
                if (a = "number" != typeof t || e ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof e) return this._parseTimeOrLabel(e, i && "number" == typeof t && null == this._labels[e] ? t - a : 0, i);
                if (e = e || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = a);
                else {
                    if (-1 === (s = t.indexOf("="))) return null == this._labels[t] ? i ? this._labels[t] = a + e : e : this._labels[t] + e;
                    e = parseInt(t.charAt(s - 1) + "1", 10) * Number(t.substr(s + 1)), t = s > 1 ? this._parseTimeOrLabel(t.substr(0, s - 1), 0, i) : a
                }
                return Number(t) + e
            }, p.seek = function(t, e) {
                return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e)
            }, p.stop = function() {
                return this.paused(!0)
            }, p.gotoAndPlay = function(t, e) {
                return this.play(t, e)
            }, p.gotoAndStop = function(t, e) {
                return this.pause(t, e)
            }, p.render = function(t, e, i) {
                this._gc && this._enabled(!0, !1);
                var n, r, o, c, l, h, u, d = this._time,
                    p = this._dirty ? this.totalDuration() : this._totalDuration,
                    f = this._startTime,
                    m = this._timeScale,
                    g = this._paused;
                if (d !== this._time && (t += this._time - d), t >= p - 1e-7 && t >= 0) this._totalTime = this._time = p, this._reversed || this._hasPausedChild() || (r = !0, c = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || 1e-10 === this._rawPrevTime) && this._rawPrevTime !== t && this._first && (l = !0, this._rawPrevTime > 1e-10 && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, t = p + 1e-4;
                else if (t < 1e-7)
                    if (this._totalTime = this._time = 0, (0 !== d || 0 === this._duration && 1e-10 !== this._rawPrevTime && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (c = "onReverseComplete", r = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = r = !0, c = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                    else {
                        if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && r)
                            for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                        t = 0, this._initted || (l = !0)
                    }
                else {
                    if (this._hasPause && !this._forcingPlayhead && !e) {
                        if (t >= d)
                            for (n = this._first; n && n._startTime <= t && !h;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (h = n), n = n._next;
                        else
                            for (n = this._last; n && n._startTime >= t && !h;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (h = n), n = n._prev;
                        h && (this._time = t = h._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
                    }
                    this._totalTime = this._time = this._rawPrevTime = t
                }
                if (this._time !== d && this._first || i || l || h) {
                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== d && t > 0 && (this._active = !0), 0 === d && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (u = this._time) >= d)
                        for (n = this._first; n && (o = n._next, u === this._time && (!this._paused || g));)(n._active || n._startTime <= u && !n._paused && !n._gc) && (h === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = o;
                    else
                        for (n = this._last; n && (o = n._prev, u === this._time && (!this._paused || g));) {
                            if (n._active || n._startTime <= d && !n._paused && !n._gc) {
                                if (h === n) {
                                    for (h = n._prev; h && h.endTime() > this._time;) h.render(h._reversed ? h.totalDuration() - (t - h._startTime) * h._timeScale : (t - h._startTime) * h._timeScale, e, i), h = h._prev;
                                    h = null, this.pause()
                                }
                                n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                            }
                            n = o
                        }
                    this._onUpdate && (e || (a.length && s(), this._callback("onUpdate"))), c && (this._gc || f !== this._startTime && m === this._timeScale || (0 === this._time || p >= this.totalDuration()) && (r && (a.length && s(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[c] && this._callback(c)))
                }
            }, p._hasPausedChild = function() {
                for (var e = this._first; e;) {
                    if (e._paused || e instanceof t && e._hasPausedChild()) return !0;
                    e = e._next
                }
                return !1
            }, p.getChildren = function(t, e, i, r) {
                r = r || -9999999999;
                for (var o = [], a = this._first, s = 0; a;) a._startTime < r || (a instanceof n.f ? !1 !== e && (o[s++] = a) : (!1 !== i && (o[s++] = a), !1 !== t && (s = (o = o.concat(a.getChildren(!0, e, i))).length))), a = a._next;
                return o
            }, p.getTweensOf = function(t, e) {
                var i, r, o = this._gc,
                    a = [],
                    s = 0;
                for (o && this._enabled(!0, !0), r = (i = n.f.getTweensOf(t)).length; --r > -1;)(i[r].timeline === this || e && this._contains(i[r])) && (a[s++] = i[r]);
                return o && this._enabled(!1, !0), a
            }, p.recent = function() {
                return this._recent
            }, p._contains = function(t) {
                for (var e = t.timeline; e;) {
                    if (e === this) return !0;
                    e = e.timeline
                }
                return !1
            }, p.shiftChildren = function(t, e, i) {
                i = i || 0;
                for (var n, r = this._first, o = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
                if (e)
                    for (n in o) o[n] >= i && (o[n] += t);
                return this._uncache(!0)
            }, p._kill = function(t, e) {
                if (!t && !e) return this._enabled(!1, !1);
                for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1;) i[n]._kill(t, e) && (r = !0);
                return r
            }, p.clear = function(t) {
                var e = this.getChildren(!1, !0, !0),
                    i = e.length;
                for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
                return !1 !== t && (this._labels = {}), this._uncache(!0)
            }, p.invalidate = function() {
                for (var t = this._first; t;) t.invalidate(), t = t._next;
                return n.a.prototype.invalidate.call(this)
            }, p._enabled = function(t, e) {
                if (t === this._gc)
                    for (var i = this._first; i;) i._enabled(t, !0), i = i._next;
                return n.c.prototype._enabled.call(this, t, e)
            }, p.totalTime = function(t, e, i) {
                this._forcingPlayhead = !0;
                var r = n.a.prototype.totalTime.apply(this, arguments);
                return this._forcingPlayhead = !1, r
            }, p.duration = function(t) {
                return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
            }, p.totalDuration = function(t) {
                if (!arguments.length) {
                    if (this._dirty) {
                        for (var e, i, n = 0, r = this._last, o = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > o && this._sortChildren && !r._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(r, r._startTime - r._delay), this._calculatingDuration = 0) : o = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale, this._time -= r._startTime, this._totalTime -= r._startTime, this._rawPrevTime -= r._startTime), this.shiftChildren(-r._startTime, !1, -9999999999), o = 0), (i = r._startTime + r._totalDuration / r._timeScale) > n && (n = i), r = e;
                        this._duration = this._totalDuration = n, this._dirty = !1
                    }
                    return this._totalDuration
                }
                return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
            }, p.paused = function(t) {
                if (!t)
                    for (var e = this._first, i = this._time; e;) e._startTime === i && "isPause" === e.data && (e._rawPrevTime = 0), e = e._next;
                return n.a.prototype.paused.apply(this, arguments)
            }, p.usesFrames = function() {
                for (var t = this._timeline; t._timeline;) t = t._timeline;
                return t === n.a._rootFramesTimeline
            }, p.rawTime = function(t) {
                return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
            }, t
        }, !0);
    var d = n.g.TimelineLite;
    /*!
     * VERSION: 2.0.2
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    n.e._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function() {
        var t = function(t) {
                d.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0
            },
            e = n.f._internals,
            i = e.lazyTweens,
            r = e.lazyRender,
            o = n.e._gsDefine.globals,
            a = new n.b(null, null, 1, 0),
            s = t.prototype = new d;
        return s.constructor = t, s.kill()._gc = !1, t.version = "2.0.2", s.invalidate = function() {
            return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), d.prototype.invalidate.call(this)
        }, s.addCallback = function(t, e, i, r) {
            return this.add(n.f.delayedCall(0, t, i, r), e)
        }, s.removeCallback = function(t, e) {
            if (t)
                if (null == e) this._kill(null, t);
                else
                    for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); --n > -1;) i[n]._startTime === r && i[n]._enabled(!1, !1);
            return this
        }, s.removePause = function(t) {
            return this.removeCallback(d._internals.pauseCallback, t)
        }, s.tweenTo = function(t, e) {
            e = e || {};
            var i, r, s, c = {
                    ease: a,
                    useFrames: this.usesFrames(),
                    immediateRender: !1,
                    lazy: !1
                },
                l = e.repeat && o.TweenMax || n.f;
            for (r in e) c[r] = e[r];
            return c.time = this._parseTimeOrLabel(t), i = Math.abs(Number(c.time) - this._time) / this._timeScale || .001, s = new l(this, i, c), c.onStart = function() {
                s.target.paused(!0), s.vars.time === s.target.time() || i !== s.duration() || s.isFromTo || s.duration(Math.abs(s.vars.time - s.target.time()) / s.target._timeScale).render(s.time(), !0, !0), e.onStart && e.onStart.apply(e.onStartScope || e.callbackScope || s, e.onStartParams || [])
            }, s
        }, s.tweenFromTo = function(t, e, i) {
            i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                onComplete: this.seek,
                onCompleteParams: [t],
                callbackScope: this
            }, i.immediateRender = !1 !== i.immediateRender;
            var n = this.tweenTo(e, i);
            return n.isFromTo = 1, n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
        }, s.render = function(t, e, n) {
            this._gc && this._enabled(!0, !1);
            var o, a, s, c, l, h, u, d, p = this._time,
                f = this._dirty ? this.totalDuration() : this._totalDuration,
                m = this._duration,
                g = this._totalTime,
                v = this._startTime,
                y = this._timeScale,
                _ = this._rawPrevTime,
                x = this._paused,
                b = this._cycle;
            if (p !== this._time && (t += this._time - p), t >= f - 1e-7 && t >= 0) this._locked || (this._totalTime = f, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (a = !0, c = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || _ < 0 || 1e-10 === _) && _ !== t && this._first && (l = !0, _ > 1e-10 && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : (this._time = m, t = m + 1e-4);
            else if (t < 1e-7)
                if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== p || 0 === m && 1e-10 !== _ && (_ > 0 || t < 0 && _ >= 0) && !this._locked) && (c = "onReverseComplete", a = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = a = !0, c = "onReverseComplete") : _ >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                else {
                    if (this._rawPrevTime = m || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && a)
                        for (o = this._first; o && 0 === o._startTime;) o._duration || (a = !1), o = o._next;
                    t = 0, this._initted || (l = !0)
                }
            else if (0 === m && _ < 0 && (l = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (h = m + this._repeatDelay, this._cycle = this._totalTime / h >> 0, 0 !== this._cycle && this._cycle === this._totalTime / h && g <= t && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 0 != (1 & this._cycle) && (this._time = m - this._time), this._time > m ? (this._time = m, t = m + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) {
                if ((t = this._time) >= p || this._repeat && b !== this._cycle)
                    for (o = this._first; o && o._startTime <= t && !u;) o._duration || "isPause" !== o.data || o.ratio || 0 === o._startTime && 0 === this._rawPrevTime || (u = o), o = o._next;
                else
                    for (o = this._last; o && o._startTime >= t && !u;) o._duration || "isPause" === o.data && o._rawPrevTime > 0 && (u = o), o = o._prev;
                u && u._startTime < m && (this._time = t = u._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay))
            }
            if (this._cycle !== b && !this._locked) {
                var w = this._yoyo && 0 != (1 & b),
                    M = w === (this._yoyo && 0 != (1 & this._cycle)),
                    T = this._totalTime,
                    E = this._cycle,
                    S = this._rawPrevTime,
                    A = this._time;
                if (this._totalTime = b * m, this._cycle < b ? w = !w : this._totalTime += m, this._time = p, this._rawPrevTime = 0 === m ? _ - 1e-4 : _, this._cycle = b, this._locked = !0, p = w ? 0 : m, this.render(p, e, 0 === m), e || this._gc || this.vars.onRepeat && (this._cycle = E, this._locked = !1, this._callback("onRepeat")), p !== this._time) return;
                if (M && (this._cycle = b, this._locked = !0, p = w ? m + 1e-4 : -1e-4, this.render(p, !0, !1)), this._locked = !1, this._paused && !x) return;
                this._time = A, this._totalTime = T, this._cycle = E, this._rawPrevTime = S
            }
            if (this._time !== p && this._first || n || l || u) {
                if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== g && t > 0 && (this._active = !0), 0 === g && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (d = this._time) >= p)
                    for (o = this._first; o && (s = o._next, d === this._time && (!this._paused || x));)(o._active || o._startTime <= this._time && !o._paused && !o._gc) && (u === o && this.pause(), o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (t - o._startTime) * o._timeScale, e, n) : o.render((t - o._startTime) * o._timeScale, e, n)), o = s;
                else
                    for (o = this._last; o && (s = o._prev, d === this._time && (!this._paused || x));) {
                        if (o._active || o._startTime <= p && !o._paused && !o._gc) {
                            if (u === o) {
                                for (u = o._prev; u && u.endTime() > this._time;) u.render(u._reversed ? u.totalDuration() - (t - u._startTime) * u._timeScale : (t - u._startTime) * u._timeScale, e, n), u = u._prev;
                                u = null, this.pause()
                            }
                            o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (t - o._startTime) * o._timeScale, e, n) : o.render((t - o._startTime) * o._timeScale, e, n)
                        }
                        o = s
                    }
                this._onUpdate && (e || (i.length && r(), this._callback("onUpdate"))), c && (this._locked || this._gc || v !== this._startTime && y === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (a && (i.length && r(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[c] && this._callback(c)))
            } else g !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate"))
        }, s.getActive = function(t, e, i) {
            null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
            var n, r, o = [],
                a = this.getChildren(t, e, i),
                s = 0,
                c = a.length;
            for (n = 0; n < c; n++)(r = a[n]).isActive() && (o[s++] = r);
            return o
        }, s.getLabelAfter = function(t) {
            t || 0 !== t && (t = this._time);
            var e, i = this.getLabelsArray(),
                n = i.length;
            for (e = 0; e < n; e++)
                if (i[e].time > t) return i[e].name;
            return null
        }, s.getLabelBefore = function(t) {
            null == t && (t = this._time);
            for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                if (e[i].time < t) return e[i].name;
            return null
        }, s.getLabelsArray = function() {
            var t, e = [],
                i = 0;
            for (t in this._labels) e[i++] = {
                time: this._labels[t],
                name: t
            };
            return e.sort(function(t, e) {
                return t.time - e.time
            }), e
        }, s.invalidate = function() {
            return this._locked = !1, d.prototype.invalidate.call(this)
        }, s.progress = function(t, e) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
        }, s.totalProgress = function(t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
        }, s.totalDuration = function(t) {
            return arguments.length ? -1 !== this._repeat && t ? this.timeScale(this.totalDuration() / t) : this : (this._dirty && (d.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
        }, s.time = function(t, e) {
            return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
        }, s.repeat = function(t) {
            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
        }, s.repeatDelay = function(t) {
            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
        }, s.yoyo = function(t) {
            return arguments.length ? (this._yoyo = t, this) : this._yoyo
        }, s.currentLabel = function(t) {
            return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
        }, t
    }, !0);
    var p = n.g.TimelineMax,
        f = 180 / Math.PI,
        m = [],
        g = [],
        v = [],
        y = {},
        _ = n.e._gsDefine.globals,
        x = function(t, e, i, n) {
            i === n && (i = n - (n - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
        },
        b = function(t, e, i, n) {
            var r = {
                    a: t
                },
                o = {},
                a = {},
                s = {
                    c: n
                },
                c = (t + e) / 2,
                l = (e + i) / 2,
                h = (i + n) / 2,
                u = (c + l) / 2,
                d = (l + h) / 2,
                p = (d - u) / 8;
            return r.b = c + (t - c) / 4, o.b = u + p, r.c = o.a = (r.b + o.b) / 2, o.c = a.a = (u + d) / 2, a.b = d - p, s.b = h + (n - h) / 4, a.c = s.a = (a.b + s.b) / 2, [r, o, a, s]
        },
        w = function(t, e, i, n, r) {
            var o, a, s, c, l, h, u, d, p, f, y, _, x, w = t.length - 1,
                M = 0,
                T = t[0].a;
            for (o = 0; o < w; o++) a = (l = t[M]).a, s = l.d, c = t[M + 1].d, r ? (y = m[o], x = ((_ = g[o]) + y) * e * .25 / (n ? .5 : v[o] || .5), d = s - ((h = s - (s - a) * (n ? .5 * e : 0 !== y ? x / y : 0)) + (((u = s + (c - s) * (n ? .5 * e : 0 !== _ ? x / _ : 0)) - h) * (3 * y / (y + _) + .5) / 4 || 0))) : d = s - ((h = s - (s - a) * e * .5) + (u = s + (c - s) * e * .5)) / 2, h += d, u += d, l.c = p = h, l.b = 0 !== o ? T : T = l.a + .6 * (l.c - l.a), l.da = s - a, l.ca = p - a, l.ba = T - a, i ? (f = b(a, T, p, s), t.splice(M, 1, f[0], f[1], f[2], f[3]), M += 4) : M++, T = u;
            (l = t[M]).b = T, l.c = T + .4 * (l.d - T), l.da = l.d - l.a, l.ca = l.c - l.a, l.ba = T - l.a, i && (f = b(l.a, T, l.c, l.d), t.splice(M, 1, f[0], f[1], f[2], f[3]))
        },
        M = function(t, e, i, n) {
            var r, o, a, s, c, l, h = [];
            if (n)
                for (o = (t = [n].concat(t)).length; --o > -1;) "string" == typeof(l = t[o][e]) && "=" === l.charAt(1) && (t[o][e] = n[e] + Number(l.charAt(0) + l.substr(2)));
            if ((r = t.length - 2) < 0) return h[0] = new x(t[0][e], 0, 0, t[0][e]), h;
            for (o = 0; o < r; o++) a = t[o][e], s = t[o + 1][e], h[o] = new x(a, 0, 0, s), i && (c = t[o + 2][e], m[o] = (m[o] || 0) + (s - a) * (s - a), g[o] = (g[o] || 0) + (c - s) * (c - s));
            return h[o] = new x(t[o][e], 0, 0, t[o + 1][e]), h
        },
        T = function(t, e, i, n, r, o) {
            var a, s, c, l, h, u, d, p, f = {},
                _ = [],
                x = o || t[0];
            for (s in r = "string" == typeof r ? "," + r + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == e && (e = 1), t[0]) _.push(s);
            if (t.length > 1) {
                for (p = t[t.length - 1], d = !0, a = _.length; --a > -1;)
                    if (s = _[a], Math.abs(x[s] - p[s]) > .05) {
                        d = !1;
                        break
                    }
                d && (t = t.concat(), o && t.unshift(o), t.push(t[1]), o = t[t.length - 3])
            }
            for (m.length = g.length = v.length = 0, a = _.length; --a > -1;) s = _[a], y[s] = -1 !== r.indexOf("," + s + ","), f[s] = M(t, s, y[s], o);
            for (a = m.length; --a > -1;) m[a] = Math.sqrt(m[a]), g[a] = Math.sqrt(g[a]);
            if (!n) {
                for (a = _.length; --a > -1;)
                    if (y[s])
                        for (u = (c = f[_[a]]).length - 1, l = 0; l < u; l++) h = c[l + 1].da / g[l] + c[l].da / m[l] || 0, v[l] = (v[l] || 0) + h * h;
                for (a = v.length; --a > -1;) v[a] = Math.sqrt(v[a])
            }
            for (a = _.length, l = i ? 4 : 1; --a > -1;) c = f[s = _[a]], w(c, e, i, n, y[s]), d && (c.splice(0, l), c.splice(c.length - l, l));
            return f
        },
        E = function(t, e, i) {
            for (var n, r, o, a, s, c, l, h, u, d, p, f = 1 / i, m = t.length; --m > -1;)
                for (o = (d = t[m]).a, a = d.d - o, s = d.c - o, c = d.b - o, n = r = 0, h = 1; h <= i; h++) n = r - (r = ((l = f * h) * l * a + 3 * (u = 1 - l) * (l * s + u * c)) * l), e[p = m * i + h - 1] = (e[p] || 0) + n * n
        },
        S = n.e._gsDefine.plugin({
            propName: "bezier",
            priority: -1,
            version: "1.3.8",
            API: 2,
            global: !0,
            init: function(t, e, i) {
                this._target = t, e instanceof Array && (e = {
                    values: e
                }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                var n, r, o, a, s, c = e.values || [],
                    l = {},
                    h = c[0],
                    u = e.autoRotate || i.vars.orientToBezier;
                for (n in this._autoRotate = u ? u instanceof Array ? u : [
                        ["x", "y", "rotation", !0 === u ? 0 : Number(u) || 0]
                    ] : null, h) this._props.push(n);
                for (o = this._props.length; --o > -1;) n = this._props[o], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], l[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), s || l[n] !== c[0][n] && (s = l);
                if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? T(c, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, s) : function(t, e, i) {
                        var n, r, o, a, s, c, l, h, u, d, p, f = {},
                            m = "cubic" === (e = e || "soft") ? 3 : 2,
                            g = "soft" === e,
                            v = [];
                        if (g && i && (t = [i].concat(t)), null == t || t.length < m + 1) throw "invalid Bezier data";
                        for (u in t[0]) v.push(u);
                        for (c = v.length; --c > -1;) {
                            for (f[u = v[c]] = s = [], d = 0, h = t.length, l = 0; l < h; l++) n = null == i ? t[l][u] : "string" == typeof(p = t[l][u]) && "=" === p.charAt(1) ? i[u] + Number(p.charAt(0) + p.substr(2)) : Number(p), g && l > 1 && l < h - 1 && (s[d++] = (n + s[d - 2]) / 2), s[d++] = n;
                            for (h = d - m + 1, d = 0, l = 0; l < h; l += m) n = s[l], r = s[l + 1], o = s[l + 2], a = 2 === m ? 0 : s[l + 3], s[d++] = p = 3 === m ? new x(n, r, o, a) : new x(n, (2 * r + n) / 3, (2 * r + o) / 3, o);
                            s.length = d
                        }
                        return f
                    }(c, e.type, l), this._segCount = this._beziers[n].length, this._timeRes) {
                    var d = function(t, e) {
                        var i, n, r, o, a = [],
                            s = [],
                            c = 0,
                            l = 0,
                            h = (e = e >> 0 || 6) - 1,
                            u = [],
                            d = [];
                        for (i in t) E(t[i], a, e);
                        for (r = a.length, n = 0; n < r; n++) c += Math.sqrt(a[n]), d[o = n % e] = c, o === h && (l += c, u[o = n / e >> 0] = d, s[o] = l, c = 0, d = []);
                        return {
                            length: l,
                            lengths: s,
                            segments: u
                        }
                    }(this._beziers, this._timeRes);
                    this._length = d.length, this._lengths = d.lengths, this._segments = d.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                }
                if (u = this._autoRotate)
                    for (this._initialRotations = [], u[0] instanceof Array || (this._autoRotate = u = [u]), o = u.length; --o > -1;) {
                        for (a = 0; a < 3; a++) n = u[o][a], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                        n = u[o][2], this._initialRotations[o] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n)
                    }
                return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
            },
            set: function(t) {
                var e, i, n, r, o, a, s, c, l, h, u = this._segCount,
                    d = this._func,
                    p = this._target,
                    m = t !== this._startRatio;
                if (this._timeRes) {
                    if (l = this._lengths, h = this._curSeg, t *= this._length, n = this._li, t > this._l2 && n < u - 1) {
                        for (c = u - 1; n < c && (this._l2 = l[++n]) <= t;);
                        this._l1 = l[n - 1], this._li = n, this._curSeg = h = this._segments[n], this._s2 = h[this._s1 = this._si = 0]
                    } else if (t < this._l1 && n > 0) {
                        for (; n > 0 && (this._l1 = l[--n]) >= t;);
                        0 === n && t < this._l1 ? this._l1 = 0 : n++, this._l2 = l[n], this._li = n, this._curSeg = h = this._segments[n], this._s1 = h[(this._si = h.length - 1) - 1] || 0, this._s2 = h[this._si]
                    }
                    if (e = n, t -= this._l1, n = this._si, t > this._s2 && n < h.length - 1) {
                        for (c = h.length - 1; n < c && (this._s2 = h[++n]) <= t;);
                        this._s1 = h[n - 1], this._si = n
                    } else if (t < this._s1 && n > 0) {
                        for (; n > 0 && (this._s1 = h[--n]) >= t;);
                        0 === n && t < this._s1 ? this._s1 = 0 : n++, this._s2 = h[n], this._si = n
                    }
                    a = (n + (t - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                } else a = (t - (e = t < 0 ? 0 : t >= 1 ? u - 1 : u * t >> 0) * (1 / u)) * u;
                for (i = 1 - a, n = this._props.length; --n > -1;) r = this._props[n], s = (a * a * (o = this._beziers[r][e]).da + 3 * i * (a * o.ca + i * o.ba)) * a + o.a, this._mod[r] && (s = this._mod[r](s, p)), d[r] ? p[r](s) : p[r] = s;
                if (this._autoRotate) {
                    var g, v, y, _, x, b, w, M = this._autoRotate;
                    for (n = M.length; --n > -1;) r = M[n][2], b = M[n][3] || 0, w = !0 === M[n][4] ? 1 : f, o = this._beziers[M[n][0]], g = this._beziers[M[n][1]], o && g && (o = o[e], g = g[e], v = o.a + (o.b - o.a) * a, v += ((_ = o.b + (o.c - o.b) * a) - v) * a, _ += (o.c + (o.d - o.c) * a - _) * a, y = g.a + (g.b - g.a) * a, y += ((x = g.b + (g.c - g.b) * a) - y) * a, x += (g.c + (g.d - g.c) * a - x) * a, s = m ? Math.atan2(x - y, _ - v) * w + b : this._initialRotations[n], this._mod[r] && (s = this._mod[r](s, p)), d[r] ? p[r](s) : p[r] = s)
                }
            }
        }),
        A = S.prototype;
    
    S.bezierThrough = T, S.cubicToQuadratic = b, S._autoCSS = !0, S.quadraticToCubic = function(t, e, i) {
            return new x(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
        }, S._cssRegister = function() {
            var t = _.CSSPlugin;
            if (t) {
                var e = t._internals,
                    i = e._parseToProxy,
                    n = e._setPluginRatio,
                    r = e.CSSPropTween;
                e._registerComplexSpecialProp("bezier", {
                    parser: function(t, e, o, a, s, c) {
                        e instanceof Array && (e = {
                            values: e
                        }), c = new S;
                        var l, h, u, d = e.values,
                            p = d.length - 1,
                            f = [],
                            m = {};
                        if (p < 0) return s;
                        for (l = 0; l <= p; l++) u = i(t, d[l], a, s, c, p !== l), f[l] = u.end;
                        for (h in e) m[h] = e[h];
                        return m.values = f, (s = new r(t, "bezier", 0, 0, u.pt, 2)).data = u, s.plugin = c, s.setRatio = n, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (l = !0 === m.autoRotate ? 0 : Number(m.autoRotate), m.autoRotate = null != u.end.left ? [
                            ["left", "top", "rotation", l, !1]
                        ] : null != u.end.x && [
                            ["x", "y", "rotation", l, !1]
                        ]), m.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, a._overwriteProps.push("rotation")), c._onInitTween(u.proxy, m, a._tween), s
                    }
                })
            }
        }, A._mod = function(t) {
            for (var e, i = this._overwriteProps, n = i.length; --n > -1;)(e = t[i[n]]) && "function" == typeof e && (this._mod[i[n]] = e)
        }, A._kill = function(t) {
            var e, i, n = this._props;
            for (e in this._beziers)
                if (e in t)
                    for (delete this._beziers[e], delete this._func[e], i = n.length; --i > -1;) n[i] === e && n.splice(i, 1);
            if (n = this._autoRotate)
                for (i = n.length; --i > -1;) t[n[i][2]] && n.splice(i, 1);
            return this._super._kill.call(this, t)
        },
        /*!
         * VERSION: 1.16.1
         * DATE: 2018-08-27
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         * 
         * @author: Jack Doyle, jack@greensock.com
         **/
        n.e._gsDefine("easing.Back", ["easing.Ease"], function() {
            var t, e, i, r, o = n.e.GreenSockGlobals || n.e,
                a = o.com.greensock,
                s = 2 * Math.PI,
                c = Math.PI / 2,
                l = a._class,
                h = function(t, e) {
                    var i = l("easing." + t, function() {}, !0),
                        r = i.prototype = new n.b;
                    return r.constructor = i, r.getRatio = e, i
                },
                u = n.b.register || function() {},
                d = function(t, e, i, n, r) {
                    var o = l("easing." + t, {
                        easeOut: new e,
                        easeIn: new i,
                        easeInOut: new n
                    }, !0);
                    return u(o, t), o
                },
                p = function(t, e, i) {
                    this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
                },
                f = function(t, e) {
                    var i = l("easing." + t, function(t) {
                            this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                        }, !0),
                        r = i.prototype = new n.b;
                    return r.constructor = i, r.getRatio = e, r.config = function(t) {
                        return new i(t)
                    }, i
                },
                m = d("Back", f("BackOut", function(t) {
                    return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
                }), f("BackIn", function(t) {
                    return t * t * ((this._p1 + 1) * t - this._p1)
                }), f("BackInOut", function(t) {
                    return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
                })),
                g = l("easing.SlowMo", function(t, e, i) {
                    e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
                }, !0),
                v = g.prototype = new n.b;
            return v.constructor = g, v.getRatio = function(t) {
                var e = t + (.5 - t) * this._p;
                return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
            }, g.ease = new g(.7, .7), v.config = g.config = function(t, e, i) {
                return new g(t, e, i)
            }, (v = (t = l("easing.SteppedEase", function(t, e) {
                t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
            }, !0)).prototype = new n.b).constructor = t, v.getRatio = function(t) {
                return t < 0 ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
            }, v.config = t.config = function(e, i) {
                return new t(e, i)
            }, (v = (e = l("easing.ExpoScaleEase", function(t, e, i) {
                this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = i
            }, !0)).prototype = new n.b).constructor = e, v.getRatio = function(t) {
                return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2
            }, v.config = e.config = function(t, i, n) {
                return new e(t, i, n)
            }, (v = (i = l("easing.RoughEase", function(t) {
                for (var e, i, r, o, a, s, c = (t = t || {}).taper || "none", l = [], h = 0, u = 0 | (t.points || 20), d = u, f = !1 !== t.randomize, m = !0 === t.clamp, g = t.template instanceof n.b ? t.template : null, v = "number" == typeof t.strength ? .4 * t.strength : .4; --d > -1;) e = f ? Math.random() : 1 / u * d, i = g ? g.getRatio(e) : e, r = "none" === c ? v : "out" === c ? (o = 1 - e) * o * v : "in" === c ? e * e * v : e < .5 ? (o = 2 * e) * o * .5 * v : (o = 2 * (1 - e)) * o * .5 * v, f ? i += Math.random() * r - .5 * r : d % 2 ? i += .5 * r : i -= .5 * r, m && (i > 1 ? i = 1 : i < 0 && (i = 0)), l[h++] = {
                    x: e,
                    y: i
                };
                for (l.sort(function(t, e) {
                        return t.x - e.x
                    }), s = new p(1, 1, null), d = u; --d > -1;) a = l[d], s = new p(a.x, a.y, s);
                this._prev = new p(0, 0, 0 !== s.t ? s : s.next)
            }, !0)).prototype = new n.b).constructor = i, v.getRatio = function(t) {
                var e = this._prev;
                if (t > e.t) {
                    for (; e.next && t >= e.t;) e = e.next;
                    e = e.prev
                } else
                    for (; e.prev && t <= e.t;) e = e.prev;
                return this._prev = e, e.v + (t - e.t) / e.gap * e.c
            }, v.config = function(t) {
                return new i(t)
            }, i.ease = new i, d("Bounce", h("BounceOut", function(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            }), h("BounceIn", function(t) {
                return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
            }), h("BounceInOut", function(t) {
                var e = t < .5;
                return (t = e ? 1 - 2 * t : 2 * t - 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
            })), d("Circ", h("CircOut", function(t) {
                return Math.sqrt(1 - (t -= 1) * t)
            }), h("CircIn", function(t) {
                return -(Math.sqrt(1 - t * t) - 1)
            }), h("CircInOut", function(t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            })), d("Elastic", (r = function(t, e, i) {
                var r = l("easing." + t, function(t, e) {
                        this._p1 = t >= 1 ? t : 1, this._p2 = (e || i) / (t < 1 ? t : 1), this._p3 = this._p2 / s * (Math.asin(1 / this._p1) || 0), this._p2 = s / this._p2
                    }, !0),
                    o = r.prototype = new n.b;
                return o.constructor = r, o.getRatio = e, o.config = function(t, e) {
                    return new r(t, e)
                }, r
            })("ElasticOut", function(t) {
                return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
            }, .3), r("ElasticIn", function(t) {
                return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)
            }, .3), r("ElasticInOut", function(t) {
                return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
            }, .45)), d("Expo", h("ExpoOut", function(t) {
                return 1 - Math.pow(2, -10 * t)
            }), h("ExpoIn", function(t) {
                return Math.pow(2, 10 * (t - 1)) - .001
            }), h("ExpoInOut", function(t) {
                return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
            })), d("Sine", h("SineOut", function(t) {
                return Math.sin(t * c)
            }), h("SineIn", function(t) {
                return 1 - Math.cos(t * c)
            }), h("SineInOut", function(t) {
                return -.5 * (Math.cos(Math.PI * t) - 1)
            })), l("easing.EaseLookup", {
                find: function(t) {
                    return n.b.map[t]
                }
            }, !0), u(o.SlowMo, "SlowMo", "ease,"), u(i, "RoughEase", "ease,"), u(t, "SteppedEase", "ease,"), m
        }, !0);
    var P = n.g.Back,
        L = n.g.Elastic,
        C = n.g.Bounce,
        R = n.g.RoughEase,
        O = n.g.SlowMo,
        I = n.g.SteppedEase,
        D = n.g.Circ,
        k = n.g.Expo,
        N = n.g.Sine,
        B = n.g.ExpoScaleEase;
    r._autoActivated = [d, p, o, a, S, s, u, P, L, C, R, O, I, D, k, N, B], i.d(e, "a", function() {
        return n.f
    })
}, function(t, e) {
    var i;
    i = function() {
        return this
    }();
    try {
        i = i || Function("return this")() || (0, eval)("this")
    } catch (t) {
        "object" == typeof window && (i = window)
    }
    t.exports = i
}, function(t, e, i) {
    "use strict";
    (function(t) {
        var n = i(1),
            r = i(2),
            o = i(5),
            a = i.n(o),
            s = (i(11), i(12), i(13), i(16), i(6));
        i(17), i(19);

        function c(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function l(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
            }
        }
        window.Zlib = a.a.Zlib;
        var h = function() {
            function e() {
                ! function(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }(this, e), this.$el = null, this.mixer = null, this.progressAnimation = 0, this.isFbxLoaded = !1, this.canBlow = !1, this.loopDoubleSideFuck = 1, this.isFirstAnimDone = !1, this.speed = .11, this.colors = {
                    middleFinger: 12124236,
                    ground: 720972
                }, this.middleFingers = [], this.mixers = [], this.actions = [], this.update = this.update.bind(this)
            }
            return function(t, e, i) {
                e && l(t.prototype, e), i && l(t, i)
            }(e, [{
                key: "init",
                value: function(e) {
                    var i = e.$el;
                    this.$el = i, this.scene = new n.Scene, this.scene.background = new t.Color(819), this.scene.fog = new t.Fog(this.colors.ground, 100, 500), this.camera = new n.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 2e3), this.camera.position.set(-20, 50, 30), this.renderer = new n.WebGLRenderer({
                        antialias: !0
                    }), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(window.innerWidth, window.innerHeight), this.renderer.shadowMap.enabled = !0, this.$el.appendChild(this.renderer.domElement), this.controls = this.initControls(this.camera), this.clock = new t.Clock, this.loadModels(), this.initLights(), this.initSpace(), this.update(), this.initGui(), this.initEvents(), this.initDOM()
                }
            }, {
                key: "initDOM",
                value: function() {
                    this.$el = document.querySelector(".Home"), this.$els = {}, this.$els = function(t) {
                        for (var e = 1; e < arguments.length; e++) {
                            var i = null != arguments[e] ? arguments[e] : {},
                                n = Object.keys(i);
                            "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter(function(t) {
                                return Object.getOwnPropertyDescriptor(i, t).enumerable
                            }))), n.forEach(function(e) {
                                c(t, e, i[e])
                            })
                        }
                        return t
                    }({}, this.$els, {
                        blow: this.$el.querySelector(".blow"),
                        blowSpans: this.$el.querySelectorAll("span")
                    })
                }
            }, {
                key: "initEvents",
                value: function() {
                    window.addEventListener("resize", this.resize.bind(this), !1)
                }
            }, {
                key: "initGui",
                value: function() {
                    var t = this,
                        e = {
                            progressAnimation: this.progressAnimation,
                            speed: this.speed
                        };
                    s.a.add(e, "speed", .05, .3).onChange(function() {
                        t.speed = e.speed, t.progressAnimation = e.progressAnimation
                    })
                }
            }, {
                key: "initControls",
                value: function(e) {
                    var i = new t.OrbitControls(e, this.renderer.domElement);
                    return i.update(), i
                }
            }, {
                key: "initLights",
                value: function() {
                    var e = new t.HemisphereLight(16777215, 16777215, .5),
                        i = new t.DirectionalLight(16777215, .8);
                    i.position.set(200, 200, 100), i.castShadow = !0, this.debugLight(-200, 200, 100, 0);
                    var n = new t.DirectionalLight(16777215, .4);
                    n.position.set(-200, 200, 100), n.castShadow = !0, this.debugLight(-200, 200, 100, 0), this.scene.add(n), this.scene.add(e), this.scene.add(i)
                }
            }, {
                key: "debugLight",
                value: function(e, i, n, r) {
                    var o = new t.SphereGeometry(5, 32, 32),
                        a = new t.MeshPhongMaterial({
                            color: 0
                        }),
                        s = new t.Mesh(o, a);
                    s.position.set(-200, 200, 100), this.scene.add(s)
                }
            }, {
                key: "initSpace",
                value: function() {
                    var e = new t.Mesh(new t.PlaneBufferGeometry(2e3, 2e3), new t.MeshPhongMaterial({
                        color: this.colors.ground
                    }));
                    e.rotation.x = -Math.PI / 2, e.position.y = -30, this.scene.add(e);
                    var i = new t.SphereGeometry(800, 32, 32),
                        n = new t.MeshPhongMaterial({
                            color: this.colors.ground,
                            side: t.BackSide
                        }),
                        r = new t.Mesh(i, n);
                    r.receiveShadow = !0, r.position.y = 200, this.scene.add(r)
                }
            }, {
                key: "loadModels",
                value: function() {
                    var e = this,
                        i = new t.FBXLoader;
                    this.group = new t.Group;
                    for (var n = 0; n < 2; n++) i.load("assets/models/fuck-emma.FBX", function(t) {
                        return e.onLoaded(t)
                    })
                }
            }, {
                key: "onLoaded",
                value: function(t) {
                    this.isFbxLoaded = !0, this.initMiddleFinger(t)
                }
            }, {
                key: "initMiddleFinger",
                value: function(e) {
                    var i = e;
                    i.children[0].material = new t.MeshLambertMaterial({
                        color: this.colors.middleFinger,
                        skinning: !0,
                        flatShading: !0,
                        side: t.DoubleSide
                    }), i.traverse(function(t) {
                        t.isMesh && (t.receiveShadow = !0)
                    }), this.group.add(i), this.middleFingers.push(i), i.position.y = -112, i.position.z = -30, 1 == this.middleFingers.length ? (i.position.x = 35, this.showMiddleFinger(0)) : (i.position.x = -20, i.scale.x = -1, this.scene.add(this.group)), i.children[0].material.opacity = 0, i.children[0].material.transparent = !0, this.initAnimations(this.middleFingers.length - 1)
                }
            }, {
                key: "initAnimations",
                value: function(e) {
                    this.middleFingers[e].mixer = new t.AnimationMixer(this.middleFingers[e]), this.mixers.push(this.middleFingers[e].mixer), this.actions.push(this.mixers[e].clipAction(this.middleFingers[e].animations[0])), this.actions[e].play()
                }
            }, {
                key: "update",
                value: function() {
                    requestAnimationFrame(this.update), this.controls.update(), this.controls.enableZoom = !1, this.controls.enableRotate = !1, this.controls.enablePan = !1, this.updateAnimation(), this.renderer.render(this.scene, this.camera)
                }
            }, {
                key: "updateAnimation",
                value: function() {
                    var t = this;
                    if (this.isFbxLoaded) {
                        for (var e = 0; e < this.mixers.length; e++) this.mixers[e].update(0);
                        for (var i = 0; i < this.actions.length; i++) this.isBlowEnd || (this.actions[i].time = this.progressAnimation)
                    }
                    this.isFbxLoaded && !this.isFirstAnimDone && (this.isFirstAnimDone = !0, r.a.to(this, 2.3, {
                        progressAnimation: .66,
                        delay: 2.2,
                        onComplete: function() {
                            t.showMiddleFinger(1), t.moveX(), t.animateTwice(), t.isBlowEnd = !0
                        }
                    }))
                }
            }, {
                key: "resize",
                value: function() {
                    this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(window.innerWidth, window.innerHeight)
                }
            }, {
                key: "showMiddleFinger",
                value: function(t) {
                    var e = this;
                    r.a.to(this.middleFingers[t].children[0].material, .5, {
                        opacity: 1,
                        onComplete: function() {
                            0 == t && e.animate()
                        }
                    })
                }
            }, {
                key: "animate",
                value: function() {
                    r.a.to(this.camera.position, 4, {
                        x: 0,
                        z: 35,
                        y: 0,
                        ease: Expo.easeInOut
                    }), r.a.to(this, 4, {
                        progressAnimation: .3,
                        ease: Expo.easeOut
                    }), TweenMax.delayedCall(.4, this.showBlow.bind(this))
                }
            }, {
                key: "showBlow",
                value: function() {
                    var t;
                    TweenMax.staggerFromTo(this.$els.blowSpans, .5, {
                        y: 200,
                        opacity: 0
                    }, (c(t = {
                        y: 0,
                        opacity: 1,
                        delay: 1,
                        ease: Back.easeOut
                    }, "delay", 2), c(t, "onComplete", this.hideBlow.bind(this)), t), .04)
                }
            }, {
                key: "hideBlow",
                value: function() {
                    var t = this;
                    TweenMax.to(this.$els.blow, .5, {
                        y: 240,
                        scale: .4,
                        delay: 1,
                        ease: Back.easeOut,
                        onComplete: function() {
                            t.canBlow = !0
                        }
                    }, .04)
                }
            }, {
                key: "moveX",
                value: function() {
                    r.a.to(this.group.position, .8, {
                        x: -8,
                        ease: Expo.easeOut
                    })
                }
            }, {
                key: "animateTwice",
                value: function() {
                    this.loopDoubleSideFuck = -1 * this.loopDoubleSideFuck, 1 == this.loopDoubleSideFuck ? (TweenMax.to(this.middleFingers[0].position, this.speed, {
                        z: -35,
                        y: -120,
                        onComplete: this.animateTwice.bind(this)
                    }), TweenMax.to(this.middleFingers[1].position, this.speed, {
                        z: -30,
                        y: -112
                    }), TweenMax.to(this.group.position, this.speed, {
                        x: -6
                    })) : (TweenMax.to(this.middleFingers[0].position, this.speed, {
                        z: -30,
                        y: -112,
                        onComplete: this.animateTwice.bind(this)
                    }), TweenMax.to(this.middleFingers[1].position, this.speed, {
                        z: -35,
                        y: -120
                    }), TweenMax.to(this.group.position, this.speed, {
                        x: -10
                    }))
                }
            }]), e
        }();
        e.a = new h
    }).call(this, i(1))
}, function(t, e) {
    /** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
    (function() {
        "use strict";
        var t = void 0,
            e = this;

        function i(i, n) {
            var r, o = i.split("."),
                a = e;
            !(o[0] in a) && a.execScript && a.execScript("var " + o[0]);
            for (; o.length && (r = o.shift());) o.length || n === t ? a = a[r] ? a[r] : a[r] = {} : a[r] = n
        }
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array && "undefined" != typeof DataView;

        function r(t) {
            var e, i, r, o, a, s, c, l, h, u, d = t.length,
                p = 0,
                f = Number.POSITIVE_INFINITY;
            for (l = 0; l < d; ++l) t[l] > p && (p = t[l]), t[l] < f && (f = t[l]);
            for (e = 1 << p, i = new(n ? Uint32Array : Array)(e), r = 1, o = 0, a = 2; r <= p;) {
                for (l = 0; l < d; ++l)
                    if (t[l] === r) {
                        for (s = 0, c = o, h = 0; h < r; ++h) s = s << 1 | 1 & c, c >>= 1;
                        for (u = r << 16 | l, h = s; h < e; h += a) i[h] = u;
                        ++o
                    }++r, o <<= 1, a <<= 1
            }
            return [i, p, f]
        }

        function o(t, e) {
            switch (this.g = [], this.h = 32768, this.d = this.f = this.a = this.l = 0, this.input = n ? new Uint8Array(t) : t, this.m = !1, this.i = s, this.r = !1, !e && (e = {}) || (e.index && (this.a = e.index), e.bufferSize && (this.h = e.bufferSize), e.bufferType && (this.i = e.bufferType), e.resize && (this.r = e.resize)), this.i) {
                case a:
                    this.b = 32768, this.c = new(n ? Uint8Array : Array)(32768 + this.h + 258);
                    break;
                case s:
                    this.b = 0, this.c = new(n ? Uint8Array : Array)(this.h), this.e = this.z, this.n = this.v, this.j = this.w;
                    break;
                default:
                    throw Error("invalid inflate mode")
            }
        }
        var a = 0,
            s = 1,
            c = {
                t: a,
                s: s
            };
        o.prototype.k = function() {
            for (; !this.m;) {
                var e = A(this, 3);
                switch (1 & e && (this.m = !0), e >>>= 1) {
                    case 0:
                        var i = this.input,
                            o = this.a,
                            c = this.c,
                            l = this.b,
                            h = i.length,
                            u = t,
                            p = c.length,
                            f = t;
                        if (this.d = this.f = 0, o + 1 >= h) throw Error("invalid uncompressed block header: LEN");
                        if (u = i[o++] | i[o++] << 8, o + 1 >= h) throw Error("invalid uncompressed block header: NLEN");
                        if (u === ~(i[o++] | i[o++] << 8)) throw Error("invalid uncompressed block header: length verify");
                        if (o + u > i.length) throw Error("input buffer is broken");
                        switch (this.i) {
                            case a:
                                for (; l + u > c.length;) {
                                    if (u -= f = p - l, n) c.set(i.subarray(o, o + f), l), l += f, o += f;
                                    else
                                        for (; f--;) c[l++] = i[o++];
                                    this.b = l, c = this.e(), l = this.b
                                }
                                break;
                            case s:
                                for (; l + u > c.length;) c = this.e({
                                    p: 2
                                });
                                break;
                            default:
                                throw Error("invalid inflate mode")
                        }
                        if (n) c.set(i.subarray(o, o + u), l), l += u, o += u;
                        else
                            for (; u--;) c[l++] = i[o++];
                        this.a = o, this.b = l, this.c = c;
                        break;
                    case 1:
                        this.j(T, S);
                        break;
                    case 2:
                        var m, g, v, y, _ = A(this, 5) + 257,
                            x = A(this, 5) + 1,
                            b = A(this, 4) + 4,
                            w = new(n ? Uint8Array : Array)(d.length),
                            M = t,
                            E = t,
                            L = t,
                            C = t,
                            R = t;
                        for (R = 0; R < b; ++R) w[d[R]] = A(this, 3);
                        if (!n)
                            for (R = b, b = w.length; R < b; ++R) w[d[R]] = 0;
                        for (m = r(w), M = new(n ? Uint8Array : Array)(_ + x), R = 0, y = _ + x; R < y;) switch (E = P(this, m), E) {
                            case 16:
                                for (C = 3 + A(this, 2); C--;) M[R++] = L;
                                break;
                            case 17:
                                for (C = 3 + A(this, 3); C--;) M[R++] = 0;
                                L = 0;
                                break;
                            case 18:
                                for (C = 11 + A(this, 7); C--;) M[R++] = 0;
                                L = 0;
                                break;
                            default:
                                L = M[R++] = E
                        }
                        g = r(n ? M.subarray(0, _) : M.slice(0, _)), v = r(n ? M.subarray(_) : M.slice(_)), this.j(g, v);
                        break;
                    default:
                        throw Error("unknown BTYPE: " + e)
                }
            }
            return this.n()
        };
        var l, h, u = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
            d = n ? new Uint16Array(u) : u,
            p = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
            f = n ? new Uint16Array(p) : p,
            m = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
            g = n ? new Uint8Array(m) : m,
            v = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
            y = n ? new Uint16Array(v) : v,
            _ = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
            x = n ? new Uint8Array(_) : _,
            b = new(n ? Uint8Array : Array)(288);
        for (l = 0, h = b.length; l < h; ++l) b[l] = 143 >= l ? 8 : 255 >= l ? 9 : 279 >= l ? 7 : 8;
        var w, M, T = r(b),
            E = new(n ? Uint8Array : Array)(30);
        for (w = 0, M = E.length; w < M; ++w) E[w] = 5;
        var S = r(E);

        function A(t, e) {
            for (var i, n = t.f, r = t.d, o = t.input, a = t.a, s = o.length; r < e;) {
                if (a >= s) throw Error("input buffer is broken");
                n |= o[a++] << r, r += 8
            }
            return i = n & (1 << e) - 1, t.f = n >>> e, t.d = r - e, t.a = a, i
        }

        function P(t, e) {
            for (var i, n, r = t.f, o = t.d, a = t.input, s = t.a, c = a.length, l = e[0], h = e[1]; o < h && !(s >= c);) r |= a[s++] << o, o += 8;
            if ((n = (i = l[r & (1 << h) - 1]) >>> 16) > o) throw Error("invalid code length: " + n);
            return t.f = r >> n, t.d = o - n, t.a = s, 65535 & i
        }

        function L(t, e) {
            var i, n;
            switch (this.input = t, this.a = 0, !e && (e = {}) || (e.index && (this.a = e.index), e.verify && (this.A = e.verify)), i = t[this.a++], n = t[this.a++], 15 & i) {
                case C:
                    this.method = C;
                    break;
                default:
                    throw Error("unsupported compression method")
            }
            if (0 != ((i << 8) + n) % 31) throw Error("invalid fcheck flag:" + ((i << 8) + n) % 31);
            if (32 & n) throw Error("fdict flag is not supported");
            this.q = new o(t, {
                index: this.a,
                bufferSize: e.bufferSize,
                bufferType: e.bufferType,
                resize: e.resize
            })
        }
        o.prototype.j = function(t, e) {
            var i = this.c,
                n = this.b;
            this.o = t;
            for (var r, o, a, s, c = i.length - 258; 256 !== (r = P(this, t));)
                if (256 > r) n >= c && (this.b = n, i = this.e(), n = this.b), i[n++] = r;
                else
                    for (s = f[o = r - 257], 0 < g[o] && (s += A(this, g[o])), r = P(this, e), a = y[r], 0 < x[r] && (a += A(this, x[r])), n >= c && (this.b = n, i = this.e(), n = this.b); s--;) i[n] = i[n++ - a];
            for (; 8 <= this.d;) this.d -= 8, this.a--;
            this.b = n
        }, o.prototype.w = function(t, e) {
            var i = this.c,
                n = this.b;
            this.o = t;
            for (var r, o, a, s, c = i.length; 256 !== (r = P(this, t));)
                if (256 > r) n >= c && (c = (i = this.e()).length), i[n++] = r;
                else
                    for (s = f[o = r - 257], 0 < g[o] && (s += A(this, g[o])), r = P(this, e), a = y[r], 0 < x[r] && (a += A(this, x[r])), n + s > c && (c = (i = this.e()).length); s--;) i[n] = i[n++ - a];
            for (; 8 <= this.d;) this.d -= 8, this.a--;
            this.b = n
        }, o.prototype.e = function() {
            var t, e, i = new(n ? Uint8Array : Array)(this.b - 32768),
                r = this.b - 32768,
                o = this.c;
            if (n) i.set(o.subarray(32768, i.length));
            else
                for (t = 0, e = i.length; t < e; ++t) i[t] = o[t + 32768];
            if (this.g.push(i), this.l += i.length, n) o.set(o.subarray(r, r + 32768));
            else
                for (t = 0; 32768 > t; ++t) o[t] = o[r + t];
            return this.b = 32768, o
        }, o.prototype.z = function(t) {
            var e, i, r, o = this.input.length / this.a + 1 | 0,
                a = this.input,
                s = this.c;
            return t && ("number" == typeof t.p && (o = t.p), "number" == typeof t.u && (o += t.u)), 2 > o ? i = (r = (a.length - this.a) / this.o[2] / 2 * 258 | 0) < s.length ? s.length + r : s.length << 1 : i = s.length * o, n ? (e = new Uint8Array(i)).set(s) : e = s, this.c = e
        }, o.prototype.n = function() {
            var t, e, i, r, o, a = 0,
                s = this.c,
                c = this.g,
                l = new(n ? Uint8Array : Array)(this.l + (this.b - 32768));
            if (0 === c.length) return n ? this.c.subarray(32768, this.b) : this.c.slice(32768, this.b);
            for (e = 0, i = c.length; e < i; ++e)
                for (r = 0, o = (t = c[e]).length; r < o; ++r) l[a++] = t[r];
            for (e = 32768, i = this.b; e < i; ++e) l[a++] = s[e];
            return this.g = [], this.buffer = l
        }, o.prototype.v = function() {
            var t, e = this.b;
            return n ? this.r ? (t = new Uint8Array(e)).set(this.c.subarray(0, e)) : t = this.c.subarray(0, e) : (this.c.length > e && (this.c.length = e), t = this.c), this.buffer = t
        }, L.prototype.k = function() {
            var t, e, i = this.input;
            if (t = this.q.k(), this.a = this.q.a, this.A) {
                e = (i[this.a++] << 24 | i[this.a++] << 16 | i[this.a++] << 8 | i[this.a++]) >>> 0;
                var n = t;
                if ("string" == typeof n) {
                    var r, o, a = n.split("");
                    for (r = 0, o = a.length; r < o; r++) a[r] = (255 & a[r].charCodeAt(0)) >>> 0;
                    n = a
                }
                for (var s, c = 1, l = 0, h = n.length, u = 0; 0 < h;) {
                    h -= s = 1024 < h ? 1024 : h;
                    do {
                        l += c += n[u++]
                    } while (--s);
                    c %= 65521, l %= 65521
                }
                if (e !== (l << 16 | c) >>> 0) throw Error("invalid adler-32 checksum")
            }
            return t
        };
        var C = 8;
        i("Zlib.Inflate", L), i("Zlib.Inflate.prototype.decompress", L.prototype.k);
        var R, O, I, D, k = {
            ADAPTIVE: c.s,
            BLOCK: c.t
        };
        if (Object.keys) R = Object.keys(k);
        else
            for (O in R = [], I = 0, k) R[I++] = O;
        for (I = 0, D = R.length; I < D; ++I) i("Zlib.Inflate.BufferType." + (O = R[I]), k[O])
    }).call(this)
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        var i = t.__state.conversionName.toString(),
            n = Math.round(t.r),
            r = Math.round(t.g),
            o = Math.round(t.b),
            a = t.a,
            s = Math.round(t.h),
            c = t.s.toFixed(1),
            l = t.v.toFixed(1);
        if (e || "THREE_CHAR_HEX" === i || "SIX_CHAR_HEX" === i) {
            for (var h = t.hex.toString(16); h.length < 6;) h = "0" + h;
            return "#" + h
        }
        return "CSS_RGB" === i ? "rgb(" + n + "," + r + "," + o + ")" : "CSS_RGBA" === i ? "rgba(" + n + "," + r + "," + o + "," + a + ")" : "HEX" === i ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === i ? "[" + n + "," + r + "," + o + "]" : "RGBA_ARRAY" === i ? "[" + n + "," + r + "," + o + "," + a + "]" : "RGB_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + o + "}" : "RGBA_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + o + ",a:" + a + "}" : "HSV_OBJ" === i ? "{h:" + s + ",s:" + c + ",v:" + l + "}" : "HSVA_OBJ" === i ? "{h:" + s + ",s:" + c + ",v:" + l + ",a:" + a + "}" : "unknown format"
    }
    var r = Array.prototype.forEach,
        o = Array.prototype.slice,
        a = {
            BREAK: {},
            extend: function(t) {
                return this.each(o.call(arguments, 1), function(e) {
                    (this.isObject(e) ? Object.keys(e) : []).forEach(function(i) {
                        this.isUndefined(e[i]) || (t[i] = e[i])
                    }.bind(this))
                }, this), t
            },
            defaults: function(t) {
                return this.each(o.call(arguments, 1), function(e) {
                    (this.isObject(e) ? Object.keys(e) : []).forEach(function(i) {
                        this.isUndefined(t[i]) && (t[i] = e[i])
                    }.bind(this))
                }, this), t
            },
            compose: function() {
                var t = o.call(arguments);
                return function() {
                    for (var e = o.call(arguments), i = t.length - 1; i >= 0; i--) e = [t[i].apply(this, e)];
                    return e[0]
                }
            },
            each: function(t, e, i) {
                if (t)
                    if (r && t.forEach && t.forEach === r) t.forEach(e, i);
                    else if (t.length === t.length + 0) {
                    var n, o = void 0;
                    for (o = 0, n = t.length; o < n; o++)
                        if (o in t && e.call(i, t[o], o) === this.BREAK) return
                } else
                    for (var a in t)
                        if (e.call(i, t[a], a) === this.BREAK) return
            },
            defer: function(t) {
                setTimeout(t, 0)
            },
            debounce: function(t, e, i) {
                var n = void 0;
                return function() {
                    var r = this,
                        o = arguments;
                    var a = i || !n;
                    clearTimeout(n), n = setTimeout(function() {
                        n = null, i || t.apply(r, o)
                    }, e), a && t.apply(r, o)
                }
            },
            toArray: function(t) {
                return t.toArray ? t.toArray() : o.call(t)
            },
            isUndefined: function(t) {
                return void 0 === t
            },
            isNull: function(t) {
                return null === t
            },
            isNaN: function(t) {
                function e(e) {
                    return t.apply(this, arguments)
                }
                return e.toString = function() {
                    return t.toString()
                }, e
            }(function(t) {
                return isNaN(t)
            }),
            isArray: Array.isArray || function(t) {
                return t.constructor === Array
            },
            isObject: function(t) {
                return t === Object(t)
            },
            isNumber: function(t) {
                return t === t + 0
            },
            isString: function(t) {
                return t === t + ""
            },
            isBoolean: function(t) {
                return !1 === t || !0 === t
            },
            isFunction: function(t) {
                return "[object Function]" === Object.prototype.toString.call(t)
            }
        },
        s = [{
            litmus: a.isString,
            conversions: {
                THREE_CHAR_HEX: {
                    read: function(t) {
                        var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
                        return null !== e && {
                            space: "HEX",
                            hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0)
                        }
                    },
                    write: n
                },
                SIX_CHAR_HEX: {
                    read: function(t) {
                        var e = t.match(/^#([A-F0-9]{6})$/i);
                        return null !== e && {
                            space: "HEX",
                            hex: parseInt("0x" + e[1].toString(), 0)
                        }
                    },
                    write: n
                },
                CSS_RGB: {
                    read: function(t) {
                        var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                        return null !== e && {
                            space: "RGB",
                            r: parseFloat(e[1]),
                            g: parseFloat(e[2]),
                            b: parseFloat(e[3])
                        }
                    },
                    write: n
                },
                CSS_RGBA: {
                    read: function(t) {
                        var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
                        return null !== e && {
                            space: "RGB",
                            r: parseFloat(e[1]),
                            g: parseFloat(e[2]),
                            b: parseFloat(e[3]),
                            a: parseFloat(e[4])
                        }
                    },
                    write: n
                }
            }
        }, {
            litmus: a.isNumber,
            conversions: {
                HEX: {
                    read: function(t) {
                        return {
                            space: "HEX",
                            hex: t,
                            conversionName: "HEX"
                        }
                    },
                    write: function(t) {
                        return t.hex
                    }
                }
            }
        }, {
            litmus: a.isArray,
            conversions: {
                RGB_ARRAY: {
                    read: function(t) {
                        return 3 === t.length && {
                            space: "RGB",
                            r: t[0],
                            g: t[1],
                            b: t[2]
                        }
                    },
                    write: function(t) {
                        return [t.r, t.g, t.b]
                    }
                },
                RGBA_ARRAY: {
                    read: function(t) {
                        return 4 === t.length && {
                            space: "RGB",
                            r: t[0],
                            g: t[1],
                            b: t[2],
                            a: t[3]
                        }
                    },
                    write: function(t) {
                        return [t.r, t.g, t.b, t.a]
                    }
                }
            }
        }, {
            litmus: a.isObject,
            conversions: {
                RGBA_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.r) && a.isNumber(t.g) && a.isNumber(t.b) && a.isNumber(t.a)) && {
                            space: "RGB",
                            r: t.r,
                            g: t.g,
                            b: t.b,
                            a: t.a
                        }
                    },
                    write: function(t) {
                        return {
                            r: t.r,
                            g: t.g,
                            b: t.b,
                            a: t.a
                        }
                    }
                },
                RGB_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.r) && a.isNumber(t.g) && a.isNumber(t.b)) && {
                            space: "RGB",
                            r: t.r,
                            g: t.g,
                            b: t.b
                        }
                    },
                    write: function(t) {
                        return {
                            r: t.r,
                            g: t.g,
                            b: t.b
                        }
                    }
                },
                HSVA_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.h) && a.isNumber(t.s) && a.isNumber(t.v) && a.isNumber(t.a)) && {
                            space: "HSV",
                            h: t.h,
                            s: t.s,
                            v: t.v,
                            a: t.a
                        }
                    },
                    write: function(t) {
                        return {
                            h: t.h,
                            s: t.s,
                            v: t.v,
                            a: t.a
                        }
                    }
                },
                HSV_OBJ: {
                    read: function(t) {
                        return !!(a.isNumber(t.h) && a.isNumber(t.s) && a.isNumber(t.v)) && {
                            space: "HSV",
                            h: t.h,
                            s: t.s,
                            v: t.v
                        }
                    },
                    write: function(t) {
                        return {
                            h: t.h,
                            s: t.s,
                            v: t.v
                        }
                    }
                }
            }
        }],
        c = void 0,
        l = void 0,
        h = function() {
            l = !1;
            var t = arguments.length > 1 ? a.toArray(arguments) : arguments[0];
            return a.each(s, function(e) {
                if (e.litmus(t)) return a.each(e.conversions, function(e, i) {
                    if (c = e.read(t), !1 === l && !1 !== c) return l = c, c.conversionName = i, c.conversion = e, a.BREAK
                }), a.BREAK
            }), l
        },
        u = void 0,
        d = {
            hsv_to_rgb: function(t, e, i) {
                var n = Math.floor(t / 60) % 6,
                    r = t / 60 - Math.floor(t / 60),
                    o = i * (1 - e),
                    a = i * (1 - r * e),
                    s = i * (1 - (1 - r) * e),
                    c = [
                        [i, s, o],
                        [a, i, o],
                        [o, i, s],
                        [o, a, i],
                        [s, o, i],
                        [i, o, a]
                    ][n];
                return {
                    r: 255 * c[0],
                    g: 255 * c[1],
                    b: 255 * c[2]
                }
            },
            rgb_to_hsv: function(t, e, i) {
                var n = Math.min(t, e, i),
                    r = Math.max(t, e, i),
                    o = r - n,
                    a = void 0;
                return 0 === r ? {
                    h: NaN,
                    s: 0,
                    v: 0
                } : (a = t === r ? (e - i) / o : e === r ? 2 + (i - t) / o : 4 + (t - e) / o, (a /= 6) < 0 && (a += 1), {
                    h: 360 * a,
                    s: o / r,
                    v: r / 255
                })
            },
            rgb_to_hex: function(t, e, i) {
                var n = this.hex_with_component(0, 2, t);
                return n = this.hex_with_component(n, 1, e), n = this.hex_with_component(n, 0, i)
            },
            component_from_hex: function(t, e) {
                return t >> 8 * e & 255
            },
            hex_with_component: function(t, e, i) {
                return i << (u = 8 * e) | t & ~(255 << u)
            }
        },
        p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
        } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        },
        f = function(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        },
        m = function() {
            function t(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }
            return function(e, i, n) {
                return i && t(e.prototype, i), n && t(e, n), e
            }
        }(),
        g = function t(e, i, n) {
            null === e && (e = Function.prototype);
            var r = Object.getOwnPropertyDescriptor(e, i);
            if (void 0 === r) {
                var o = Object.getPrototypeOf(e);
                return null === o ? void 0 : t(o, i, n)
            }
            if ("value" in r) return r.value;
            var a = r.get;
            return void 0 !== a ? a.call(n) : void 0
        },
        v = function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
        },
        y = function(t, e) {
            if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !e || "object" != typeof e && "function" != typeof e ? t : e
        },
        _ = function() {
            function t() {
                if (f(this, t), this.__state = h.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
                this.__state.a = this.__state.a || 1
            }
            return m(t, [{
                key: "toString",
                value: function() {
                    return n(this)
                }
            }, {
                key: "toHexString",
                value: function() {
                    return n(this, !0)
                }
            }, {
                key: "toOriginal",
                value: function() {
                    return this.__state.conversion.write(this)
                }
            }]), t
        }();

    function x(t, e, i) {
        Object.defineProperty(t, e, {
            get: function() {
                return "RGB" === this.__state.space ? this.__state[e] : (_.recalculateRGB(this, e, i), this.__state[e])
            },
            set: function(t) {
                "RGB" !== this.__state.space && (_.recalculateRGB(this, e, i), this.__state.space = "RGB"), this.__state[e] = t
            }
        })
    }

    function b(t, e) {
        Object.defineProperty(t, e, {
            get: function() {
                return "HSV" === this.__state.space ? this.__state[e] : (_.recalculateHSV(this), this.__state[e])
            },
            set: function(t) {
                "HSV" !== this.__state.space && (_.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t
            }
        })
    }
    _.recalculateRGB = function(t, e, i) {
        if ("HEX" === t.__state.space) t.__state[e] = d.component_from_hex(t.__state.hex, i);
        else {
            if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
            a.extend(t.__state, d.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v))
        }
    }, _.recalculateHSV = function(t) {
        var e = d.rgb_to_hsv(t.r, t.g, t.b);
        a.extend(t.__state, {
            s: e.s,
            v: e.v
        }), a.isNaN(e.h) ? a.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h
    }, _.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], x(_.prototype, "r", 2), x(_.prototype, "g", 1), x(_.prototype, "b", 0), b(_.prototype, "h"), b(_.prototype, "s"), b(_.prototype, "v"), Object.defineProperty(_.prototype, "a", {
        get: function() {
            return this.__state.a
        },
        set: function(t) {
            this.__state.a = t
        }
    }), Object.defineProperty(_.prototype, "hex", {
        get: function() {
            return "HEX" !== !this.__state.space && (this.__state.hex = d.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex
        },
        set: function(t) {
            this.__state.space = "HEX", this.__state.hex = t
        }
    });
    var w = function() {
            function t(e, i) {
                f(this, t), this.initialValue = e[i], this.domElement = document.createElement("div"), this.object = e, this.property = i, this.__onChange = void 0, this.__onFinishChange = void 0
            }
            return m(t, [{
                key: "onChange",
                value: function(t) {
                    return this.__onChange = t, this
                }
            }, {
                key: "onFinishChange",
                value: function(t) {
                    return this.__onFinishChange = t, this
                }
            }, {
                key: "setValue",
                value: function(t) {
                    return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this
                }
            }, {
                key: "getValue",
                value: function() {
                    return this.object[this.property]
                }
            }, {
                key: "updateDisplay",
                value: function() {
                    return this
                }
            }, {
                key: "isModified",
                value: function() {
                    return this.initialValue !== this.getValue()
                }
            }]), t
        }(),
        M = {};
    a.each({
        HTMLEvents: ["change"],
        MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
        KeyboardEvents: ["keydown"]
    }, function(t, e) {
        a.each(t, function(t) {
            M[t] = e
        })
    });
    var T = /(\d+(\.\d+)?)px/;

    function E(t) {
        if ("0" === t || a.isUndefined(t)) return 0;
        var e = t.match(T);
        return a.isNull(e) ? 0 : parseFloat(e[1])
    }
    var S = {
            makeSelectable: function(t, e) {
                void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() {
                    return !1
                } : function() {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off")
            },
            makeFullscreen: function(t, e, i) {
                var n = i,
                    r = e;
                a.isUndefined(r) && (r = !0), a.isUndefined(n) && (n = !0), t.style.position = "absolute", r && (t.style.left = 0, t.style.right = 0), n && (t.style.top = 0, t.style.bottom = 0)
            },
            fakeEvent: function(t, e, i, n) {
                var r = i || {},
                    o = M[e];
                if (!o) throw new Error("Event type " + e + " not supported.");
                var s = document.createEvent(o);
                switch (o) {
                    case "MouseEvents":
                        var c = r.x || r.clientX || 0,
                            l = r.y || r.clientY || 0;
                        s.initMouseEvent(e, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, c, l, !1, !1, !1, !1, 0, null);
                        break;
                    case "KeyboardEvents":
                        var h = s.initKeyboardEvent || s.initKeyEvent;
                        a.defaults(r, {
                            cancelable: !0,
                            ctrlKey: !1,
                            altKey: !1,
                            shiftKey: !1,
                            metaKey: !1,
                            keyCode: void 0,
                            charCode: void 0
                        }), h(e, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode);
                        break;
                    default:
                        s.initEvent(e, r.bubbles || !1, r.cancelable || !0)
                }
                a.defaults(s, n), t.dispatchEvent(s)
            },
            bind: function(t, e, i, n) {
                var r = n || !1;
                return t.addEventListener ? t.addEventListener(e, i, r) : t.attachEvent && t.attachEvent("on" + e, i), S
            },
            unbind: function(t, e, i, n) {
                var r = n || !1;
                return t.removeEventListener ? t.removeEventListener(e, i, r) : t.detachEvent && t.detachEvent("on" + e, i), S
            },
            addClass: function(t, e) {
                if (void 0 === t.className) t.className = e;
                else if (t.className !== e) {
                    var i = t.className.split(/ +/); - 1 === i.indexOf(e) && (i.push(e), t.className = i.join(" ").replace(/^\s+/, "").replace(/\s+$/, ""))
                }
                return S
            },
            removeClass: function(t, e) {
                if (e)
                    if (t.className === e) t.removeAttribute("class");
                    else {
                        var i = t.className.split(/ +/),
                            n = i.indexOf(e); - 1 !== n && (i.splice(n, 1), t.className = i.join(" "))
                    }
                else t.className = void 0;
                return S
            },
            hasClass: function(t, e) {
                return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1
            },
            getWidth: function(t) {
                var e = getComputedStyle(t);
                return E(e["border-left-width"]) + E(e["border-right-width"]) + E(e["padding-left"]) + E(e["padding-right"]) + E(e.width)
            },
            getHeight: function(t) {
                var e = getComputedStyle(t);
                return E(e["border-top-width"]) + E(e["border-bottom-width"]) + E(e["padding-top"]) + E(e["padding-bottom"]) + E(e.height)
            },
            getOffset: function(t) {
                var e = t,
                    i = {
                        left: 0,
                        top: 0
                    };
                if (e.offsetParent)
                    do {
                        i.left += e.offsetLeft, i.top += e.offsetTop, e = e.offsetParent
                    } while (e);
                return i
            },
            isActive: function(t) {
                return t === document.activeElement && (t.type || t.href)
            }
        },
        A = function(t) {
            function e(t, i) {
                f(this, e);
                var n = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                    r = n;
                return n.__prev = n.getValue(), n.__checkbox = document.createElement("input"), n.__checkbox.setAttribute("type", "checkbox"), S.bind(n.__checkbox, "change", function() {
                    r.setValue(!r.__prev)
                }, !1), n.domElement.appendChild(n.__checkbox), n.updateDisplay(), n
            }
            return v(e, w), m(e, [{
                key: "setValue",
                value: function(t) {
                    var i = g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), i
                }
            }, {
                key: "updateDisplay",
                value: function() {
                    return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                }
            }]), e
        }(),
        P = function(t) {
            function e(t, i, n) {
                f(this, e);
                var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                    o = n,
                    s = r;
                if (r.__select = document.createElement("select"), a.isArray(o)) {
                    var c = {};
                    a.each(o, function(t) {
                        c[t] = t
                    }), o = c
                }
                return a.each(o, function(t, e) {
                    var i = document.createElement("option");
                    i.innerHTML = e, i.setAttribute("value", t), s.__select.appendChild(i)
                }), r.updateDisplay(), S.bind(r.__select, "change", function() {
                    var t = this.options[this.selectedIndex].value;
                    s.setValue(t)
                }), r.domElement.appendChild(r.__select), r
            }
            return v(e, w), m(e, [{
                key: "setValue",
                value: function(t) {
                    var i = g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t);
                    return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), i
                }
            }, {
                key: "updateDisplay",
                value: function() {
                    return S.isActive(this.__select) ? this : (this.__select.value = this.getValue(), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this))
                }
            }]), e
        }(),
        L = function(t) {
            function e(t, i) {
                f(this, e);
                var n = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                    r = n;

                function o() {
                    r.setValue(r.__input.value)
                }
                return n.__input = document.createElement("input"), n.__input.setAttribute("type", "text"), S.bind(n.__input, "keyup", o), S.bind(n.__input, "change", o), S.bind(n.__input, "blur", function() {
                    r.__onFinishChange && r.__onFinishChange.call(r, r.getValue())
                }), S.bind(n.__input, "keydown", function(t) {
                    13 === t.keyCode && this.blur()
                }), n.updateDisplay(), n.domElement.appendChild(n.__input), n
            }
            return v(e, w), m(e, [{
                key: "updateDisplay",
                value: function() {
                    return S.isActive(this.__input) || (this.__input.value = this.getValue()), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                }
            }]), e
        }();

    function C(t) {
        var e = t.toString();
        return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0
    }
    var R = function(t) {
        function e(t, i, n) {
            f(this, e);
            var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                o = n || {};
            return r.__min = o.min, r.__max = o.max, r.__step = o.step, a.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step, r.__precision = C(r.__impliedStep), r
        }
        return v(e, w), m(e, [{
            key: "setValue",
            value: function(t) {
                var i = t;
                return void 0 !== this.__min && i < this.__min ? i = this.__min : void 0 !== this.__max && i > this.__max && (i = this.__max), void 0 !== this.__step && i % this.__step != 0 && (i = Math.round(i / this.__step) * this.__step), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, i)
            }
        }, {
            key: "min",
            value: function(t) {
                return this.__min = t, this
            }
        }, {
            key: "max",
            value: function(t) {
                return this.__max = t, this
            }
        }, {
            key: "step",
            value: function(t) {
                return this.__step = t, this.__impliedStep = t, this.__precision = C(t), this
            }
        }]), e
    }();
    var O = function(t) {
        function e(t, i, n) {
            f(this, e);
            var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, n));
            r.__truncationSuspended = !1;
            var o = r,
                s = void 0;

            function c() {
                o.__onFinishChange && o.__onFinishChange.call(o, o.getValue())
            }

            function l(t) {
                var e = s - t.clientY;
                o.setValue(o.getValue() + e * o.__impliedStep), s = t.clientY
            }

            function h() {
                S.unbind(window, "mousemove", l), S.unbind(window, "mouseup", h), c()
            }
            return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), S.bind(r.__input, "change", function() {
                var t = parseFloat(o.__input.value);
                a.isNaN(t) || o.setValue(t)
            }), S.bind(r.__input, "blur", function() {
                c()
            }), S.bind(r.__input, "mousedown", function(t) {
                S.bind(window, "mousemove", l), S.bind(window, "mouseup", h), s = t.clientY
            }), S.bind(r.__input, "keydown", function(t) {
                13 === t.keyCode && (o.__truncationSuspended = !0, this.blur(), o.__truncationSuspended = !1, c())
            }), r.updateDisplay(), r.domElement.appendChild(r.__input), r
        }
        return v(e, R), m(e, [{
            key: "updateDisplay",
            value: function() {
                return this.__input.value = this.__truncationSuspended ? this.getValue() : function(t, e) {
                    var i = Math.pow(10, e);
                    return Math.round(t * i) / i
                }(this.getValue(), this.__precision), g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
            }
        }]), e
    }();

    function I(t, e, i, n, r) {
        return n + (t - e) / (i - e) * (r - n)
    }
    var D = function(t) {
            function e(t, i, n, r, o) {
                f(this, e);
                var a = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, {
                        min: n,
                        max: r,
                        step: o
                    })),
                    s = a;

                function c(t) {
                    t.preventDefault();
                    var e = s.__background.getBoundingClientRect();
                    return s.setValue(I(t.clientX, e.left, e.right, s.__min, s.__max)), !1
                }

                function l() {
                    S.unbind(window, "mousemove", c), S.unbind(window, "mouseup", l), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                }

                function h(t) {
                    var e = t.touches[0].clientX,
                        i = s.__background.getBoundingClientRect();
                    s.setValue(I(e, i.left, i.right, s.__min, s.__max))
                }

                function u() {
                    S.unbind(window, "touchmove", h), S.unbind(window, "touchend", u), s.__onFinishChange && s.__onFinishChange.call(s, s.getValue())
                }
                return a.__background = document.createElement("div"), a.__foreground = document.createElement("div"), S.bind(a.__background, "mousedown", function(t) {
                    document.activeElement.blur(), S.bind(window, "mousemove", c), S.bind(window, "mouseup", l), c(t)
                }), S.bind(a.__background, "touchstart", function(t) {
                    if (1 !== t.touches.length) return;
                    S.bind(window, "touchmove", h), S.bind(window, "touchend", u), h(t)
                }), S.addClass(a.__background, "slider"), S.addClass(a.__foreground, "slider-fg"), a.updateDisplay(), a.__background.appendChild(a.__foreground), a.domElement.appendChild(a.__background), a
            }
            return v(e, R), m(e, [{
                key: "updateDisplay",
                value: function() {
                    var t = (this.getValue() - this.__min) / (this.__max - this.__min);
                    return this.__foreground.style.width = 100 * t + "%", g(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)
                }
            }]), e
        }(),
        k = function(t) {
            function e(t, i, n) {
                f(this, e);
                var r = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                    o = r;
                return r.__button = document.createElement("div"), r.__button.innerHTML = void 0 === n ? "Fire" : n, S.bind(r.__button, "click", function(t) {
                    return t.preventDefault(), o.fire(), !1
                }), S.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r
            }
            return v(e, w), m(e, [{
                key: "fire",
                value: function() {
                    this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue())
                }
            }]), e
        }(),
        N = function(t) {
            function e(t, i) {
                f(this, e);
                var n = y(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                n.__color = new _(n.getValue()), n.__temp = new _(0);
                var r = n;
                n.domElement = document.createElement("div"), S.makeSelectable(n.domElement, !1), n.__selector = document.createElement("div"), n.__selector.className = "selector", n.__saturation_field = document.createElement("div"), n.__saturation_field.className = "saturation-field", n.__field_knob = document.createElement("div"), n.__field_knob.className = "field-knob", n.__field_knob_border = "2px solid ", n.__hue_knob = document.createElement("div"), n.__hue_knob.className = "hue-knob", n.__hue_field = document.createElement("div"), n.__hue_field.className = "hue-field", n.__input = document.createElement("input"), n.__input.type = "text", n.__input_textShadow = "0 1px 1px ", S.bind(n.__input, "keydown", function(t) {
                    13 === t.keyCode && d.call(this)
                }), S.bind(n.__input, "blur", d), S.bind(n.__selector, "mousedown", function() {
                    S.addClass(this, "drag").bind(window, "mouseup", function() {
                        S.removeClass(r.__selector, "drag")
                    })
                }), S.bind(n.__selector, "touchstart", function() {
                    S.addClass(this, "drag").bind(window, "touchend", function() {
                        S.removeClass(r.__selector, "drag")
                    })
                });
                var o = document.createElement("div");

                function s(t) {
                    m(t), S.bind(window, "mousemove", m), S.bind(window, "touchmove", m), S.bind(window, "mouseup", l), S.bind(window, "touchend", l)
                }

                function c(t) {
                    g(t), S.bind(window, "mousemove", g), S.bind(window, "touchmove", g), S.bind(window, "mouseup", u), S.bind(window, "touchend", u)
                }

                function l() {
                    S.unbind(window, "mousemove", m), S.unbind(window, "touchmove", m), S.unbind(window, "mouseup", l), S.unbind(window, "touchend", l), p()
                }

                function u() {
                    S.unbind(window, "mousemove", g), S.unbind(window, "touchmove", g), S.unbind(window, "mouseup", u), S.unbind(window, "touchend", u), p()
                }

                function d() {
                    var t = h(this.value);
                    !1 !== t ? (r.__color.__state = t, r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString()
                }

                function p() {
                    r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal())
                }

                function m(t) {
                    -1 === t.type.indexOf("touch") && t.preventDefault();
                    var e = r.__saturation_field.getBoundingClientRect(),
                        i = t.touches && t.touches[0] || t,
                        n = i.clientX,
                        o = i.clientY,
                        a = (n - e.left) / (e.right - e.left),
                        s = 1 - (o - e.top) / (e.bottom - e.top);
                    return s > 1 ? s = 1 : s < 0 && (s = 0), a > 1 ? a = 1 : a < 0 && (a = 0), r.__color.v = s, r.__color.s = a, r.setValue(r.__color.toOriginal()), !1
                }

                function g(t) {
                    -1 === t.type.indexOf("touch") && t.preventDefault();
                    var e = r.__hue_field.getBoundingClientRect(),
                        i = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top);
                    return i > 1 ? i = 1 : i < 0 && (i = 0), r.__color.h = 360 * i, r.setValue(r.__color.toOriginal()), !1
                }
                return a.extend(n.__selector.style, {
                        width: "122px",
                        height: "102px",
                        padding: "3px",
                        backgroundColor: "#222",
                        boxShadow: "0px 1px 3px rgba(0,0,0,0.3)"
                    }), a.extend(n.__field_knob.style, {
                        position: "absolute",
                        width: "12px",
                        height: "12px",
                        border: n.__field_knob_border + (n.__color.v < .5 ? "#fff" : "#000"),
                        boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
                        borderRadius: "12px",
                        zIndex: 1
                    }), a.extend(n.__hue_knob.style, {
                        position: "absolute",
                        width: "15px",
                        height: "2px",
                        borderRight: "4px solid #fff",
                        zIndex: 1
                    }), a.extend(n.__saturation_field.style, {
                        width: "100px",
                        height: "100px",
                        border: "1px solid #555",
                        marginRight: "3px",
                        display: "inline-block",
                        cursor: "pointer"
                    }), a.extend(o.style, {
                        width: "100%",
                        height: "100%",
                        background: "none"
                    }), F(o, "top", "rgba(0,0,0,0)", "#000"), a.extend(n.__hue_field.style, {
                        width: "15px",
                        height: "100px",
                        border: "1px solid #555",
                        cursor: "ns-resize",
                        position: "absolute",
                        top: "3px",
                        right: "3px"
                    }),
                    function(t) {
                        t.style.background = "", t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"
                    }(n.__hue_field), a.extend(n.__input.style, {
                        outline: "none",
                        textAlign: "center",
                        color: "#fff",
                        border: 0,
                        fontWeight: "bold",
                        textShadow: n.__input_textShadow + "rgba(0,0,0,0.7)"
                    }), S.bind(n.__saturation_field, "mousedown", s), S.bind(n.__saturation_field, "touchstart", s), S.bind(n.__field_knob, "mousedown", s), S.bind(n.__field_knob, "touchstart", s), S.bind(n.__hue_field, "mousedown", c), S.bind(n.__hue_field, "touchstart", c), n.__saturation_field.appendChild(o), n.__selector.appendChild(n.__field_knob), n.__selector.appendChild(n.__saturation_field), n.__selector.appendChild(n.__hue_field), n.__hue_field.appendChild(n.__hue_knob), n.domElement.appendChild(n.__input), n.domElement.appendChild(n.__selector), n.updateDisplay(), n
            }
            return v(e, w), m(e, [{
                key: "updateDisplay",
                value: function() {
                    var t = h(this.getValue());
                    if (!1 !== t) {
                        var e = !1;
                        a.each(_.COMPONENTS, function(i) {
                            if (!a.isUndefined(t[i]) && !a.isUndefined(this.__color.__state[i]) && t[i] !== this.__color.__state[i]) return e = !0, {}
                        }, this), e && a.extend(this.__color.__state, t)
                    }
                    a.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1;
                    var i = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
                        n = 255 - i;
                    a.extend(this.__field_knob.style, {
                        marginLeft: 100 * this.__color.s - 7 + "px",
                        marginTop: 100 * (1 - this.__color.v) - 7 + "px",
                        backgroundColor: this.__temp.toHexString(),
                        border: this.__field_knob_border + "rgb(" + i + "," + i + "," + i + ")"
                    }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, F(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), a.extend(this.__input.style, {
                        backgroundColor: this.__color.toHexString(),
                        color: "rgb(" + i + "," + i + "," + i + ")",
                        textShadow: this.__input_textShadow + "rgba(" + n + "," + n + "," + n + ",.7)"
                    })
                }
            }]), e
        }(),
        B = ["-moz-", "-o-", "-webkit-", "-ms-", ""];

    function F(t, e, i, n) {
        t.style.background = "", a.each(B, function(r) {
            t.style.cssText += "background: " + r + "linear-gradient(" + e + ", " + i + " 0%, " + n + " 100%); "
        })
    }
    var z = function(t, e) {
            var i = e || document,
                n = document.createElement("style");
            n.type = "text/css", n.innerHTML = t;
            var r = i.getElementsByTagName("head")[0];
            try {
                r.appendChild(n)
            } catch (t) {}
        },
        U = function(t, e) {
            var i = t[e];
            return a.isArray(arguments[2]) || a.isObject(arguments[2]) ? new P(t, e, arguments[2]) : a.isNumber(i) ? a.isNumber(arguments[2]) && a.isNumber(arguments[3]) ? a.isNumber(arguments[4]) ? new D(t, e, arguments[2], arguments[3], arguments[4]) : new D(t, e, arguments[2], arguments[3]) : a.isNumber(arguments[4]) ? new O(t, e, {
                min: arguments[2],
                max: arguments[3],
                step: arguments[4]
            }) : new O(t, e, {
                min: arguments[2],
                max: arguments[3]
            }) : a.isString(i) ? new L(t, e) : a.isFunction(i) ? new k(t, e, "") : a.isBoolean(i) ? new A(t, e) : null
        };
    var G = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
            setTimeout(t, 1e3 / 60)
        },
        H = function() {
            function t() {
                f(this, t), this.backgroundElement = document.createElement("div"), a.extend(this.backgroundElement.style, {
                    backgroundColor: "rgba(0,0,0,0.8)",
                    top: 0,
                    left: 0,
                    display: "none",
                    zIndex: "1000",
                    opacity: 0,
                    WebkitTransition: "opacity 0.2s linear",
                    transition: "opacity 0.2s linear"
                }), S.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), a.extend(this.domElement.style, {
                    position: "fixed",
                    display: "none",
                    zIndex: "1001",
                    opacity: 0,
                    WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
                    transition: "transform 0.2s ease-out, opacity 0.2s linear"
                }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement);
                var e = this;
                S.bind(this.backgroundElement, "click", function() {
                    e.hide()
                })
            }
            return m(t, [{
                key: "show",
                value: function() {
                    var t = this;
                    this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), a.defer(function() {
                        t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)"
                    })
                }
            }, {
                key: "hide",
                value: function() {
                    var t = this,
                        e = function e() {
                            t.domElement.style.display = "none", t.backgroundElement.style.display = "none", S.unbind(t.domElement, "webkitTransitionEnd", e), S.unbind(t.domElement, "transitionend", e), S.unbind(t.domElement, "oTransitionEnd", e)
                        };
                    S.bind(this.domElement, "webkitTransitionEnd", e), S.bind(this.domElement, "transitionend", e), S.bind(this.domElement, "oTransitionEnd", e), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)"
                }
            }, {
                key: "layout",
                value: function() {
                    this.domElement.style.left = window.innerWidth / 2 - S.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - S.getHeight(this.domElement) / 2 + "px"
                }
            }]), t
        }();
    z(function(t) {
        if (t && "undefined" != typeof window) {
            var e = document.createElement("style");
            return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t
        }
    }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n"));
    var V = "Default",
        j = function() {
            try {
                return !!window.localStorage
            } catch (t) {
                return !1
            }
        }(),
        W = void 0,
        X = !0,
        q = void 0,
        Y = !1,
        Z = [],
        J = function t(e) {
            var i = this,
                n = e || {};
            this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), S.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], n = a.defaults(n, {
                closeOnTop: !1,
                autoPlace: !0,
                width: t.DEFAULT_WIDTH
            }), n = a.defaults(n, {
                resizable: n.autoPlace,
                hideable: n.autoPlace
            }), a.isUndefined(n.load) ? n.load = {
                preset: V
            } : n.preset && (n.load.preset = n.preset), a.isUndefined(n.parent) && n.hideable && Z.push(this), n.resizable = a.isUndefined(n.parent) && n.resizable, n.autoPlace && a.isUndefined(n.scrollable) && (n.scrollable = !0);
            var r = j && "true" === localStorage.getItem(it(this, "isLocal")),
                o = void 0,
                s = void 0;
            if (Object.defineProperties(this, {
                    parent: {
                        get: function() {
                            return n.parent
                        }
                    },
                    scrollable: {
                        get: function() {
                            return n.scrollable
                        }
                    },
                    autoPlace: {
                        get: function() {
                            return n.autoPlace
                        }
                    },
                    closeOnTop: {
                        get: function() {
                            return n.closeOnTop
                        }
                    },
                    preset: {
                        get: function() {
                            return i.parent ? i.getRoot().preset : n.load.preset
                        },
                        set: function(t) {
                            i.parent ? i.getRoot().preset = t : n.load.preset = t,
                                function(t) {
                                    for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e)
                                }(this), i.revert()
                        }
                    },
                    width: {
                        get: function() {
                            return n.width
                        },
                        set: function(t) {
                            n.width = t, at(i, t)
                        }
                    },
                    name: {
                        get: function() {
                            return n.name
                        },
                        set: function(t) {
                            n.name = t, s && (s.innerHTML = n.name)
                        }
                    },
                    closed: {
                        get: function() {
                            return n.closed
                        },
                        set: function(e) {
                            n.closed = e, n.closed ? S.addClass(i.__ul, t.CLASS_CLOSED) : S.removeClass(i.__ul, t.CLASS_CLOSED), this.onResize(), i.__closeButton && (i.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED)
                        }
                    },
                    load: {
                        get: function() {
                            return n.load
                        }
                    },
                    useLocalStorage: {
                        get: function() {
                            return r
                        },
                        set: function(t) {
                            j && (r = t, t ? S.bind(window, "unload", o) : S.unbind(window, "unload", o), localStorage.setItem(it(i, "isLocal"), t))
                        }
                    }
                }), a.isUndefined(n.parent)) {
                if (n.closed = !1, S.addClass(this.domElement, t.CLASS_MAIN), S.makeSelectable(this.domElement, !1), j && r) {
                    i.useLocalStorage = !0;
                    var c = localStorage.getItem(it(this, "gui"));
                    c && (n.load = JSON.parse(c))
                }
                this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, S.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), n.closeOnTop ? (S.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (S.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), S.bind(this.__closeButton, "click", function() {
                    i.closed = !i.closed
                })
            } else {
                void 0 === n.closed && (n.closed = !0);
                var l = document.createTextNode(n.name);
                S.addClass(l, "controller-name"), s = K(i, l);
                S.addClass(this.__ul, t.CLASS_CLOSED), S.addClass(s, "title"), S.bind(s, "click", function(t) {
                    return t.preventDefault(), i.closed = !i.closed, !1
                }), n.closed || (this.closed = !1)
            }
            n.autoPlace && (a.isUndefined(n.parent) && (X && (q = document.createElement("div"), S.addClass(q, "dg"), S.addClass(q, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(q), X = !1), q.appendChild(this.domElement), S.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || at(i, n.width)), this.__resizeHandler = function() {
                i.onResizeDebounced()
            }, S.bind(window, "resize", this.__resizeHandler), S.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), S.bind(this.__ul, "transitionend", this.__resizeHandler), S.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), n.resizable && ot(this), o = function() {
                j && "true" === localStorage.getItem(it(i, "isLocal")) && localStorage.setItem(it(i, "gui"), JSON.stringify(i.getSaveObject()))
            }, this.saveToLocalStorageIfPossible = o, n.parent || function() {
                var t = i.getRoot();
                t.width += 1, a.defer(function() {
                    t.width -= 1
                })
            }()
        };

    function K(t, e, i) {
        var n = document.createElement("li");
        return e && n.appendChild(e), i ? t.__ul.insertBefore(n, i) : t.__ul.appendChild(n), t.onResize(), n
    }

    function Q(t) {
        S.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && S.unbind(window, "unload", t.saveToLocalStorageIfPossible)
    }

    function $(t, e) {
        var i = t.__preset_select[t.__preset_select.selectedIndex];
        i.innerHTML = e ? i.value + "*" : i.value
    }

    function tt(t, e) {
        var i = t.getRoot(),
            n = i.__rememberedObjects.indexOf(e.object);
        if (-1 !== n) {
            var r = i.__rememberedObjectIndecesToControllers[n];
            if (void 0 === r && (r = {}, i.__rememberedObjectIndecesToControllers[n] = r), r[e.property] = e, i.load && i.load.remembered) {
                var o = i.load.remembered,
                    a = void 0;
                if (o[t.preset]) a = o[t.preset];
                else {
                    if (!o[V]) return;
                    a = o[V]
                }
                if (a[n] && void 0 !== a[n][e.property]) {
                    var s = a[n][e.property];
                    e.initialValue = s, e.setValue(s)
                }
            }
        }
    }

    function et(t, e, i, n) {
        if (void 0 === e[i]) throw new Error('Object "' + e + '" has no property "' + i + '"');
        var r = void 0;
        if (n.color) r = new N(e, i);
        else {
            var o = [e, i].concat(n.factoryArgs);
            r = U.apply(t, o)
        }
        n.before instanceof w && (n.before = n.before.__li), tt(t, r), S.addClass(r.domElement, "c");
        var s = document.createElement("span");
        S.addClass(s, "property-name"), s.innerHTML = r.property;
        var c = document.createElement("div");
        c.appendChild(s), c.appendChild(r.domElement);
        var l = K(t, c, n.before);
        return S.addClass(l, J.CLASS_CONTROLLER_ROW), r instanceof N ? S.addClass(l, "color") : S.addClass(l, p(r.getValue())),
            function(t, e, i) {
                if (i.__li = e, i.__gui = t, a.extend(i, {
                        options: function(e) {
                            if (arguments.length > 1) {
                                var n = i.__li.nextElementSibling;
                                return i.remove(), et(t, i.object, i.property, {
                                    before: n,
                                    factoryArgs: [a.toArray(arguments)]
                                })
                            }
                            if (a.isArray(e) || a.isObject(e)) {
                                var r = i.__li.nextElementSibling;
                                return i.remove(), et(t, i.object, i.property, {
                                    before: r,
                                    factoryArgs: [e]
                                })
                            }
                        },
                        name: function(t) {
                            return i.__li.firstElementChild.firstElementChild.innerHTML = t, i
                        },
                        listen: function() {
                            return i.__gui.listen(i), i
                        },
                        remove: function() {
                            return i.__gui.remove(i), i
                        }
                    }), i instanceof D) {
                    var n = new O(i.object, i.property, {
                        min: i.__min,
                        max: i.__max,
                        step: i.__step
                    });
                    a.each(["updateDisplay", "onChange", "onFinishChange", "step"], function(t) {
                        var e = i[t],
                            r = n[t];
                        i[t] = n[t] = function() {
                            var t = Array.prototype.slice.call(arguments);
                            return r.apply(n, t), e.apply(i, t)
                        }
                    }), S.addClass(e, "has-slider"), i.domElement.insertBefore(n.domElement, i.domElement.firstElementChild)
                } else if (i instanceof O) {
                    var r = function(e) {
                        if (a.isNumber(i.__min) && a.isNumber(i.__max)) {
                            var n = i.__li.firstElementChild.firstElementChild.innerHTML,
                                r = i.__gui.__listening.indexOf(i) > -1;
                            i.remove();
                            var o = et(t, i.object, i.property, {
                                before: i.__li.nextElementSibling,
                                factoryArgs: [i.__min, i.__max, i.__step]
                            });
                            return o.name(n), r && o.listen(), o
                        }
                        return e
                    };
                    i.min = a.compose(r, i.min), i.max = a.compose(r, i.max)
                } else i instanceof A ? (S.bind(e, "click", function() {
                    S.fakeEvent(i.__checkbox, "click")
                }), S.bind(i.__checkbox, "click", function(t) {
                    t.stopPropagation()
                })) : i instanceof k ? (S.bind(e, "click", function() {
                    S.fakeEvent(i.__button, "click")
                }), S.bind(e, "mouseover", function() {
                    S.addClass(i.__button, "hover")
                }), S.bind(e, "mouseout", function() {
                    S.removeClass(i.__button, "hover")
                })) : i instanceof N && (S.addClass(e, "color"), i.updateDisplay = a.compose(function(t) {
                    return e.style.borderLeftColor = i.__color.toString(), t
                }, i.updateDisplay), i.updateDisplay());
                i.setValue = a.compose(function(e) {
                    return t.getRoot().__preset_select && i.isModified() && $(t.getRoot(), !0), e
                }, i.setValue)
            }(t, l, r), t.__controllers.push(r), r
    }

    function it(t, e) {
        return document.location.href + "." + e
    }

    function nt(t, e, i) {
        var n = document.createElement("option");
        n.innerHTML = e, n.value = e, t.__preset_select.appendChild(n), i && (t.__preset_select.selectedIndex = t.__preset_select.length - 1)
    }

    function rt(t, e) {
        e.style.display = t.useLocalStorage ? "block" : "none"
    }

    function ot(t) {
        var e = void 0;

        function i(i) {
            return i.preventDefault(), t.width += e - i.clientX, t.onResize(), e = i.clientX, !1
        }

        function n() {
            S.removeClass(t.__closeButton, J.CLASS_DRAG), S.unbind(window, "mousemove", i), S.unbind(window, "mouseup", n)
        }

        function r(r) {
            return r.preventDefault(), e = r.clientX, S.addClass(t.__closeButton, J.CLASS_DRAG), S.bind(window, "mousemove", i), S.bind(window, "mouseup", n), !1
        }
        t.__resize_handle = document.createElement("div"), a.extend(t.__resize_handle.style, {
            width: "6px",
            marginLeft: "-3px",
            height: "200px",
            cursor: "ew-resize",
            position: "absolute"
        }), S.bind(t.__resize_handle, "mousedown", r), S.bind(t.__closeButton, "mousedown", r), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild)
    }

    function at(t, e) {
        t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px")
    }

    function st(t, e) {
        var i = {};
        return a.each(t.__rememberedObjects, function(n, r) {
            var o = {},
                s = t.__rememberedObjectIndecesToControllers[r];
            a.each(s, function(t, i) {
                o[i] = e ? t.initialValue : t.getValue()
            }), i[r] = o
        }), i
    }
    J.toggleHide = function() {
        Y = !Y, a.each(Z, function(t) {
            t.domElement.style.display = Y ? "none" : ""
        })
    }, J.CLASS_AUTO_PLACE = "a", J.CLASS_AUTO_PLACE_CONTAINER = "ac", J.CLASS_MAIN = "main", J.CLASS_CONTROLLER_ROW = "cr", J.CLASS_TOO_TALL = "taller-than-window", J.CLASS_CLOSED = "closed", J.CLASS_CLOSE_BUTTON = "close-button", J.CLASS_CLOSE_TOP = "close-top", J.CLASS_CLOSE_BOTTOM = "close-bottom", J.CLASS_DRAG = "drag", J.DEFAULT_WIDTH = 245, J.TEXT_CLOSED = "Close Controls", J.TEXT_OPEN = "Open Controls", J._keydownHandler = function(t) {
        "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || J.toggleHide()
    }, S.bind(window, "keydown", J._keydownHandler, !1), a.extend(J.prototype, {
        add: function(t, e) {
            return et(this, t, e, {
                factoryArgs: Array.prototype.slice.call(arguments, 2)
            })
        },
        addColor: function(t, e) {
            return et(this, t, e, {
                color: !0
            })
        },
        remove: function(t) {
            this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1);
            var e = this;
            a.defer(function() {
                e.onResize()
            })
        },
        destroy: function() {
            if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
            this.autoPlace && q.removeChild(this.domElement);
            var t = this;
            a.each(this.__folders, function(e) {
                t.removeFolder(e)
            }), S.unbind(window, "keydown", J._keydownHandler, !1), Q(this)
        },
        addFolder: function(t) {
            if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"');
            var e = {
                name: t,
                parent: this
            };
            e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]);
            var i = new J(e);
            this.__folders[t] = i;
            var n = K(this, i.domElement);
            return S.addClass(n, "folder"), i
        },
        removeFolder: function(t) {
            this.__ul.removeChild(t.domElement.parentElement), delete this.__folders[t.name], this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name], Q(t);
            var e = this;
            a.each(t.__folders, function(e) {
                t.removeFolder(e)
            }), a.defer(function() {
                e.onResize()
            })
        },
        open: function() {
            this.closed = !1
        },
        close: function() {
            this.closed = !0
        },
        onResize: function() {
            var t = this.getRoot();
            if (t.scrollable) {
                var e = S.getOffset(t.__ul).top,
                    i = 0;
                a.each(t.__ul.childNodes, function(e) {
                    t.autoPlace && e === t.__save_row || (i += S.getHeight(e))
                }), window.innerHeight - e - 20 < i ? (S.addClass(t.domElement, J.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - 20 + "px") : (S.removeClass(t.domElement, J.CLASS_TOO_TALL), t.__ul.style.height = "auto")
            }
            t.__resize_handle && a.defer(function() {
                t.__resize_handle.style.height = t.__ul.offsetHeight + "px"
            }), t.__closeButton && (t.__closeButton.style.width = t.width + "px")
        },
        onResizeDebounced: a.debounce(function() {
            this.onResize()
        }, 50),
        remember: function() {
            if (a.isUndefined(W) && ((W = new H).domElement.innerHTML = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'), this.parent) throw new Error("You can only call remember on a top level GUI.");
            var t = this;
            a.each(Array.prototype.slice.call(arguments), function(e) {
                0 === t.__rememberedObjects.length && function(t) {
                    var e = t.__save_row = document.createElement("li");
                    S.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), S.addClass(e, "save-row");
                    var i = document.createElement("span");
                    i.innerHTML = "&nbsp;", S.addClass(i, "button gears");
                    var n = document.createElement("span");
                    n.innerHTML = "Save", S.addClass(n, "button"), S.addClass(n, "save");
                    var r = document.createElement("span");
                    r.innerHTML = "New", S.addClass(r, "button"), S.addClass(r, "save-as");
                    var o = document.createElement("span");
                    o.innerHTML = "Revert", S.addClass(o, "button"), S.addClass(o, "revert");
                    var s = t.__preset_select = document.createElement("select");
                    t.load && t.load.remembered ? a.each(t.load.remembered, function(e, i) {
                        nt(t, i, i === t.preset)
                    }) : nt(t, V, !1);
                    if (S.bind(s, "change", function() {
                            for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                            t.preset = this.value
                        }), e.appendChild(s), e.appendChild(i), e.appendChild(n), e.appendChild(r), e.appendChild(o), j) {
                        var c = document.getElementById("dg-local-explain"),
                            l = document.getElementById("dg-local-storage"),
                            h = document.getElementById("dg-save-locally");
                        h.style.display = "block", "true" === localStorage.getItem(it(t, "isLocal")) && l.setAttribute("checked", "checked"), rt(t, c), S.bind(l, "change", function() {
                            t.useLocalStorage = !t.useLocalStorage, rt(t, c)
                        })
                    }
                    var u = document.getElementById("dg-new-constructor");
                    S.bind(u, "keydown", function(t) {
                        !t.metaKey || 67 !== t.which && 67 !== t.keyCode || W.hide()
                    }), S.bind(i, "click", function() {
                        u.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), W.show(), u.focus(), u.select()
                    }), S.bind(n, "click", function() {
                        t.save()
                    }), S.bind(r, "click", function() {
                        var e = prompt("Enter a new preset name.");
                        e && t.saveAs(e)
                    }), S.bind(o, "click", function() {
                        t.revert()
                    })
                }(t), -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e)
            }), this.autoPlace && at(this, this.width)
        },
        getRoot: function() {
            for (var t = this; t.parent;) t = t.parent;
            return t
        },
        getSaveObject: function() {
            var t = this.load;
            return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = st(this)), t.folders = {}, a.each(this.__folders, function(e, i) {
                t.folders[i] = e.getSaveObject()
            }), t
        },
        save: function() {
            this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = st(this), $(this, !1), this.saveToLocalStorageIfPossible()
        },
        saveAs: function(t) {
            this.load.remembered || (this.load.remembered = {}, this.load.remembered[V] = st(this, !0)), this.load.remembered[t] = st(this), this.preset = t, nt(this, t, !0), this.saveToLocalStorageIfPossible()
        },
        revert: function(t) {
            a.each(this.__controllers, function(e) {
                this.getRoot().load.remembered ? tt(t || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue())
            }, this), a.each(this.__folders, function(t) {
                t.revert(t)
            }), t || $(this.getRoot(), !1)
        },
        listen: function(t) {
            var e = 0 === this.__listening.length;
            this.__listening.push(t), e && function t(e) {
                0 !== e.length && G.call(window, function() {
                    t(e)
                });
                a.each(e, function(t) {
                    t.updateDisplay()
                })
            }(this.__listening)
        },
        updateDisplay: function() {
            a.each(this.__controllers, function(t) {
                t.updateDisplay()
            }), a.each(this.__folders, function(t) {
                t.updateDisplay()
            })
        }
    });
    var ct = new J;
    e.a = ct
}, function(t, e, i) {}, function(t, e, i) {}, function(t, e, i) {}, function(t, e) {
    t.exports = function(t) {
        if (!t.webpackPolyfill) {
            var e = Object.create(t);
            e.children || (e.children = []), Object.defineProperty(e, "loaded", {
                enumerable: !0,
                get: function() {
                    return e.l
                }
            }), Object.defineProperty(e, "id", {
                enumerable: !0,
                get: function() {
                    return e.i
                }
            }), Object.defineProperty(e, "exports", {
                enumerable: !0
            }), e.webpackPolyfill = 1
        }
        return e
    }
}, function(t, e, i) {
    (function(t) {
        function e(t) {
            return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            })(t)
        }
        t.FBXLoader = function() {
            var i, n, r;

            function o(e) {
                this.manager = void 0 !== e ? e : t.DefaultLoadingManager
            }

            function a(t) {
                this.textureLoader = t
            }

            function s() {}

            function c() {}

            function l() {}

            function h() {}

            function u(t, e) {
                this.dv = new DataView(t), this.offset = 0, this.littleEndian = void 0 === e || e
            }

            function d() {}

            function p(t) {
                var e = t.match(/FBXVersion: (\d+)/);
                if (e) return parseInt(e[1]);
                throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
            }

            function f(t) {
                return t / 46186158e3
            }
            o.prototype = {
                constructor: o,
                crossOrigin: "anonymous",
                load: function(e, i, n, r) {
                    var o = this,
                        a = void 0 === o.path ? t.LoaderUtils.extractUrlBase(e) : o.path,
                        s = new t.FileLoader(this.manager);
                    s.setResponseType("arraybuffer"), s.load(e, function(t) {
                        try {
                            i(o.parse(t, a))
                        } catch (t) {
                            setTimeout(function() {
                                r && r(t), o.manager.itemError(e)
                            }, 0)
                        }
                    }, n, r)
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                parse: function(e, n) {
                    if (function(t) {
                            var e = "Kaydara FBX Binary  \0";
                            return t.byteLength >= e.length && e === w(t, 0, e.length)
                        }(e)) i = (new h).parse(e);
                    else {
                        var r = w(e);
                        if (! function(t) {
                                var e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"],
                                    i = 0;

                                function n(e) {
                                    var n = t[e - 1];
                                    return t = t.slice(i + e), i++, n
                                }
                                for (var r = 0; r < e.length; ++r) {
                                    var o = n(1);
                                    if (o === e[r]) return !1
                                }
                                return !0
                            }(r)) throw new Error("THREE.FBXLoader: Unknown format.");
                        if (p(r) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + p(r));
                        i = (new l).parse(r)
                    }
                    return new a(new t.TextureLoader(this.manager).setPath(this.resourcePath || n).setCrossOrigin(this.crossOrigin)).parse(i)
                }
            }, a.prototype = {
                constructor: a,
                parse: function() {
                    n = this.parseConnections();
                    var t = this.parseImages(),
                        e = this.parseTextures(t),
                        i = this.parseMaterials(e),
                        o = this.parseDeformers(),
                        a = (new s).parse(o);
                    return this.parseScene(o, a, i), r
                },
                parseConnections: function() {
                    var t = new Map;
                    "Connections" in i && i.Connections.connections.forEach(function(e) {
                        var i = e[0],
                            n = e[1],
                            r = e[2];
                        t.has(i) || t.set(i, {
                            parents: [],
                            children: []
                        });
                        var o = {
                            ID: n,
                            relationship: r
                        };
                        t.get(i).parents.push(o), t.has(n) || t.set(n, {
                            parents: [],
                            children: []
                        });
                        var a = {
                            ID: i,
                            relationship: r
                        };
                        t.get(n).children.push(a)
                    });
                    return t
                },
                parseImages: function() {
                    var t = {},
                        e = {};
                    if ("Video" in i.Objects) {
                        var n = i.Objects.Video;
                        for (var r in n) {
                            var o = n[r];
                            if (t[l = parseInt(r)] = o.RelativeFilename || o.Filename, "Content" in o) {
                                var a = o.Content instanceof ArrayBuffer && o.Content.byteLength > 0,
                                    s = "string" == typeof o.Content && "" !== o.Content;
                                if (a || s) {
                                    var c = this.parseImage(n[r]);
                                    e[o.RelativeFilename || o.Filename] = c
                                }
                            }
                        }
                    }
                    for (var l in t) {
                        var h = t[l];
                        void 0 !== e[h] ? t[l] = e[h] : t[l] = t[l].split("\\").pop()
                    }
                    return t
                },
                parseImage: function(e) {
                    var i, n = e.Content,
                        r = e.RelativeFilename || e.Filename,
                        o = r.slice(r.lastIndexOf(".") + 1).toLowerCase();
                    switch (o) {
                        case "bmp":
                            i = "image/bmp";
                            break;
                        case "jpg":
                        case "jpeg":
                            i = "image/jpeg";
                            break;
                        case "png":
                            i = "image/png";
                            break;
                        case "tif":
                            i = "image/tiff";
                            break;
                        case "tga":
                            if ("function" != typeof t.TGALoader) return void console.warn("FBXLoader: THREE.TGALoader is required to load TGA textures");
                            if (null === t.Loader.Handlers.get(".tga")) {
                                var a = new t.TGALoader;
                                a.setPath(this.textureLoader.path), t.Loader.Handlers.add(/\.tga$/i, a)
                            }
                            i = "image/tga";
                            break;
                        default:
                            return void console.warn('FBXLoader: Image type "' + o + '" is not supported.')
                    }
                    if ("string" == typeof n) return "data:" + i + ";base64," + n;
                    var s = new Uint8Array(n);
                    return window.URL.createObjectURL(new Blob([s], {
                        type: i
                    }))
                },
                parseTextures: function(t) {
                    var e = new Map;
                    if ("Texture" in i.Objects) {
                        var n = i.Objects.Texture;
                        for (var r in n) {
                            var o = this.parseTexture(n[r], t);
                            e.set(parseInt(r), o)
                        }
                    }
                    return e
                },
                parseTexture: function(e, i) {
                    var n = this.loadTexture(e, i);
                    n.ID = e.id, n.name = e.attrName;
                    var r = e.WrapModeU,
                        o = e.WrapModeV,
                        a = void 0 !== r ? r.value : 0,
                        s = void 0 !== o ? o.value : 0;
                    if (n.wrapS = 0 === a ? t.RepeatWrapping : t.ClampToEdgeWrapping, n.wrapT = 0 === s ? t.RepeatWrapping : t.ClampToEdgeWrapping, "Scaling" in e) {
                        var c = e.Scaling.value;
                        n.repeat.x = c[0], n.repeat.y = c[1]
                    }
                    return n
                },
                loadTexture: function(e, i) {
                    var r, o, a = this.textureLoader.path,
                        s = n.get(e.id).children;
                    void 0 !== s && s.length > 0 && void 0 !== i[s[0].ID] && (0 !== (r = i[s[0].ID]).indexOf("blob:") && 0 !== r.indexOf("data:") || this.textureLoader.setPath(void 0));
                    var c = e.FileName.slice(-3).toLowerCase();
                    if ("tga" === c) {
                        var l = t.Loader.Handlers.get(".tga");
                        null === l ? (console.warn("FBXLoader: TGALoader not found, creating empty placeholder texture for", r), o = new t.Texture) : o = l.load(r)
                    } else "psd" === c ? (console.warn("FBXLoader: PSD textures are not supported, creating empty placeholder texture for", r), o = new t.Texture) : o = this.textureLoader.load(r);
                    return this.textureLoader.setPath(a), o
                },
                parseMaterials: function(t) {
                    var e = new Map;
                    if ("Material" in i.Objects) {
                        var n = i.Objects.Material;
                        for (var r in n) {
                            var o = this.parseMaterial(n[r], t);
                            null !== o && e.set(parseInt(r), o)
                        }
                    }
                    return e
                },
                parseMaterial: function(i, r) {
                    var o = i.id,
                        a = i.attrName,
                        s = i.ShadingModel;
                    if ("object" === e(s) && (s = s.value), !n.has(o)) return null;
                    var c, l = this.parseParameters(i, r, o);
                    switch (s.toLowerCase()) {
                        case "phong":
                            c = new t.MeshPhongMaterial;
                            break;
                        case "lambert":
                            c = new t.MeshLambertMaterial;
                            break;
                        default:
                            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), c = new t.MeshPhongMaterial({
                                color: 3342591
                            })
                    }
                    return c.setValues(l), c.name = a, c
                },
                parseParameters: function(e, i, r) {
                    var o = {};
                    e.BumpFactor && (o.bumpScale = e.BumpFactor.value), e.Diffuse ? o.color = (new t.Color).fromArray(e.Diffuse.value) : e.DiffuseColor && "Color" === e.DiffuseColor.type && (o.color = (new t.Color).fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (o.displacementScale = e.DisplacementFactor.value), e.Emissive ? o.emissive = (new t.Color).fromArray(e.Emissive.value) : e.EmissiveColor && "Color" === e.EmissiveColor.type && (o.emissive = (new t.Color).fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (o.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (o.opacity = parseFloat(e.Opacity.value)), o.opacity < 1 && (o.transparent = !0), e.ReflectionFactor && (o.reflectivity = e.ReflectionFactor.value), e.Shininess && (o.shininess = e.Shininess.value), e.Specular ? o.specular = (new t.Color).fromArray(e.Specular.value) : e.SpecularColor && "Color" === e.SpecularColor.type && (o.specular = (new t.Color).fromArray(e.SpecularColor.value));
                    var a = this;
                    return n.get(r).children.forEach(function(e) {
                        var n = e.relationship;
                        switch (n) {
                            case "Bump":
                                o.bumpMap = a.getTexture(i, e.ID);
                                break;
                            case "DiffuseColor":
                                o.map = a.getTexture(i, e.ID);
                                break;
                            case "DisplacementColor":
                                o.displacementMap = a.getTexture(i, e.ID);
                                break;
                            case "EmissiveColor":
                                o.emissiveMap = a.getTexture(i, e.ID);
                                break;
                            case "NormalMap":
                                o.normalMap = a.getTexture(i, e.ID);
                                break;
                            case "ReflectionColor":
                                o.envMap = a.getTexture(i, e.ID), o.envMap.mapping = t.EquirectangularReflectionMapping;
                                break;
                            case "SpecularColor":
                                o.specularMap = a.getTexture(i, e.ID);
                                break;
                            case "TransparentColor":
                                o.alphaMap = a.getTexture(i, e.ID), o.transparent = !0;
                                break;
                            case "AmbientColor":
                            case "ShininessExponent":
                            case "SpecularFactor":
                            case "VectorDisplacementColor":
                            default:
                                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n)
                        }
                    }), o
                },
                getTexture: function(t, e) {
                    return "LayeredTexture" in i.Objects && e in i.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), e = n.get(e).children[0].ID), t.get(e)
                },
                parseDeformers: function() {
                    var t = {},
                        e = {};
                    if ("Deformer" in i.Objects) {
                        var r = i.Objects.Deformer;
                        for (var o in r) {
                            var a = r[o],
                                s = n.get(parseInt(o));
                            if ("Skin" === a.attrType) {
                                var c = this.parseSkeleton(s, r);
                                c.ID = o, s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), c.geometryID = s.parents[0].ID, t[o] = c
                            } else if ("BlendShape" === a.attrType) {
                                var l = {
                                    id: o
                                };
                                l.rawTargets = this.parseMorphTargets(s, r), l.id = o, s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), e[o] = l
                            }
                        }
                    }
                    return {
                        skeletons: t,
                        morphTargets: e
                    }
                },
                parseSkeleton: function(e, i) {
                    var n = [];
                    return e.children.forEach(function(e) {
                        var r = i[e.ID];
                        if ("Cluster" === r.attrType) {
                            var o = {
                                ID: e.ID,
                                indices: [],
                                weights: [],
                                transformLink: (new t.Matrix4).fromArray(r.TransformLink.a)
                            };
                            "Indexes" in r && (o.indices = r.Indexes.a, o.weights = r.Weights.a), n.push(o)
                        }
                    }), {
                        rawBones: n,
                        bones: []
                    }
                },
                parseMorphTargets: function(t, e) {
                    for (var i = [], r = 0; r < t.children.length; r++) {
                        var o = t.children[r],
                            a = e[o.ID],
                            s = {
                                name: a.attrName,
                                initialWeight: a.DeformPercent,
                                id: a.id,
                                fullWeights: a.FullWeights.a
                            };
                        if ("BlendShapeChannel" !== a.attrType) return;
                        s.geoID = n.get(parseInt(o.ID)).children.filter(function(t) {
                            return void 0 === t.relationship
                        })[0].ID, i.push(s)
                    }
                    return i
                },
                parseScene: function(e, o, a) {
                    r = new t.Group;
                    var s = this.parseModels(e.skeletons, o, a),
                        l = i.Objects.Model,
                        h = this;
                    s.forEach(function(t) {
                        var e = l[t.ID];
                        h.setLookAtProperties(t, e), n.get(t.ID).parents.forEach(function(e) {
                            var i = s.get(e.ID);
                            void 0 !== i && i.add(t)
                        }), null === t.parent && r.add(t)
                    }), this.bindSkeleton(e.skeletons, o, s), this.createAmbientLight(), this.setupMorphMaterials(), r.traverse(function(t) {
                        if (t.userData.transformData) {
                            t.parent && (t.userData.transformData.parentMatrixWorld = t.parent.matrix);
                            var e = _(t.userData.transformData);
                            t.applyMatrix(e)
                        }
                    });
                    var u = (new c).parse();
                    1 === r.children.length && r.children[0].isGroup && (r.children[0].animations = u, r = r.children[0]), r.animations = u
                },
                parseModels: function(e, r, o) {
                    var a = new Map,
                        s = i.Objects.Model;
                    for (var c in s) {
                        var l = parseInt(c),
                            h = s[c],
                            u = n.get(l),
                            d = this.buildSkeleton(u, e, l, h.attrName);
                        if (!d) {
                            switch (h.attrType) {
                                case "Camera":
                                    d = this.createCamera(u);
                                    break;
                                case "Light":
                                    d = this.createLight(u);
                                    break;
                                case "Mesh":
                                    d = this.createMesh(u, r, o);
                                    break;
                                case "NurbsCurve":
                                    d = this.createCurve(u, r);
                                    break;
                                case "LimbNode":
                                case "Root":
                                    d = new t.Bone;
                                    break;
                                case "Null":
                                default:
                                    d = new t.Group
                            }
                            d.name = t.PropertyBinding.sanitizeNodeName(h.attrName), d.ID = l
                        }
                        this.getTransformData(d, h), a.set(l, d)
                    }
                    return a
                },
                buildSkeleton: function(e, i, n, r) {
                    var o = null;
                    return e.parents.forEach(function(e) {
                        for (var a in i) {
                            var s = i[a];
                            s.rawBones.forEach(function(i, a) {
                                if (i.ID === e.ID) {
                                    var c = o;
                                    (o = new t.Bone).matrixWorld.copy(i.transformLink), o.name = t.PropertyBinding.sanitizeNodeName(r), o.ID = n, s.bones[a] = o, null !== c && o.add(c)
                                }
                            })
                        }
                    }), o
                },
                createCamera: function(e) {
                    var n, r;
                    if (e.children.forEach(function(t) {
                            var e = i.Objects.NodeAttribute[t.ID];
                            void 0 !== e && (r = e)
                        }), void 0 === r) n = new t.Object3D;
                    else {
                        var o = 0;
                        void 0 !== r.CameraProjectionType && 1 === r.CameraProjectionType.value && (o = 1);
                        var a = 1;
                        void 0 !== r.NearPlane && (a = r.NearPlane.value / 1e3);
                        var s = 1e3;
                        void 0 !== r.FarPlane && (s = r.FarPlane.value / 1e3);
                        var c = window.innerWidth,
                            l = window.innerHeight;
                        void 0 !== r.AspectWidth && void 0 !== r.AspectHeight && (c = r.AspectWidth.value, l = r.AspectHeight.value);
                        var h = c / l,
                            u = 45;
                        void 0 !== r.FieldOfView && (u = r.FieldOfView.value);
                        var d = r.FocalLength ? r.FocalLength.value : null;
                        switch (o) {
                            case 0:
                                n = new t.PerspectiveCamera(u, h, a, s), null !== d && n.setFocalLength(d);
                                break;
                            case 1:
                                n = new t.OrthographicCamera(-c / 2, c / 2, l / 2, -l / 2, a, s);
                                break;
                            default:
                                console.warn("THREE.FBXLoader: Unknown camera type " + o + "."), n = new t.Object3D
                        }
                    }
                    return n
                },
                createLight: function(e) {
                    var n, r;
                    if (e.children.forEach(function(t) {
                            var e = i.Objects.NodeAttribute[t.ID];
                            void 0 !== e && (r = e)
                        }), void 0 === r) n = new t.Object3D;
                    else {
                        var o;
                        o = void 0 === r.LightType ? 0 : r.LightType.value;
                        var a = 16777215;
                        void 0 !== r.Color && (a = (new t.Color).fromArray(r.Color.value));
                        var s = void 0 === r.Intensity ? 1 : r.Intensity.value / 100;
                        void 0 !== r.CastLightOnObject && 0 === r.CastLightOnObject.value && (s = 0);
                        var c = 0;
                        void 0 !== r.FarAttenuationEnd && (c = void 0 !== r.EnableFarAttenuation && 0 === r.EnableFarAttenuation.value ? 0 : r.FarAttenuationEnd.value);
                        switch (o) {
                            case 0:
                                n = new t.PointLight(a, s, c, 1);
                                break;
                            case 1:
                                n = new t.DirectionalLight(a, s);
                                break;
                            case 2:
                                var l = Math.PI / 3;
                                void 0 !== r.InnerAngle && (l = t.Math.degToRad(r.InnerAngle.value));
                                var h = 0;
                                void 0 !== r.OuterAngle && (h = t.Math.degToRad(r.OuterAngle.value), h = Math.max(h, 1)), n = new t.SpotLight(a, s, c, l, h, 1);
                                break;
                            default:
                                console.warn("THREE.FBXLoader: Unknown light type " + r.LightType.value + ", defaulting to a THREE.PointLight."), n = new t.PointLight(a, s)
                        }
                        void 0 !== r.CastShadows && 1 === r.CastShadows.value && (n.castShadow = !0)
                    }
                    return n
                },
                createMesh: function(e, i, n) {
                    var r, o = null,
                        a = null,
                        s = [];
                    return e.children.forEach(function(t) {
                        i.has(t.ID) && (o = i.get(t.ID)), n.has(t.ID) && s.push(n.get(t.ID))
                    }), s.length > 1 ? a = s : s.length > 0 ? a = s[0] : (a = new t.MeshPhongMaterial({
                        color: 13421772
                    }), s.push(a)), "color" in o.attributes && s.forEach(function(e) {
                        e.vertexColors = t.VertexColors
                    }), o.FBX_Deformer ? (s.forEach(function(t) {
                        t.skinning = !0
                    }), r = new t.SkinnedMesh(o, a)) : r = new t.Mesh(o, a), r
                },
                createCurve: function(e, i) {
                    var n = e.children.reduce(function(t, e) {
                            return i.has(e.ID) && (t = i.get(e.ID)), t
                        }, null),
                        r = new t.LineBasicMaterial({
                            color: 3342591,
                            linewidth: 1
                        });
                    return new t.Line(n, r)
                },
                getTransformData: function(t, e) {
                    var i = {};
                    "InheritType" in e && (i.inheritType = parseInt(e.InheritType.value)), i.eulerOrder = "RotationOrder" in e ? x(e.RotationOrder.value) : "ZYX", "Lcl_Translation" in e && (i.translation = e.Lcl_Translation.value), "PreRotation" in e && (i.preRotation = e.PreRotation.value), "Lcl_Rotation" in e && (i.rotation = e.Lcl_Rotation.value), "PostRotation" in e && (i.postRotation = e.PostRotation.value), "Lcl_Scaling" in e && (i.scale = e.Lcl_Scaling.value), "ScalingOffset" in e && (i.scalingOffset = e.ScalingOffset.value), "ScalingPivot" in e && (i.scalingPivot = e.ScalingPivot.value), "RotationOffset" in e && (i.rotationOffset = e.RotationOffset.value), "RotationPivot" in e && (i.rotationPivot = e.RotationPivot.value), t.userData.transformData = i
                },
                setLookAtProperties: function(e, o) {
                    "LookAtProperty" in o && n.get(e.ID).children.forEach(function(n) {
                        if ("LookAtProperty" === n.relationship) {
                            var o = i.Objects.Model[n.ID];
                            if ("Lcl_Translation" in o) {
                                var a = o.Lcl_Translation.value;
                                void 0 !== e.target ? (e.target.position.fromArray(a), r.add(e.target)) : e.lookAt((new t.Vector3).fromArray(a))
                            }
                        }
                    })
                },
                bindSkeleton: function(e, i, r) {
                    var o = this.parsePoseNodes();
                    for (var a in e) {
                        var s = e[a];
                        n.get(parseInt(s.ID)).parents.forEach(function(e) {
                            if (i.has(e.ID)) {
                                var a = e.ID;
                                n.get(a).parents.forEach(function(e) {
                                    r.has(e.ID) && r.get(e.ID).bind(new t.Skeleton(s.bones), o[e.ID])
                                })
                            }
                        })
                    }
                },
                parsePoseNodes: function() {
                    var e = {};
                    if ("Pose" in i.Objects) {
                        var n = i.Objects.Pose;
                        for (var r in n)
                            if ("BindPose" === n[r].attrType) {
                                var o = n[r].PoseNode;
                                Array.isArray(o) ? o.forEach(function(i) {
                                    e[i.Node] = (new t.Matrix4).fromArray(i.Matrix.a)
                                }) : e[o.Node] = (new t.Matrix4).fromArray(o.Matrix.a)
                            }
                    }
                    return e
                },
                createAmbientLight: function() {
                    if ("GlobalSettings" in i && "AmbientColor" in i.GlobalSettings) {
                        var e = i.GlobalSettings.AmbientColor.value,
                            n = e[0],
                            o = e[1],
                            a = e[2];
                        if (0 !== n || 0 !== o || 0 !== a) {
                            var s = new t.Color(n, o, a);
                            r.add(new t.AmbientLight(s, 1))
                        }
                    }
                },
                setupMorphMaterials: function() {
                    var t = this;
                    r.traverse(function(e) {
                        e.isMesh && e.geometry.morphAttributes.position && e.geometry.morphAttributes.position.length && (Array.isArray(e.material) ? e.material.forEach(function(i, n) {
                            t.setupMorphMaterial(e, i, n)
                        }) : t.setupMorphMaterial(e, e.material))
                    })
                },
                setupMorphMaterial: function(t, e, i) {
                    var n = t.uuid,
                        o = e.uuid,
                        a = !1;
                    if (r.traverse(function(t) {
                            t.isMesh && (Array.isArray(t.material) ? t.material.forEach(function(e) {
                                e.uuid === o && t.uuid !== n && (a = !0)
                            }) : t.material.uuid === o && t.uuid !== n && (a = !0))
                        }), !0 === a) {
                        var s = e.clone();
                        s.morphTargets = !0, void 0 === i ? t.material = s : t.material[i] = s
                    } else e.morphTargets = !0
                }
            }, s.prototype = {
                constructor: s,
                parse: function(t) {
                    var e = new Map;
                    if ("Geometry" in i.Objects) {
                        var r = i.Objects.Geometry;
                        for (var o in r) {
                            var a = n.get(parseInt(o)),
                                s = this.parseGeometry(a, r[o], t);
                            e.set(parseInt(o), s)
                        }
                    }
                    return e
                },
                parseGeometry: function(t, e, i) {
                    switch (e.attrType) {
                        case "Mesh":
                            return this.parseMeshGeometry(t, e, i);
                        case "NurbsCurve":
                            return this.parseNurbsGeometry(e)
                    }
                },
                parseMeshGeometry: function(t, e, n) {
                    var r = n.skeletons,
                        o = n.morphTargets,
                        a = t.parents.map(function(t) {
                            return i.Objects.Model[t.ID]
                        });
                    if (0 !== a.length) {
                        var s = t.children.reduce(function(t, e) {
                                return void 0 !== r[e.ID] && (t = r[e.ID]), t
                            }, null),
                            c = t.children.reduce(function(t, e) {
                                return void 0 !== o[e.ID] && (t = o[e.ID]), t
                            }, null),
                            l = a[0],
                            h = {};
                        "RotationOrder" in l && (h.eulerOrder = x(l.RotationOrder.value)), "InheritType" in l && (h.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (h.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (h.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (h.scale = l.GeometricScaling.value);
                        var u = _(h);
                        return this.genGeometry(e, s, c, u)
                    }
                },
                genGeometry: function(e, i, n, r) {
                    var o = new t.BufferGeometry;
                    e.attrName && (o.name = e.attrName);
                    var a = this.parseGeoNode(e, i),
                        s = this.genBuffers(a),
                        c = new t.Float32BufferAttribute(s.vertex, 3);
                    if (r.applyToBufferAttribute(c), o.addAttribute("position", c), s.colors.length > 0 && o.addAttribute("color", new t.Float32BufferAttribute(s.colors, 3)), i && (o.addAttribute("skinIndex", new t.Uint16BufferAttribute(s.weightsIndices, 4)), o.addAttribute("skinWeight", new t.Float32BufferAttribute(s.vertexWeights, 4)), o.FBX_Deformer = i), s.normal.length > 0) {
                        var l = new t.Float32BufferAttribute(s.normal, 3);
                        (new t.Matrix3).getNormalMatrix(r).applyToBufferAttribute(l), o.addAttribute("normal", l)
                    }
                    if (s.uvs.forEach(function(e, i) {
                            var n = "uv" + (i + 1).toString();
                            0 === i && (n = "uv"), o.addAttribute(n, new t.Float32BufferAttribute(s.uvs[i], 2))
                        }), a.material && "AllSame" !== a.material.mappingType) {
                        var h = s.materialIndex[0],
                            u = 0;
                        if (s.materialIndex.forEach(function(t, e) {
                                t !== h && (o.addGroup(u, e - u, h), h = t, u = e)
                            }), o.groups.length > 0) {
                            var d = o.groups[o.groups.length - 1],
                                p = d.start + d.count;
                            p !== s.materialIndex.length && o.addGroup(p, s.materialIndex.length - p, h)
                        }
                        0 === o.groups.length && o.addGroup(0, s.materialIndex.length, s.materialIndex[0])
                    }
                    return this.addMorphTargets(o, e, n, r), o
                },
                parseGeoNode: function(t, e) {
                    var i = {};
                    if (i.vertexPositions = void 0 !== t.Vertices ? t.Vertices.a : [], i.vertexIndices = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [], t.LayerElementColor && (i.color = this.parseVertexColors(t.LayerElementColor[0])), t.LayerElementMaterial && (i.material = this.parseMaterialIndices(t.LayerElementMaterial[0])), t.LayerElementNormal && (i.normal = this.parseNormals(t.LayerElementNormal[0])), t.LayerElementUV) {
                        i.uv = [];
                        for (var n = 0; t.LayerElementUV[n];) i.uv.push(this.parseUVs(t.LayerElementUV[n])), n++
                    }
                    return i.weightTable = {}, null !== e && (i.skeleton = e, e.rawBones.forEach(function(t, e) {
                        t.indices.forEach(function(n, r) {
                            void 0 === i.weightTable[n] && (i.weightTable[n] = []), i.weightTable[n].push({
                                id: e,
                                weight: t.weights[r]
                            })
                        })
                    })), i
                },
                genBuffers: function(t) {
                    var e = {
                            vertex: [],
                            normal: [],
                            colors: [],
                            uvs: [],
                            materialIndex: [],
                            vertexWeights: [],
                            weightsIndices: []
                        },
                        i = 0,
                        n = 0,
                        r = !1,
                        o = [],
                        a = [],
                        s = [],
                        c = [],
                        l = [],
                        h = [],
                        u = this;
                    return t.vertexIndices.forEach(function(d, p) {
                        var f = !1;
                        d < 0 && (d ^= -1, f = !0);
                        var m = [],
                            v = [];
                        if (o.push(3 * d, 3 * d + 1, 3 * d + 2), t.color) {
                            var y = g(p, i, d, t.color);
                            s.push(y[0], y[1], y[2])
                        }
                        if (t.skeleton) {
                            if (void 0 !== t.weightTable[d] && t.weightTable[d].forEach(function(t) {
                                    v.push(t.weight), m.push(t.id)
                                }), v.length > 4) {
                                r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r = !0);
                                var _ = [0, 0, 0, 0],
                                    x = [0, 0, 0, 0];
                                v.forEach(function(t, e) {
                                    var i = t,
                                        n = m[e];
                                    x.forEach(function(t, e, r) {
                                        if (i > t) {
                                            r[e] = i, i = t;
                                            var o = _[e];
                                            _[e] = n, n = o
                                        }
                                    })
                                }), m = _, v = x
                            }
                            for (; v.length < 4;) v.push(0), m.push(0);
                            for (var b = 0; b < 4; ++b) l.push(v[b]), h.push(m[b])
                        }
                        if (t.normal) {
                            y = g(p, i, d, t.normal);
                            a.push(y[0], y[1], y[2])
                        }
                        if (t.material && "AllSame" !== t.material.mappingType) var w = g(p, i, d, t.material)[0];
                        t.uv && t.uv.forEach(function(t, e) {
                            var n = g(p, i, d, t);
                            void 0 === c[e] && (c[e] = []), c[e].push(n[0]), c[e].push(n[1])
                        }), n++, f && (u.genFace(e, t, o, w, a, s, c, l, h, n), i++, n = 0, o = [], a = [], s = [], c = [], l = [], h = [])
                    }), e
                },
                genFace: function(t, e, i, n, r, o, a, s, c, l) {
                    for (var h = 2; h < l; h++) t.vertex.push(e.vertexPositions[i[0]]), t.vertex.push(e.vertexPositions[i[1]]), t.vertex.push(e.vertexPositions[i[2]]), t.vertex.push(e.vertexPositions[i[3 * (h - 1)]]), t.vertex.push(e.vertexPositions[i[3 * (h - 1) + 1]]), t.vertex.push(e.vertexPositions[i[3 * (h - 1) + 2]]), t.vertex.push(e.vertexPositions[i[3 * h]]), t.vertex.push(e.vertexPositions[i[3 * h + 1]]), t.vertex.push(e.vertexPositions[i[3 * h + 2]]), e.skeleton && (t.vertexWeights.push(s[0]), t.vertexWeights.push(s[1]), t.vertexWeights.push(s[2]), t.vertexWeights.push(s[3]), t.vertexWeights.push(s[4 * (h - 1)]), t.vertexWeights.push(s[4 * (h - 1) + 1]), t.vertexWeights.push(s[4 * (h - 1) + 2]), t.vertexWeights.push(s[4 * (h - 1) + 3]), t.vertexWeights.push(s[4 * h]), t.vertexWeights.push(s[4 * h + 1]), t.vertexWeights.push(s[4 * h + 2]), t.vertexWeights.push(s[4 * h + 3]), t.weightsIndices.push(c[0]), t.weightsIndices.push(c[1]), t.weightsIndices.push(c[2]), t.weightsIndices.push(c[3]), t.weightsIndices.push(c[4 * (h - 1)]), t.weightsIndices.push(c[4 * (h - 1) + 1]), t.weightsIndices.push(c[4 * (h - 1) + 2]), t.weightsIndices.push(c[4 * (h - 1) + 3]), t.weightsIndices.push(c[4 * h]), t.weightsIndices.push(c[4 * h + 1]), t.weightsIndices.push(c[4 * h + 2]), t.weightsIndices.push(c[4 * h + 3])), e.color && (t.colors.push(o[0]), t.colors.push(o[1]), t.colors.push(o[2]), t.colors.push(o[3 * (h - 1)]), t.colors.push(o[3 * (h - 1) + 1]), t.colors.push(o[3 * (h - 1) + 2]), t.colors.push(o[3 * h]), t.colors.push(o[3 * h + 1]), t.colors.push(o[3 * h + 2])), e.material && "AllSame" !== e.material.mappingType && (t.materialIndex.push(n), t.materialIndex.push(n), t.materialIndex.push(n)), e.normal && (t.normal.push(r[0]), t.normal.push(r[1]), t.normal.push(r[2]), t.normal.push(r[3 * (h - 1)]), t.normal.push(r[3 * (h - 1) + 1]), t.normal.push(r[3 * (h - 1) + 2]), t.normal.push(r[3 * h]), t.normal.push(r[3 * h + 1]), t.normal.push(r[3 * h + 2])), e.uv && e.uv.forEach(function(e, i) {
                        void 0 === t.uvs[i] && (t.uvs[i] = []), t.uvs[i].push(a[i][0]), t.uvs[i].push(a[i][1]), t.uvs[i].push(a[i][2 * (h - 1)]), t.uvs[i].push(a[i][2 * (h - 1) + 1]), t.uvs[i].push(a[i][2 * h]), t.uvs[i].push(a[i][2 * h + 1])
                    })
                },
                addMorphTargets: function(t, e, n, r) {
                    if (null !== n) {
                        t.morphAttributes.position = [];
                        var o = this;
                        n.rawTargets.forEach(function(n) {
                            var a = i.Objects.Geometry[n.geoID];
                            void 0 !== a && o.genMorphGeometry(t, e, a, r, n.name)
                        })
                    }
                },
                genMorphGeometry: function(e, i, n, r, o) {
                    var a = new t.BufferGeometry;
                    n.attrName && (a.name = n.attrName);
                    for (var s = void 0 !== i.PolygonVertexIndex ? i.PolygonVertexIndex.a : [], c = void 0 !== i.Vertices ? i.Vertices.a.slice() : [], l = void 0 !== n.Vertices ? n.Vertices.a : [], h = void 0 !== n.Indexes ? n.Indexes.a : [], u = 0; u < h.length; u++) {
                        var d = 3 * h[u];
                        c[d] += l[3 * u], c[d + 1] += l[3 * u + 1], c[d + 2] += l[3 * u + 2]
                    }
                    var p = {
                            vertexIndices: s,
                            vertexPositions: c
                        },
                        f = this.genBuffers(p),
                        m = new t.Float32BufferAttribute(f.vertex, 3);
                    m.name = o || n.attrName, r.applyToBufferAttribute(m), e.morphAttributes.position.push(m)
                },
                parseNormals: function(t) {
                    var e = t.MappingInformationType,
                        i = t.ReferenceInformationType,
                        n = t.Normals.a,
                        r = [];
                    return "IndexToDirect" === i && ("NormalIndex" in t ? r = t.NormalIndex.a : "NormalsIndex" in t && (r = t.NormalsIndex.a)), {
                        dataSize: 3,
                        buffer: n,
                        indices: r,
                        mappingType: e,
                        referenceType: i
                    }
                },
                parseUVs: function(t) {
                    var e = t.MappingInformationType,
                        i = t.ReferenceInformationType,
                        n = t.UV.a,
                        r = [];
                    return "IndexToDirect" === i && (r = t.UVIndex.a), {
                        dataSize: 2,
                        buffer: n,
                        indices: r,
                        mappingType: e,
                        referenceType: i
                    }
                },
                parseVertexColors: function(t) {
                    var e = t.MappingInformationType,
                        i = t.ReferenceInformationType,
                        n = t.Colors.a,
                        r = [];
                    return "IndexToDirect" === i && (r = t.ColorIndex.a), {
                        dataSize: 4,
                        buffer: n,
                        indices: r,
                        mappingType: e,
                        referenceType: i
                    }
                },
                parseMaterialIndices: function(t) {
                    var e = t.MappingInformationType,
                        i = t.ReferenceInformationType;
                    if ("NoMappingInformation" === e) return {
                        dataSize: 1,
                        buffer: [0],
                        indices: [0],
                        mappingType: "AllSame",
                        referenceType: i
                    };
                    for (var n = t.Materials.a, r = [], o = 0; o < n.length; ++o) r.push(o);
                    return {
                        dataSize: 1,
                        buffer: n,
                        indices: r,
                        mappingType: e,
                        referenceType: i
                    }
                },
                parseNurbsGeometry: function(e) {
                    if (void 0 === t.NURBSCurve) return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new t.BufferGeometry;
                    var i = parseInt(e.Order);
                    if (isNaN(i)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new t.BufferGeometry;
                    for (var n, r, o = i - 1, a = e.KnotVector.a, s = [], c = e.Points.a, l = 0, h = c.length; l < h; l += 4) s.push((new t.Vector4).fromArray(c, l));
                    if ("Closed" === e.Form) s.push(s[0]);
                    else if ("Periodic" === e.Form) {
                        n = o, r = a.length - 1 - n;
                        for (l = 0; l < o; ++l) s.push(s[l])
                    }
                    var u = new t.NURBSCurve(o, a, s, n, r).getPoints(7 * s.length),
                        d = new Float32Array(3 * u.length);
                    u.forEach(function(t, e) {
                        t.toArray(d, 3 * e)
                    });
                    var p = new t.BufferGeometry;
                    return p.addAttribute("position", new t.BufferAttribute(d, 3)), p
                }
            }, c.prototype = {
                constructor: c,
                parse: function() {
                    var t = [],
                        e = this.parseClips();
                    if (void 0 !== e) {
                        for (var i in e) {
                            var n = e[i],
                                r = this.addClip(n);
                            t.push(r)
                        }
                        return t
                    }
                },
                parseClips: function() {
                    if (void 0 !== i.Objects.AnimationCurve) {
                        var t = this.parseAnimationCurveNodes();
                        this.parseAnimationCurves(t);
                        var e = this.parseAnimationLayers(t);
                        return this.parseAnimStacks(e)
                    }
                },
                parseAnimationCurveNodes: function() {
                    var t = i.Objects.AnimationCurveNode,
                        e = new Map;
                    for (var n in t) {
                        var r = t[n];
                        if (null !== r.attrName.match(/S|R|T|DeformPercent/)) {
                            var o = {
                                id: r.id,
                                attr: r.attrName,
                                curves: {}
                            };
                            e.set(o.id, o)
                        }
                    }
                    return e
                },
                parseAnimationCurves: function(t) {
                    var e = i.Objects.AnimationCurve;
                    for (var r in e) {
                        var o = {
                                id: e[r].id,
                                times: e[r].KeyTime.a.map(f),
                                values: e[r].KeyValueFloat.a
                            },
                            a = n.get(o.id);
                        if (void 0 !== a) {
                            var s = a.parents[0].ID,
                                c = a.parents[0].relationship;
                            c.match(/X/) ? t.get(s).curves.x = o : c.match(/Y/) ? t.get(s).curves.y = o : c.match(/Z/) ? t.get(s).curves.z = o : c.match(/d|DeformPercent/) && t.has(s) && (t.get(s).curves.morph = o)
                        }
                    }
                },
                parseAnimationLayers: function(e) {
                    var o = i.Objects.AnimationLayer,
                        a = new Map;
                    for (var s in o) {
                        var c = [],
                            l = n.get(parseInt(s));
                        if (void 0 !== l) l.children.forEach(function(o, a) {
                            if (e.has(o.ID)) {
                                var s = e.get(o.ID);
                                if (void 0 !== s.curves.x || void 0 !== s.curves.y || void 0 !== s.curves.z) {
                                    if (void 0 === c[a])
                                        if (void 0 !== (f = n.get(o.ID).parents.filter(function(t) {
                                                return void 0 !== t.relationship
                                            })[0].ID)) {
                                            var l = i.Objects.Model[f.toString()],
                                                h = {
                                                    modelName: t.PropertyBinding.sanitizeNodeName(l.attrName),
                                                    ID: l.id,
                                                    initialPosition: [0, 0, 0],
                                                    initialRotation: [0, 0, 0],
                                                    initialScale: [1, 1, 1]
                                                };
                                            r.traverse(function(t) {
                                                (t.ID = l.id) && (h.transform = t.matrix, t.userData.transformData && (h.eulerOrder = t.userData.transformData.eulerOrder))
                                            }), h.transform || (h.transform = new t.Matrix4), "PreRotation" in l && (h.preRotation = l.PreRotation.value), "PostRotation" in l && (h.postRotation = l.PostRotation.value), c[a] = h
                                        }
                                    c[a] && (c[a][s.attr] = s)
                                } else if (void 0 !== s.curves.morph) {
                                    if (void 0 === c[a]) {
                                        var u = n.get(o.ID).parents.filter(function(t) {
                                                return void 0 !== t.relationship
                                            })[0].ID,
                                            d = n.get(u).parents[0].ID,
                                            p = n.get(d).parents[0].ID,
                                            f = n.get(p).parents[0].ID;
                                        l = i.Objects.Model[f], h = {
                                            modelName: t.PropertyBinding.sanitizeNodeName(l.attrName),
                                            morphName: i.Objects.Deformer[u].attrName
                                        };
                                        c[a] = h
                                    }
                                    c[a][s.attr] = s
                                }
                            }
                        }), a.set(parseInt(s), c)
                    }
                    return a
                },
                parseAnimStacks: function(t) {
                    var e = i.Objects.AnimationStack,
                        r = {};
                    for (var o in e) {
                        var a = n.get(parseInt(o)).children;
                        a.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                        var s = t.get(a[0].ID);
                        r[o] = {
                            name: e[o].attrName,
                            layer: s
                        }
                    }
                    return r
                },
                addClip: function(e) {
                    var i = [],
                        n = this;
                    return e.layer.forEach(function(t) {
                        i = i.concat(n.generateTracks(t))
                    }), new t.AnimationClip(e.name, -1, i)
                },
                generateTracks: function(e) {
                    var i = [],
                        n = new t.Vector3,
                        r = new t.Quaternion,
                        o = new t.Vector3;
                    if (e.transform && e.transform.decompose(n, r, o), n = n.toArray(), r = (new t.Euler).setFromQuaternion(r, e.eulerOrder).toArray(), o = o.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) {
                        var a = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
                        void 0 !== a && i.push(a)
                    }
                    if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
                        var s = this.generateRotationTrack(e.modelName, e.R.curves, r, e.preRotation, e.postRotation, e.eulerOrder);
                        void 0 !== s && i.push(s)
                    }
                    if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
                        var c = this.generateVectorTrack(e.modelName, e.S.curves, o, "scale");
                        void 0 !== c && i.push(c)
                    }
                    if (void 0 !== e.DeformPercent) {
                        var l = this.generateMorphTrack(e);
                        void 0 !== l && i.push(l)
                    }
                    return i
                },
                generateVectorTrack: function(e, i, n, r) {
                    var o = this.getTimesForAllAxes(i),
                        a = this.getKeyframeTrackValues(o, i, n);
                    return new t.VectorKeyframeTrack(e + "." + r, o, a)
                },
                generateRotationTrack: function(e, i, n, r, o, a) {
                    void 0 !== i.x && (this.interpolateRotations(i.x), i.x.values = i.x.values.map(t.Math.degToRad)), void 0 !== i.y && (this.interpolateRotations(i.y), i.y.values = i.y.values.map(t.Math.degToRad)), void 0 !== i.z && (this.interpolateRotations(i.z), i.z.values = i.z.values.map(t.Math.degToRad));
                    var s = this.getTimesForAllAxes(i),
                        c = this.getKeyframeTrackValues(s, i, n);
                    void 0 !== r && ((r = r.map(t.Math.degToRad)).push(a), r = (new t.Euler).fromArray(r), r = (new t.Quaternion).setFromEuler(r)), void 0 !== o && ((o = o.map(t.Math.degToRad)).push(a), o = (new t.Euler).fromArray(o), o = (new t.Quaternion).setFromEuler(o).inverse());
                    for (var l = new t.Quaternion, h = new t.Euler, u = [], d = 0; d < c.length; d += 3) h.set(c[d], c[d + 1], c[d + 2], a), l.setFromEuler(h), void 0 !== r && l.premultiply(r), void 0 !== o && l.multiply(o), l.toArray(u, d / 3 * 4);
                    return new t.QuaternionKeyframeTrack(e + ".quaternion", s, u)
                },
                generateMorphTrack: function(e) {
                    var i = e.DeformPercent.curves.morph,
                        n = i.values.map(function(t) {
                            return t / 100
                        }),
                        o = r.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
                    return new t.NumberKeyframeTrack(e.modelName + ".morphTargetInfluences[" + o + "]", i.times, n)
                },
                getTimesForAllAxes: function(t) {
                    var e = [];
                    return void 0 !== t.x && (e = e.concat(t.x.times)), void 0 !== t.y && (e = e.concat(t.y.times)), void 0 !== t.z && (e = e.concat(t.z.times)), e = e.sort(function(t, e) {
                        return t - e
                    }).filter(function(t, e, i) {
                        return i.indexOf(t) == e
                    })
                },
                getKeyframeTrackValues: function(t, e, i) {
                    var n = i,
                        r = [],
                        o = -1,
                        a = -1,
                        s = -1;
                    return t.forEach(function(t) {
                        if (e.x && (o = e.x.times.indexOf(t)), e.y && (a = e.y.times.indexOf(t)), e.z && (s = e.z.times.indexOf(t)), -1 !== o) {
                            var i = e.x.values[o];
                            r.push(i), n[0] = i
                        } else r.push(n[0]);
                        if (-1 !== a) {
                            var c = e.y.values[a];
                            r.push(c), n[1] = c
                        } else r.push(n[1]);
                        if (-1 !== s) {
                            var l = e.z.values[s];
                            r.push(l), n[2] = l
                        } else r.push(n[2])
                    }), r
                },
                interpolateRotations: function(t) {
                    for (var e = 1; e < t.values.length; e++) {
                        var i = t.values[e - 1],
                            n = t.values[e] - i,
                            r = Math.abs(n);
                        if (r >= 180) {
                            for (var o = r / 180, a = n / o, s = i + a, c = t.times[e - 1], l = (t.times[e] - c) / o, h = c + l, u = [], d = []; h < t.times[e];) u.push(h), h += l, d.push(s), s += a;
                            t.times = M(t.times, e, u), t.values = M(t.values, e, d)
                        }
                    }
                }
            }, l.prototype = {
                constructor: l,
                getPrevNode: function() {
                    return this.nodeStack[this.currentIndent - 2]
                },
                getCurrentNode: function() {
                    return this.nodeStack[this.currentIndent - 1]
                },
                getCurrentProp: function() {
                    return this.currentProp
                },
                pushStack: function(t) {
                    this.nodeStack.push(t), this.currentIndent += 1
                },
                popStack: function() {
                    this.nodeStack.pop(), this.currentIndent -= 1
                },
                setCurrentProp: function(t, e) {
                    this.currentProp = t, this.currentPropName = e
                },
                parse: function(t) {
                    this.currentIndent = 0, this.allNodes = new d, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
                    var e = this,
                        i = t.split(/[\r\n]+/);
                    return i.forEach(function(t, n) {
                        var r = t.match(/^[\s\t]*;/),
                            o = t.match(/^[\s\t]*$/);
                        if (!r && !o) {
                            var a = t.match("^\\t{" + e.currentIndent + "}(\\w+):(.*){", ""),
                                s = t.match("^\\t{" + e.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
                                c = t.match("^\\t{" + (e.currentIndent - 1) + "}}");
                            a ? e.parseNodeBegin(t, a) : s ? e.parseNodeProperty(t, s, i[++n]) : c ? e.popStack() : t.match(/^[^\s\t}]/) && e.parseNodePropertyContinued(t)
                        }
                    }), this.allNodes
                },
                parseNodeBegin: function(t, e) {
                    var i = e[1].trim().replace(/^"/, "").replace(/"$/, ""),
                        n = e[2].split(",").map(function(t) {
                            return t.trim().replace(/^"/, "").replace(/"$/, "")
                        }),
                        r = {
                            name: i
                        },
                        o = this.parseNodeAttr(n),
                        a = this.getCurrentNode();
                    0 === this.currentIndent ? this.allNodes.add(i, r) : i in a ? ("PoseNode" === i ? a.PoseNode.push(r) : void 0 !== a[i].id && (a[i] = {}, a[i][a[i].id] = a[i]), "" !== o.id && (a[i][o.id] = r)) : "number" == typeof o.id ? (a[i] = {}, a[i][o.id] = r) : "Properties70" !== i && (a[i] = "PoseNode" === i ? [r] : r), "number" == typeof o.id && (r.id = o.id), "" !== o.name && (r.attrName = o.name), "" !== o.type && (r.attrType = o.type), this.pushStack(r)
                },
                parseNodeAttr: function(t) {
                    var e = t[0];
                    "" !== t[0] && (e = parseInt(t[0]), isNaN(e) && (e = t[0]));
                    var i = "",
                        n = "";
                    return t.length > 1 && (i = t[1].replace(/^(\w+)::/, ""), n = t[2]), {
                        id: e,
                        name: i,
                        type: n
                    }
                },
                parseNodeProperty: function(t, e, i) {
                    var n = e[1].replace(/^"/, "").replace(/"$/, "").trim(),
                        r = e[2].replace(/^"/, "").replace(/"$/, "").trim();
                    "Content" === n && "," === r && (r = i.replace(/"/g, "").replace(/,$/, "").trim());
                    var o = this.getCurrentNode();
                    if ("Properties70" !== o.name) {
                        if ("C" === n) {
                            var a = r.split(",").slice(1),
                                s = parseInt(a[0]),
                                c = parseInt(a[1]),
                                l = r.split(",").slice(3);
                            n = "connections",
                                function(t, e) {
                                    for (var i = 0, n = t.length, r = e.length; i < r; i++, n++) t[n] = e[i]
                                }(r = [s, c], l = l.map(function(t) {
                                    return t.trim().replace(/^"/, "")
                                })), void 0 === o[n] && (o[n] = [])
                        }
                        "Node" === n && (o.id = r), n in o && Array.isArray(o[n]) ? o[n].push(r) : "a" !== n ? o[n] = r : o.a = r, this.setCurrentProp(o, n), "a" === n && "," !== r.slice(-1) && (o.a = b(r))
                    } else this.parseNodeSpecialProperty(t, n, r)
                },
                parseNodePropertyContinued: function(t) {
                    var e = this.getCurrentNode();
                    e.a += t, "," !== t.slice(-1) && (e.a = b(e.a))
                },
                parseNodeSpecialProperty: function(t, e, i) {
                    var n = i.split('",').map(function(t) {
                            return t.trim().replace(/^\"/, "").replace(/\s/, "_")
                        }),
                        r = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        c = n[4];
                    switch (o) {
                        case "int":
                        case "enum":
                        case "bool":
                        case "ULongLong":
                        case "double":
                        case "Number":
                        case "FieldOfView":
                            c = parseFloat(c);
                            break;
                        case "Color":
                        case "ColorRGB":
                        case "Vector3D":
                        case "Lcl_Translation":
                        case "Lcl_Rotation":
                        case "Lcl_Scaling":
                            c = b(c)
                    }
                    this.getPrevNode()[r] = {
                        type: o,
                        type2: a,
                        flag: s,
                        value: c
                    }, this.setCurrentProp(this.getPrevNode(), r)
                }
            }, h.prototype = {
                constructor: h,
                parse: function(t) {
                    var e = new u(t);
                    e.skip(23);
                    var i = e.getUint32();
                    console.log("THREE.FBXLoader: FBX binary version: " + i);
                    for (var n = new d; !this.endOfContent(e);) {
                        var r = this.parseNode(e, i);
                        null !== r && n.add(r.name, r)
                    }
                    return n
                },
                endOfContent: function(t) {
                    return t.size() % 16 == 0 ? (t.getOffset() + 160 + 16 & -16) >= t.size() : t.getOffset() + 160 + 16 >= t.size()
                },
                parseNode: function(t, e) {
                    var i = {},
                        n = e >= 7500 ? t.getUint64() : t.getUint32(),
                        r = e >= 7500 ? t.getUint64() : t.getUint32(),
                        o = (e >= 7500 ? t.getUint64() : t.getUint32(), t.getUint8()),
                        a = t.getString(o);
                    if (0 === n) return null;
                    for (var s = [], c = 0; c < r; c++) s.push(this.parseProperty(t));
                    var l = s.length > 0 ? s[0] : "",
                        h = s.length > 1 ? s[1] : "",
                        u = s.length > 2 ? s[2] : "";
                    for (i.singleProperty = 1 === r && t.getOffset() === n; n > t.getOffset();) {
                        var d = this.parseNode(t, e);
                        null !== d && this.parseSubNode(a, i, d)
                    }
                    return i.propertyList = s, "number" == typeof l && (i.id = l), "" !== h && (i.attrName = h), "" !== u && (i.attrType = u), "" !== a && (i.name = a), i
                },
                parseSubNode: function(t, e, i) {
                    if (!0 === i.singleProperty) {
                        var n = i.propertyList[0];
                        Array.isArray(n) ? (e[i.name] = i, i.a = n) : e[i.name] = n
                    } else if ("Connections" === t && "C" === i.name) {
                        var r = [];
                        i.propertyList.forEach(function(t, e) {
                            0 !== e && r.push(t)
                        }), void 0 === e.connections && (e.connections = []), e.connections.push(r)
                    } else if ("Properties70" === i.name) {
                        Object.keys(i).forEach(function(t) {
                            e[t] = i[t]
                        })
                    } else if ("Properties70" === t && "P" === i.name) {
                        var o, a = i.propertyList[0],
                            s = i.propertyList[1],
                            c = i.propertyList[2],
                            l = i.propertyList[3];
                        0 === a.indexOf("Lcl ") && (a = a.replace("Lcl ", "Lcl_")), 0 === s.indexOf("Lcl ") && (s = s.replace("Lcl ", "Lcl_")), o = "Color" === s || "ColorRGB" === s || "Vector" === s || "Vector3D" === s || 0 === s.indexOf("Lcl_") ? [i.propertyList[4], i.propertyList[5], i.propertyList[6]] : i.propertyList[4], e[a] = {
                            type: s,
                            type2: c,
                            flag: l,
                            value: o
                        }
                    } else void 0 === e[i.name] ? "number" == typeof i.id ? (e[i.name] = {}, e[i.name][i.id] = i) : e[i.name] = i : "PoseNode" === i.name ? (Array.isArray(e[i.name]) || (e[i.name] = [e[i.name]]), e[i.name].push(i)) : void 0 === e[i.name][i.id] && (e[i.name][i.id] = i)
                },
                parseProperty: function(t) {
                    var e = t.getString(1);
                    switch (e) {
                        case "C":
                            return t.getBoolean();
                        case "D":
                            return t.getFloat64();
                        case "F":
                            return t.getFloat32();
                        case "I":
                            return t.getInt32();
                        case "L":
                            return t.getInt64();
                        case "R":
                            var i = t.getUint32();
                            return t.getArrayBuffer(i);
                        case "S":
                            i = t.getUint32();
                            return t.getString(i);
                        case "Y":
                            return t.getInt16();
                        case "b":
                        case "c":
                        case "d":
                        case "f":
                        case "i":
                        case "l":
                            var n = t.getUint32(),
                                r = t.getUint32(),
                                o = t.getUint32();
                            if (0 === r) switch (e) {
                                case "b":
                                case "c":
                                    return t.getBooleanArray(n);
                                case "d":
                                    return t.getFloat64Array(n);
                                case "f":
                                    return t.getFloat32Array(n);
                                case "i":
                                    return t.getInt32Array(n);
                                case "l":
                                    return t.getInt64Array(n)
                            }
                            "undefined" == typeof Zlib && console.error("THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js");
                            var a = new u(new Zlib.Inflate(new Uint8Array(t.getArrayBuffer(o))).decompress().buffer);
                            switch (e) {
                                case "b":
                                case "c":
                                    return a.getBooleanArray(n);
                                case "d":
                                    return a.getFloat64Array(n);
                                case "f":
                                    return a.getFloat32Array(n);
                                case "i":
                                    return a.getInt32Array(n);
                                case "l":
                                    return a.getInt64Array(n)
                            }
                        default:
                            throw new Error("THREE.FBXLoader: Unknown property type " + e)
                    }
                }
            }, u.prototype = {
                constructor: u,
                getOffset: function() {
                    return this.offset
                },
                size: function() {
                    return this.dv.buffer.byteLength
                },
                skip: function(t) {
                    this.offset += t
                },
                getBoolean: function() {
                    return 1 == (1 & this.getUint8())
                },
                getBooleanArray: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getBoolean());
                    return e
                },
                getUint8: function() {
                    var t = this.dv.getUint8(this.offset);
                    return this.offset += 1, t
                },
                getInt16: function() {
                    var t = this.dv.getInt16(this.offset, this.littleEndian);
                    return this.offset += 2, t
                },
                getInt32: function() {
                    var t = this.dv.getInt32(this.offset, this.littleEndian);
                    return this.offset += 4, t
                },
                getInt32Array: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getInt32());
                    return e
                },
                getUint32: function() {
                    var t = this.dv.getUint32(this.offset, this.littleEndian);
                    return this.offset += 4, t
                },
                getInt64: function() {
                    var t, e;
                    return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 2147483648 & e ? (e = 4294967295 & ~e, 4294967295 === (t = 4294967295 & ~t) && (e = e + 1 & 4294967295), -(4294967296 * e + (t = t + 1 & 4294967295))) : 4294967296 * e + t
                },
                getInt64Array: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getInt64());
                    return e
                },
                getUint64: function() {
                    var t, e;
                    return this.littleEndian ? (t = this.getUint32(), e = this.getUint32()) : (e = this.getUint32(), t = this.getUint32()), 4294967296 * e + t
                },
                getFloat32: function() {
                    var t = this.dv.getFloat32(this.offset, this.littleEndian);
                    return this.offset += 4, t
                },
                getFloat32Array: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getFloat32());
                    return e
                },
                getFloat64: function() {
                    var t = this.dv.getFloat64(this.offset, this.littleEndian);
                    return this.offset += 8, t
                },
                getFloat64Array: function(t) {
                    for (var e = [], i = 0; i < t; i++) e.push(this.getFloat64());
                    return e
                },
                getArrayBuffer: function(t) {
                    var e = this.dv.buffer.slice(this.offset, this.offset + t);
                    return this.offset += t, e
                },
                getString: function(e) {
                    for (var i = [], n = 0; n < e; n++) i[n] = this.getUint8();
                    var r = i.indexOf(0);
                    return r >= 0 && (i = i.slice(0, r)), t.LoaderUtils.decodeText(new Uint8Array(i))
                }
            }, d.prototype = {
                constructor: d,
                add: function(t, e) {
                    this[t] = e
                }
            };
            var m = [];

            function g(t, e, i, n) {
                var r;
                switch (n.mappingType) {
                    case "ByPolygonVertex":
                        r = t;
                        break;
                    case "ByPolygon":
                        r = e;
                        break;
                    case "ByVertice":
                        r = i;
                        break;
                    case "AllSame":
                        r = n.indices[0];
                        break;
                    default:
                        console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType)
                }
                "IndexToDirect" === n.referenceType && (r = n.indices[r]);
                var o = r * n.dataSize,
                    a = o + n.dataSize;
                return function(t, e, i, n) {
                    for (var r = i, o = 0; r < n; r++, o++) t[o] = e[r];
                    return t
                }(m, n.buffer, o, a)
            }
            var v = new t.Euler,
                y = new t.Vector3;

            function _(e) {
                var i, n = new t.Matrix4,
                    r = new t.Matrix4,
                    o = new t.Matrix4,
                    a = new t.Matrix4,
                    s = new t.Matrix4,
                    c = new t.Matrix4,
                    l = new t.Matrix4,
                    h = new t.Matrix4,
                    u = new t.Matrix4,
                    d = new t.Matrix4,
                    p = new t.Matrix4,
                    f = e.inheritType ? e.inheritType : 0;
                (e.translation && n.setPosition(y.fromArray(e.translation)), e.preRotation) && ((i = e.preRotation.map(t.Math.degToRad)).push(e.eulerOrder), r.makeRotationFromEuler(v.fromArray(i)));
                e.rotation && ((i = e.rotation.map(t.Math.degToRad)).push(e.eulerOrder), o.makeRotationFromEuler(v.fromArray(i)));
                e.postRotation && ((i = e.postRotation.map(t.Math.degToRad)).push(e.eulerOrder), a.makeRotationFromEuler(v.fromArray(i)));
                e.scale && s.scale(y.fromArray(e.scale)), e.scalingOffset && l.setPosition(y.fromArray(e.scalingOffset)), e.scalingPivot && c.setPosition(y.fromArray(e.scalingPivot)), e.rotationOffset && h.setPosition(y.fromArray(e.rotationOffset)), e.rotationPivot && u.setPosition(y.fromArray(e.rotationPivot)), e.parentMatrixWorld && (d = e.parentMatrixWorld);
                var m = r.multiply(o).multiply(a),
                    g = new t.Matrix4;
                d.extractRotation(g);
                var _, x, b, w, M = new t.Matrix4;
                if (M.copyPosition(d), b = M.getInverse(M).multiply(d), x = g.getInverse(g).multiply(b), _ = s, 0 === f) w = g.multiply(m).multiply(x).multiply(_);
                else if (1 === f) w = g.multiply(x).multiply(m).multiply(_);
                else {
                    var T = (new t.Matrix4).copy(s),
                        E = x.multiply(T.getInverse(T));
                    w = g.multiply(m).multiply(E).multiply(_)
                }
                var S = n.multiply(h).multiply(u).multiply(r).multiply(o).multiply(a).multiply(u.getInverse(u)).multiply(l).multiply(c).multiply(s).multiply(c.getInverse(c)),
                    A = (new t.Matrix4).copyPosition(S),
                    P = d.multiply(A);
                return p.copyPosition(P), S = p.multiply(w)
            }

            function x(t) {
                var e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
                return 6 === (t = t || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[t]
            }

            function b(t) {
                return t.split(",").map(function(t) {
                    return parseFloat(t)
                })
            }

            function w(e, i, n) {
                return void 0 === i && (i = 0), void 0 === n && (n = e.byteLength), t.LoaderUtils.decodeText(new Uint8Array(e, i, n))
            }

            function M(t, e, i) {
                return t.slice(0, e).concat(i).concat(t.slice(e))
            }
            return o
        }()
    }).call(this, i(1))
}, function(t, e, i) {
    (function(t) {
        t.OrbitControls = function(e, i) {
            this.object = e, this.domElement = void 0 !== i ? i : document, this.enabled = !0, this.target = new t.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                BOTTOM: 40
            }, this.mouseButtons = {
                LEFT: t.MOUSE.LEFT,
                MIDDLE: t.MOUSE.MIDDLE,
                RIGHT: t.MOUSE.RIGHT
            }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function() {
                return h.phi
            }, this.getAzimuthalAngle = function() {
                return h.theta
            }, this.saveState = function() {
                n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom
            }, this.reset = function() {
                n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(r), n.update(), c = s.NONE
            }, this.update = function() {
                var i = new t.Vector3,
                    o = (new t.Quaternion).setFromUnitVectors(e.up, new t.Vector3(0, 1, 0)),
                    a = o.clone().inverse(),
                    m = new t.Vector3,
                    g = new t.Quaternion;
                return function() {
                    var t = n.object.position;
                    return i.copy(t).sub(n.target), i.applyQuaternion(o), h.setFromVector3(i), n.autoRotate && c === s.NONE && E(2 * Math.PI / 60 / 60 * n.autoRotateSpeed), h.theta += u.theta, h.phi += u.phi, h.theta = Math.max(n.minAzimuthAngle, Math.min(n.maxAzimuthAngle, h.theta)), h.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, h.phi)), h.makeSafe(), h.radius *= d, h.radius = Math.max(n.minDistance, Math.min(n.maxDistance, h.radius)), n.target.add(p), i.setFromSpherical(h), i.applyQuaternion(a), t.copy(n.target).add(i), n.object.lookAt(n.target), !0 === n.enableDamping ? (u.theta *= 1 - n.dampingFactor, u.phi *= 1 - n.dampingFactor, p.multiplyScalar(1 - n.dampingFactor)) : (u.set(0, 0, 0), p.set(0, 0, 0)), d = 1, !!(f || m.distanceToSquared(n.object.position) > l || 8 * (1 - g.dot(n.object.quaternion)) > l) && (n.dispatchEvent(r), m.copy(n.object.position), g.copy(n.object.quaternion), f = !1, !0)
                }
            }(), this.dispose = function() {
                n.domElement.removeEventListener("contextmenu", G, !1), n.domElement.removeEventListener("mousedown", I, !1), n.domElement.removeEventListener("wheel", N, !1), n.domElement.removeEventListener("touchstart", F, !1), n.domElement.removeEventListener("touchend", U, !1), n.domElement.removeEventListener("touchmove", z, !1), document.removeEventListener("mousemove", D, !1), document.removeEventListener("mouseup", k, !1), window.removeEventListener("keydown", B, !1)
            };
            var n = this,
                r = {
                    type: "change"
                },
                o = {
                    type: "start"
                },
                a = {
                    type: "end"
                },
                s = {
                    NONE: -1,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2,
                    TOUCH_ROTATE: 3,
                    TOUCH_DOLLY_PAN: 4
                },
                c = s.NONE,
                l = 1e-6,
                h = new t.Spherical,
                u = new t.Spherical,
                d = 1,
                p = new t.Vector3,
                f = !1,
                m = new t.Vector2,
                g = new t.Vector2,
                v = new t.Vector2,
                y = new t.Vector2,
                _ = new t.Vector2,
                x = new t.Vector2,
                b = new t.Vector2,
                w = new t.Vector2,
                M = new t.Vector2;

            function T() {
                return Math.pow(.95, n.zoomSpeed)
            }

            function E(t) {
                u.theta -= t
            }

            function S(t) {
                u.phi -= t
            }
            var A = function() {
                    var e = new t.Vector3;
                    return function(t, i) {
                        e.setFromMatrixColumn(i, 0), e.multiplyScalar(-t), p.add(e)
                    }
                }(),
                P = function() {
                    var e = new t.Vector3;
                    return function(t, i) {
                        !0 === n.screenSpacePanning ? e.setFromMatrixColumn(i, 1) : (e.setFromMatrixColumn(i, 0), e.crossVectors(n.object.up, e)), e.multiplyScalar(t), p.add(e)
                    }
                }(),
                L = function() {
                    var e = new t.Vector3;
                    return function(t, i) {
                        var r = n.domElement === document ? n.domElement.body : n.domElement;
                        if (n.object.isPerspectiveCamera) {
                            var o = n.object.position;
                            e.copy(o).sub(n.target);
                            var a = e.length();
                            a *= Math.tan(n.object.fov / 2 * Math.PI / 180), A(2 * t * a / r.clientHeight, n.object.matrix), P(2 * i * a / r.clientHeight, n.object.matrix)
                        } else n.object.isOrthographicCamera ? (A(t * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix), P(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1)
                    }
                }();

            function C(t) {
                n.object.isPerspectiveCamera ? d /= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * t)), n.object.updateProjectionMatrix(), f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
            }

            function R(t) {
                n.object.isPerspectiveCamera ? d *= t : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / t)), n.object.updateProjectionMatrix(), f = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1)
            }

            function O(t) {
                y.set(t.clientX, t.clientY)
            }

            function I(t) {
                if (!1 !== n.enabled) {
                    switch (t.preventDefault(), t.button) {
                        case n.mouseButtons.LEFT:
                            if (t.ctrlKey || t.metaKey || t.shiftKey) {
                                if (!1 === n.enablePan) return;
                                O(t), c = s.PAN
                            } else {
                                if (!1 === n.enableRotate) return;
                                ! function(t) {
                                    m.set(t.clientX, t.clientY)
                                }(t), c = s.ROTATE
                            }
                            break;
                        case n.mouseButtons.MIDDLE:
                            if (!1 === n.enableZoom) return;
                            ! function(t) {
                                b.set(t.clientX, t.clientY)
                            }(t), c = s.DOLLY;
                            break;
                        case n.mouseButtons.RIGHT:
                            if (!1 === n.enablePan) return;
                            O(t), c = s.PAN
                    }
                    c !== s.NONE && (document.addEventListener("mousemove", D, !1), document.addEventListener("mouseup", k, !1), n.dispatchEvent(o))
                }
            }

            function D(t) {
                if (!1 !== n.enabled) switch (t.preventDefault(), c) {
                    case s.ROTATE:
                        if (!1 === n.enableRotate) return;
                        ! function(t) {
                            g.set(t.clientX, t.clientY), v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
                            var e = n.domElement === document ? n.domElement.body : n.domElement;
                            E(2 * Math.PI * v.x / e.clientHeight), S(2 * Math.PI * v.y / e.clientHeight), m.copy(g), n.update()
                        }(t);
                        break;
                    case s.DOLLY:
                        if (!1 === n.enableZoom) return;
                        ! function(t) {
                            w.set(t.clientX, t.clientY), M.subVectors(w, b), M.y > 0 ? C(T()) : M.y < 0 && R(T()), b.copy(w), n.update()
                        }(t);
                        break;
                    case s.PAN:
                        if (!1 === n.enablePan) return;
                        ! function(t) {
                            _.set(t.clientX, t.clientY), x.subVectors(_, y).multiplyScalar(n.panSpeed), L(x.x, x.y), y.copy(_), n.update()
                        }(t)
                }
            }

            function k(t) {
                !1 !== n.enabled && (document.removeEventListener("mousemove", D, !1), document.removeEventListener("mouseup", k, !1), n.dispatchEvent(a), c = s.NONE)
            }

            function N(t) {
                !1 === n.enabled || !1 === n.enableZoom || c !== s.NONE && c !== s.ROTATE || (t.preventDefault(), t.stopPropagation(), n.dispatchEvent(o), function(t) {
                    t.deltaY < 0 ? R(T()) : t.deltaY > 0 && C(T()), n.update()
                }(t), n.dispatchEvent(a))
            }

            function B(t) {
                !1 !== n.enabled && !1 !== n.enableKeys && !1 !== n.enablePan && function(t) {
                    switch (t.keyCode) {
                        case n.keys.UP:
                            L(0, n.keyPanSpeed), n.update();
                            break;
                        case n.keys.BOTTOM:
                            L(0, -n.keyPanSpeed), n.update();
                            break;
                        case n.keys.LEFT:
                            L(n.keyPanSpeed, 0), n.update();
                            break;
                        case n.keys.RIGHT:
                            L(-n.keyPanSpeed, 0), n.update()
                    }
                }(t)
            }

            function F(t) {
                if (!1 !== n.enabled) {
                    switch (t.preventDefault(), t.touches.length) {
                        case 1:
                            if (!1 === n.enableRotate) return;
                            ! function(t) {
                                m.set(t.touches[0].pageX, t.touches[0].pageY)
                            }(t), c = s.TOUCH_ROTATE;
                            break;
                        case 2:
                            if (!1 === n.enableZoom && !1 === n.enablePan) return;
                            ! function(t) {
                                if (n.enableZoom) {
                                    var e = t.touches[0].pageX - t.touches[1].pageX,
                                        i = t.touches[0].pageY - t.touches[1].pageY,
                                        r = Math.sqrt(e * e + i * i);
                                    b.set(0, r)
                                }
                                if (n.enablePan) {
                                    var o = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                                        a = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                                    y.set(o, a)
                                }
                            }(t), c = s.TOUCH_DOLLY_PAN;
                            break;
                        default:
                            c = s.NONE
                    }
                    c !== s.NONE && n.dispatchEvent(o)
                }
            }

            function z(t) {
                if (!1 !== n.enabled) switch (t.preventDefault(), t.stopPropagation(), t.touches.length) {
                    case 1:
                        if (!1 === n.enableRotate) return;
                        if (c !== s.TOUCH_ROTATE) return;
                        ! function(t) {
                            g.set(t.touches[0].pageX, t.touches[0].pageY), v.subVectors(g, m).multiplyScalar(n.rotateSpeed);
                            var e = n.domElement === document ? n.domElement.body : n.domElement;
                            E(2 * Math.PI * v.x / e.clientHeight), S(2 * Math.PI * v.y / e.clientHeight), m.copy(g), n.update()
                        }(t);
                        break;
                    case 2:
                        if (!1 === n.enableZoom && !1 === n.enablePan) return;
                        if (c !== s.TOUCH_DOLLY_PAN) return;
                        ! function(t) {
                            if (n.enableZoom) {
                                var e = t.touches[0].pageX - t.touches[1].pageX,
                                    i = t.touches[0].pageY - t.touches[1].pageY,
                                    r = Math.sqrt(e * e + i * i);
                                w.set(0, r), M.set(0, Math.pow(w.y / b.y, n.zoomSpeed)), C(M.y), b.copy(w)
                            }
                            if (n.enablePan) {
                                var o = .5 * (t.touches[0].pageX + t.touches[1].pageX),
                                    a = .5 * (t.touches[0].pageY + t.touches[1].pageY);
                                _.set(o, a), x.subVectors(_, y).multiplyScalar(n.panSpeed), L(x.x, x.y), y.copy(_)
                            }
                            n.update()
                        }(t);
                        break;
                    default:
                        c = s.NONE
                }
            }

            function U(t) {
                !1 !== n.enabled && (n.dispatchEvent(a), c = s.NONE)
            }

            function G(t) {
                !1 !== n.enabled && t.preventDefault()
            }
            n.domElement.addEventListener("contextmenu", G, !1), n.domElement.addEventListener("mousedown", I, !1), n.domElement.addEventListener("wheel", N, !1), n.domElement.addEventListener("touchstart", F, !1), n.domElement.addEventListener("touchend", U, !1), n.domElement.addEventListener("touchmove", z, !1), window.addEventListener("keydown", B, !1), this.update()
        }, t.OrbitControls.prototype = Object.create(t.EventDispatcher.prototype), t.OrbitControls.prototype.constructor = t.OrbitControls, Object.defineProperties(t.OrbitControls.prototype, {
            center: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target
                }
            },
            noZoom: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !t
                }
            },
            noRotate: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !t
                }
            },
            noPan: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !t
                }
            },
            noKeys: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !t
                }
            },
            staticMoving: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !t
                }
            },
            dynamicDampingFactor: {
                get: function() {
                    return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor
                },
                set: function(t) {
                    console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = t
                }
            }
        })
    }).call(this, i(1))
}, function(t, e, i) {
    "use strict";
    i(1), i(14), i(15)
}, function(t, e) {
    t.exports = ""
}, function(t, e) {
    t.exports = ""
}, function(t, e, i) {
    "use strict";

    function n(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
        }
    }
    new(function() {
        function t() {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.mediaStreamSource = null, this.audioContext = null, this.meter = null
        }
        return function(t, e, i) {
            e && n(t.prototype, e), i && n(t, i)
        }(t, [{
            key: "init",
            value: function() {
                this.startAudioContext()
            }
        }, {
            key: "startAudioContext",
            value: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext, this.audioContext = new AudioContext;
                navigator.mediaDevices.getUserMedia({
                    audio: !0,
                    video: !1
                }).then(this.gotStream.bind(this)).catch(this.didntGetStream.bind(this))
            }
        }, {
            key: "didntGetStream",
            value: function() {
                alert("Stream generation failed.")
            }
        }, {
            key: "gotStream",
            value: function(t) {
                console.log("l"), this.mediaStreamSource = this.audioContext.createMediaStreamSource(t), this.meter = this.createAudioMeter(this.audioContext), this.mediaStreamSource.connect(this.meter)
            }
        }, {
            key: "createAudioMeter",
            value: function(t, e, i, n) {
                var r = t.createScriptProcessor(512);
                return r.onaudioprocess = this.volumeAudioProcess, r.clipping = !1, r.lastClip = 0, r.volume = 0, r.clipLevel = e || .98, r.averaging = i || .95, r.clipLag = n || 750, r.connect(t.destination), r.checkClipping = function() {
                    return !!this.clipping && (this.lastClip + this.clipLag < window.performance.now() && (this.clipping = !1), this.clipping)
                }, r.shutdown = function() {
                    this.disconnect(), this.onaudioprocess = null
                }, r
            }
        }, {
            key: "volumeAudioProcess",
            value: function(t) {
                for (var e, i = t.inputBuffer.getChannelData(0), n = i.length, r = 0, o = 0; o < n; o++) e = i[o], Math.abs(e) >= this.clipLevel && (this.clipping = !0, this.lastClip = window.performance.now()), r += e * e;
                var a = Math.sqrt(r / n);
                this.volume = Math.max(a, this.volume * this.averaging)
            }
        }]), t
    }())
}, function(t, e, i) {
    "use strict";
    (function(e) {
        var n, r, o, a = new(i(18)),
            s = t.exports = {
                noiseLevelConst: 5e3,
                noiseOffConst: 2e3,
                noiseOffSlowConst: 2e3,
                onFastConstant: -.4,
                onFastNumOfVar: 4,
                offSlowNumOfPow: 10,
                offFastConst: .5,
                functionRunning: !1,
                ThrOnFast: 1,
                ThrOffFast: 1,
                ThrOffSlow: 1,
                maxVariance: 0,
                minVariance: 0,
                pow: 0,
                noiseLevel: -1,
                pwVariance: 0,
                varOffVar: 0,
                sampleSize: 1024,
                fftSize: 1024,
                frequencyBin: [],
                countBlow: 0,
                windowArray: [],
                vcd: 0,
                windowArray_2: [],
                vcd_2: 0,
                mainCondition: !1,
                offFastVar: 0,
                offFastVarCount: 0,
                pcd: 0,
                PowerWindow: [],
                pw: 0,
                run: function(t) {
                    this.pfu = t || {}, this.pfu.onFNlc && (s.noiseLevelConst = this.pfu.onFNlc), this.pfu.onFvar && (s.onFastNumOfVar = this.pfu.onFvar), this.pfu.onFCvar && (s.onFastConstant = this.pfu.onFCvar, s.onFastConstant = -1 * s.onFastConstant),
                        function(t, e) {
                            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia, navigator.getUserMedia(t, e, h)
                        }({
                            audio: !0
                        }, l)
                },
                events: a
            };
        window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.oAudioContext || window.msAudioContext;
        var c = new e.AudioContext;

        function l(t) {
            var e;
            n = c.createMediaStreamSource(t), (r = c.createAnalyser()).smoothingTimeConstant = .3, r.fftSize = s.fftSize, (o = c.createScriptProcessor(s.sampleSize, 1, 1)).onaudioprocess = function() {
                s.pow = 0, e = new Uint8Array(r.frequencyBinCount), r.getByteFrequencyData(e);
                for (var t = 0; t < e.length; t++) s.frequencyBin[t] = e[t];
                s.frequencyBin.forEach(function(t) {
                    s.pow += t
                }), -1 === s.noiseLevel ? s.noiseLevel = s.pow : s.pow < s.noiseLevel ? s.noiseLevel = s.pow : s.pow > s.noiseLevel && (s.countBlow < 30 ? s.noiseLevel = s.noiseLevel + 10 : s.countBlow > 30 && (s.noiseLevel = s.noiseLevel + 0)), s.ThrOnFast = Math.round(s.noiseLevel + s.noiseLevelConst), s.ThrOffFast = Math.round(s.noiseLevel + s.noiseOffConst), s.ThrOffSlow = Math.round(s.noiseLevel + s.noiseOffSlowConst), s.PowerWindow[s.pw] = s.pow, s.pw > 0 && s.pw < 500 ? s.pwVariance = Math.round(s.PowerWindow[s.pw] - s.PowerWindow[s.pw - 1]) : s.pw > 500 && (s.pw = 0, s.PowerWindow.length = 0), s.pw++, !1 === s.functionRunning ? (s.countBlow = 0, function(t, e) {
                    t > s.ThrOnFast && !1 === s.mainCondition ? e > 0 && e > s.maxVariance ? (s.maxVariance = e, s.minVariance = Math.round(s.onFastConstant * s.maxVariance), s.varOffVar = s.minVariance * s.offFastConst) : e < 0 && e < s.maxVariance && (s.mainCondition = !0) : t > s.ThrOnFast && !0 === s.mainCondition && (s.windowArray[s.vcd] = e, s.vcd === s.onFastNumOfVar ? s.windowArray.every(d) ? (s.functionRunning = !0, u.start()) : (s.mainCondition = !1, s.vcd = 0, s.windowArray.length = 0, s.maxVariance = 0, s.minVariance = 0) : s.vcd++);
                    s.pcd < 35 ? t > s.ThrOnFast && e > -3e3 ? s.pcd++ : s.pcd = 0 : (s.functionRunning = !0, u.start(), s.pcd = 0)
                }(s.pow, s.pwVariance)) : !0 === s.functionRunning && (s.countBlow++, function(t, e) {
                    s.offFastVarCount < 15 ? (e < s.offFastVar && (s.offFastVar = e), s.offFastVarCount++) : s.offFastVarCount = 0;
                    t < s.ThrOffFast && s.offFastVar < s.varOffVar ? f() : t < s.ThrOffFast && s.offFastVar > s.varOffVar && (s.windowArray_2[s.vcd_2] = t, s.vcd_2 === s.offSlowNumOfPow ? (s.windowArray_2.every(p) && f(), s.windowArray_2.splice(0, 1)) : s.vcd_2++)
                }(s.pow, s.pwVariance))
            }, n.connect(r), r.connect(o), o.connect(c.destination)
        }

        function h() {
            e.alert("Stream generation failed")
        }
        var u = {
            stop: function() {
                a.emit("stop")
            },
            start: function() {
                s.functionRunning = !0, a.emit("start")
            }
        };

        function d(t, e, i) {
            return t > s.minVariance && t < -1 * s.minVariance
        }

        function p(t, e, i) {
            return t < s.ThrOffSlow
        }

        function f() {
            s.vcd = 0, s.vcd_2 = 0, s.pw = 0, s.pcd = 0, s.maxVariance = 0, s.minVariance = 0, s.varOffVar = 0, s.mainCondition = !1, s.windowArray.length = 0, s.windowArray_2.length = 0, s.offFastVar = 0, s.offFastVarCount = 0, s.functionRunning = !1, u.stop()
        }
    }).call(this, i(3))
}, function(t, e) {
    function i() {
        this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0
    }

    function n(t) {
        return "function" == typeof t
    }

    function r(t) {
        return "object" == typeof t && null !== t
    }

    function o(t) {
        return void 0 === t
    }
    t.exports = i, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._maxListeners = void 0, i.defaultMaxListeners = 10, i.prototype.setMaxListeners = function(t) {
        if (! function(t) {
                return "number" == typeof t
            }(t) || t < 0 || isNaN(t)) throw TypeError("n must be a positive number");
        return this._maxListeners = t, this
    }, i.prototype.emit = function(t) {
        var e, i, a, s, c, l;
        if (this._events || (this._events = {}), "error" === t && (!this._events.error || r(this._events.error) && !this._events.error.length)) {
            if ((e = arguments[1]) instanceof Error) throw e;
            var h = new Error('Uncaught, unspecified "error" event. (' + e + ")");
            throw h.context = e, h
        }
        if (o(i = this._events[t])) return !1;
        if (n(i)) switch (arguments.length) {
            case 1:
                i.call(this);
                break;
            case 2:
                i.call(this, arguments[1]);
                break;
            case 3:
                i.call(this, arguments[1], arguments[2]);
                break;
            default:
                s = Array.prototype.slice.call(arguments, 1), i.apply(this, s)
        } else if (r(i))
            for (s = Array.prototype.slice.call(arguments, 1), a = (l = i.slice()).length, c = 0; c < a; c++) l[c].apply(this, s);
        return !0
    }, i.prototype.addListener = function(t, e) {
        var a;
        if (!n(e)) throw TypeError("listener must be a function");
        return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", t, n(e.listener) ? e.listener : e), this._events[t] ? r(this._events[t]) ? this._events[t].push(e) : this._events[t] = [this._events[t], e] : this._events[t] = e, r(this._events[t]) && !this._events[t].warned && (a = o(this._maxListeners) ? i.defaultMaxListeners : this._maxListeners) && a > 0 && this._events[t].length > a && (this._events[t].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[t].length), "function" == typeof console.trace && console.trace()), this
    }, i.prototype.on = i.prototype.addListener, i.prototype.once = function(t, e) {
        if (!n(e)) throw TypeError("listener must be a function");
        var i = !1;

        function r() {
            this.removeListener(t, r), i || (i = !0, e.apply(this, arguments))
        }
        return r.listener = e, this.on(t, r), this
    }, i.prototype.removeListener = function(t, e) {
        var i, o, a, s;
        if (!n(e)) throw TypeError("listener must be a function");
        if (!this._events || !this._events[t]) return this;
        if (a = (i = this._events[t]).length, o = -1, i === e || n(i.listener) && i.listener === e) delete this._events[t], this._events.removeListener && this.emit("removeListener", t, e);
        else if (r(i)) {
            for (s = a; s-- > 0;)
                if (i[s] === e || i[s].listener && i[s].listener === e) {
                    o = s;
                    break
                }
            if (o < 0) return this;
            1 === i.length ? (i.length = 0, delete this._events[t]) : i.splice(o, 1), this._events.removeListener && this.emit("removeListener", t, e)
        }
        return this
    }, i.prototype.removeAllListeners = function(t) {
        var e, i;
        if (!this._events) return this;
        if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[t] && delete this._events[t], this;
        if (0 === arguments.length) {
            for (e in this._events) "removeListener" !== e && this.removeAllListeners(e);
            return this.removeAllListeners("removeListener"), this._events = {}, this
        }
        if (n(i = this._events[t])) this.removeListener(t, i);
        else if (i)
            for (; i.length;) this.removeListener(t, i[i.length - 1]);
        return delete this._events[t], this
    }, i.prototype.listeners = function(t) {
        return this._events && this._events[t] ? n(this._events[t]) ? [this._events[t]] : this._events[t].slice() : []
    }, i.prototype.listenerCount = function(t) {
        if (this._events) {
            var e = this._events[t];
            if (n(e)) return 1;
            if (e) return e.length
        }
        return 0
    }, i.listenerCount = function(t, e) {
        return t.listenerCount(e)
    }
}, function(t, e, i) {}, function(t, e, i) {
    "use strict";
    i.r(e);
    i(7), i(8), i(9);
    var n = i(4);
    i(2);

    function r(t, e, i) {
        return e in t ? Object.defineProperty(t, e, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = i, t
    }

    function o(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
        }
    }
    var a = function() {
        function t(e) {
            var i = e.$el;
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.$el = i
        }
        return function(t, e, i) {
            e && o(t.prototype, e), i && o(t, i)
        }(t, [{
            key: "init",
            value: function() {
                this.initDOM(), this.initWebGL()
            }
        }, {
            key: "initDOM",
            value: function() {
                this.$el = document.querySelector(".Home"), this.$els = {}, this.$els = function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = null != arguments[e] ? arguments[e] : {},
                            n = Object.keys(i);
                        "function" == typeof Object.getOwnPropertySymbols && (n = n.concat(Object.getOwnPropertySymbols(i).filter(function(t) {
                            return Object.getOwnPropertyDescriptor(i, t).enumerable
                        }))), n.forEach(function(e) {
                            r(t, e, i[e])
                        })
                    }
                    return t
                }({}, this.$els, {
                    blow: this.$el.querySelector(".blow"),
                    blowSpans: this.$el.querySelectorAll("span")
                })
            }
        }, {
            key: "initWebGL",
            value: function() {
                n.a.init({
                    $el: document.querySelector(".App-wrapWebGL")
                })
            }
        }]), t
    }();

    function s(t, e) {
        for (var i = 0; i < e.length; i++) {
            var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
        }
    }
    var c = new(function() {
        function t() {
            ! function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }(this, t), this.$el = document.querySelector(".App"), this.home = new a({
                $el: this.$el.querySelector(".Home")
            })
        }
        return function(t, e, i) {
            e && s(t.prototype, e), i && s(t, i)
        }(t, [{
            key: "init",
            value: function() {
                this.home.init()
            }
        }]), t
    }());
    document.querySelector(".dg.ac").style.display = "none", c.init()
}]);
